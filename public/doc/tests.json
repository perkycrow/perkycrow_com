{
  "/application/application.doc.js": {
    "file": "/application/application.test.js",
    "describes": [
      {
        "title": "Application",
        "line": 12,
        "beforeEach": {
          "line": 17,
          "source": "mockManifest = {\n    getAsset: vi.fn(),\n    getSource: vi.fn(),\n    getConfig: vi.fn(),\n    setConfig: vi.fn()\n}\n\nvi.spyOn(Manifest.prototype, 'getAsset').mockImplementation((...args) => {\n    return mockManifest.getAsset(...args)\n})\n\nvi.spyOn(Manifest.prototype, 'getSource').mockImplementation((...args) => {\n    return mockManifest.getSource(...args)\n})\n\nvi.spyOn(Manifest.prototype, 'getConfig').mockImplementation((path) => {\n    return mockManifest.getConfig(path)\n})\n\nvi.spyOn(Manifest.prototype, 'setConfig').mockImplementation((path, value) => {\n    return mockManifest.setConfig(path, value)\n})\n\nconst mockPerkyViewElement = document.createElement('div')\nmockPerkyViewElement.exitFullscreenMode = vi.fn()\nmockPerkyViewElement.enterFullscreenMode = vi.fn()\nvi.spyOn(PerkyView.prototype, 'mount').mockReturnValue(null)\nvi.spyOn(PerkyView, 'defaultElement').mockReturnValue(mockPerkyViewElement)\n\napplication = new Application()"
        },
        "afterEach": {
          "line": 51,
          "source": "vi.restoreAllMocks()"
        },
        "tests": [
          {
            "title": "constructor",
            "line": 56,
            "source": "expect(application).toBeInstanceOf(PerkyModule)\nexpect(application.manifest).toBeInstanceOf(Manifest)\nexpect(application.actionDispatcher).toBeDefined()\nexpect(application.loaders).toBeInstanceOf(Registry)\nexpect(application.perkyView).toBeInstanceOf(PerkyView)\nexpect(application.sourceManager).toBeDefined()"
          },
          {
            "title": "constructor with custom manifest",
            "line": 66,
            "source": "vi.restoreAllMocks()\n\nconst customManifestData = {\n    config: {name: 'Test App'}\n}\n\nconst customApp = new Application({manifest: customManifestData})\n\nexpect(customApp.manifest).toBeDefined()\nexpect(customApp.manifest.getConfig('name')).toBe('Test App')"
          },
          {
            "title": "constructor with manifest instance",
            "line": 80,
            "source": "vi.restoreAllMocks()\n\nconst manifest = new Manifest({\n    data: {\n        config: {name: 'Test App Instance'}\n    }\n})\nconst customApp = new Application({manifest})\n\nexpect(customApp.manifest).toBeInstanceOf(Manifest)\nexpect(customApp.manifest.getConfig('name')).toBe('Test App Instance')"
          },
          {
            "title": "constructor with static manifest",
            "line": 95,
            "source": "vi.restoreAllMocks()\n\nclass CustomApp extends Application {\n    static manifest = {\n        config: {name: 'Static Manifest App'}\n    }\n}\n\nconst customApp = new CustomApp()\n\nexpect(customApp.manifest).toBeInstanceOf(Manifest)\nexpect(customApp.manifest.getConfig('name')).toBe('Static Manifest App')"
          },
          {
            "title": "constructor registers keyboard and mouse devices",
            "line": 111,
            "source": "const testApp = new Application()\n\nexpect(testApp.getDevice('keyboard')).toBeInstanceOf(KeyboardDevice)\nexpect(testApp.getDevice('mouse')).toBeInstanceOf(MouseDevice)"
          },
          {
            "title": "constructor calls configure if defined",
            "line": 119,
            "source": "class ConfiguredApp extends Application {\n    constructor () {\n        super()\n    }\n\n    configureApplication () {\n        this.configureCalled = true\n    }\n}\n\nconst app = new ConfiguredApp()\nexpect(app.configureCalled).toBe(true)"
          },
          {
            "title": "loadAsset",
            "line": 136,
            "source": "vi.spyOn(application, 'loadAsset').mockResolvedValue('loaded')\n\nconst promise = application.loadAsset('logo')\n\nexpect(application.loadAsset).toHaveBeenCalledWith('logo')\nawait expect(promise).resolves.toBe('loaded')"
          },
          {
            "title": "loadTag",
            "line": 146,
            "source": "vi.spyOn(application, 'loadTag').mockResolvedValue('loaded')\n\nconst promise = application.loadTag('mainScene')\n\nexpect(application.loadTag).toHaveBeenCalledWith('mainScene')\nawait expect(promise).resolves.toBe('loaded')"
          },
          {
            "title": "loadAll",
            "line": 156,
            "source": "vi.spyOn(application, 'loadAll').mockResolvedValue('loaded')\n\nconst promise = application.loadAll()\n\nexpect(application.loadAll).toHaveBeenCalled()\nawait expect(promise).resolves.toBe('loaded')"
          },
          {
            "title": "getSource",
            "line": 166,
            "source": "application.getSource('logo')\n\nexpect(mockManifest.getSource).toHaveBeenCalledWith('logo')"
          },
          {
            "title": "config",
            "line": 173,
            "source": "application.setConfig('debug', true)\n\nexpect(mockManifest.setConfig).toHaveBeenCalledWith('debug', true)"
          },
          {
            "title": "dispose calls perkyView.dispose() which dismounts",
            "line": 180,
            "source": "const perkyView = application.perkyView\nvi.spyOn(perkyView, 'dispose')\nvi.spyOn(perkyView, 'dismount')\n\napplication.dispose()\n\nexpect(perkyView.dispose).toHaveBeenCalled()\nexpect(perkyView.dismount).toHaveBeenCalled()"
          },
          {
            "title": "input event handling integration",
            "line": 192,
            "source": "class TestController extends PerkyModule {\n    jump = vi.fn()\n}\n\nconst testApp = new Application()\nconst controller = testApp.registerController('game', TestController)\ntestApp.setActiveControllers('game')\ntestApp.bindInput({\n    deviceName: 'keyboard',\n    controlName: 'Space',\n    actionName: 'jump',\n    controllerName: 'game'\n})\n\nconst keyboardDevice = testApp.getDevice('keyboard')\nexpect(keyboardDevice).toBeDefined()\n\nconst spaceControl = keyboardDevice.getControl('Space') || keyboardDevice.findOrCreateControl(ButtonControl, {name: 'Space'})\n\nspaceControl.press({code: 'Space'})\n\nawait new Promise(resolve => setTimeout(resolve, 0))\nexpect(controller.jump).toHaveBeenCalled()"
          },
          {
            "title": "inputSystem alias provides access to InputSystem",
            "line": 219,
            "source": "expect(application.inputSystem.getDevice('keyboard')).toBeDefined()\nexpect(application.inputSystem.getDevice('mouse')).toBeDefined()"
          },
          {
            "title": "inputSystem and inputBinder getters",
            "line": 225,
            "source": "expect(application.inputSystem).toBeDefined()\nexpect(application.inputBinder).toBeDefined()"
          },
          {
            "title": "bind and unbind",
            "line": 231,
            "source": "const binding = application.bindInput({\n    deviceName: 'keyboard',\n    controlName: 'Enter',\n    actionName: 'select'\n})\n\nexpect(binding).toBeDefined()\nexpect(binding.actionName).toBe('select')\nexpect(application.getAllBindings()).toHaveLength(1)\n\nconst result = application.unbind({actionName: 'select'})\nexpect(result).toBe(true)\nexpect(application.getAllBindings()).toHaveLength(0)"
          },
          {
            "title": "getBinding and hasBinding",
            "line": 248,
            "source": "application.bindInput({\n    deviceName: 'keyboard',\n    controlName: 'Tab',\n    actionName: 'nextTab'\n})\n\nexpect(application.hasBinding({actionName: 'nextTab'})).toBe(true)\n\nconst binding = application.getBinding({actionName: 'nextTab'})\nexpect(binding).toBeDefined()\nexpect(binding.actionName).toBe('nextTab')\n\nexpect(application.hasBinding({actionName: 'nonExistent'})).toBe(false)\nexpect(application.getBinding({actionName: 'nonExistent'})).toBeNull()"
          },
          {
            "title": "getBindingsForInput",
            "line": 266,
            "source": "application.bindInput({\n    deviceName: 'keyboard',\n    controlName: 'F1',\n    actionName: 'help'\n})\n\nconst bindings = application.getBindingsForInput({\n    deviceName: 'keyboard',\n    controlName: 'F1',\n    eventType: 'pressed'\n})\n\nexpect(bindings).toHaveLength(1)\nexpect(bindings[0].actionName).toBe('help')"
          },
          {
            "title": "clearBindings",
            "line": 284,
            "source": "application.bindInput({deviceName: 'keyboard', controlName: 'A', actionName: 'action1'})\napplication.bindInput({deviceName: 'keyboard', controlName: 'B', actionName: 'action2'})\n\nexpect(application.getAllBindings()).toHaveLength(2)\n\napplication.clearBindings()\nexpect(application.getAllBindings()).toHaveLength(0)"
          },
          {
            "title": "device management",
            "line": 295,
            "source": "expect(application.registerDevice).toBeDefined()\nexpect(application.getDevice).toBeDefined()\n\nconst keyboardDevice = application.getDevice('keyboard')\nconst mouseDevice = application.getDevice('mouse')\nexpect(keyboardDevice).toBeInstanceOf(KeyboardDevice)\nexpect(mouseDevice).toBeInstanceOf(MouseDevice)\nexpect(application.getDevice('nonExistent')).toBeNull()"
          },
          {
            "title": "input state queries",
            "line": 307,
            "source": "expect(application.isPressed('keyboard', 'Space')).toBe(false)\nexpect(application.isPressedAny('Jump')).toBe(false)\nexpect(application.getInputValue('mouse', 'leftButton')).toBe(0)\nexpect(application.getInputValueAny('Fire')).toBeUndefined()\nexpect(application.getControl('keyboard', 'Space')).toBeNull()\nexpect(application.getControlAny('Jump')).toBeNull()"
          },
          {
            "title": "input state shortcuts - isKeyPressed and isMousePressed",
            "line": 317,
            "source": "expect(application.isKeyPressed('Space')).toBe(false)\nexpect(application.isKeyPressed('ArrowLeft')).toBe(false)\nexpect(application.isKeyPressed('KeyW')).toBe(false)\n\nexpect(application.isMousePressed('leftButton')).toBe(false)\nexpect(application.isMousePressed('rightButton')).toBe(false)\nexpect(application.isMousePressed('middleButton')).toBe(false)\n\nexpect(application.isKeyPressed('Space')).toBe(application.isPressed('keyboard', 'Space'))\nexpect(application.isMousePressed('leftButton')).toBe(application.isPressed('mouse', 'leftButton'))"
          },
          {
            "title": "input value shortcuts - getKeyValue and getMouseValue",
            "line": 331,
            "source": "expect(application.getKeyValue('Space')).toBeUndefined()\nexpect(application.getKeyValue('ArrowLeft')).toBeUndefined()\nexpect(application.getKeyValue('KeyW')).toBeUndefined()\n\nexpect(application.getMouseValue('leftButton')).toBe(application.getInputValue('mouse', 'leftButton'))\nexpect(application.getMouseValue('rightButton')).toBe(application.getInputValue('mouse', 'rightButton'))\nexpect(application.getMouseValue('position')).toBe(application.getInputValue('mouse', 'position'))\n\nexpect(application.getKeyValue('Space')).toBe(application.getInputValue('keyboard', 'Space'))\nexpect(application.getMouseValue('leftButton')).toBe(application.getInputValue('mouse', 'leftButton'))\nexpect(application.getMouseValue('unknownControl')).toBe(application.getInputValue('mouse', 'unknownControl'))"
          },
          {
            "title": "input shortcuts with simulated key presses",
            "line": 346,
            "source": "const keyboardDevice = application.getDevice('keyboard')\nconst mouseDevice = application.getDevice('mouse')\n\nconst spaceControl = keyboardDevice.findOrCreateControl(ButtonControl, {name: 'Space'})\nspaceControl.press()\n\nexpect(application.isKeyPressed('Space')).toBe(true)\nexpect(application.getKeyValue('Space')).toBe(1)\nexpect(application.isPressed('keyboard', 'Space')).toBe(true)\n\nconst leftButtonControl = mouseDevice.findOrCreateControl(ButtonControl, {name: 'leftButton'})\nleftButtonControl.press()\n\nexpect(application.isMousePressed('leftButton')).toBe(true)\nexpect(application.getMouseValue('leftButton')).toBe(1)\nexpect(application.isPressed('mouse', 'leftButton')).toBe(true)\n\nspaceControl.release()\nleftButtonControl.release()\n\nexpect(application.isKeyPressed('Space')).toBe(false)\nexpect(application.getKeyValue('Space')).toBe(0)\nexpect(application.isMousePressed('leftButton')).toBe(false)\nexpect(application.getMouseValue('leftButton')).toBe(0)"
          },
          {
            "title": "input shortcuts consistency verification",
            "line": 374,
            "source": "const testCases = [\n    {key: 'Space', device: 'keyboard'},\n    {key: 'ArrowLeft', device: 'keyboard'},\n    {key: 'KeyW', device: 'keyboard'},\n    {key: 'leftButton', device: 'mouse'},\n    {key: 'rightButton', device: 'mouse'},\n    {key: 'unknownControl', device: 'keyboard'},\n    {key: 'unknownControl', device: 'mouse'}\n]\n\ntestCases.forEach(({key, device}) => {\n    if (device === 'keyboard') {\n        expect(application.isKeyPressed(key)).toBe(application.isPressed('keyboard', key))\n        expect(application.getKeyValue(key)).toBe(application.getInputValue('keyboard', key))\n    } else {\n        expect(application.isMousePressed(key)).toBe(application.isPressed('mouse', key))\n        expect(application.getMouseValue(key)).toBe(application.getInputValue('mouse', key))\n    }\n})\n\nexpect(application.isKeyPressed('NonExistentKey')).toBe(false)\nexpect(application.isMousePressed('NonExistentButton')).toBe(false)"
          },
          {
            "title": "bindKey convenience method",
            "line": 400,
            "source": "const binding = application.bindInput({controlName: 'Escape', actionName: 'pause'})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('keyboard')\nexpect(binding.controlName).toBe('Escape')\nexpect(binding.actionName).toBe('pause')\nexpect(binding.eventType).toBe('pressed')\n\nconst releasedBinding = application.bindInput({controlName: 'Escape', actionName: 'resume', eventType: 'released'})\nexpect(releasedBinding.eventType).toBe('released')"
          },
          {
            "title": "bindMouse convenience method",
            "line": 414,
            "source": "const binding = application.bindInput({controlName: 'leftButton', actionName: 'shoot'})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('mouse')\nexpect(binding.controlName).toBe('leftButton')\nexpect(binding.actionName).toBe('shoot')\nexpect(binding.eventType).toBe('pressed')\n\nconst releasedBinding = application.bindInput({controlName: 'rightButton', actionName: 'aim', eventType: 'released'})\nexpect(releasedBinding.eventType).toBe('released')"
          },
          {
            "title": "addControl",
            "line": 428,
            "source": "const control = application.addControl('keyboard', ButtonControl, {name: 'CustomKey'})\n\nexpect(control).toBeInstanceOf(ButtonControl)\nexpect(control.name).toBe('CustomKey')\n\nconst keyboardDevice = application.getDevice('keyboard')\nexpect(keyboardDevice.getControl('CustomKey')).toBe(control)"
          },
          {
            "title": "use method installs child class",
            "line": 439,
            "source": "class TestChild extends PerkyModule {\n    constructor (options) {\n        super({...options, $id: 'testChild'})\n    }\n}\n\napplication.create(TestChild, {$id: 'testChild', $category: 'default'})\n\nexpect(application.hasChild('testChild')).toBe(true)"
          },
          {
            "title": "use method installs child instance",
            "line": 452,
            "source": "class TestChild extends PerkyModule {\n    constructor (options) {\n        super({...options, $id: 'testChild'})\n    }\n}\n\napplication.create(TestChild, {\n    $id: 'testChild',\n    $category: 'default'\n})\n\nexpect(application.hasChild('testChild')).toBe(true)"
          },
          {
            "title": "use method with options",
            "line": 468,
            "source": "class TestChild extends PerkyModule {\n    constructor (options) {\n        super({...options, $id: 'testChild'})\n    }\n}\n\napplication.create(TestChild, {\n    $id: 'testChild',\n    $category: 'default',\n    someOption: true\n})\n\nconst child = application.getChild('testChild')\nexpect(child.options.someOption).toBe(true)"
          }
        ],
        "describes": [
          {
            "title": "bindKey flexible API",
            "line": 486,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "parameter format with controllerName",
                "line": 488,
                "source": "const binding = application.bindInput({controlName: 'KeyF', actionName: 'fire', eventType: 'pressed', controllerName: 'player1'})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('keyboard')\nexpect(binding.controlName).toBe('KeyF')\nexpect(binding.actionName).toBe('fire')\nexpect(binding.eventType).toBe('pressed')\nexpect(binding.controllerName).toBe('player1')"
              },
              {
                "title": "parameter format with eventType and no controllerName",
                "line": 499,
                "source": "const binding = application.bindInput({controlName: 'KeyG', actionName: 'grenade', eventType: 'released'})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('keyboard')\nexpect(binding.controlName).toBe('KeyG')\nexpect(binding.actionName).toBe('grenade')\nexpect(binding.eventType).toBe('released')\nexpect(binding.controllerName).toBeNull()"
              },
              {
                "title": "object format with actionName only",
                "line": 510,
                "source": "const binding = application.bindInput({controlName: 'KeyH', actionName: 'heal'})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('keyboard')\nexpect(binding.controlName).toBe('KeyH')\nexpect(binding.actionName).toBe('heal')\nexpect(binding.eventType).toBe('pressed')\nexpect(binding.controllerName).toBeNull()"
              },
              {
                "title": "object format with actionName and eventType",
                "line": 521,
                "source": "const binding = application.bindInput({\n    controlName: 'KeyI',\n    actionName: 'inventory',\n    eventType: 'released'\n})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('keyboard')\nexpect(binding.controlName).toBe('KeyI')\nexpect(binding.actionName).toBe('inventory')\nexpect(binding.eventType).toBe('released')\nexpect(binding.controllerName).toBeNull()"
              },
              {
                "title": "object format with all options",
                "line": 536,
                "source": "const binding = application.bindInput({\n    controlName: 'KeyJ',\n    actionName: 'jump',\n    eventType: 'pressed',\n    controllerName: 'player2'\n})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('keyboard')\nexpect(binding.controlName).toBe('KeyJ')\nexpect(binding.actionName).toBe('jump')\nexpect(binding.eventType).toBe('pressed')\nexpect(binding.controllerName).toBe('player2')"
              },
              {
                "title": "object format with partial options uses defaults",
                "line": 552,
                "source": "const binding = application.bindInput({\n    controlName: 'KeyK',\n    actionName: 'kick',\n    controllerName: 'player3'\n})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('keyboard')\nexpect(binding.controlName).toBe('KeyK')\nexpect(binding.actionName).toBe('kick')\nexpect(binding.eventType).toBe('pressed')\nexpect(binding.controllerName).toBe('player3')"
              },
              {
                "title": "backwards compatibility - original format still works",
                "line": 567,
                "source": "const binding = application.bindInput({controlName: 'KeyL', actionName: 'look'})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('keyboard')\nexpect(binding.controlName).toBe('KeyL')\nexpect(binding.actionName).toBe('look')\nexpect(binding.eventType).toBe('pressed')\nexpect(binding.controllerName).toBeNull()"
              }
            ],
            "describes": []
          },
          {
            "title": "bindMouse flexible API",
            "line": 581,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "parameter format with controllerName",
                "line": 583,
                "source": "const binding = application.bindInput({controlName: 'middleButton', actionName: 'zoom', eventType: 'pressed', controllerName: 'camera'})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('mouse')\nexpect(binding.controlName).toBe('middleButton')\nexpect(binding.actionName).toBe('zoom')\nexpect(binding.eventType).toBe('pressed')\nexpect(binding.controllerName).toBe('camera')"
              },
              {
                "title": "parameter format with eventType and no controllerName",
                "line": 594,
                "source": "const binding = application.bindInput({controlName: 'rightButton', actionName: 'context', eventType: 'released'})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('mouse')\nexpect(binding.controlName).toBe('rightButton')\nexpect(binding.actionName).toBe('context')\nexpect(binding.eventType).toBe('released')\nexpect(binding.controllerName).toBeNull()"
              },
              {
                "title": "object format with actionName only",
                "line": 605,
                "source": "const binding = application.bindInput({controlName: 'leftButton', actionName: 'select'})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('mouse')\nexpect(binding.controlName).toBe('leftButton')\nexpect(binding.actionName).toBe('select')\nexpect(binding.eventType).toBe('pressed')\nexpect(binding.controllerName).toBeNull()"
              },
              {
                "title": "object format with actionName and eventType",
                "line": 616,
                "source": "const binding = application.bindInput({\n    controlName: 'rightButton',\n    actionName: 'menu',\n    eventType: 'released'\n})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('mouse')\nexpect(binding.controlName).toBe('rightButton')\nexpect(binding.actionName).toBe('menu')\nexpect(binding.eventType).toBe('released')\nexpect(binding.controllerName).toBeNull()"
              },
              {
                "title": "object format with all options",
                "line": 631,
                "source": "const binding = application.bindInput({\n    controlName: 'leftButton',\n    actionName: 'fire',\n    eventType: 'pressed',\n    controllerName: 'weapon'\n})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('mouse')\nexpect(binding.controlName).toBe('leftButton')\nexpect(binding.actionName).toBe('fire')\nexpect(binding.eventType).toBe('pressed')\nexpect(binding.controllerName).toBe('weapon')"
              },
              {
                "title": "object format with partial options uses defaults",
                "line": 647,
                "source": "const binding = application.bindInput({\n    controlName: 'middleButton',\n    actionName: 'special',\n    controllerName: 'ui'\n})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('mouse')\nexpect(binding.controlName).toBe('middleButton')\nexpect(binding.actionName).toBe('special')\nexpect(binding.eventType).toBe('pressed')\nexpect(binding.controllerName).toBe('ui')"
              },
              {
                "title": "backwards compatibility - original format still works",
                "line": 662,
                "source": "const binding = application.bindInput({controlName: 'rightButton', actionName: 'aim'})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('mouse')\nexpect(binding.controlName).toBe('rightButton')\nexpect(binding.actionName).toBe('aim')\nexpect(binding.eventType).toBe('pressed')\nexpect(binding.controllerName).toBeNull()"
              },
              {
                "title": "object format validation - empty object should throw",
                "line": 673,
                "source": "expect(() => {\n    application.bindMouse('leftButton', {})\n}).toThrow()"
              },
              {
                "title": "object format validation - undefined actionName should throw",
                "line": 679,
                "source": "expect(() => {\n    application.bindMouse('rightButton', {actionName: undefined})\n}).toThrow()"
              },
              {
                "title": "parameter format validation - undefined actionName should throw",
                "line": 685,
                "source": "expect(() => {\n    application.bindMouse('middleButton', undefined)\n}).toThrow()"
              }
            ],
            "describes": []
          },
          {
            "title": "flexible API edge cases",
            "line": 694,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "mixed usage in same application",
                "line": 696,
                "source": "const binding1 = application.bindInput({controlName: 'Digit1', actionName: 'slot1', eventType: 'pressed', controllerName: 'inventory'})\n\nconst binding2 = application.bindInput({\n    controlName: 'Digit2',\n    actionName: 'slot2',\n    eventType: 'pressed',\n    controllerName: 'inventory'\n})\n\nexpect(binding1.actionName).toBe('slot1')\nexpect(binding1.controllerName).toBe('inventory')\nexpect(binding2.actionName).toBe('slot2')\nexpect(binding2.controllerName).toBe('inventory')\n\nconst allBindings = application.getAllBindings()\nconst inventoryBindings = allBindings.filter(b => b.controllerName === 'inventory')\nexpect(inventoryBindings).toHaveLength(2)"
              },
              {
                "title": "object format with empty object defaults everything",
                "line": 716,
                "source": "expect(() => {\n    application.bindKey('KeyEmpty', {})\n}).toThrow()"
              },
              {
                "title": "object format with undefined actionName",
                "line": 722,
                "source": "expect(() => {\n    application.bindKey('KeyUndef', {actionName: undefined})\n}).toThrow()"
              },
              {
                "title": "object format with null actionName",
                "line": 728,
                "source": "expect(() => {\n    application.bindKey('KeyNull', {actionName: null})\n}).toThrow()"
              },
              {
                "title": "object format with empty string actionName",
                "line": 734,
                "source": "expect(() => {\n    application.bindKey('KeyEmpty', {actionName: ''})\n}).toThrow()"
              },
              {
                "title": "parameter format with undefined actionName",
                "line": 740,
                "source": "expect(() => {\n    application.bindKey('KeyParamUndef', undefined)\n}).toThrow()"
              },
              {
                "title": "parameter format with null actionName",
                "line": 746,
                "source": "expect(() => {\n    application.bindKey('KeyParamNull', null)\n}).toThrow()"
              }
            ],
            "describes": []
          },
          {
            "title": "bindCombo",
            "line": 755,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "accepts string format with auto-detection",
                "line": 757,
                "source": "const combo = application.bindCombo(['ShiftLeft', 'leftButton'], 'shiftClick')\n\nexpect(combo).toBeDefined()\nexpect(combo.controls).toHaveLength(2)\nexpect(combo.controls[0].deviceName).toBe('keyboard')\nexpect(combo.controls[0].controlName).toBe('ShiftLeft')\nexpect(combo.controls[1].deviceName).toBe('mouse')\nexpect(combo.controls[1].controlName).toBe('leftButton')\nexpect(combo.actionName).toBe('shiftClick')"
              },
              {
                "title": "accepts object format",
                "line": 770,
                "source": "const combo = application.bindCombo([\n    {deviceName: 'keyboard', controlName: 'ControlLeft'},\n    {deviceName: 'mouse', controlName: 'rightButton'}\n], 'ctrlRightClick')\n\nexpect(combo.controls).toHaveLength(2)\nexpect(combo.controls[0].deviceName).toBe('keyboard')\nexpect(combo.controls[1].deviceName).toBe('mouse')"
              },
              {
                "title": "accepts mixed string and object formats",
                "line": 782,
                "source": "const combo = application.bindCombo([\n    'ControlLeft',\n    {deviceName: 'mouse', controlName: 'leftButton'}\n], 'mixedCombo')\n\nexpect(combo.controls).toHaveLength(2)\nexpect(combo.controls[0].deviceName).toBe('keyboard')\nexpect(combo.controls[0].controlName).toBe('ControlLeft')\nexpect(combo.controls[1].deviceName).toBe('mouse')\nexpect(combo.controls[1].controlName).toBe('leftButton')"
              },
              {
                "title": "works with keyboard-only combinations",
                "line": 796,
                "source": "const combo = application.bindCombo(['ControlLeft', 'KeyS'], 'save')\n\nexpect(combo.controls).toHaveLength(2)\nexpect(combo.controls.every(c => c.deviceName === 'keyboard')).toBe(true)"
              },
              {
                "title": "works with mouse-only combinations",
                "line": 804,
                "source": "const combo = application.bindCombo(['leftButton', 'rightButton'], 'bothButtons')\n\nexpect(combo.controls).toHaveLength(2)\nexpect(combo.controls.every(c => c.deviceName === 'mouse')).toBe(true)"
              },
              {
                "title": "supports controller and eventType",
                "line": 812,
                "source": "const combo = application.bindCombo(\n    ['AltLeft', 'middleButton'],\n    'special',\n    'editor',\n    'released'\n)\n\nexpect(combo.controllerName).toBe('editor')\nexpect(combo.eventType).toBe('released')"
              },
              {
                "title": "integration test - triggers when all controls are pressed",
                "line": 825,
                "source": "class TestController extends PerkyModule {\n    smartCombo = vi.fn()\n}\n\nconst testApp = new Application()\n\n\nconst controller = testApp.registerController('editor', TestController)\ntestApp.setActiveControllers('editor')\ntestApp.bindCombo(['ControlLeft', 'leftButton'], 'smartCombo', 'editor')\n\nconst keyboardDevice = testApp.getDevice('keyboard')\nconst mouseDevice = testApp.getDevice('mouse')\n\nconst ctrlControl = keyboardDevice.findOrCreateControl(ButtonControl, {name: 'ControlLeft'})\nconst leftButtonControl = mouseDevice.findOrCreateControl(ButtonControl, {name: 'leftButton'})\n\nctrlControl.press({code: 'ControlLeft'})\nawait new Promise(resolve => setTimeout(resolve, 0))\nexpect(controller.smartCombo).not.toHaveBeenCalled()\n\nleftButtonControl.press()\nawait new Promise(resolve => setTimeout(resolve, 0))\nexpect(controller.smartCombo).toHaveBeenCalled()"
              }
            ],
            "describes": []
          },
          {
            "title": "isActionPressed and getActionControls",
            "line": 855,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "isActionPressed - returns false when action not bound",
                "line": 857,
                "source": "expect(application.isActionPressed('nonExistent')).toBe(false)"
              },
              {
                "title": "isActionPressed - returns false when control not pressed",
                "line": 862,
                "source": "application.bindInput({controlName: 'Space', actionName: 'jump'})\nexpect(application.isActionPressed('jump')).toBe(false)"
              },
              {
                "title": "isActionPressed - returns true when control is pressed",
                "line": 868,
                "source": "application.bindInput({controlName: 'Space', actionName: 'jump'})\n\nconst keyboardDevice = application.getDevice('keyboard')\nconst spaceControl = keyboardDevice.findOrCreateControl(ButtonControl, {name: 'Space'})\nspaceControl.press()\n\nexpect(application.isActionPressed('jump')).toBe(true)"
              },
              {
                "title": "isActionPressed - works with multiple bindings for same action",
                "line": 879,
                "source": "application.bindInput({controlName: 'Space', actionName: 'jump'})\napplication.bindInput({controlName: 'KeyW', actionName: 'jump'})\n\nconst keyboardDevice = application.getDevice('keyboard')\nconst wControl = keyboardDevice.findOrCreateControl(ButtonControl, {name: 'KeyW'})\nwControl.press()\n\nexpect(application.isActionPressed('jump')).toBe(true)"
              },
              {
                "title": "isActionPressed - filters by controllerName",
                "line": 891,
                "source": "application.bindInput({controlName: 'Space', actionName: 'jump', eventType: 'pressed', controllerName: 'player1'})\napplication.bindInput({controlName: 'KeyW', actionName: 'jump', eventType: 'pressed', controllerName: 'player2'})\n\nconst keyboardDevice = application.getDevice('keyboard')\nconst spaceControl = keyboardDevice.findOrCreateControl(ButtonControl, {name: 'Space'})\nspaceControl.press()\n\nexpect(application.isActionPressed('jump', 'player1')).toBe(true)\nexpect(application.isActionPressed('jump', 'player2')).toBe(false)\nexpect(application.isActionPressed('jump')).toBe(true)"
              },
              {
                "title": "isActionPressed - works with composite bindings",
                "line": 905,
                "source": "application.bindCombo(['ControlLeft', 'KeyS'], 'save')\n\nconst keyboardDevice = application.getDevice('keyboard')\nconst ctrlControl = keyboardDevice.findOrCreateControl(ButtonControl, {name: 'ControlLeft'})\nconst sControl = keyboardDevice.findOrCreateControl(ButtonControl, {name: 'KeyS'})\n\nctrlControl.press()\nexpect(application.isActionPressed('save')).toBe(false)\n\nsControl.press()\nexpect(application.isActionPressed('save')).toBe(true)\n\nctrlControl.release()\nexpect(application.isActionPressed('save')).toBe(false)"
              },
              {
                "title": "getActionControls - returns empty array when action not bound",
                "line": 923,
                "source": "const controls = application.getActionControls('nonExistent')\nexpect(controls).toHaveLength(0)"
              },
              {
                "title": "getActionControls - returns control for simple binding",
                "line": 929,
                "source": "application.bindInput({controlName: 'Space', actionName: 'jump'})\n\nconst keyboardDevice = application.getDevice('keyboard')\nconst spaceControl = keyboardDevice.findOrCreateControl(ButtonControl, {name: 'Space'})\n\nconst controls = application.getActionControls('jump')\nexpect(controls).toHaveLength(1)\nexpect(controls[0]).toBe(spaceControl)"
              },
              {
                "title": "getActionControls - returns multiple controls for multiple bindings",
                "line": 941,
                "source": "application.bindInput({controlName: 'Space', actionName: 'jump', eventType: 'pressed', controllerName: 'player1'})\napplication.bindInput({controlName: 'KeyW', actionName: 'jump', eventType: 'pressed', controllerName: 'player2'})\n\nconst keyboardDevice = application.getDevice('keyboard')\nconst spaceControl = keyboardDevice.findOrCreateControl(ButtonControl, {name: 'Space'})\nconst wControl = keyboardDevice.findOrCreateControl(ButtonControl, {name: 'KeyW'})\n\nconst controls = application.getActionControls('jump')\nexpect(controls).toHaveLength(2)\nexpect(controls).toContain(spaceControl)\nexpect(controls).toContain(wControl)"
              },
              {
                "title": "getActionControls - filters by controllerName",
                "line": 956,
                "source": "application.bindInput({controlName: 'Space', actionName: 'jump', eventType: 'pressed', controllerName: 'player1'})\napplication.bindInput({controlName: 'KeyW', actionName: 'jump', eventType: 'pressed', controllerName: 'player2'})\n\nconst keyboardDevice = application.getDevice('keyboard')\nkeyboardDevice.findOrCreateControl(ButtonControl, {name: 'Space'})\nkeyboardDevice.findOrCreateControl(ButtonControl, {name: 'KeyW'})\n\nconst player1Controls = application.getActionControls('jump', 'player1')\nexpect(player1Controls).toHaveLength(1)\nexpect(player1Controls[0].name).toBe('Space')\n\nconst player2Controls = application.getActionControls('jump', 'player2')\nexpect(player2Controls).toHaveLength(1)\nexpect(player2Controls[0].name).toBe('KeyW')\n\nconst allControls = application.getActionControls('jump')\nexpect(allControls).toHaveLength(2)"
              },
              {
                "title": "getActionControls - works with composite bindings",
                "line": 977,
                "source": "application.bindCombo(['ControlLeft', 'KeyS'], 'save')\n\nconst keyboardDevice = application.getDevice('keyboard')\nconst ctrlControl = keyboardDevice.findOrCreateControl(ButtonControl, {name: 'ControlLeft'})\nconst sControl = keyboardDevice.findOrCreateControl(ButtonControl, {name: 'KeyS'})\n\nconst controls = application.getActionControls('save')\nexpect(controls).toHaveLength(2)\nexpect(controls).toContain(ctrlControl)\nexpect(controls).toContain(sControl)"
              },
              {
                "title": "getActionControls - handles non-existent controls gracefully",
                "line": 991,
                "source": "application.bindInput({controlName: 'Space', actionName: 'jump'})\n\nconst controls = application.getActionControls('jump')\nexpect(controls).toHaveLength(0)"
              },
              {
                "title": "getActionControls - works with cross-device bindings",
                "line": 999,
                "source": "application.bindInput({controlName: 'Space', actionName: 'action', eventType: 'pressed', controllerName: 'keyboard-input'})\napplication.bindInput({controlName: 'leftButton', actionName: 'action', eventType: 'pressed', controllerName: 'mouse-input'})\n\nconst keyboardDevice = application.getDevice('keyboard')\nconst mouseDevice = application.getDevice('mouse')\nconst spaceControl = keyboardDevice.findOrCreateControl(ButtonControl, {name: 'Space'})\nconst leftButtonControl = mouseDevice.findOrCreateControl(ButtonControl, {name: 'leftButton'})\n\nconst controls = application.getActionControls('action')\nexpect(controls).toHaveLength(2)\nexpect(controls).toContain(spaceControl)\nexpect(controls).toContain(leftButtonControl)"
              }
            ],
            "describes": []
          },
          {
            "title": "controller bindings auto-registration",
            "line": 1017,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "registers simple bindings when controller is registered",
                "line": 1019,
                "source": "class TestController extends PerkyModule {\n    static bindings = {\n        shoot: 'Space',\n        jump: 'KeyJ'\n    }\n\n    static normalizeBindings () {\n        return [\n            {action: 'shoot', key: 'Space', scoped: false, eventType: 'pressed', controllerName: null},\n            {action: 'jump', key: 'KeyJ', scoped: false, eventType: 'pressed', controllerName: null}\n        ]\n    }\n}\n\nconst beforeBindings = application.getAllBindings()\nexpect(beforeBindings.filter(b => b.actionName === 'shoot')).toHaveLength(0)\n\napplication.registerController('game', TestController)\n\nconst afterBindings = application.getAllBindings()\nconst shootBinding = afterBindings.find(b => b.actionName === 'shoot')\nconst jumpBinding = afterBindings.find(b => b.actionName === 'jump')\n\nexpect(shootBinding).toBeDefined()\nexpect(shootBinding.controlName).toBe('Space')\nexpect(shootBinding.controllerName).toBeNull()\n\nexpect(jumpBinding).toBeDefined()\nexpect(jumpBinding.controlName).toBe('KeyJ')\nexpect(jumpBinding.controllerName).toBeNull()"
              },
              {
                "title": "registers scoped bindings with controllerName",
                "line": 1053,
                "source": "class TestController extends PerkyModule {\n    static bindings = {\n        shoot: {keys: 'Space', scoped: true}\n    }\n\n    static normalizeBindings (controllerName) {\n        return [\n            {action: 'shoot', key: 'Space', scoped: true, eventType: 'pressed', controllerName}\n        ]\n    }\n}\n\napplication.registerController('player', TestController)\n\nconst bindings = application.getAllBindings()\nconst shootBinding = bindings.find(b => b.actionName === 'shoot' && b.controllerName === 'player')\n\nexpect(shootBinding).toBeDefined()\nexpect(shootBinding.controlName).toBe('Space')\nexpect(shootBinding.controllerName).toBe('player')"
              },
              {
                "title": "registers multiple keys for same action",
                "line": 1077,
                "source": "class TestController extends PerkyModule {\n    static bindings = {\n        moveUp: ['KeyW', 'ArrowUp']\n    }\n\n    static normalizeBindings () {\n        return [\n            {action: 'moveUp', key: 'KeyW', scoped: false, eventType: 'pressed', controllerName: null},\n            {action: 'moveUp', key: 'ArrowUp', scoped: false, eventType: 'pressed', controllerName: null}\n        ]\n    }\n}\n\napplication.registerController('game', TestController)\n\nconst bindings = application.getAllBindings()\nconst moveUpBindings = bindings.filter(b => b.actionName === 'moveUp')\n\nexpect(moveUpBindings.length).toBeGreaterThanOrEqual(2)\nexpect(moveUpBindings.some(b => b.controlName === 'KeyW')).toBe(true)\nexpect(moveUpBindings.some(b => b.controlName === 'ArrowUp')).toBe(true)"
              },
              {
                "title": "registers bindings with custom eventType",
                "line": 1102,
                "source": "class TestController extends PerkyModule {\n    static bindings = {\n        boost: {keys: 'ShiftLeft', eventType: 'released'}\n    }\n\n    static normalizeBindings () {\n        return [\n            {action: 'boost', key: 'ShiftLeft', scoped: false, eventType: 'released', controllerName: null}\n        ]\n    }\n}\n\napplication.registerController('game', TestController)\n\nconst bindings = application.getAllBindings()\nconst boostBinding = bindings.find(b => b.actionName === 'boost')\n\nexpect(boostBinding).toBeDefined()\nexpect(boostBinding.eventType).toBe('released')"
              },
              {
                "title": "allows multiple controllers with same keys (different scopes)",
                "line": 1125,
                "source": "class GameController extends PerkyModule {\n    static bindings = {\n        move: {keys: 'ArrowUp', scoped: true}\n    }\n\n    static normalizeBindings (controllerName) {\n        return [\n            {action: 'move', key: 'ArrowUp', scoped: true, eventType: 'pressed', controllerName}\n        ]\n    }\n}\n\nclass MenuController extends PerkyModule {\n    static bindings = {\n        navigate: {keys: 'ArrowUp', scoped: true}\n    }\n\n    static normalizeBindings (controllerName) {\n        return [\n            {action: 'navigate', key: 'ArrowUp', scoped: true, eventType: 'pressed', controllerName}\n        ]\n    }\n}\n\napplication.registerController('game', GameController)\napplication.registerController('menu', MenuController)\n\nconst bindings = application.getAllBindings()\nconst arrowUpBindings = bindings.filter(b => b.controlName === 'ArrowUp')\n\nexpect(arrowUpBindings.length).toBeGreaterThanOrEqual(2)\n\nconst gameBinding = arrowUpBindings.find(b => b.controllerName === 'game')\nconst menuBinding = arrowUpBindings.find(b => b.controllerName === 'menu')\n\nexpect(gameBinding).toBeDefined()\nexpect(gameBinding.actionName).toBe('move')\n\nexpect(menuBinding).toBeDefined()\nexpect(menuBinding.actionName).toBe('navigate')"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/application/perky_view.doc.js": {
    "file": "/application/perky_view.test.js",
    "describes": [
      {
        "title": "PerkyView",
        "line": 6,
        "beforeEach": {
          "line": 11,
          "source": "element = document.createElement('div')\nelement.id = 'test-view'\n\ncontainer = document.createElement('div')\ncontainer.id = 'test-container'\ndocument.body.appendChild(container)\n\nvi.spyOn(element, 'offsetWidth', 'get').mockReturnValue(0)\nvi.spyOn(element, 'offsetHeight', 'get').mockReturnValue(0)\nvi.spyOn(element, 'getBoundingClientRect').mockReturnValue({\n    left: 0,\n    top: 0,\n    width: 0,\n    height: 0,\n    right: 0,\n    bottom: 0,\n    x: 0,\n    y: 0\n})\n\nvi.spyOn(PerkyModule.prototype, 'emit')\n\nview = new PerkyView({element})"
        },
        "afterEach": {
          "line": 38,
          "source": "vi.restoreAllMocks()\ndocument.body.innerHTML = ''"
        },
        "tests": [
          {
            "title": "constructor with element",
            "line": 44,
            "source": "expect(view.element).toBe(element)"
          },
          {
            "title": "constructor with container",
            "line": 49,
            "source": "const viewWithContainer = new PerkyView({\n    element,\n    container\n})\n\nexpect(container.contains(element)).toBe(true)\nexpect(viewWithContainer.container).toBe(container)"
          },
          {
            "title": "constructor with default element",
            "line": 60,
            "source": "const defaultView = new PerkyView()\n\nexpect(defaultView.element.tagName).toBe('DIV')\nexpect(defaultView.element.className).toBe('perky-view')"
          },
          {
            "title": "html getter",
            "line": 68,
            "source": "element.innerHTML = '<div>test content</div>'\nexpect(view.html).toBe('<div>test content</div>')"
          },
          {
            "title": "width getter",
            "line": 74,
            "source": "element.style.width = '300px'\nvi.spyOn(element, 'offsetWidth', 'get').mockReturnValue(300)\nexpect(view.width).toBe(300)"
          },
          {
            "title": "height getter",
            "line": 81,
            "source": "element.style.height = '400px'\nvi.spyOn(element, 'offsetHeight', 'get').mockReturnValue(400)\nexpect(view.height).toBe(400)"
          },
          {
            "title": "aspectRatio getter",
            "line": 88,
            "source": "element.style.width = '300px'\nelement.style.height = '400px'\nvi.spyOn(element, 'offsetWidth', 'get').mockReturnValue(300)\nvi.spyOn(element, 'offsetHeight', 'get').mockReturnValue(400)\nexpect(view.aspectRatio).toBe(300 / 400)"
          },
          {
            "title": "size getter",
            "line": 97,
            "source": "element.style.width = '300px'\nelement.style.height = '400px'\nvi.spyOn(element, 'offsetWidth', 'get').mockReturnValue(300)\nvi.spyOn(element, 'offsetHeight', 'get').mockReturnValue(400)\nexpect(view.size).toEqual({\n    width: 300,\n    height: 400\n})"
          },
          {
            "title": "addClass",
            "line": 109,
            "source": "view.addClass('test-class')\nexpect(element.classList.contains('test-class')).toBe(true)"
          },
          {
            "title": "removeClass",
            "line": 115,
            "source": "element.classList.add('test-class')\nview.removeClass('test-class')\nexpect(element.classList.contains('test-class')).toBe(false)"
          },
          {
            "title": "hasClass",
            "line": 122,
            "source": "element.classList.add('test-class')\nexpect(view.hasClass('test-class')).toBe(true)"
          },
          {
            "title": "setSize",
            "line": 128,
            "source": "view.setSize({width: 100, height: 200})\n\nexpect(element.style.width).toBe('100px')\nexpect(element.style.height).toBe('200px')"
          },
          {
            "title": "setSize with custom unit",
            "line": 136,
            "source": "view.setSize({width: 100, height: 200, unit: '%'})\n\nexpect(element.style.width).toBe('100%')\nexpect(element.style.height).toBe('200%')"
          },
          {
            "title": "fit",
            "line": 144,
            "source": "container.style.width = '500px'\ncontainer.style.height = '600px'\ncontainer.appendChild(element)\n\nvi.spyOn(container, 'getBoundingClientRect').mockReturnValue({\n    width: 500,\n    height: 600,\n    left: 0,\n    top: 0,\n    right: 500,\n    bottom: 600,\n    x: 0,\n    y: 0\n})\n\nview.fit()\n\nexpect(element.style.width).toBe('500px')\nexpect(element.style.height).toBe('600px')"
          },
          {
            "title": "mount",
            "line": 167,
            "source": "view.mount(container)\n\nexpect(container.contains(element)).toBe(true)\nexpect(view.container).toBe(container)\nexpect(view.emit).toHaveBeenCalledWith('mount', {container})"
          },
          {
            "title": "isVisible",
            "line": 176,
            "source": "element.style.display = 'block'\nexpect(view.isVisible()).toBe(true)\n\nelement.style.display = 'none'\nexpect(view.isVisible()).toBe(false)"
          },
          {
            "title": "display getter and setter",
            "line": 185,
            "source": "view.display = 'flex'\nexpect(element.style.display).toBe('flex')\nexpect(view.display).toBe('flex')\nexpect(view.display = 'flex').toBe('flex')"
          },
          {
            "title": "hide",
            "line": 193,
            "source": "element.style.display = 'flex'\nview.hide()\n\nexpect(element.style.display).toBe('none')"
          },
          {
            "title": "show restores previous display",
            "line": 201,
            "source": "element.style.display = 'flex'\nview.hide()\nview.show()\n\nexpect(element.style.display).toBe('flex')"
          },
          {
            "title": "show without previous display",
            "line": 210,
            "source": "view.show()\nexpect(element.style.display).toBe('')"
          }
        ],
        "describes": []
      }
    ]
  },
  "/core/notifier.doc.js": {
    "file": "/core/notifier.test.js",
    "describes": [
      {
        "title": "Notifier",
        "line": 5,
        "beforeEach": {
          "line": 9,
          "source": "notifier = new Notifier()"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor",
            "line": 14,
            "source": "expect(notifier.getListenersFor('any')).toBeUndefined()"
          },
          {
            "title": "getListenersFor",
            "line": 19,
            "source": "expect(notifier.getListenersFor('foo')).toBeUndefined()\n\nnotifier.on('foo', () => { })\nexpect(notifier.getListenersFor('foo')).toHaveLength(1)"
          },
          {
            "title": "on",
            "line": 27,
            "source": "const listener = () => { }\n\nexpect(notifier.on('foo', listener)).toBe(listener)\nexpect(notifier.getListenersFor('foo')).toEqual([listener])"
          },
          {
            "title": "once",
            "line": 35,
            "source": "const listener = vi.fn()\nconst wrapper = notifier.once('foo', listener)\n\nexpect(wrapper).not.toBe(listener)\nexpect(notifier.getListenersFor('foo')).toEqual([wrapper])\n\nnotifier.emit('foo', 1, 2, 3)\nexpect(listener).toHaveBeenCalledWith(1, 2, 3)\nexpect(notifier.getListenersFor('foo')).toEqual([])"
          },
          {
            "title": "off",
            "line": 48,
            "source": "const listener = () => { }\n\nexpect(notifier.off('foo', listener)).toBe(false)\n\nnotifier.on('foo', listener)\nexpect(notifier.off('foo', listener)).toBe(true)\nexpect(notifier.getListenersFor('foo')).toEqual([])"
          },
          {
            "title": "emit",
            "line": 59,
            "source": "const listener = vi.fn()\n\nnotifier.on('foo', listener)\nnotifier.emit('foo', 1, 2, 3)\nexpect(listener).toHaveBeenCalledWith(1, 2, 3)\n\nnotifier.emit('bar')\nexpect(listener).toHaveBeenCalledTimes(1)"
          },
          {
            "title": "removeListeners",
            "line": 71,
            "source": "notifier.on('foo', () => { })\nnotifier.on('bar', () => { })\n\nexpect(notifier.getListenersFor('foo')).toHaveLength(1)\nexpect(notifier.getListenersFor('bar')).toHaveLength(1)\n\nnotifier.removeListeners()\nexpect(notifier.getListenersFor('foo')).toBeUndefined()\nexpect(notifier.getListenersFor('bar')).toBeUndefined()"
          },
          {
            "title": "removeListenersFor",
            "line": 84,
            "source": "notifier.on('foo', () => { })\nnotifier.on('bar', () => { })\n\nexpect(notifier.getListenersFor('foo')).toHaveLength(1)\nexpect(notifier.getListenersFor('bar')).toHaveLength(1)\n\nnotifier.removeListenersFor('foo')\nexpect(notifier.getListenersFor('foo')).toBeUndefined()\nexpect(notifier.getListenersFor('bar')).toHaveLength(1)"
          },
          {
            "title": "instances have separate listeners",
            "line": 97,
            "source": "const notifier1 = new Notifier()\nconst notifier2 = new Notifier()\n\nnotifier1.on('test', () => { })\nexpect(notifier1.getListenersFor('test')).toHaveLength(1)\nexpect(notifier2.getListenersFor('test')).toBeUndefined()\n\nnotifier2.on('test', () => { })\nnotifier2.on('test', () => { })\nexpect(notifier1.getListenersFor('test')).toHaveLength(1)\nexpect(notifier2.getListenersFor('test')).toHaveLength(2)"
          },
          {
            "title": "emit passes notifier as this context to listeners",
            "line": 112,
            "source": "let receivedContext\n\nfunction listener () {\n    receivedContext = this\n}\n\nnotifier.on('test', listener)\nnotifier.emit('test', 'arg1', 'arg2')\n\nexpect(receivedContext).toBe(notifier)"
          }
        ],
        "describes": [
          {
            "title": "listenTo",
            "line": 126,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "should register listener on target and track it",
                "line": 127,
                "source": "const target = new Notifier()\nconst listener = vi.fn()\n\nnotifier.listenTo(target, 'test', listener)\ntarget.emit('test', 1, 2, 3)\n\nexpect(listener).toHaveBeenCalledWith(1, 2, 3)"
              },
              {
                "title": "should track multiple listeners on same target",
                "line": 137,
                "source": "const target = new Notifier()\nconst listener1 = vi.fn()\nconst listener2 = vi.fn()\n\nnotifier.listenTo(target, 'event1', listener1)\nnotifier.listenTo(target, 'event2', listener2)\n\ntarget.emit('event1', 'a')\ntarget.emit('event2', 'b')\n\nexpect(listener1).toHaveBeenCalledWith('a')\nexpect(listener2).toHaveBeenCalledWith('b')"
              },
              {
                "title": "should track listeners on multiple targets",
                "line": 152,
                "source": "const target1 = new Notifier()\nconst target2 = new Notifier()\nconst listener1 = vi.fn()\nconst listener2 = vi.fn()\n\nnotifier.listenTo(target1, 'test', listener1)\nnotifier.listenTo(target2, 'test', listener2)\n\ntarget1.emit('test', 1)\ntarget2.emit('test', 2)\n\nexpect(listener1).toHaveBeenCalledWith(1)\nexpect(listener2).toHaveBeenCalledWith(2)"
              }
            ],
            "describes": []
          },
          {
            "title": "listenToOnce",
            "line": 170,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "should register one-time listener on target",
                "line": 171,
                "source": "const target = new Notifier()\nconst listener = vi.fn()\n\nnotifier.listenToOnce(target, 'test', listener)\n\ntarget.emit('test', 1, 2, 3)\nexpect(listener).toHaveBeenCalledWith(1, 2, 3)\nexpect(listener).toHaveBeenCalledTimes(1)\n\n// Should not be called again\ntarget.emit('test', 4, 5, 6)\nexpect(listener).toHaveBeenCalledTimes(1)"
              },
              {
                "title": "should remove from tracking after execution",
                "line": 186,
                "source": "const target = new Notifier()\nconst listener = vi.fn()\n\nnotifier.listenToOnce(target, 'test', listener)\ntarget.emit('test', 'data')\n\n// Cleanup should not fail even if listener already executed\nexpect(() => notifier.cleanExternalListeners()).not.toThrow()"
              },
              {
                "title": "should work with multiple one-time listeners",
                "line": 197,
                "source": "const target = new Notifier()\nconst listener1 = vi.fn()\nconst listener2 = vi.fn()\n\nnotifier.listenToOnce(target, 'event1', listener1)\nnotifier.listenToOnce(target, 'event2', listener2)\n\ntarget.emit('event1', 'a')\ntarget.emit('event2', 'b')\n\nexpect(listener1).toHaveBeenCalledWith('a')\nexpect(listener2).toHaveBeenCalledWith('b')\nexpect(listener1).toHaveBeenCalledTimes(1)\nexpect(listener2).toHaveBeenCalledTimes(1)"
              }
            ],
            "describes": []
          },
          {
            "title": "cleanExternalListeners",
            "line": 216,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "should remove all tracked listeners",
                "line": 217,
                "source": "const target = new Notifier()\nconst listener1 = vi.fn()\nconst listener2 = vi.fn()\n\nnotifier.listenTo(target, 'event1', listener1)\nnotifier.listenTo(target, 'event2', listener2)\n\nnotifier.cleanExternalListeners()\n\n// Listeners should not be called after cleanup\ntarget.emit('event1', 'a')\ntarget.emit('event2', 'b')\n\nexpect(listener1).not.toHaveBeenCalled()\nexpect(listener2).not.toHaveBeenCalled()"
              },
              {
                "title": "should remove listeners from multiple targets",
                "line": 235,
                "source": "const target1 = new Notifier()\nconst target2 = new Notifier()\nconst listener1 = vi.fn()\nconst listener2 = vi.fn()\n\nnotifier.listenTo(target1, 'test', listener1)\nnotifier.listenTo(target2, 'test', listener2)\n\nnotifier.cleanExternalListeners()\n\ntarget1.emit('test', 1)\ntarget2.emit('test', 2)\n\nexpect(listener1).not.toHaveBeenCalled()\nexpect(listener2).not.toHaveBeenCalled()"
              },
              {
                "title": "should handle empty listener list",
                "line": 253,
                "source": "expect(() => notifier.cleanExternalListeners()).not.toThrow()"
              },
              {
                "title": "should allow reusing notifier after cleanup",
                "line": 257,
                "source": "const target = new Notifier()\nconst listener1 = vi.fn()\nconst listener2 = vi.fn()\n\nnotifier.listenTo(target, 'test', listener1)\nnotifier.cleanExternalListeners()\nnotifier.listenTo(target, 'test', listener2)\n\ntarget.emit('test', 'data')\n\nexpect(listener1).not.toHaveBeenCalled()\nexpect(listener2).toHaveBeenCalledWith('data')"
              },
              {
                "title": "should cleanup mix of listenTo and listenToOnce",
                "line": 272,
                "source": "const target = new Notifier()\nconst listener1 = vi.fn()\nconst listener2 = vi.fn()\n\nnotifier.listenTo(target, 'event1', listener1)\nnotifier.listenToOnce(target, 'event2', listener2)\n\nnotifier.cleanExternalListeners()\n\ntarget.emit('event1', 'a')\ntarget.emit('event2', 'b')\n\nexpect(listener1).not.toHaveBeenCalled()\nexpect(listener2).not.toHaveBeenCalled()"
              }
            ],
            "describes": []
          },
          {
            "title": "emitter",
            "line": 291,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "should return a function that emits the given event",
                "line": 292,
                "source": "const listener = vi.fn()\nnotifier.on('test', listener)\n\nconst emitTest = notifier.emitter('test')\nemitTest(1, 2, 3)\n\nexpect(listener).toHaveBeenCalledWith(1, 2, 3)"
              },
              {
                "title": "should pass all arguments to emit",
                "line": 302,
                "source": "const listener = vi.fn()\nnotifier.on('foo', listener)\n\nconst emitFoo = notifier.emitter('foo')\nemitFoo('a', 'b', 'c', 'd')\n\nexpect(listener).toHaveBeenCalledWith('a', 'b', 'c', 'd')"
              },
              {
                "title": "should work with no arguments",
                "line": 312,
                "source": "const listener = vi.fn()\nnotifier.on('bar', listener)\n\nconst emitBar = notifier.emitter('bar')\nemitBar()\n\nexpect(listener).toHaveBeenCalledWith()"
              },
              {
                "title": "should create different emitters for different events",
                "line": 322,
                "source": "const listener1 = vi.fn()\nconst listener2 = vi.fn()\nnotifier.on('event1', listener1)\nnotifier.on('event2', listener2)\n\nconst emit1 = notifier.emitter('event1')\nconst emit2 = notifier.emitter('event2')\n\nemit1('data1')\nemit2('data2')\n\nexpect(listener1).toHaveBeenCalledWith('data1')\nexpect(listener2).toHaveBeenCalledWith('data2')"
              }
            ],
            "describes": []
          },
          {
            "title": "delegateEvents",
            "line": 340,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "should delegate events from target without namespace",
                "line": 341,
                "source": "const target = new Notifier()\nconst listener = vi.fn()\n\nnotifier.on('test', listener)\nnotifier.delegateEvents(target, ['test'])\n\ntarget.emit('test', 1, 2, 3)\nexpect(listener).toHaveBeenCalledWith(1, 2, 3)"
              },
              {
                "title": "should delegate events with namespace prefix",
                "line": 352,
                "source": "const target = new Notifier()\nconst listener = vi.fn()\n\nnotifier.on('child:test', listener)\nnotifier.delegateEvents(target, ['test'], 'child')\n\ntarget.emit('test', 'data')\nexpect(listener).toHaveBeenCalledWith('data')"
              },
              {
                "title": "should handle multiple events from array",
                "line": 363,
                "source": "const target = new Notifier()\nconst listener1 = vi.fn()\nconst listener2 = vi.fn()\n\nnotifier.on('event1', listener1)\nnotifier.on('event2', listener2)\nnotifier.delegateEvents(target, ['event1', 'event2'])\n\ntarget.emit('event1', 'a')\ntarget.emit('event2', 'b')\n\nexpect(listener1).toHaveBeenCalledWith('a')\nexpect(listener2).toHaveBeenCalledWith('b')"
              },
              {
                "title": "should handle events object",
                "line": 379,
                "source": "const target = new Notifier()\nconst listener1 = vi.fn()\nconst listener2 = vi.fn()\n\nnotifier.on('foo', listener1)\nnotifier.on('bar', listener2)\nnotifier.delegateEvents(target, {foo: true, bar: true})\n\ntarget.emit('foo', 1)\ntarget.emit('bar', 2)\n\nexpect(listener1).toHaveBeenCalledWith(1)\nexpect(listener2).toHaveBeenCalledWith(2)"
              },
              {
                "title": "should combine namespace with events object",
                "line": 395,
                "source": "const target = new Notifier()\nconst listener1 = vi.fn()\nconst listener2 = vi.fn()\n\nnotifier.on('ns:foo', listener1)\nnotifier.on('ns:bar', listener2)\nnotifier.delegateEvents(target, {foo: true, bar: true}, 'ns')\n\ntarget.emit('foo', 'x')\ntarget.emit('bar', 'y')\n\nexpect(listener1).toHaveBeenCalledWith('x')\nexpect(listener2).toHaveBeenCalledWith('y')"
              },
              {
                "title": "should return early if target is null",
                "line": 411,
                "source": "expect(() => notifier.delegateEvents(null, ['test'])).not.toThrow()"
              },
              {
                "title": "should return early if target is undefined",
                "line": 415,
                "source": "expect(() => notifier.delegateEvents(undefined, ['test'])).not.toThrow()"
              },
              {
                "title": "should return early if events is not array or object",
                "line": 419,
                "source": "const target = new Notifier()\nexpect(() => notifier.delegateEvents(target, 'string')).not.toThrow()\nexpect(() => notifier.delegateEvents(target, 123)).not.toThrow()"
              },
              {
                "title": "should cleanup delegated listeners",
                "line": 425,
                "source": "const target = new Notifier()\nconst listener = vi.fn()\n\nnotifier.on('test', listener)\nnotifier.delegateEvents(target, ['test'])\n\ntarget.emit('test', 'before')\nexpect(listener).toHaveBeenCalledWith('before')\n\nnotifier.cleanExternalListeners()\n\ntarget.emit('test', 'after')\nexpect(listener).toHaveBeenCalledTimes(1)"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/core/perky_module.doc.js": {
    "file": "/core/perky_module.test.js",
    "describes": [
      {
        "title": "PerkyModule",
        "line": 6,
        "beforeEach": {
          "line": 11,
          "source": "const childrenRegistry = new Registry()\nhost = {\n    started: false,\n    on: vi.fn(),\n    emit: vi.fn(),\n    childrenRegistry: childrenRegistry,\n    hasChild: vi.fn((name) => childrenRegistry.has(name)),\n    getChild: vi.fn((name) => childrenRegistry.get(name))\n}\n\nchild = new PerkyModule({$id: 'testChild'})"
        },
        "afterEach": {
          "line": 26,
          "source": "vi.restoreAllMocks()"
        },
        "tests": [
          {
            "title": "constructor",
            "line": 31,
            "source": "expect(child).toBeInstanceOf(PerkyModule)\nexpect(child.$id).toBe('testChild')\nexpect(child.options).toEqual({$id: 'testChild'})\nexpect(child.host).toBeNull()\nexpect(child.installed).toBe(false)"
          },
          {
            "title": "constructor with default name",
            "line": 40,
            "source": "class TestChild extends PerkyModule { }\nconst ext = new TestChild()\nexpect(ext.$id).toBe('TestChild')"
          },
          {
            "title": "install",
            "line": 47,
            "source": "const result = child.install(host, {})\n\nexpect(result).toBe(true)\nexpect(child.host).toBe(host)\nexpect(child.installed).toBe(true)"
          },
          {
            "title": "uninstall",
            "line": 56,
            "source": "child.install(host, {})\nconst result = child.uninstall()\n\nexpect(result).toBe(true)\nexpect(child.host).toBeNull()\nexpect(child.installed).toBe(false)"
          },
          {
            "title": "uninstall when not installed",
            "line": 66,
            "source": "const result = child.uninstall()\nexpect(result).toBe(false)"
          },
          {
            "title": "use with Child class",
            "line": 72,
            "source": "class TestChild extends PerkyModule { }\n\nconst result = child.create(TestChild, {\n    $id: 'test',\n    $category: 'test'\n})\n\nexpect(result).toBeInstanceOf(TestChild)\nexpect(result).toBe(child.getChild('test'))\nexpect(child.hasChild('test')).toBe(true)"
          },
          {
            "title": "auto-generates unique IDs when $id not provided",
            "line": 86,
            "source": "class Enemy extends PerkyModule { }\n\nconst enemy1 = child.create(Enemy, {$category: 'enemy'})\nconst enemy2 = child.create(Enemy, {$category: 'enemy'})\nconst enemy3 = child.create(Enemy, {$category: 'enemy'})\n\nexpect(child.hasChild('enemy')).toBe(true)\nexpect(child.getChild('enemy')).toBe(enemy1)\n\nexpect(child.hasChild('enemy_1')).toBe(true)\nexpect(child.getChild('enemy_1')).toBe(enemy2)\n\nexpect(child.hasChild('enemy_2')).toBe(true)\nexpect(child.getChild('enemy_2')).toBe(enemy3)"
          },
          {
            "title": "explicit $id creates single instance (replacement)",
            "line": 104,
            "source": "class Player extends PerkyModule { }\n\nconst player1 = child.create(Player, {\n    $id: 'player',\n    $category: 'player'\n})\n\nconst player2 = child.create(Player, {\n    $id: 'player',\n    $category: 'player'\n})\n\nexpect(child.hasChild('player')).toBe(true)\nexpect(child.getChild('player')).toBe(player2)\nexpect(child.getChild('player')).not.toBe(player1)\n\nexpect(child.hasChild('player_1')).toBe(false)"
          },
          {
            "title": "unique IDs work with different categories",
            "line": 125,
            "source": "class Enemy extends PerkyModule { }\nclass Projectile extends PerkyModule { }\n\nconst enemy1 = child.create(Enemy, {$category: 'enemy'})\nconst enemy1Name = child.childrenRegistry.keyFor(enemy1)\n\nconst projectile1 = child.create(Projectile, {$category: 'projectile'})\nconst projectile1Name = child.childrenRegistry.keyFor(projectile1)\n\nconst enemy2 = child.create(Enemy, {$category: 'enemy'})\nconst enemy2Name = child.childrenRegistry.keyFor(enemy2)\n\nconst projectile2 = child.create(Projectile, {$category: 'projectile'})\nconst projectile2Name = child.childrenRegistry.keyFor(projectile2)\n\nexpect(child.hasChild(enemy1Name)).toBe(true)\nexpect(child.hasChild(enemy2Name)).toBe(true)\nexpect(child.hasChild(projectile1Name)).toBe(true)\nexpect(child.hasChild(projectile2Name)).toBe(true)\n\nexpect(enemy1).not.toBe(enemy2)\nexpect(projectile1).not.toBe(projectile2)"
          },
          {
            "title": "listNamesFor - single category",
            "line": 151,
            "source": "class TestChild1 extends PerkyModule { }\nclass TestChild2 extends PerkyModule { }\n\nchild.create(TestChild1, {\n    $id: 'ext1',\n    $category: 'module'\n})\n\nchild.create(TestChild2, {\n    $id: 'ext2',\n    $category: 'module'\n})\n\nconst modules = child.listNamesFor('module')\n\nexpect(modules).toHaveLength(2)\nexpect(modules).toContain('ext1')\nexpect(modules).toContain('ext2')"
          },
          {
            "title": "listNamesFor - mixed categories",
            "line": 173,
            "source": "class TestChild1 extends PerkyModule { }\nclass TestChild2 extends PerkyModule { }\nclass TestChild3 extends PerkyModule { }\n\nchild.create(TestChild1, {\n    $id: 'ext1',\n    $category: 'module'\n})\n\nchild.create(TestChild2, {\n    $id: 'ext2',\n    $category: 'service'\n})\n\nchild.create(TestChild3, {\n    $id: 'ext3',\n    $category: 'module'\n})\n\nconst modules = child.listNamesFor('module')\nconst services = child.listNamesFor('service')\n\nexpect(modules).toHaveLength(2)\nexpect(modules).toContain('ext1')\nexpect(modules).toContain('ext3')\n\nexpect(services).toHaveLength(1)\nexpect(services).toContain('ext2')"
          },
          {
            "title": "listNamesFor - empty category",
            "line": 205,
            "source": "const parent = new PerkyModule()\n\nparent.create(PerkyModule, {$category: 'module'})\nparent.create(PerkyModule, {$category: 'module'})\n\nconst services = parent.listNamesFor('service')\nexpect(services).toEqual([])"
          },
          {
            "title": "listNamesFor - dynamic category update",
            "line": 216,
            "source": "const parent = new PerkyModule()\n\nconst childA = parent.create(PerkyModule, {$id: 'childA', $category: 'module'})\nparent.create(PerkyModule, {$id: 'childB', $category: 'service'})\n\nexpect(parent.listNamesFor('module')).toEqual(['childA'])\nexpect(parent.listNamesFor('service')).toEqual(['childB'])\n\nchildA.$category = 'service'\n\nexpect(parent.listNamesFor('module')).toEqual([])\nconst serviceChildren = parent.listNamesFor('service')\nexpect(serviceChildren).toHaveLength(2)\nexpect(serviceChildren).toContain('childA')\nexpect(serviceChildren).toContain('childB')"
          },
          {
            "title": "category index is automatically created",
            "line": 235,
            "source": "const registry = child.childrenRegistry\n\nexpect(registry.hasIndex('$category')).toBe(true)"
          },
          {
            "title": "category index is updated when children are added",
            "line": 242,
            "source": "class TestChild extends PerkyModule { }\nconst registry = child.childrenRegistry\n\nchild.create(TestChild, {\n    $id: 'ext1',\n    $category: 'module'\n})\n\nchild.create(TestChild, {\n    $id: 'ext2',\n    $category: 'service'\n})\n\nconst moduleChildren = registry.lookup('$category', 'module')\nconst serviceChildren = registry.lookup('$category', 'service')\n\nexpect(moduleChildren).toHaveLength(1)\nexpect(serviceChildren).toHaveLength(1)\nexpect(moduleChildren[0]).toBe(child.getChild('ext1'))\nexpect(serviceChildren[0]).toBe(child.getChild('ext2'))"
          },
          {
            "title": "category index is updated when children are removed",
            "line": 266,
            "source": "class TestChild extends PerkyModule { }\nconst registry = child.childrenRegistry\n\nchild.create(TestChild, {\n    $id: 'ext1',\n    $category: 'module'\n})\n\nchild.create(TestChild, {\n    $id: 'ext2',\n    $category: 'module'\n})\n\nlet moduleChildren = registry.lookup('$category', 'module')\nexpect(moduleChildren).toHaveLength(2)\n\nchild.removeChild('ext1')\n\nmoduleChildren = registry.lookup('$category', 'module')\nexpect(moduleChildren).toHaveLength(1)\nexpect(moduleChildren[0]).toBe(child.getChild('ext2'))"
          },
          {
            "title": "registry key is updated when child name changes",
            "line": 291,
            "source": "const parent = new PerkyModule()\n\nconst childModule = parent.create(PerkyModule, {\n    $id: 'oldName',\n    $category: 'module'\n})\n\nexpect(parent.hasChild('oldName')).toBe(true)\nexpect(parent.getChild('oldName')).toBe(childModule)\n\nchildModule.$id = 'newName'\n\nexpect(parent.hasChild('oldName')).toBe(false)\nexpect(parent.hasChild('newName')).toBe(true)\nexpect(parent.getChild('newName')).toBe(childModule)"
          },
          {
            "title": "use with binding",
            "line": 310,
            "source": "class TestChild extends PerkyModule { }\n\nchild.create(TestChild, {\n    $id: 'test',\n    $bind: 'testProperty'\n})\n\nexpect(child.testProperty).toBeInstanceOf(TestChild)"
          },
          {
            "title": "binding updates automatically when $bind changes",
            "line": 322,
            "source": "class TestChild extends PerkyModule { }\n\nconst testChild = child.create(TestChild, {\n    $id: 'test',\n    $bind: 'oldProperty'\n})\n\nexpect(child.oldProperty).toBe(testChild)\nexpect(child.newProperty).toBeUndefined()\n\ntestChild.$bind = 'newProperty'\n\nexpect(child.oldProperty).toBeUndefined()\nexpect(child.newProperty).toBe(testChild)"
          },
          {
            "title": "use with lifecycle disabled",
            "line": 340,
            "source": "class TestChild extends PerkyModule { }\nconst startSpy = vi.spyOn(TestChild.prototype, 'start')\n\nchild.create(TestChild, {\n    $id: 'test',\n    $lifecycle: false\n})\n\nchild.start()\n\nexpect(startSpy).not.toHaveBeenCalled()"
          },
          {
            "title": "use emits registration events",
            "line": 355,
            "source": "class TestChild extends PerkyModule { }\nconst emitSpy = vi.spyOn(child, 'emit')\n\nconst granchild = child.create(TestChild, {\n    $id: 'test',\n    $category: 'testCategory'\n})\n\nexpect(emitSpy).toHaveBeenCalledWith('testCategory:set', 'test', granchild)"
          },
          {
            "title": "removeChild",
            "line": 368,
            "source": "class TestChild extends PerkyModule { }\n\nconst instance = child.create(TestChild, {\n    $id: 'test',\n    $category: 'test'\n})\n\nconst uninstallSpy = vi.spyOn(instance, 'uninstall')\nconst disposeSpy = vi.spyOn(instance, 'dispose')\n\n\nconst result = child.removeChild('test')\n\nexpect(result).toBe(true)\nexpect(uninstallSpy).toHaveBeenCalled()\nexpect(disposeSpy).toHaveBeenCalled()"
          },
          {
            "title": "removeChild non-existent",
            "line": 388,
            "source": "const result = child.removeChild('nonexistent')\nexpect(result).toBe(false)"
          },
          {
            "title": "lifecycle cascade",
            "line": 394,
            "source": "class ChildChild extends PerkyModule { }\nnew ChildChild()\n\nconst childChild = child.create(ChildChild, {\n    $id: 'default',\n    $lifecycle: true\n})\n\nconst childStartSpy = vi.spyOn(childChild, 'start')\nconst childStopSpy = vi.spyOn(childChild, 'stop')\n\nchild.start()\nexpect(childStartSpy).toHaveBeenCalled()\n\nchild.stop()\nexpect(childStopSpy).toHaveBeenCalled()"
          },
          {
            "title": "delegateTo with methods",
            "line": 414,
            "source": "const hostModule = new PerkyModule({$id: 'host'})\nconst childModule = new PerkyModule({$id: 'child'})\n\nchildModule.method1 = vi.fn()\nchildModule.method2 = vi.fn()\n\nchildModule.delegateTo(hostModule, ['method1', 'method2'])\n\nexpect(hostModule.method1).toBeDefined()\nexpect(hostModule.method2).toBeDefined()\nexpect(typeof hostModule.method1).toBe('function')\nexpect(typeof hostModule.method2).toBe('function')"
          },
          {
            "title": "delegateTo with properties",
            "line": 430,
            "source": "const hostModule = new PerkyModule({$id: 'host'})\nconst childModule = new PerkyModule({$id: 'child'})\n\nchildModule.prop1 = 'value1'\nchildModule.prop2 = 'value2'\n\nchildModule.delegateTo(hostModule, ['prop1', 'prop2'])\n\nexpect(hostModule.prop1).toBe('value1')\nexpect(hostModule.prop2).toBe('value2')\n\nhostModule.prop1 = 'newValue'\nexpect(childModule.prop1).toBe('newValue')"
          },
          {
            "title": "delegateTo with mixed methods and properties",
            "line": 447,
            "source": "const hostModule = new PerkyModule({$id: 'host'})\nconst childModule = new PerkyModule({$id: 'child'})\n\nchildModule.count = 0\nchildModule.increment = function () {\n    this.count++\n}\nchildModule.decrement = function () {\n    this.count--\n}\n\nchildModule.delegateTo(hostModule, ['count', 'increment', 'decrement'])\n\nexpect(hostModule.count).toBe(0)\nexpect(typeof hostModule.increment).toBe('function')\nexpect(typeof hostModule.decrement).toBe('function')\n\nhostModule.increment()\nexpect(childModule.count).toBe(1)\nexpect(hostModule.count).toBe(1)\n\nhostModule.decrement()\nexpect(childModule.count).toBe(0)\nexpect(hostModule.count).toBe(0)"
          },
          {
            "title": "delegateTo with getters and setters",
            "line": 475,
            "source": "const hostModule = new PerkyModule({$id: 'host'})\nconst childModule = new PerkyModule({$id: 'child'})\n\nchildModule.internalValue = 10\nObject.defineProperty(childModule, 'value', {\n    get () {\n        return this.internalValue\n    },\n    set (newValue) {\n        this.internalValue = newValue\n    },\n    enumerable: true,\n    configurable: true\n})\n\nchildModule.delegateTo(hostModule, ['value'])\n\nexpect(hostModule.value).toBe(10)\n\nhostModule.value = 20\nexpect(childModule.value).toBe(20)\nexpect(hostModule.value).toBe(20)"
          },
          {
            "title": "delegateTo with object-based aliasing",
            "line": 501,
            "source": "const hostModule = new PerkyModule({$id: 'host'})\nconst childModule = new PerkyModule({$id: 'child'})\n\nchildModule.originalMethod = vi.fn(() => 'result')\nchildModule.originalProp = 'value'\n\nchildModule.delegateTo(hostModule, {\n    originalMethod: 'aliasedMethod',\n    originalProp: 'aliasedProp'\n})\n\nexpect(hostModule.aliasedMethod).toBeDefined()\nexpect(typeof hostModule.aliasedMethod).toBe('function')\nexpect(hostModule.aliasedMethod()).toBe('result')\nexpect(childModule.originalMethod).toHaveBeenCalled()\n\nexpect(hostModule.aliasedProp).toBe('value')\n\nhostModule.aliasedProp = 'new value'\nexpect(childModule.originalProp).toBe('new value')"
          },
          {
            "title": "delegateTo cleans up delegations on uninstall",
            "line": 525,
            "source": "const hostModule = new PerkyModule({$id: 'host'})\nconst childModule = hostModule.create(PerkyModule, {$id: 'child'})\n\nchildModule.getValue = vi.fn(() => 42)\nchildModule.someData = 'test'\n\nchildModule.delegateTo(hostModule, ['getValue', 'someData'])\n\nexpect(hostModule.getValue).toBeDefined()\nexpect(hostModule.getValue()).toBe(42)\nexpect(hostModule.someData).toBe('test')\n\nchildModule.uninstall()\n\nexpect(hostModule.getValue).toBeUndefined()\nexpect(hostModule.someData).toBeUndefined()"
          },
          {
            "title": "delegateTo cleans up delegations on dispose",
            "line": 545,
            "source": "const hostModule = new PerkyModule({$id: 'host'})\nconst childModule = hostModule.create(PerkyModule, {$id: 'child'})\n\nchildModule.doSomething = vi.fn()\n\nchildModule.delegateTo(hostModule, ['doSomething'])\n\nexpect(hostModule.doSomething).toBeDefined()\n\nchildModule.dispose()\n\nexpect(hostModule.doSomething).toBeUndefined()"
          },
          {
            "title": "delegateTo with object-based aliasing cleans up on uninstall",
            "line": 561,
            "source": "const hostModule = new PerkyModule({$id: 'host'})\nconst childModule = hostModule.create(PerkyModule, {$id: 'child'})\n\nchildModule.originalMethod = vi.fn(() => 'result')\n\nchildModule.delegateTo(hostModule, {originalMethod: 'aliasedMethod'})\n\nexpect(hostModule.aliasedMethod).toBeDefined()\nexpect(hostModule.aliasedMethod()).toBe('result')\n\nchildModule.uninstall()\n\nexpect(hostModule.aliasedMethod).toBeUndefined()"
          },
          {
            "title": "cleanDelegations removes all delegated properties",
            "line": 578,
            "source": "const hostModule = new PerkyModule({$id: 'host'})\nconst childModule = new PerkyModule({$id: 'child'})\n\nchildModule.method1 = vi.fn()\nchildModule.method2 = vi.fn()\nchildModule.prop1 = 'value1'\n\nchildModule.delegateTo(hostModule, ['method1', 'prop1'])\nchildModule.delegateTo(hostModule, ['method2'])\n\nexpect(hostModule.method1).toBeDefined()\nexpect(hostModule.method2).toBeDefined()\nexpect(hostModule.prop1).toBe('value1')\n\nchildModule.cleanDelegations()\n\nexpect(hostModule.method1).toBeUndefined()\nexpect(hostModule.method2).toBeUndefined()\nexpect(hostModule.prop1).toBeUndefined()"
          },
          {
            "title": "delegateEventsTo forwards events to host",
            "line": 601,
            "source": "const hostModule = new PerkyModule({$id: 'host'})\nconst childModule = hostModule.create(PerkyModule, {$id: 'child'})\n\nconst updateSpy = vi.fn()\nconst renderSpy = vi.fn()\n\nhostModule.on('update', updateSpy)\nhostModule.on('render', renderSpy)\n\nchildModule.delegateEventsTo(hostModule, ['update', 'render'])\n\nchildModule.emit('update', 0.16)\nchildModule.emit('render', 1.0)\n\nexpect(updateSpy).toHaveBeenCalledWith(0.16)\nexpect(renderSpy).toHaveBeenCalledWith(1.0)"
          },
          {
            "title": "delegateEventsTo with namespace prefixes events",
            "line": 621,
            "source": "const hostModule = new PerkyModule({$id: 'host'})\nconst childModule = hostModule.create(PerkyModule, {$id: 'child'})\n\nconst spy = vi.fn()\nhostModule.on('child:update', spy)\n\nchildModule.delegateEventsTo(hostModule, ['update'], 'child')\n\nchildModule.emit('update', 0.16)\n\nexpect(spy).toHaveBeenCalledWith(0.16)"
          },
          {
            "title": "delegateEventsTo cleans up on uninstall",
            "line": 636,
            "source": "const hostModule = new PerkyModule({$id: 'host'})\nconst childModule = hostModule.create(PerkyModule, {$id: 'child'})\n\nconst spy = vi.fn()\nhostModule.on('update', spy)\n\nchildModule.delegateEventsTo(hostModule, ['update'])\n\nchildModule.emit('update', 0.16)\nexpect(spy).toHaveBeenCalledTimes(1)\n\nchildModule.uninstall()\n\nchildModule.emit('update', 0.16)\nexpect(spy).toHaveBeenCalledTimes(1)"
          },
          {
            "title": "delegateEventsTo cleans up on dispose",
            "line": 655,
            "source": "const hostModule = new PerkyModule({$id: 'host'})\nconst childModule = hostModule.create(PerkyModule, {$id: 'child'})\n\nconst spy = vi.fn()\nhostModule.on('update', spy)\n\nchildModule.delegateEventsTo(hostModule, ['update'])\n\nchildModule.emit('update', 0.16)\nexpect(spy).toHaveBeenCalledTimes(1)\n\nchildModule.dispose()\n\nchildModule.emit('update', 0.16)\nexpect(spy).toHaveBeenCalledTimes(1)"
          },
          {
            "title": "dispose calls dispose on all children in cascade",
            "line": 674,
            "source": "class ChildChild1 extends PerkyModule { }\nclass ChildChild2 extends PerkyModule { }\n\nconst child1 = child.create(ChildChild1, {\n    $id: 'child1'\n})\n\nconst child2 = child.create(ChildChild2, {\n    $id: 'child2'\n})\n\nconst child1DisposeSpy = vi.spyOn(child1, 'dispose')\nconst child2DisposeSpy = vi.spyOn(child2, 'dispose')\n\nchild.dispose()\n\nexpect(child1DisposeSpy).toHaveBeenCalled()\nexpect(child2DisposeSpy).toHaveBeenCalled()\nexpect(child1.disposed).toBe(true)\nexpect(child2.disposed).toBe(true)\nexpect(child.disposed).toBe(true)"
          },
          {
            "title": "dispose with multiple nested children",
            "line": 699,
            "source": "class Level1Child extends PerkyModule { }\nclass Level2Child extends PerkyModule { }\n\nconst level1 = child.create(Level1Child, {\n    $id: 'level1'\n})\n\nconst level2 = child.create(Level2Child, {\n    $id: 'level2'\n})\n\nconst level1DisposeSpy = vi.spyOn(level1, 'dispose')\nconst level2DisposeSpy = vi.spyOn(level2, 'dispose')\n\nchild.dispose()\n\nexpect(level1DisposeSpy).toHaveBeenCalled()\nexpect(level2DisposeSpy).toHaveBeenCalled()\nexpect(level2.disposed).toBe(true)\nexpect(level1.disposed).toBe(true)\nexpect(child.disposed).toBe(true)"
          },
          {
            "title": "dispose skips already disposed children",
            "line": 724,
            "source": "class ChildChild extends PerkyModule { }\n\nconst childChild = new ChildChild()\nconst childDisposeSpy = vi.spyOn(child, 'dispose')\n\nchild.create(ChildChild, {\n    instance: childChild,\n    $id: 'default'\n})\n\nchild.dispose()\nexpect(childDisposeSpy).toHaveBeenCalledTimes(1)\nexpect(child.disposed).toBe(true)\n\nchildDisposeSpy.mockClear()\n\nchildChild.dispose()\n\nexpect(childDisposeSpy).not.toHaveBeenCalled()\nexpect(childChild.disposed).toBe(true)"
          },
          {
            "title": "dispose clears children registry after disposing all children",
            "line": 748,
            "source": "class ChildChild extends PerkyModule { }\n\nconst childChild = new ChildChild()\n\nchild.create(ChildChild, {\n    instance: childChild,\n    $id: 'default'\n})\n\nexpect(child.hasChild('default')).toBe(true)\n\nchild.dispose()\n\nexpect(child.hasChild('default')).toBe(false)\nexpect(child.childrenRegistry.size).toBe(0)"
          }
        ],
        "describes": [
          {
            "title": "static $category",
            "line": 767,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "uses PerkyModule default category \"perkyModule\" when not specified",
                "line": 768,
                "source": "const module = child.create(PerkyModule, {$id: 'test'})\nexpect(module.$category).toBe('perkyModule')"
              },
              {
                "title": "uses static $category from subclass",
                "line": 774,
                "source": "class GameController extends PerkyModule {\n    static $category = 'controller'\n}\n\nconst controller = child.create(GameController, {$id: 'game'})\nexpect(controller.$category).toBe('controller')"
              },
              {
                "title": "explicit $category overrides static $category",
                "line": 784,
                "source": "class GameController extends PerkyModule {\n    static $category = 'controller'\n}\n\nconst controller = child.create(GameController, {\n    $id: 'game',\n    $category: 'custom'\n})\n\nexpect(controller.$category).toBe('custom')"
              },
              {
                "title": "works with multiple levels of inheritance",
                "line": 798,
                "source": "class BaseController extends PerkyModule {\n    static $category = 'controller'\n}\n\nclass GameController extends BaseController {\n    static $category = 'gameController'\n}\n\nconst controller = child.create(GameController, {$id: 'game'})\nexpect(controller.$category).toBe('gameController')"
              },
              {
                "title": "subclass without static $category falls back to parent",
                "line": 812,
                "source": "class BaseController extends PerkyModule {\n    static $category = 'controller'\n}\n\nclass GameController extends BaseController {\n    // No static $category override\n}\n\nconst controller = child.create(GameController, {$id: 'game'})\nexpect(controller.$category).toBe('controller')"
              },
              {
                "title": "auto-generates unique IDs using static $category",
                "line": 826,
                "source": "class Monster extends PerkyModule {\n    static $category = 'monster'\n}\n\n// Use a fresh parent to ensure predictable ID generation\nconst parent = new PerkyModule()\nconst monster1 = parent.create(Monster)\nconst monster2 = parent.create(Monster)\nconst monster3 = parent.create(Monster)\n\nexpect(monster1.$category).toBe('monster')\nexpect(monster2.$category).toBe('monster')\nexpect(monster3.$category).toBe('monster')\n\nexpect(monster1.$id).toBe('monster')\nexpect(monster2.$id).toBe('monster_1')\nexpect(monster3.$id).toBe('monster_2')"
              },
              {
                "title": "emits correct event based on static $category",
                "line": 847,
                "source": "class GameController extends PerkyModule {\n    static $category = 'controller'\n}\n\nconst emitSpy = vi.spyOn(child, 'emit')\nconst controller = child.create(GameController, {$id: 'game'})\n\nexpect(emitSpy).toHaveBeenCalledWith('controller:set', 'game', controller)"
              },
              {
                "title": "listNamesFor works with static $category",
                "line": 859,
                "source": "class GameController extends PerkyModule {\n    static $category = 'controller'\n}\n\nclass InputController extends PerkyModule {\n    static $category = 'controller'\n}\n\nchild.create(GameController, {$id: 'game'})\nchild.create(InputController, {$id: 'input'})\n\nconst controllers = child.listNamesFor('controller')\nexpect(controllers).toHaveLength(2)\nexpect(controllers).toContain('game')\nexpect(controllers).toContain('input')"
              }
            ],
            "describes": []
          },
          {
            "title": "$eagerStart",
            "line": 879,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "default $eagerStart is true for PerkyModule",
                "line": 880,
                "source": "const module = child.create(PerkyModule, {$id: 'test'})\nexpect(module.$eagerStart).toBe(true)"
              },
              {
                "title": "child starts eagerly when parent is already started",
                "line": 886,
                "source": "child.start()\n\nconst module = child.create(PerkyModule, {$id: 'test'})\n\nexpect(module.started).toBe(true)"
              },
              {
                "title": "child does not start when parent is not started",
                "line": 895,
                "source": "const module = child.create(PerkyModule, {$id: 'test'})\n\nexpect(module.started).toBe(false)"
              },
              {
                "title": "$eagerStart: false prevents automatic start",
                "line": 902,
                "source": "child.start()\n\nconst module = child.create(PerkyModule, {\n    $id: 'test',\n    $eagerStart: false\n})\n\nexpect(module.started).toBe(false)"
              },
              {
                "title": "$eagerStart: true forces eager start",
                "line": 914,
                "source": "child.start()\n\nconst module = child.create(PerkyModule, {\n    $id: 'test',\n    $eagerStart: true\n})\n\nexpect(module.started).toBe(true)"
              },
              {
                "title": "static $eagerStart is inherited from class",
                "line": 926,
                "source": "class LazyModule extends PerkyModule {\n    static $eagerStart = false\n}\n\nchild.start()\n\nconst module = child.create(LazyModule, {$id: 'test'})\n\nexpect(module.$eagerStart).toBe(false)\nexpect(module.started).toBe(false)"
              },
              {
                "title": "explicit $eagerStart overrides static $eagerStart",
                "line": 940,
                "source": "class LazyModule extends PerkyModule {\n    static $eagerStart = false\n}\n\nchild.start()\n\nconst module = child.create(LazyModule, {\n    $id: 'test',\n    $eagerStart: true\n})\n\nexpect(module.$eagerStart).toBe(true)\nexpect(module.started).toBe(true)"
              },
              {
                "title": "$eagerStart cascading: option > static > default",
                "line": 957,
                "source": "class CustomModule extends PerkyModule {\n    static $eagerStart = false\n}\n\nconst module1 = child.create(CustomModule, {$id: 'test1'})\nexpect(module1.$eagerStart).toBe(false)\n\nconst module2 = child.create(CustomModule, {\n    $id: 'test2',\n    $eagerStart: true\n})\nexpect(module2.$eagerStart).toBe(true)\n\nconst module3 = child.create(PerkyModule, {$id: 'test3'})\nexpect(module3.$eagerStart).toBe(true)"
              },
              {
                "title": "$eagerStart works with $lifecycle: false",
                "line": 976,
                "source": "child.start()\n\nconst module = child.create(PerkyModule, {\n    $id: 'test',\n    $eagerStart: true,\n    $lifecycle: false\n})\n\nexpect(module.started).toBe(false)"
              },
              {
                "title": "lazy module can be started manually later",
                "line": 989,
                "source": "child.start()\n\nconst module = child.create(PerkyModule, {\n    $id: 'test',\n    $eagerStart: false\n})\n\nexpect(module.started).toBe(false)\n\nmodule.start()\n\nexpect(module.started).toBe(true)"
              },
              {
                "title": "multiple children with mixed $eagerStart",
                "line": 1005,
                "source": "child.start()\n\nconst eager1 = child.create(PerkyModule, {\n    $id: 'eager1',\n    $eagerStart: true\n})\n\nconst lazy1 = child.create(PerkyModule, {\n    $id: 'lazy1',\n    $eagerStart: false\n})\n\nconst eager2 = child.create(PerkyModule, {\n    $id: 'eager2'\n})\n\nexpect(eager1.started).toBe(true)\nexpect(lazy1.started).toBe(false)\nexpect(eager2.started).toBe(true)"
              },
              {
                "title": "eagerStart getter returns correct value",
                "line": 1028,
                "source": "const eager = child.create(PerkyModule, {\n    $id: 'eager',\n    $eagerStart: true\n})\n\nconst lazy = child.create(PerkyModule, {\n    $id: 'lazy',\n    $eagerStart: false\n})\nexpect(eager.$eagerStart).toBe(true)\nexpect(lazy.$eagerStart).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "$lifecycle",
            "line": 1044,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "$lifecycle is true by default",
                "line": 1046,
                "source": "const module = new PerkyModule()\nexpect(module.$lifecycle).toBe(true)"
              },
              {
                "title": "$lifecycle can be set to false via options",
                "line": 1052,
                "source": "const module = new PerkyModule({$lifecycle: false})\nexpect(module.$lifecycle).toBe(false)"
              },
              {
                "title": "$lifecycle is true when option is explicitly true",
                "line": 1058,
                "source": "const module = new PerkyModule({$lifecycle: true})\nexpect(module.$lifecycle).toBe(true)"
              }
            ],
            "describes": []
          },
          {
            "title": "$status",
            "line": 1066,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns \"stopped\" for new module",
                "line": 1068,
                "source": "const module = new PerkyModule()\nexpect(module.$status).toBe('stopped')"
              },
              {
                "title": "returns \"started\" when module is running",
                "line": 1074,
                "source": "const module = new PerkyModule()\nmodule.start()\nexpect(module.$status).toBe('started')"
              },
              {
                "title": "returns \"stopped\" after stopping a started module",
                "line": 1081,
                "source": "const module = new PerkyModule()\nmodule.start()\nmodule.stop()\nexpect(module.$status).toBe('stopped')"
              },
              {
                "title": "returns \"disposed\" when module is disposed",
                "line": 1089,
                "source": "const module = new PerkyModule()\nmodule.dispose()\nexpect(module.$status).toBe('disposed')"
              },
              {
                "title": "returns \"static\" when $lifecycle is false",
                "line": 1096,
                "source": "const module = new PerkyModule({$lifecycle: false})\nexpect(module.$status).toBe('static')"
              },
              {
                "title": "returns \"static\" even if started when $lifecycle is false",
                "line": 1102,
                "source": "const module = new PerkyModule({$lifecycle: false})\nmodule.start()\nexpect(module.$status).toBe('static')"
              },
              {
                "title": "disposed takes precedence over started",
                "line": 1109,
                "source": "const module = new PerkyModule()\nmodule.start()\nmodule.dispose()\nexpect(module.$status).toBe('disposed')"
              }
            ],
            "describes": []
          },
          {
            "title": "$tags",
            "line": 1119,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "initializes with empty tags by default",
                "line": 1121,
                "source": "const module = new PerkyModule()\nexpect(module.$tags).toEqual([])"
              },
              {
                "title": "initializes with tags from options",
                "line": 1127,
                "source": "const module = new PerkyModule({$tags: ['enemy', 'collidable']})\nexpect(module.$tags).toEqual(['enemy', 'collidable'])"
              },
              {
                "title": "$tags returns array copy",
                "line": 1133,
                "source": "const module = new PerkyModule({$tags: ['test']})\nconst tags1 = module.$tags\nconst tags2 = module.$tags\nexpect(tags1).not.toBe(tags2)\nexpect(tags1).toEqual(tags2)"
              },
              {
                "title": "tags property returns ObservableSet",
                "line": 1142,
                "source": "const module = new PerkyModule()\nexpect(module.tags).toBeDefined()\nexpect(module.tags.size).toBe(0)"
              },
              {
                "title": "can add tags via tags.add()",
                "line": 1149,
                "source": "const module = new PerkyModule()\nmodule.tags.add('enemy')\nmodule.tags.add('collidable')\n\nexpect(module.$tags).toEqual(['enemy', 'collidable'])\nexpect(module.tags.size).toBe(2)"
              },
              {
                "title": "can delete tags via tags.delete()",
                "line": 1159,
                "source": "const module = new PerkyModule({$tags: ['enemy', 'collidable', 'flying']})\n\nmodule.tags.delete('flying')\n\nexpect(module.$tags).toEqual(['enemy', 'collidable'])\nexpect(module.tags.size).toBe(2)"
              },
              {
                "title": "can clear tags via tags.clear()",
                "line": 1169,
                "source": "const module = new PerkyModule({$tags: ['enemy', 'collidable']})\n\nmodule.tags.clear()\n\nexpect(module.$tags).toEqual([])\nexpect(module.tags.size).toBe(0)"
              },
              {
                "title": "tags.add() emits add event",
                "line": 1179,
                "source": "const module = new PerkyModule()\nlet addedTag\n\nmodule.tags.on('add', (tag) => {\n    addedTag = tag\n})\n\nmodule.tags.add('enemy')\n\nexpect(addedTag).toBe('enemy')"
              },
              {
                "title": "tags.delete() emits delete event",
                "line": 1193,
                "source": "const module = new PerkyModule({$tags: ['enemy']})\nlet deletedTag\n\nmodule.tags.on('delete', (tag) => {\n    deletedTag = tag\n})\n\nmodule.tags.delete('enemy')\n\nexpect(deletedTag).toBe('enemy')"
              },
              {
                "title": "tags.clear() emits clear event",
                "line": 1207,
                "source": "const module = new PerkyModule({$tags: ['enemy', 'collidable']})\nlet clearedTags\n\nmodule.tags.on('clear', (tags) => {\n    clearedTags = tags\n})\n\nmodule.tags.clear()\n\nexpect(clearedTags).toEqual(['enemy', 'collidable'])"
              },
              {
                "title": "tags support chaining",
                "line": 1221,
                "source": "const module = new PerkyModule()\n\nmodule.tags.add('enemy').add('collidable').add('flying')\n\nexpect(module.$tags).toEqual(['enemy', 'collidable', 'flying'])"
              },
              {
                "title": "tags support iteration",
                "line": 1230,
                "source": "const module = new PerkyModule({$tags: ['a', 'b', 'c']})\n\nconst collected = []\nfor (const tag of module.tags) {\n    collected.push(tag)\n}\n\nexpect(collected).toEqual(['a', 'b', 'c'])"
              },
              {
                "title": "can set $tags with array",
                "line": 1242,
                "source": "const module = new PerkyModule({$tags: ['enemy', 'collidable']})\n\nmodule.$tags = ['friendly', 'flying']\n\nexpect(module.$tags).toEqual(['friendly', 'flying'])\nexpect(module.tags.size).toBe(2)"
              },
              {
                "title": "setting $tags clears old tags",
                "line": 1252,
                "source": "const module = new PerkyModule({$tags: ['a', 'b', 'c']})\n\nmodule.$tags = ['x', 'y']\n\nexpect(module.$tags).toEqual(['x', 'y'])\nexpect(module.tags.has('a')).toBe(false)\nexpect(module.tags.has('b')).toBe(false)"
              },
              {
                "title": "setting $tags emits clear and add events",
                "line": 1263,
                "source": "const module = new PerkyModule({$tags: ['old']})\nlet clearedTags\nlet addedTags = []\n\nmodule.tags.on('clear', (tags) => {\n    clearedTags = tags\n})\nmodule.tags.on('add', (tag) => {\n    addedTags.push(tag)\n})\n\nmodule.$tags = ['new1', 'new2']\n\nexpect(clearedTags).toEqual(['old'])\nexpect(addedTags).toEqual(['new1', 'new2'])"
              },
              {
                "title": "setting $tags to empty array clears all",
                "line": 1282,
                "source": "const module = new PerkyModule({$tags: ['a', 'b']})\n\nmodule.$tags = []\n\nexpect(module.$tags).toEqual([])\nexpect(module.tags.size).toBe(0)"
              },
              {
                "title": "hasTag returns true when tag exists",
                "line": 1292,
                "source": "const module = new PerkyModule({$tags: ['enemy', 'collidable']})\nexpect(module.hasTag('enemy')).toBe(true)\nexpect(module.hasTag('collidable')).toBe(true)"
              },
              {
                "title": "hasTag returns false when tag does not exist",
                "line": 1299,
                "source": "const module = new PerkyModule({$tags: ['enemy']})\nexpect(module.hasTag('friendly')).toBe(false)\nexpect(module.hasTag('collidable')).toBe(false)"
              },
              {
                "title": "hasTag returns false when no tags set",
                "line": 1306,
                "source": "const module = new PerkyModule()\nexpect(module.hasTag('enemy')).toBe(false)"
              },
              {
                "title": "addTag adds a tag",
                "line": 1312,
                "source": "const module = new PerkyModule()\nmodule.addTag('enemy')\nexpect(module.hasTag('enemy')).toBe(true)"
              },
              {
                "title": "addTag returns true when tag is new",
                "line": 1319,
                "source": "const module = new PerkyModule()\nexpect(module.addTag('enemy')).toBe(true)"
              },
              {
                "title": "addTag returns false when tag already exists",
                "line": 1325,
                "source": "const module = new PerkyModule({$tags: ['enemy']})\nexpect(module.addTag('enemy')).toBe(false)"
              },
              {
                "title": "removeTag removes a tag",
                "line": 1331,
                "source": "const module = new PerkyModule({$tags: ['enemy', 'collidable']})\nmodule.removeTag('enemy')\nexpect(module.hasTag('enemy')).toBe(false)\nexpect(module.hasTag('collidable')).toBe(true)"
              },
              {
                "title": "removeTag returns true when tag existed",
                "line": 1339,
                "source": "const module = new PerkyModule({$tags: ['enemy']})\nexpect(module.removeTag('enemy')).toBe(true)"
              },
              {
                "title": "removeTag returns false when tag did not exist",
                "line": 1345,
                "source": "const module = new PerkyModule()\nexpect(module.removeTag('enemy')).toBe(false)"
              },
              {
                "title": "hasTags returns true when all tags exist (array)",
                "line": 1351,
                "source": "const module = new PerkyModule({$tags: ['enemy', 'collidable', 'flying']})\nexpect(module.hasTags(['enemy', 'collidable'])).toBe(true)\nexpect(module.hasTags(['enemy'])).toBe(true)"
              },
              {
                "title": "hasTags returns false when some tags missing (array)",
                "line": 1358,
                "source": "const module = new PerkyModule({$tags: ['enemy', 'collidable']})\nexpect(module.hasTags(['enemy', 'flying'])).toBe(false)\nexpect(module.hasTags(['friendly', 'enemy'])).toBe(false)"
              },
              {
                "title": "hasTags returns false when no tags match (array)",
                "line": 1365,
                "source": "const module = new PerkyModule({$tags: ['enemy']})\nexpect(module.hasTags(['friendly', 'collidable'])).toBe(false)"
              },
              {
                "title": "hasTags fallback: accepts string and checks single tag",
                "line": 1371,
                "source": "const module = new PerkyModule({$tags: ['enemy', 'collidable']})\nexpect(module.hasTags('enemy')).toBe(true)\nexpect(module.hasTags('collidable')).toBe(true)\nexpect(module.hasTags('friendly')).toBe(false)"
              },
              {
                "title": "hasTags returns true for empty array",
                "line": 1379,
                "source": "const module = new PerkyModule({$tags: ['enemy']})\nexpect(module.hasTags([])).toBe(true)"
              },
              {
                "title": "hasTags returns false when no tags set",
                "line": 1385,
                "source": "const module = new PerkyModule()\nexpect(module.hasTags(['enemy'])).toBe(false)\nexpect(module.hasTags('enemy')).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "composite tag indexing",
            "line": 1394,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "childrenByTags returns children matching all tags (without index)",
                "line": 1396,
                "source": "const child1 = child.create(PerkyModule, {$id: 'c1', $tags: ['enemy', 'collidable', 'flying']})\nconst child2 = child.create(PerkyModule, {$id: 'c2', $tags: ['enemy', 'collidable']})\nchild.create(PerkyModule, {$id: 'c3', $tags: ['friendly', 'collidable']})\n\nconst enemyColliders = child.childrenByTags(['enemy', 'collidable'])\n\nexpect(enemyColliders).toHaveLength(2)\nexpect(enemyColliders).toContain(child1)\nexpect(enemyColliders).toContain(child2)"
              },
              {
                "title": "childrenByTags returns empty array for no matches",
                "line": 1409,
                "source": "child.create(PerkyModule, {$id: 'c1', $tags: ['enemy']})\n\nconst result = child.childrenByTags(['enemy', 'collidable'])\n\nexpect(result).toEqual([])"
              },
              {
                "title": "childrenByTags returns empty array for empty tags",
                "line": 1418,
                "source": "const result = child.childrenByTags()\n\nexpect(result).toEqual([])"
              },
              {
                "title": "addTagsIndex creates composite index",
                "line": 1425,
                "source": "const result = child.addTagsIndex(['enemy', 'collidable'])\n\nexpect(result).toBe(true)\nexpect(child.childrenRegistry.hasIndex('collidable_enemy')).toBe(true)"
              },
              {
                "title": "addTagsIndex normalizes tag order",
                "line": 1433,
                "source": "child.addTagsIndex(['collidable', 'enemy'])\n\nexpect(child.childrenRegistry.hasIndex('collidable_enemy')).toBe(true)"
              },
              {
                "title": "addTagsIndex returns false if already indexed",
                "line": 1440,
                "source": "const result1 = child.addTagsIndex(['enemy', 'collidable'])\nconst result2 = child.addTagsIndex(['enemy', 'collidable'])\n\nexpect(result1).toBe(true)\nexpect(result2).toBe(false)"
              },
              {
                "title": "addTagsIndex returns false for empty array",
                "line": 1449,
                "source": "const result = child.addTagsIndex([])\n\nexpect(result).toBe(false)"
              },
              {
                "title": "addTagsIndex returns false for non-array",
                "line": 1456,
                "source": "const result = child.addTagsIndex('invalid')\n\nexpect(result).toBe(false)"
              },
              {
                "title": "childrenByTags uses index when available",
                "line": 1463,
                "source": "const child1 = child.create(PerkyModule, {$id: 'c1', $tags: ['enemy', 'collidable']})\nchild.create(PerkyModule, {$id: 'c2', $tags: ['enemy']})\n\nchild.addTagsIndex(['enemy', 'collidable'])\n\nconst result = child.childrenByTags(['enemy', 'collidable'])\n\nexpect(result).toHaveLength(1)\nexpect(result).toContain(child1)"
              },
              {
                "title": "removeTagsIndex removes composite index",
                "line": 1476,
                "source": "child.addTagsIndex(['enemy', 'collidable'])\nconst result = child.removeTagsIndex(['enemy', 'collidable'])\n\nexpect(result).toBe(true)\nexpect(child.childrenRegistry.hasIndex('collidable_enemy')).toBe(false)"
              },
              {
                "title": "removeTagsIndex returns false if not indexed",
                "line": 1485,
                "source": "const result = child.removeTagsIndex(['enemy', 'collidable'])\n\nexpect(result).toBe(false)"
              },
              {
                "title": "index automatically updates when child tags change (add)",
                "line": 1492,
                "source": "const testChild = child.create(PerkyModule, {$id: 'test', $tags: ['enemy']})\nchild.addTagsIndex(['enemy', 'collidable'])\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(0)\n\ntestChild.tags.add('collidable')\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(1)\nexpect(child.childrenByTags(['enemy', 'collidable'])).toContain(testChild)"
              },
              {
                "title": "index automatically updates when child tags change (delete)",
                "line": 1504,
                "source": "const testChild = child.create(PerkyModule, {$id: 'test', $tags: ['enemy', 'collidable']})\nchild.addTagsIndex(['enemy', 'collidable'])\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(1)\n\ntestChild.tags.delete('collidable')\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(0)"
              },
              {
                "title": "index automatically updates when child tags change (clear)",
                "line": 1516,
                "source": "const testChild = child.create(PerkyModule, {$id: 'test', $tags: ['enemy', 'collidable']})\nchild.addTagsIndex(['enemy', 'collidable'])\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(1)\n\ntestChild.tags.clear()\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(0)"
              },
              {
                "title": "index updates when $tags is reassigned",
                "line": 1528,
                "source": "const testChild = child.create(PerkyModule, {$id: 'test', $tags: ['enemy']})\nchild.addTagsIndex(['enemy', 'collidable'])\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(0)\n\ntestChild.$tags = ['enemy', 'collidable']\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(1)"
              },
              {
                "title": "multiple composite indexes work independently",
                "line": 1540,
                "source": "const enemy = child.create(PerkyModule, {$id: 'enemy', $tags: ['enemy', 'collidable']})\nconst friendly = child.create(PerkyModule, {$id: 'friendly', $tags: ['friendly', 'collidable']})\n\nchild.addTagsIndex(['enemy', 'collidable'])\nchild.addTagsIndex(['friendly', 'collidable'])\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toEqual([enemy])\nexpect(child.childrenByTags(['friendly', 'collidable'])).toEqual([friendly])"
              },
              {
                "title": "events are cleaned up when child is removed",
                "line": 1552,
                "source": "const testChild = child.create(PerkyModule, {$id: 'test', $tags: ['enemy', 'collidable']})\nchild.addTagsIndex(['enemy', 'collidable'])\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(1)\n\nchild.removeChild('test')\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(0)\n\ntestChild.tags.add('flying')\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(0)"
              },
              {
                "title": "index hooks are added to existing children",
                "line": 1567,
                "source": "const testChild = child.create(PerkyModule, {$id: 'test', $tags: ['enemy']})\n\nchild.addTagsIndex(['enemy', 'collidable'])\n\ntestChild.tags.add('collidable')\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(1)"
              },
              {
                "title": "single tag query works",
                "line": 1578,
                "source": "const child1 = child.create(PerkyModule, {$id: 'c1', $tags: ['enemy']})\nconst child2 = child.create(PerkyModule, {$id: 'c2', $tags: ['enemy', 'flying']})\nchild.create(PerkyModule, {$id: 'c3', $tags: ['friendly']})\n\nconst enemies = child.childrenByTags('enemy')\n\nexpect(enemies).toHaveLength(2)\nexpect(enemies).toContain(child1)\nexpect(enemies).toContain(child2)"
              },
              {
                "title": "works with children without tags",
                "line": 1591,
                "source": "child.create(PerkyModule, {$id: 'c1'})\nconst child2 = child.create(PerkyModule, {$id: 'c2', $tags: ['enemy']})\n\nconst result = child.childrenByTags('enemy')\n\nexpect(result).toEqual([child2])"
              }
            ],
            "describes": []
          },
          {
            "title": "#setupTagIndexListeners",
            "line": 1603,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "listeners are set up when creating a child with tags and indexes exist",
                "line": 1605,
                "source": "child.addTagsIndex(['enemy', 'collidable'])\n\nconst testChild = child.create(PerkyModule, {$id: 'test', $tags: ['enemy']})\n\ntestChild.tags.add('collidable')\n\nconst result = child.childrenByTags(['enemy', 'collidable'])\nexpect(result).toHaveLength(1)\nexpect(result).toContain(testChild)"
              },
              {
                "title": "listeners ARE set up when addTagsIndex is called for existing children",
                "line": 1618,
                "source": "const testChild = child.create(PerkyModule, {$id: 'test', $tags: ['enemy']})\n\nchild.addTagsIndex(['enemy', 'collidable'])\n\ntestChild.tags.add('collidable')\n\nconst result = child.childrenByTags(['enemy', 'collidable'])\nexpect(result).toHaveLength(1)\nexpect(result).toContain(testChild)"
              },
              {
                "title": "listeners ARE set up for children even without initial tags",
                "line": 1631,
                "source": "child.addTagsIndex(['enemy', 'collidable'])\n\nconst testChild = child.create(PerkyModule, {$id: 'test'})\n\ntestChild.tags.add('enemy')\ntestChild.tags.add('collidable')\n\nconst result = child.childrenByTags(['enemy', 'collidable'])\nexpect(result).toHaveLength(1)\nexpect(result).toContain(testChild)"
              },
              {
                "title": "adding a tag triggers index update for all registered indexes",
                "line": 1645,
                "source": "child.addTagsIndex(['enemy', 'collidable'])\nchild.addTagsIndex(['enemy', 'flying'])\n\nconst testChild = child.create(PerkyModule, {$id: 'test', $tags: ['enemy']})\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(0)\nexpect(child.childrenByTags(['enemy', 'flying'])).toHaveLength(0)\n\ntestChild.tags.add('collidable')\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(1)\nexpect(child.childrenByTags(['enemy', 'flying'])).toHaveLength(0)\n\ntestChild.tags.add('flying')\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(1)\nexpect(child.childrenByTags(['enemy', 'flying'])).toHaveLength(1)"
              },
              {
                "title": "deleting a tag triggers index update for all registered indexes",
                "line": 1666,
                "source": "child.addTagsIndex(['enemy', 'collidable'])\nchild.addTagsIndex(['enemy', 'flying'])\n\nconst testChild = child.create(PerkyModule, {$id: 'test', $tags: ['enemy', 'collidable', 'flying']})\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(1)\nexpect(child.childrenByTags(['enemy', 'flying'])).toHaveLength(1)\n\ntestChild.tags.delete('collidable')\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(0)\nexpect(child.childrenByTags(['enemy', 'flying'])).toHaveLength(1)\n\ntestChild.tags.delete('flying')\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(0)\nexpect(child.childrenByTags(['enemy', 'flying'])).toHaveLength(0)"
              },
              {
                "title": "clearing tags triggers index update for all registered indexes",
                "line": 1687,
                "source": "child.addTagsIndex(['enemy', 'collidable'])\nchild.addTagsIndex(['enemy', 'flying'])\n\nconst testChild = child.create(PerkyModule, {$id: 'test', $tags: ['enemy', 'collidable', 'flying']})\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(1)\nexpect(child.childrenByTags(['enemy', 'flying'])).toHaveLength(1)\n\ntestChild.tags.clear()\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(0)\nexpect(child.childrenByTags(['enemy', 'flying'])).toHaveLength(0)"
              },
              {
                "title": "multiple children with different tag combinations",
                "line": 1703,
                "source": "child.addTagsIndex(['enemy', 'collidable'])\nchild.addTagsIndex(['friendly', 'collidable'])\n\nconst enemy = child.create(PerkyModule, {$id: 'enemy', $tags: ['enemy']})\nconst friendly = child.create(PerkyModule, {$id: 'friendly', $tags: ['friendly']})\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(0)\nexpect(child.childrenByTags(['friendly', 'collidable'])).toHaveLength(0)\n\nenemy.tags.add('collidable')\nfriendly.tags.add('collidable')\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(1)\nexpect(child.childrenByTags(['enemy', 'collidable'])).toContain(enemy)\n\nexpect(child.childrenByTags(['friendly', 'collidable'])).toHaveLength(1)\nexpect(child.childrenByTags(['friendly', 'collidable'])).toContain(friendly)"
              },
              {
                "title": "tag changes work correctly when adding index before creating children",
                "line": 1724,
                "source": "child.addTagsIndex(['enemy', 'collidable'])\n\nconst enemy1 = child.create(PerkyModule, {$id: 'enemy1', $tags: ['enemy']})\nconst enemy2 = child.create(PerkyModule, {$id: 'enemy2', $tags: ['enemy', 'collidable']})\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toEqual([enemy2])\n\nenemy1.tags.add('collidable')\n\nconst result = child.childrenByTags(['enemy', 'collidable'])\nexpect(result).toHaveLength(2)\nexpect(result).toContain(enemy1)\nexpect(result).toContain(enemy2)\n\nenemy2.tags.delete('enemy')\n\nconst result2 = child.childrenByTags(['enemy', 'collidable'])\nexpect(result2).toHaveLength(1)\nexpect(result2).toContain(enemy1)"
              },
              {
                "title": "listeners are set up for existing children when adding a new index",
                "line": 1747,
                "source": "const testChild = child.create(PerkyModule, {$id: 'test', $tags: ['enemy']})\n\nchild.addTagsIndex(['enemy', 'collidable'])\n\ntestChild.tags.add('collidable')\n\nconst result = child.childrenByTags(['enemy', 'collidable'])\nexpect(result).toHaveLength(1)\nexpect(result).toContain(testChild)"
              }
            ],
            "describes": []
          },
          {
            "title": "query and queryAll",
            "line": 1762,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "query finds direct child by id",
                "line": 1764,
                "source": "const player = child.create(PerkyModule, {$id: 'player'})\n\nconst result = child.query('#player')\n\nexpect(result).toBe(player)"
              },
              {
                "title": "query returns null when not found",
                "line": 1773,
                "source": "child.create(PerkyModule, {$id: 'player'})\n\nconst result = child.query('#enemy')\n\nexpect(result).toBeNull()"
              },
              {
                "title": "query finds child by tag",
                "line": 1782,
                "source": "const enemy = child.create(PerkyModule, {$id: 'e1', $tags: ['enemy']})\n\nconst result = child.query('.enemy')\n\nexpect(result).toBe(enemy)"
              },
              {
                "title": "query finds nested children",
                "line": 1791,
                "source": "const world = child.create(PerkyModule, {$id: 'world'})\nconst player = world.create(PerkyModule, {$id: 'player'})\n\nconst result = child.query('#world #player')\n\nexpect(result).toBe(player)"
              },
              {
                "title": "queryAll finds all matching children",
                "line": 1801,
                "source": "const enemy1 = child.create(PerkyModule, {$id: 'e1', $tags: ['enemy']})\nconst enemy2 = child.create(PerkyModule, {$id: 'e2', $tags: ['enemy']})\nchild.create(PerkyModule, {$id: 'player'})\n\nconst result = child.queryAll('.enemy')\n\nexpect(result).toHaveLength(2)\nexpect(result).toContain(enemy1)\nexpect(result).toContain(enemy2)"
              },
              {
                "title": "queryAll returns empty array when none found",
                "line": 1814,
                "source": "child.create(PerkyModule, {$id: 'player'})\n\nconst result = child.queryAll('.enemy')\n\nexpect(result).toEqual([])"
              },
              {
                "title": "queryAll finds nested children from multiple parents",
                "line": 1823,
                "source": "const scene1 = child.create(PerkyModule, {$id: 's1', $category: 'scene'})\nconst scene2 = child.create(PerkyModule, {$id: 's2', $category: 'scene'})\nconst enemy1 = scene1.create(PerkyModule, {$id: 'e1', $tags: ['enemy']})\nconst enemy2 = scene2.create(PerkyModule, {$id: 'e2', $tags: ['enemy']})\n\nconst result = child.queryAll('@scene .enemy')\n\nexpect(result).toHaveLength(2)\nexpect(result).toContain(enemy1)\nexpect(result).toContain(enemy2)"
              },
              {
                "title": "query with combined selectors",
                "line": 1837,
                "source": "child.create(PerkyModule, {$id: 'e1', $tags: ['enemy']})\nconst boss = child.create(PerkyModule, {$id: 'e2', $tags: ['enemy', 'boss']})\n\nconst result = child.query('.enemy.boss')\n\nexpect(result).toBe(boss)"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/core/utils.doc.js": {
    "file": "/core/utils.test.js",
    "describes": [
      {
        "title": "String Utils",
        "line": 17,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "toCamelCase",
            "line": 19,
            "source": "expect(toCamelCase('hello_world')).toEqual('helloWorld')\nexpect(toCamelCase('hello-world')).toEqual('helloWorld')\nexpect(toCamelCase('hello world')).toEqual('helloWorld')\nexpect(toCamelCase('HelloWorld')).toEqual('helloWorld')\nexpect(toCamelCase('Hello')).toEqual('hello')"
          },
          {
            "title": "toPascalCase",
            "line": 28,
            "source": "expect(toPascalCase('hello_world')).toEqual('HelloWorld')\nexpect(toPascalCase('hello-world')).toEqual('HelloWorld')\nexpect(toPascalCase('hello world')).toEqual('HelloWorld')\nexpect(toPascalCase('HelloWorld')).toEqual('HelloWorld')\nexpect(toPascalCase('Hello')).toEqual('Hello')"
          },
          {
            "title": "toSnakeCase",
            "line": 37,
            "source": "expect(toSnakeCase('helloWorld')).toEqual('hello_world')\nexpect(toSnakeCase('HelloWorld')).toEqual('hello_world')\nexpect(toSnakeCase('hello-world')).toEqual('hello_world')\nexpect(toSnakeCase('hello world')).toEqual('hello_world')\nexpect(toSnakeCase('Hello')).toEqual('hello')"
          },
          {
            "title": "singularize",
            "line": 46,
            "source": "expect(singularize('books')).toEqual('book')\nexpect(singularize('cars')).toEqual('car')\nexpect(singularize('houses')).toEqual('house')\n\nexpect(singularize('boxes')).toEqual('box')\nexpect(singularize('dishes')).toEqual('dish')\nexpect(singularize('buses')).toEqual('bus')\nexpect(singularize('wishes')).toEqual('wish')\n\nexpect(singularize('cities')).toEqual('city')\nexpect(singularize('flies')).toEqual('fly')\nexpect(singularize('stories')).toEqual('story')\n\nexpect(singularize('leaves')).toEqual('leaf')\nexpect(singularize('lives')).toEqual('life')\nexpect(singularize('wolves')).toEqual('wolf')\n\nexpect(singularize('men')).toEqual('man')\nexpect(singularize('women')).toEqual('woman')\nexpect(singularize('children')).toEqual('child')\nexpect(singularize('people')).toEqual('person')\nexpect(singularize('mice')).toEqual('mouse')\nexpect(singularize('feet')).toEqual('foot')\nexpect(singularize('teeth')).toEqual('tooth')\nexpect(singularize('cacti')).toEqual('cactus')\n\nexpect(singularize('fish')).toEqual('fish')\nexpect(singularize('deer')).toEqual('deer')"
          },
          {
            "title": "uniqueId",
            "line": 78,
            "source": "beforeEach(() => {\n    resetUniqueId('testCollection')\n    resetUniqueId('anotherCollection')\n})\n\nconst id1 = uniqueId('testCollection', 'item')\nexpect(id1).toBe('item')\n\nconst id2 = uniqueId('testCollection', 'item')\nexpect(id2).toBe('item_1')\n\nconst id3 = uniqueId('testCollection', 'item')\nexpect(id3).toBe('item_2')\n\nconst user1 = uniqueId('testCollection', 'user')\nexpect(user1).toBe('user')\n\nconst user2 = uniqueId('testCollection', 'user')\nexpect(user2).toBe('user_1')\n\nconst product1 = uniqueId('anotherCollection', 'product')\nexpect(product1).toBe('product')\n\nconst product2 = uniqueId('anotherCollection', 'product')\nexpect(product2).toBe('product_1')\n\nconst single1 = uniqueId('single')\nexpect(single1).toBe('single')\n\nconst single2 = uniqueId('single')\nexpect(single2).toBe('single_1')\n\nconst single3 = uniqueId('single')\nexpect(single3).toBe('single_2')\n\nconst other1 = uniqueId('other')\nexpect(other1).toBe('other')\n\nconst other2 = uniqueId('other')\nexpect(other2).toBe('other_1')"
          },
          {
            "title": "resetUniqueId",
            "line": 122,
            "source": "// Start fresh\nresetUniqueId('testCollection')\n\nuniqueId('testCollection', 'item')\nuniqueId('testCollection', 'item')\nuniqueId('testCollection', 'user')\n\nresetUniqueId('testCollection', 'item')\n\nconst newItem = uniqueId('testCollection', 'item')\nexpect(newItem).toBe('item')\n\nconst newUser = uniqueId('testCollection', 'user')\nexpect(newUser).toBe('user_1')\n\nresetUniqueId('testCollection')\n\nconst resetItem = uniqueId('testCollection', 'item')\nexpect(resetItem).toBe('item')\n\nconst resetUser = uniqueId('testCollection', 'user')\nexpect(resetUser).toBe('user')"
          }
        ],
        "describes": []
      },
      {
        "title": "Object Utils",
        "line": 150,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "deepMerge",
            "line": 152,
            "source": "expect(deepMerge({a: 1}, {b: 2})).toEqual({a: 1, b: 2})\nexpect(deepMerge({a: 1, b: 2}, {b: 3})).toEqual({a: 1, b: 3})\n\nexpect(deepMerge(\n    {a: {b: 1, c: 2}},\n    {a: {c: 3, d: 4}}\n)).toEqual({a: {b: 1, c: 3, d: 4}})\n\nexpect(deepMerge(\n    {a: [1, 2]},\n    {a: [3, 4]}\n)).toEqual({a: [1, 2, 3, 4]})\n\nexpect(deepMerge({a: 1}, null)).toEqual({a: 1})\nexpect(deepMerge({a: 1}, undefined)).toEqual({a: 1})"
          },
          {
            "title": "deepMerge handles circular references",
            "line": 171,
            "source": "const circular = {a: 1}\ncircular.self = circular\n\nexpect(() => {\n    deepMerge({}, circular)\n}).not.toThrow()\n\nconst result = deepMerge({b: 2}, circular)\nexpect(result.a).toBe(1)\nexpect(result.b).toBe(2)\nexpect(result.self).toBe(circular)"
          },
          {
            "title": "setDefaults",
            "line": 186,
            "source": "expect(setDefaults({a: 1}, {a: 0, b: 2})).toEqual({a: 1, b: 2})\n\nexpect(setDefaults(\n    {a: {b: 1}},\n    {a: {b: 0, c: 2}, d: 3}\n)).toEqual({a: {b: 1, c: 2}, d: 3})\n\nexpect(setDefaults({}, {a: 1, b: 2})).toEqual({a: 1, b: 2})\n\nexpect(setDefaults(null, {a: 1, b: 2})).toEqual({a: 1, b: 2})\nexpect(setDefaults(undefined, {a: 1, b: 2})).toEqual({a: 1, b: 2})"
          },
          {
            "title": "getNestedValue",
            "line": 201,
            "source": "const obj = {\n    a: 1,\n    b: {\n        c: 2,\n        d: {\n            e: 3\n        }\n    }\n}\n\nexpect(getNestedValue(obj, 'a')).toBe(1)\nexpect(getNestedValue(obj, 'b.c')).toBe(2)\nexpect(getNestedValue(obj, 'b.d.e')).toBe(3)\n\nexpect(getNestedValue(obj, 'x')).toBeUndefined()\nexpect(getNestedValue(obj, 'b.x')).toBeUndefined()\nexpect(getNestedValue(obj, 'b.d.x')).toBeUndefined()\n\nexpect(getNestedValue(obj)).toEqual(obj)"
          },
          {
            "title": "setNestedValue",
            "line": 224,
            "source": "const obj = {}\n\nsetNestedValue(obj, 'a', 1)\nexpect(obj).toEqual({a: 1})\n\nsetNestedValue(obj, 'b.c', 2)\nexpect(obj.b.c).toBe(2)\n\nsetNestedValue(obj, 'b.c', 3)\nexpect(obj.b.c).toBe(3)\n\nsetNestedValue(obj, 'b.d.e', 4)\nexpect(obj.b.d.e).toBe(4)\nexpect(obj).toEqual({a: 1, b: {c: 3, d: {e: 4}}})"
          }
        ],
        "describes": []
      },
      {
        "title": "delegateProperties",
        "line": 244,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "delegates methods with array notation",
            "line": 246,
            "source": "const source = {\n    method1: () => 'result1',\n    method2: () => 'result2'\n}\nconst receiver = {}\n\ndelegateProperties(receiver, source, ['method1', 'method2'])\n\nexpect(receiver.method1()).toBe('result1')\nexpect(receiver.method2()).toBe('result2')"
          },
          {
            "title": "delegates properties with array notation",
            "line": 260,
            "source": "const source = {prop1: 'value1', prop2: 'value2'}\nconst receiver = {}\n\ndelegateProperties(receiver, source, ['prop1', 'prop2'])\n\nexpect(receiver.prop1).toBe('value1')\nexpect(receiver.prop2).toBe('value2')"
          },
          {
            "title": "property changes reflect on source",
            "line": 271,
            "source": "const source = {prop: 'initial'}\nconst receiver = {}\n\ndelegateProperties(receiver, source, ['prop'])\n\nreceiver.prop = 'changed'\nexpect(source.prop).toBe('changed')"
          },
          {
            "title": "delegates with object notation (aliasing)",
            "line": 282,
            "source": "const source = {\n    originalMethod: () => 'result',\n    originalProp: 'value'\n}\nconst receiver = {}\n\ndelegateProperties(receiver, source, {\n    originalMethod: 'aliasedMethod',\n    originalProp: 'aliasedProp'\n})\n\nexpect(receiver.aliasedMethod()).toBe('result')\nexpect(receiver.aliasedProp).toBe('value')"
          },
          {
            "title": "delegates getters and setters",
            "line": 299,
            "source": "let internalValue = 10\nconst source = {}\nObject.defineProperty(source, 'value', {\n    get () {\n        return internalValue\n    },\n    set (newValue) {\n        internalValue = newValue\n    },\n    enumerable: true,\n    configurable: true\n})\n\nconst receiver = {}\ndelegateProperties(receiver, source, ['value'])\n\nexpect(receiver.value).toBe(10)\nreceiver.value = 20\nexpect(internalValue).toBe(20)\nexpect(receiver.value).toBe(20)"
          },
          {
            "title": "methods are bound to source context",
            "line": 323,
            "source": "const source = {\n    name: 'source',\n    getName () {\n        return this.name\n    }\n}\nconst receiver = {name: 'receiver'}\n\ndelegateProperties(receiver, source, ['getName'])\n\nexpect(receiver.getName()).toBe('source')"
          }
        ],
        "describes": []
      }
    ]
  },
  "/editor/perky_logger.doc.js": {
    "file": "/editor/perky_logger.test.js",
    "describes": [
      {
        "title": "PerkyLogger",
        "line": 5,
        "beforeEach": {
          "line": 10,
          "source": "logger = new PerkyLogger()\ndocument.body.appendChild(logger)"
        },
        "afterEach": {
          "line": 16,
          "source": "document.body.innerHTML = ''"
        },
        "tests": [
          {
            "title": "custom element creation",
            "line": 21,
            "source": "expect(logger).toBeInstanceOf(PerkyLogger)\nexpect(logger.tagName).toBe('PERKY-LOGGER')"
          },
          {
            "title": "constructor initializes with default options",
            "line": 27,
            "source": "expect(logger.maxEntries).toBe(50)\nexpect(logger.position).toBe('bottom')\nexpect(logger.timestamp).toBe(false)\nexpect(logger.entries).toEqual([])"
          },
          {
            "title": "constructor accepts custom attributes",
            "line": 35,
            "source": "const customLogger = new PerkyLogger()\ncustomLogger.maxEntries = 100\ncustomLogger.position = 'top'\ncustomLogger.timestamp = true\n\nexpect(customLogger.maxEntries).toBe(100)\nexpect(customLogger.position).toBe('top')\nexpect(customLogger.timestamp).toBe(true)"
          },
          {
            "title": "log creates a log entry with the specified type",
            "line": 47,
            "source": "const message = 'Test message'\nconst type = 'info'\n\nconst entry = logger.log(message, type)\n\nexpect(entry.className).toContain('logger-entry')\nexpect(entry.className).toContain('log-info')\nexpect(entry.querySelector('.logger-message').textContent).toBe(message)\nexpect(logger.entries.length).toBe(1)\nexpect(logger.entries[0]).toBe(entry)"
          },
          {
            "title": "log creates timestamp when enabled",
            "line": 61,
            "source": "logger.timestamp = true\nconst message = 'Test message with timestamp'\n\nconst entry = logger.log(message, 'info')\n\nconst timestamp = entry.querySelector('.logger-timestamp')\nexpect(timestamp).not.toBeNull()\nexpect(entry.textContent).toContain(message)"
          },
          {
            "title": "log removes oldest entries when limit is reached",
            "line": 73,
            "source": "logger.maxEntries = 3\n\nconst entry1 = logger.log('Message 1', 'info')\nconst entry2 = logger.log('Message 2', 'info')\nconst entry3 = logger.log('Message 3', 'info')\nconst entry4 = logger.log('Message 4', 'info')\n\nexpect(logger.entries.length).toBe(3)\nexpect(logger.entries).not.toContain(entry1)\nexpect(logger.entries).toContain(entry2)\nexpect(logger.entries).toContain(entry3)\nexpect(logger.entries).toContain(entry4)"
          },
          {
            "title": "info logs a message with info type",
            "line": 89,
            "source": "vi.spyOn(logger, 'log')\n\nlogger.info('Info message')\n\nexpect(logger.log).toHaveBeenCalledWith('Info message', 'info')"
          },
          {
            "title": "warn logs a message with warn type",
            "line": 98,
            "source": "vi.spyOn(logger, 'log')\n\nlogger.warn('Warning message')\n\nexpect(logger.log).toHaveBeenCalledWith('Warning message', 'warn')"
          },
          {
            "title": "error logs a message with error type",
            "line": 107,
            "source": "vi.spyOn(logger, 'log')\n\nlogger.error('Error message')\n\nexpect(logger.log).toHaveBeenCalledWith('Error message', 'error')"
          },
          {
            "title": "success logs a message with success type",
            "line": 116,
            "source": "vi.spyOn(logger, 'log')\n\nlogger.success('Success message')\n\nexpect(logger.log).toHaveBeenCalledWith('Success message', 'success')"
          },
          {
            "title": "notice logs a message with notice type",
            "line": 125,
            "source": "vi.spyOn(logger, 'log')\n\nlogger.notice('Notice message')\n\nexpect(logger.log).toHaveBeenCalledWith('Notice message', 'notice')"
          },
          {
            "title": "spacer creates a spacer entry",
            "line": 134,
            "source": "logger.spacer()\n\nexpect(logger.entries.length).toBe(1)\nexpect(logger.entries[0].className).toContain('logger-spacer')"
          },
          {
            "title": "title creates a title entry",
            "line": 142,
            "source": "logger.title('Test Title')\n\nexpect(logger.entries.length).toBe(1)\nexpect(logger.entries[0].className).toContain('logger-title-entry')\nexpect(logger.entries[0].textContent).toBe('Test Title')"
          },
          {
            "title": "clear removes all entries",
            "line": 151,
            "source": "logger.log('Message 1', 'info')\nlogger.log('Message 2', 'warn')\nlogger.log('Message 3', 'error')\n\nexpect(logger.entries.length).toBe(3)\n\nlogger.clear()\n\nexpect(logger.entries.length).toBe(0)"
          },
          {
            "title": "render displays correct structure",
            "line": 164,
            "source": "const loggerDiv = logger.shadowRoot.querySelector('.logger')\nconst content = logger.shadowRoot.querySelector('.logger-content')\n\nexpect(loggerDiv).toBeTruthy()\nexpect(content).toBeTruthy()"
          },
          {
            "title": "entries are rendered in content",
            "line": 173,
            "source": "logger.log('Test message', 'info')\n\nconst content = logger.shadowRoot.querySelector('.logger-content')\nexpect(content.children.length).toBe(1)"
          },
          {
            "title": "position updates logger classes",
            "line": 181,
            "source": "logger.position = 'top'\n\nconst loggerDiv = logger.shadowRoot.querySelector('.logger')\n\nexpect(loggerDiv.className).toContain('logger')\nexpect(loggerDiv.className).toContain('logger-top')"
          },
          {
            "title": "multiple message arguments are formatted correctly",
            "line": 191,
            "source": "logger.info('Message', 123, {key: 'value'})\n\nexpect(logger.entries.length).toBe(1)\nexpect(logger.entries[0].textContent).toContain('Message')\nexpect(logger.entries[0].textContent).toContain('123')\nexpect(logger.entries[0].textContent).toContain('key')"
          },
          {
            "title": "can be used like a DOM element",
            "line": 201,
            "source": "const container = document.createElement('div')\nconst newLogger = new PerkyLogger()\n\ncontainer.appendChild(newLogger)\n\nexpect(container.contains(newLogger)).toBe(true)\nexpect(newLogger.parentElement).toBe(container)\n\nnewLogger.info('Test message')\nexpect(newLogger.entries.length).toBe(1)"
          },
          {
            "title": "theme property works correctly",
            "line": 215,
            "source": "expect(logger.theme).toBe('')\n\nlogger.theme = 'light'\n\nexpect(logger.theme).toBe('light')\nexpect(logger.hasAttribute('theme')).toBe(true)\nexpect(logger.getAttribute('theme')).toBe('light')\n\nlogger.theme = ''\n\nexpect(logger.theme).toBe('')\nexpect(logger.hasAttribute('theme')).toBe(false)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/game/game_loop.doc.js": {
    "file": "/game/game_loop.test.js",
    "describes": [
      {
        "title": "GameLoop",
        "line": 6,
        "beforeEach": {
          "line": 12,
          "source": "originalRequestAnimationFrame = global.requestAnimationFrame\noriginalPerformanceNow = global.performance.now\nanimationCallbacks = []\n\nlet time = 0\nglobal.performance.now = vi.fn(() => {\n    time += 16.7 // ~60fps\n    return time\n})\n\nglobal.requestAnimationFrame = vi.fn(callback => {\n    animationCallbacks.push(callback)\n    return 1 // Return a dummy ID\n})\n\nvi.spyOn(PerkyModule.prototype, 'emit')\n\ngameLoop = new GameLoop()"
        },
        "afterEach": {
          "line": 34,
          "source": "vi.restoreAllMocks()\nglobal.requestAnimationFrame = originalRequestAnimationFrame\nglobal.performance.now = originalPerformanceNow\nanimationCallbacks = []"
        },
        "tests": [
          {
            "title": "constructor",
            "line": 42,
            "source": "expect(gameLoop).toBeInstanceOf(PerkyModule)\nexpect(gameLoop.frameInterval).toBe(1000 / 60)\nexpect(gameLoop.paused).toBe(false)\nexpect(gameLoop.maxFrameSkip).toBe(5)"
          },
          {
            "title": "constructor with custom params",
            "line": 50,
            "source": "const customLoop = new GameLoop({\n    fps: 30,\n    maxFrameSkip: 3\n})\n\nexpect(customLoop.frameInterval).toBe(1000 / 30)\nexpect(customLoop.maxFrameSkip).toBe(3)"
          },
          {
            "title": "running getter",
            "line": 61,
            "source": "expect(gameLoop.running).toBe(false)\n\ngameLoop.start()\nexpect(gameLoop.running).toBe(true)\n\ngameLoop.paused = true\nexpect(gameLoop.running).toBe(false)"
          },
          {
            "title": "start",
            "line": 72,
            "source": "gameLoop.start()\n\nexpect(gameLoop.started).toBe(true)\nexpect(gameLoop.lastTime).toBeDefined()\nexpect(gameLoop.accumulator).toBe(0)\nexpect(gameLoop.frameCount).toBe(0)\nexpect(global.requestAnimationFrame).toHaveBeenCalled()"
          },
          {
            "title": "start with already started",
            "line": 83,
            "source": "gameLoop.start()\n\nvi.clearAllMocks()\nconst result = gameLoop.start()\n\nexpect(result).toBe(false)\nexpect(requestAnimationFrame).not.toHaveBeenCalled()"
          },
          {
            "title": "pause",
            "line": 94,
            "source": "gameLoop.start()\ngameLoop.paused = false\n\nconst result = gameLoop.pause('param')\n\nexpect(result).toBe(true)\nexpect(gameLoop.paused).toBe(true)\nexpect(gameLoop.emit).toHaveBeenCalledWith('pause', 'param')"
          },
          {
            "title": "pause when not running",
            "line": 106,
            "source": "vi.clearAllMocks()\n\nconst result = gameLoop.pause()\n\nexpect(result).toBe(false)\nexpect(gameLoop.emit).not.toHaveBeenCalled()"
          },
          {
            "title": "resume",
            "line": 116,
            "source": "gameLoop.start()\ngameLoop.paused = true\n\nconst result = gameLoop.resume('param')\n\nexpect(result).toBe(true)\nexpect(gameLoop.paused).toBe(false)\nexpect(gameLoop.emit).toHaveBeenCalledWith('resume', 'param')\nexpect(requestAnimationFrame).toHaveBeenCalled()"
          },
          {
            "title": "resume when not paused",
            "line": 129,
            "source": "gameLoop.start()\ngameLoop.paused = false\n\nvi.clearAllMocks()\n\nconst result = gameLoop.resume()\n\nexpect(result).toBe(false)\nexpect(gameLoop.emit).not.toHaveBeenCalled()"
          },
          {
            "title": "setFps and getFps",
            "line": 142,
            "source": "gameLoop.setFps(30)\n\nexpect(gameLoop.frameInterval).toBe(1000 / 30)\nexpect(gameLoop.getFps()).toBe(30)"
          },
          {
            "title": "getCurrentFps",
            "line": 150,
            "source": "expect(gameLoop.getCurrentFps()).toBe(0)\n\ngameLoop.currentFps = 59\nexpect(gameLoop.getCurrentFps()).toBe(59)"
          },
          {
            "title": "update function emits events",
            "line": 158,
            "source": "const testLoop = new GameLoop()\nconst update = vi.fn()\nconst render = vi.fn()\n\ntestLoop.on('update', update)\ntestLoop.on('render', render)\n\ntestLoop.start()\nexpect(animationCallbacks.length).toBeGreaterThan(0)\n\ntestLoop.lastTime = performance.now() - 50 // 50ms ago\n\nconst updateFn = animationCallbacks[0]\nupdateFn(performance.now())\n\nexpect(update).toHaveBeenCalled()\n\nexpect(render).toHaveBeenCalled()"
          },
          {
            "title": "update function with paused loop",
            "line": 179,
            "source": "const testLoop = new GameLoop()\nconst update = vi.fn()\nconst render = vi.fn()\n\ntestLoop.on('update', update)\ntestLoop.on('render', render)\n\ntestLoop.start()\nexpect(animationCallbacks.length).toBeGreaterThan(0)\n\ntestLoop.paused = true\n\nconst updateFn = animationCallbacks[0]\nconst result = updateFn(performance.now())\n\nexpect(result).toBe(false)\nexpect(update).not.toHaveBeenCalled()\nexpect(render).not.toHaveBeenCalled()"
          }
        ],
        "describes": []
      }
    ]
  },
  "/input/input_devices/keyboard_device.doc.js": {
    "file": "/input/input_devices/keyboard_device.test.js",
    "describes": [
      {
        "title": "KeyboardDevice",
        "line": 16,
        "beforeEach": {
          "line": 21,
          "source": "mockContainer = {\n    addEventListener: vi.fn(),\n    removeEventListener: vi.fn()\n}\n\ndevice = new KeyboardDevice({\n    container: mockContainer,\n    $id: 'testKeyboard'\n})"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor",
            "line": 34,
            "source": "expect(device).toBeInstanceOf(InputDevice)\nexpect(device.$id).toBe('testKeyboard')\nexpect(device.container).toBe(mockContainer)"
          },
          {
            "title": "constructor with default params",
            "line": 41,
            "source": "const defaultDevice = new KeyboardDevice()\nexpect(defaultDevice.$id).toBe('keyboard')\nexpect(defaultDevice.container).toBe(window)"
          },
          {
            "title": "start attaches event listeners",
            "line": 48,
            "source": "device.start()\n\nexpect(mockContainer.addEventListener).toHaveBeenCalledWith('keydown', expect.any(Function), true)\nexpect(mockContainer.addEventListener).toHaveBeenCalledWith('keyup', expect.any(Function), true)\nexpect(mockContainer.addEventListener).toHaveBeenCalledWith('blur', expect.any(Function))\nexpect(mockContainer.addEventListener).toHaveBeenCalledTimes(3)"
          },
          {
            "title": "stop removes event listeners",
            "line": 58,
            "source": "device.start()\ndevice.stop()\n\nexpect(mockContainer.removeEventListener).toHaveBeenCalledWith('keydown', expect.any(Function), true)\nexpect(mockContainer.removeEventListener).toHaveBeenCalledWith('keyup', expect.any(Function), true)\nexpect(mockContainer.removeEventListener).toHaveBeenCalledWith('blur', expect.any(Function))\nexpect(mockContainer.removeEventListener).toHaveBeenCalledTimes(3)"
          },
          {
            "title": "dispose calls stop",
            "line": 69,
            "source": "const stopSpy = vi.spyOn(device, 'stop')\ndevice.start()\ndevice.dispose()\nexpect(stopSpy).toHaveBeenCalled()"
          },
          {
            "title": "keydown event creates and presses control",
            "line": 78,
            "source": "device.start()\n\nconst keydownListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'keydown')[1]\n\nconst event = createKeyEvent('KeyA')\nkeydownListener(event)\n\nconst control = device.getControl('KeyA')\nexpect(control).toBeInstanceOf(ButtonControl)\nexpect(control.isPressed).toBe(true)\nexpect(device.isPressed('KeyA')).toBe(true)"
          },
          {
            "title": "keydown event does not press already pressed control",
            "line": 94,
            "source": "device.start()\n\nconst keydownListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'keydown')[1]\n\nconst event = createKeyEvent('KeyA')\nkeydownListener(event)\n\nconst control = device.getControl('KeyA')\nconst pressSpy = vi.spyOn(control, 'press')\n\nkeydownListener(event)\nexpect(pressSpy).not.toHaveBeenCalled()"
          },
          {
            "title": "keyup event releases control",
            "line": 111,
            "source": "device.start()\n\nconst keydownListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'keydown')[1]\nconst keyupListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'keyup')[1]\n\nconst event = createKeyEvent('KeyA')\nkeydownListener(event)\nexpect(device.isPressed('KeyA')).toBe(true)\n\nkeyupListener(event)\nexpect(device.isPressed('KeyA')).toBe(false)"
          },
          {
            "title": "keyup event does nothing for non-existent control",
            "line": 128,
            "source": "device.start()\n\nconst keyupListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'keyup')[1]\n\nconst event = createKeyEvent('KeyA')\nexpect(() => keyupListener(event)).not.toThrow()\nexpect(device.getControl('KeyA')).toBeUndefined()"
          },
          {
            "title": "blur event releases all pressed keys",
            "line": 140,
            "source": "device.start()\n\nconst keydownListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'keydown')[1]\nconst blurListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'blur')[1]\n\nkeydownListener(createKeyEvent('KeyA'))\nkeydownListener(createKeyEvent('KeyB'))\nexpect(device.isPressed('KeyA')).toBe(true)\nexpect(device.isPressed('KeyB')).toBe(true)\n\nblurListener()\nexpect(device.isPressed('KeyA')).toBe(false)\nexpect(device.isPressed('KeyB')).toBe(false)"
          },
          {
            "title": "integration test - full key press cycle",
            "line": 159,
            "source": "const controlPressedListener = vi.fn()\nconst controlReleasedListener = vi.fn()\n\ndevice.on('control:pressed', controlPressedListener)\ndevice.on('control:released', controlReleasedListener)\n\ndevice.start()\n\nconst keydownListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'keydown')[1]\nconst keyupListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'keyup')[1]\n\nconst event = createKeyEvent('Space')\n\nkeydownListener(event)\nexpect(controlPressedListener).toHaveBeenCalledTimes(1)\nexpect(device.isPressed('Space')).toBe(true)\n\nkeyupListener(event)\nexpect(controlReleasedListener).toHaveBeenCalledTimes(1)\nexpect(device.isPressed('Space')).toBe(false)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/input/input_devices/mouse_device.doc.js": {
    "file": "/input/input_devices/mouse_device.test.js",
    "describes": [
      {
        "title": "MouseDevice",
        "line": 16,
        "beforeEach": {
          "line": 21,
          "source": "mockContainer = {\n    addEventListener: vi.fn(),\n    removeEventListener: vi.fn()\n}\n\ndevice = new MouseDevice({\n    container: mockContainer,\n    $id: 'testMouse'\n})"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor",
            "line": 34,
            "source": "expect(device).toBeInstanceOf(InputDevice)\nexpect(device.$id).toBe('testMouse')\nexpect(device.container).toBe(mockContainer)"
          },
          {
            "title": "constructor with default params",
            "line": 41,
            "source": "const defaultDevice = new MouseDevice()\nexpect(defaultDevice.$id).toBe('mouse')\nexpect(defaultDevice.container).toBe(window)"
          },
          {
            "title": "creates all mouse controls",
            "line": 48,
            "source": "expect(device.getControl('leftButton')).toBeInstanceOf(ButtonControl)\nexpect(device.getControl('rightButton')).toBeInstanceOf(ButtonControl)\nexpect(device.getControl('middleButton')).toBeInstanceOf(ButtonControl)\nexpect(device.getControl('backButton')).toBeInstanceOf(ButtonControl)\nexpect(device.getControl('forwardButton')).toBeInstanceOf(ButtonControl)\nexpect(device.getControl('position')).toBeInstanceOf(Vec2Control)\nexpect(device.getControl('navigation')).toBeInstanceOf(NavigationControl)"
          },
          {
            "title": "start attaches event listeners",
            "line": 59,
            "source": "device.start()\n\nexpect(mockContainer.addEventListener).toHaveBeenCalledWith('mousedown', expect.any(Function))\nexpect(mockContainer.addEventListener).toHaveBeenCalledWith('mouseup', expect.any(Function))\nexpect(mockContainer.addEventListener).toHaveBeenCalledWith('mousemove', expect.any(Function))\nexpect(mockContainer.addEventListener).toHaveBeenCalledWith('contextmenu', expect.any(Function))\nexpect(mockContainer.addEventListener).toHaveBeenCalledWith('wheel', expect.any(Function), {passive: false})\nexpect(mockContainer.addEventListener).toHaveBeenCalledTimes(5)"
          },
          {
            "title": "stop removes event listeners",
            "line": 71,
            "source": "device.start()\ndevice.stop()\n\nexpect(mockContainer.removeEventListener).toHaveBeenCalledWith('mousedown', expect.any(Function))\nexpect(mockContainer.removeEventListener).toHaveBeenCalledWith('mouseup', expect.any(Function))\nexpect(mockContainer.removeEventListener).toHaveBeenCalledWith('mousemove', expect.any(Function))\nexpect(mockContainer.removeEventListener).toHaveBeenCalledWith('contextmenu', expect.any(Function))\nexpect(mockContainer.removeEventListener).toHaveBeenCalledWith('wheel', expect.any(Function), {passive: false})\nexpect(mockContainer.removeEventListener).toHaveBeenCalledTimes(5)"
          },
          {
            "title": "dispose calls stop",
            "line": 84,
            "source": "const stopSpy = vi.spyOn(device, 'stop')\ndevice.dispose()\nexpect(stopSpy).toHaveBeenCalled()"
          },
          {
            "title": "mousedown event presses correct button",
            "line": 91,
            "source": "device.start()\n\nconst mousedownListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'mousedown')[1]\n\nmousedownListener(createMockEvent({button: 0}))\nexpect(device.isPressed('leftButton')).toBe(true)\n\nmousedownListener(createMockEvent({button: 2}))\nexpect(device.isPressed('rightButton')).toBe(true)\n\nmousedownListener(createMockEvent({button: 1}))\nexpect(device.isPressed('middleButton')).toBe(true)"
          },
          {
            "title": "mouseup event releases correct button",
            "line": 108,
            "source": "device.start()\n\nconst mousedownListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'mousedown')[1]\nconst mouseupListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'mouseup')[1]\n\nmousedownListener(createMockEvent({button: 0}))\nexpect(device.isPressed('leftButton')).toBe(true)\n\nmouseupListener(createMockEvent({button: 0}))\nexpect(device.isPressed('leftButton')).toBe(false)"
          },
          {
            "title": "side buttons work correctly",
            "line": 124,
            "source": "device.start()\n\nconst mousedownListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'mousedown')[1]\n\nmousedownListener(createMockEvent({button: 3}))\nexpect(device.isPressed('backButton')).toBe(true)\n\nmousedownListener(createMockEvent({button: 4}))\nexpect(device.isPressed('forwardButton')).toBe(true)"
          },
          {
            "title": "mousemove updates position",
            "line": 138,
            "source": "device.start()\n\nconst mousemoveListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'mousemove')[1]\n\nconst positionControl = device.getControl('position')\nexpect(positionControl.value.x).toBe(0)\nexpect(positionControl.value.y).toBe(0)\n\nmousemoveListener(createMockEvent({clientX: 100, clientY: 200}))\nexpect(positionControl.value.x).toBe(100)\nexpect(positionControl.value.y).toBe(200)\n\nmousemoveListener(createMockEvent({clientX: 300, clientY: 400}))\nexpect(positionControl.value.x).toBe(300)\nexpect(positionControl.value.y).toBe(400)"
          },
          {
            "title": "mousedown does not press already pressed button",
            "line": 158,
            "source": "device.start()\n\nconst mousedownListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'mousedown')[1]\n\nmousedownListener(createMockEvent({button: 0}))\nconst leftButton = device.getControl('leftButton')\nconst pressSpy = vi.spyOn(leftButton, 'press')\n\nmousedownListener(createMockEvent({button: 0}))\nexpect(pressSpy).not.toHaveBeenCalled()"
          },
          {
            "title": "wheel event updates navigation control",
            "line": 173,
            "source": "device.start()\n\nconst wheelListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'wheel')[1]\n\nconst navigationControl = device.getControl('navigation')\nexpect(navigationControl.value).toEqual({deltaX: 0, deltaY: 0, deltaZ: 0, event: null})\n\nconst mockEvent = createMockEvent({deltaX: 10, deltaY: -50, deltaZ: 0})\nwheelListener(mockEvent)\nexpect(navigationControl.value).toEqual({deltaX: 10, deltaY: -50, deltaZ: 0, event: mockEvent})"
          },
          {
            "title": "integration test - full mouse interaction",
            "line": 188,
            "source": "const controlPressedListener = vi.fn()\nconst controlReleasedListener = vi.fn()\nconst controlUpdatedListener = vi.fn()\n\ndevice.on('control:pressed', controlPressedListener)\ndevice.on('control:released', controlReleasedListener)\ndevice.on('control:updated', controlUpdatedListener)\n\ndevice.start()\n\nconst mousedownListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'mousedown')[1]\nconst mouseupListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'mouseup')[1]\nconst mousemoveListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'mousemove')[1]\n\nmousemoveListener(createMockEvent({clientX: 50, clientY: 75}))\nexpect(controlUpdatedListener).toHaveBeenCalledTimes(1)\n\nmousedownListener(createMockEvent({button: 0}))\nexpect(controlPressedListener).toHaveBeenCalledTimes(1)\nexpect(device.isPressed('leftButton')).toBe(true)\n\nmouseupListener(createMockEvent({button: 0}))\nexpect(controlReleasedListener).toHaveBeenCalledTimes(1)\nexpect(device.isPressed('leftButton')).toBe(false)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/math/random.doc.js": {
    "file": "/math/random.test.js",
    "describes": [
      {
        "title": "Random",
        "line": 4,
        "beforeEach": {
          "line": 7,
          "source": "random = new Random('testSeed')"
        },
        "afterEach": null,
        "tests": [],
        "describes": [
          {
            "title": "constructor",
            "line": 12,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates instance with default seed",
                "line": 14,
                "source": "const randomWithDefaultSeed = new Random()\nexpect(randomWithDefaultSeed).toBeInstanceOf(Random)\nexpect(randomWithDefaultSeed.getSeed()).toBeDefined()"
              },
              {
                "title": "creates instance with custom seed",
                "line": 21,
                "source": "const randomWithCustomSeed = new Random('mySeed')\nexpect(randomWithCustomSeed).toBeInstanceOf(Random)\nexpect(randomWithCustomSeed.getSeed()).toEqual('mySeed')"
              }
            ],
            "describes": []
          },
          {
            "title": "determinism",
            "line": 30,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "same seed produces same sequence",
                "line": 32,
                "source": "const random1 = new Random('same-seed')\nconst random2 = new Random('same-seed')\n\nfor (let i = 0; i < 10; i++) {\n    expect(random1.between(0, 1)).toBe(random2.between(0, 1))\n}"
              },
              {
                "title": "different seeds produce different sequences",
                "line": 42,
                "source": "const random1 = new Random('seed-a')\nconst random2 = new Random('seed-b')\n\nconst sequence1 = Array.from({length: 5}, () => random1.between(0, 1))\nconst sequence2 = Array.from({length: 5}, () => random2.between(0, 1))\n\nexpect(sequence1).not.toEqual(sequence2)"
              },
              {
                "title": "returns numbers between 0 and 1",
                "line": 53,
                "source": "const testRandom = new Random('test')\nfor (let i = 0; i < 100; i++) {\n    const value = testRandom.between(0, 1)\n    expect(value).toBeGreaterThanOrEqual(0)\n    expect(value).toBeLessThan(1)\n}"
              }
            ],
            "describes": []
          },
          {
            "title": "setSeed & getSeed",
            "line": 65,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "gets and sets seed",
                "line": 67,
                "source": "expect(random.getSeed()).toEqual('testSeed')\n\nrandom.setSeed('newSeed')\nexpect(random.getSeed()).toEqual('newSeed')"
              },
              {
                "title": "setSeed resets the generator",
                "line": 75,
                "source": "const firstSequence = [\n    random.between(0, 1),\n    random.between(0, 1),\n    random.between(0, 1)\n]\n\nrandom.setSeed('testSeed')\n\nconst resetSequence = [\n    random.between(0, 1),\n    random.between(0, 1),\n    random.between(0, 1)\n]\n\nexpect(resetSequence).toEqual(firstSequence)"
              },
              {
                "title": "setSeed returns this for chaining",
                "line": 94,
                "source": "expect(random.setSeed('newSeed')).toBe(random)"
              }
            ],
            "describes": []
          },
          {
            "title": "setState & getState",
            "line": 101,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "getState returns current state with all properties",
                "line": 103,
                "source": "const state = random.getState()\n\nexpect(state).toHaveProperty('c')\nexpect(state).toHaveProperty('s0')\nexpect(state).toHaveProperty('s1')\nexpect(state).toHaveProperty('s2')"
              },
              {
                "title": "state changes after generating numbers",
                "line": 113,
                "source": "const initialState = random.getState()\n\nrandom.between(0, 10)\n\nconst newState = random.getState()\nexpect(newState).not.toEqual(initialState)"
              },
              {
                "title": "setState restores state",
                "line": 123,
                "source": "random.between(0, 1)\nrandom.between(0, 1)\nrandom.between(0, 1)\n\nconst savedState = random.getState()\n\nconst afterSave = [\n    random.between(0, 1),\n    random.between(0, 1),\n    random.between(0, 1)\n]\n\nrandom.setState(savedState)\n\nconst afterRestore = [\n    random.between(0, 1),\n    random.between(0, 1),\n    random.between(0, 1)\n]\n\nexpect(afterRestore).toEqual(afterSave)"
              },
              {
                "title": "setState returns this for chaining",
                "line": 148,
                "source": "const state = random.getState()\nexpect(random.setState(state)).toBe(random)"
              },
              {
                "title": "sequence reproduction with state",
                "line": 154,
                "source": "const initialState = random.getState()\n\nconst firstSequence = [\n    random.between(0, 100),\n    random.between(10, 50),\n    random.between(-10, 10)\n]\n\nrandom.setState(initialState)\n\nconst secondSequence = [\n    random.between(0, 100),\n    random.between(10, 50),\n    random.between(-10, 10)\n]\n\nexpect(secondSequence).toEqual(firstSequence)"
              }
            ],
            "describes": []
          },
          {
            "title": "fork",
            "line": 177,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates a new Random instance",
                "line": 179,
                "source": "const forkedRandom = random.fork()\nexpect(forkedRandom).toBeInstanceOf(Random)\nexpect(forkedRandom).not.toBe(random)"
              },
              {
                "title": "forked instance has same seed and state",
                "line": 186,
                "source": "random.between(0, 10)\n\nconst forkedRandom = random.fork()\nexpect(forkedRandom.getSeed()).toEqual(random.getSeed())\nexpect(forkedRandom.getState()).toEqual(random.getState())"
              },
              {
                "title": "forked instance produces same sequence",
                "line": 195,
                "source": "random.between(0, 10)\n\nconst forkedRandom = random.fork()\n\nconst originalSequence = [\n    random.between(0, 100),\n    random.between(0, 100),\n    random.between(0, 100)\n]\n\nrandom.setState(forkedRandom.getState())\n\nconst forkedSequence = [\n    forkedRandom.between(0, 100),\n    forkedRandom.between(0, 100),\n    forkedRandom.between(0, 100)\n]\n\nexpect(forkedSequence).toEqual(originalSequence)"
              },
              {
                "title": "forked instance diverges independently",
                "line": 218,
                "source": "random.between(0, 10)\n\nconst forkedRandom = random.fork()\n\nforkedRandom.between(0, 10)\nexpect(forkedRandom.getState()).not.toEqual(random.getState())"
              }
            ],
            "describes": []
          },
          {
            "title": "between",
            "line": 230,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns value in range",
                "line": 232,
                "source": "const value = random.between(0, 10)\nexpect(value).toBeGreaterThanOrEqual(0)\nexpect(value).toBeLessThan(10)"
              },
              {
                "title": "works with negative ranges",
                "line": 239,
                "source": "const negativeValue = random.between(-10, 0)\nexpect(negativeValue).toBeGreaterThanOrEqual(-10)\nexpect(negativeValue).toBeLessThan(0)"
              },
              {
                "title": "works with decimal ranges",
                "line": 246,
                "source": "const value = random.between(0.5, 1.5)\nexpect(value).toBeGreaterThanOrEqual(0.5)\nexpect(value).toBeLessThan(1.5)"
              }
            ],
            "describes": []
          },
          {
            "title": "intBetween",
            "line": 255,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns integer in range",
                "line": 257,
                "source": "const value = random.intBetween(0, 10)\nexpect(value).toBeGreaterThanOrEqual(0)\nexpect(value).toBeLessThan(10)\nexpect(Number.isInteger(value)).toBe(true)"
              },
              {
                "title": "returns integers for many iterations",
                "line": 265,
                "source": "for (let i = 0; i < 100; i++) {\n    const value = random.intBetween(0, 100)\n    expect(Number.isInteger(value)).toBe(true)\n}"
              }
            ],
            "describes": []
          },
          {
            "title": "pick",
            "line": 275,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns element from array",
                "line": 277,
                "source": "const array = [1, 2, 3, 4, 5]\nconst value = random.pick(array)\nexpect(array).toContain(value)"
              },
              {
                "title": "can pick all elements over many iterations",
                "line": 284,
                "source": "const array = ['a', 'b', 'c']\nconst picked = new Set()\n\nfor (let i = 0; i < 100; i++) {\n    picked.add(random.pick(array))\n}\n\nexpect(picked.size).toBe(3)"
              }
            ],
            "describes": []
          },
          {
            "title": "oneChanceIn",
            "line": 298,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns boolean",
                "line": 300,
                "source": "const result = random.oneChanceIn(2)\nexpect(typeof result).toBe('boolean')"
              },
              {
                "title": "higher chances produce fewer true results",
                "line": 306,
                "source": "const testRandom = new Random('oneChanceTest')\nlet trueCount2 = 0\nlet trueCount10 = 0\n\nfor (let i = 0; i < 1000; i++) {\n    if (testRandom.oneChanceIn(2)) {\n        trueCount2++\n    }\n    if (testRandom.oneChanceIn(10)) {\n        trueCount10++\n    }\n}\n\nexpect(trueCount2).toBeGreaterThan(trueCount10)"
              }
            ],
            "describes": []
          },
          {
            "title": "coinToss",
            "line": 326,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns boolean",
                "line": 328,
                "source": "const result = random.coinToss()\nexpect(typeof result).toBe('boolean')"
              },
              {
                "title": "produces roughly equal distribution",
                "line": 334,
                "source": "const testRandom = new Random('coinTossTest')\nlet trueCount = 0\n\nfor (let i = 0; i < 1000; i++) {\n    if (testRandom.coinToss()) {\n        trueCount++\n    }\n}\n\nexpect(trueCount).toBeGreaterThan(400)\nexpect(trueCount).toBeLessThan(600)"
              }
            ],
            "describes": []
          },
          {
            "title": "weightedChoice",
            "line": 351,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "respects weights distribution",
                "line": 353,
                "source": "const choices = [\n    {value: 'rare', weight: 1},\n    {value: 'common', weight: 99}\n]\n\nconst results = {rare: 0, common: 0}\nconst testRandom = new Random('weightedTestSeed')\n\nfor (let i = 0; i < 1000; i++) {\n    const result = testRandom.weightedChoice(choices)\n    results[result]++\n}\n\nexpect(results.common).toBeGreaterThan(results.rare)\nexpect(results.rare).toBeGreaterThan(0)"
              },
              {
                "title": "returns undefined for empty array",
                "line": 372,
                "source": "expect(random.weightedChoice([])).toBeUndefined()"
              },
              {
                "title": "returns undefined for undefined input",
                "line": 377,
                "source": "expect(random.weightedChoice()).toBeUndefined()"
              },
              {
                "title": "works with single choice",
                "line": 382,
                "source": "const choices = [{value: 'only', weight: 1}]\nexpect(random.weightedChoice(choices)).toBe('only')"
              }
            ],
            "describes": []
          },
          {
            "title": "generateSeed",
            "line": 390,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns string of default length 10",
                "line": 392,
                "source": "const seed = Random.generateSeed()\nexpect(typeof seed).toBe('string')\nexpect(seed.length).toBe(10)"
              },
              {
                "title": "respects custom length",
                "line": 399,
                "source": "const customLengthSeed = Random.generateSeed(15)\nexpect(customLengthSeed.length).toBe(15)"
              },
              {
                "title": "generates different seeds",
                "line": 405,
                "source": "const seed1 = Random.generateSeed()\nconst seed2 = Random.generateSeed()\nexpect(seed1).not.toEqual(seed2)"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/math/vec2.doc.js": {
    "file": "/math/vec2.test.js",
    "describes": [
      {
        "title": "Vec2",
        "line": 4,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "isVector2",
            "line": 571,
            "source": "const vec = new Vec2()\nexpect(vec.isVector2).toBe(true)"
          }
        ],
        "describes": [
          {
            "title": "constructor",
            "line": 6,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "with x and y",
                "line": 8,
                "source": "const vec = new Vec2(1, 2)\nexpect(vec.x).toBe(1)\nexpect(vec.y).toBe(2)"
              },
              {
                "title": "with object",
                "line": 14,
                "source": "const vec = new Vec2({x: 3, y: 4})\nexpect(vec.x).toBe(3)\nexpect(vec.y).toBe(4)"
              },
              {
                "title": "with array",
                "line": 20,
                "source": "const vec = new Vec2([7, 8])\nexpect(vec.x).toBe(7)\nexpect(vec.y).toBe(8)"
              },
              {
                "title": "with no parameters",
                "line": 26,
                "source": "const vec = new Vec2()\nexpect(vec.x).toBe(0)\nexpect(vec.y).toBe(0)"
              },
              {
                "title": "with only x",
                "line": 32,
                "source": "const vec = new Vec2(5)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(0)"
              }
            ],
            "describes": []
          },
          {
            "title": "setters",
            "line": 41,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "set",
                "line": 43,
                "source": "const vec = new Vec2()\nexpect(vec.set(3, 4)).toBe(vec)\nexpect(vec.x).toBe(3)\nexpect(vec.y).toBe(4)"
              },
              {
                "title": "setX",
                "line": 50,
                "source": "const vec = new Vec2(1, 2)\nexpect(vec.setX(5)).toBe(vec)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(2)"
              },
              {
                "title": "setY",
                "line": 57,
                "source": "const vec = new Vec2(1, 2)\nexpect(vec.setY(6)).toBe(vec)\nexpect(vec.x).toBe(1)\nexpect(vec.y).toBe(6)"
              },
              {
                "title": "setScalar",
                "line": 64,
                "source": "const vec = new Vec2()\nexpect(vec.setScalar(7)).toBe(vec)\nexpect(vec.x).toBe(7)\nexpect(vec.y).toBe(7)"
              },
              {
                "title": "setComponent",
                "line": 71,
                "source": "const vec = new Vec2(1, 2)\nexpect(vec.setComponent(0, 10)).toBe(vec)\nexpect(vec.x).toBe(10)\nexpect(vec.setComponent(1, 20)).toBe(vec)\nexpect(vec.y).toBe(20)"
              },
              {
                "title": "setComponent throws on invalid index",
                "line": 79,
                "source": "const vec = new Vec2()\nexpect(() => {\n    vec.setComponent(2, 5)\n}).toThrow('index out of range: 2')"
              }
            ],
            "describes": []
          },
          {
            "title": "copy and clone",
            "line": 89,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "copy",
                "line": 91,
                "source": "const vec1 = new Vec2(1, 2)\nconst vec2 = new Vec2(3, 4)\nexpect(vec1.copy(vec2)).toBe(vec1)\nexpect(vec1.x).toBe(3)\nexpect(vec1.y).toBe(4)"
              },
              {
                "title": "clone",
                "line": 99,
                "source": "const vec1 = new Vec2(5, 6)\nconst vec2 = vec1.clone()\nexpect(vec2).not.toBe(vec1)\nexpect(vec2.x).toBe(5)\nexpect(vec2.y).toBe(6)"
              }
            ],
            "describes": []
          },
          {
            "title": "addition",
            "line": 110,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "add",
                "line": 112,
                "source": "const vec = new Vec2(1, 2)\nexpect(vec.add(new Vec2(3, 4))).toBe(vec)\nexpect(vec.x).toBe(4)\nexpect(vec.y).toBe(6)"
              },
              {
                "title": "addScalar",
                "line": 119,
                "source": "const vec = new Vec2(1, 2)\nexpect(vec.addScalar(5)).toBe(vec)\nexpect(vec.x).toBe(6)\nexpect(vec.y).toBe(7)"
              },
              {
                "title": "addVectors",
                "line": 126,
                "source": "const vec = new Vec2()\nexpect(vec.addVectors(new Vec2(1, 2), new Vec2(3, 4))).toBe(vec)\nexpect(vec.x).toBe(4)\nexpect(vec.y).toBe(6)"
              },
              {
                "title": "addScaledVector",
                "line": 133,
                "source": "const vec = new Vec2(1, 2)\nexpect(vec.addScaledVector(new Vec2(2, 3), 2)).toBe(vec)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(8)"
              }
            ],
            "describes": []
          },
          {
            "title": "subtraction",
            "line": 143,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "sub",
                "line": 145,
                "source": "const vec = new Vec2(5, 7)\nexpect(vec.sub(new Vec2(2, 3))).toBe(vec)\nexpect(vec.x).toBe(3)\nexpect(vec.y).toBe(4)"
              },
              {
                "title": "subScalar",
                "line": 152,
                "source": "const vec = new Vec2(10, 20)\nexpect(vec.subScalar(5)).toBe(vec)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(15)"
              },
              {
                "title": "subVectors",
                "line": 159,
                "source": "const vec = new Vec2()\nexpect(vec.subVectors(new Vec2(8, 10), new Vec2(3, 4))).toBe(vec)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(6)"
              }
            ],
            "describes": []
          },
          {
            "title": "multiplication",
            "line": 169,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "multiply",
                "line": 171,
                "source": "const vec = new Vec2(2, 3)\nexpect(vec.multiply(new Vec2(4, 5))).toBe(vec)\nexpect(vec.x).toBe(8)\nexpect(vec.y).toBe(15)"
              },
              {
                "title": "multiplyScalar",
                "line": 178,
                "source": "const vec = new Vec2(3, 4)\nexpect(vec.multiplyScalar(2)).toBe(vec)\nexpect(vec.x).toBe(6)\nexpect(vec.y).toBe(8)"
              }
            ],
            "describes": []
          },
          {
            "title": "division",
            "line": 188,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "divide",
                "line": 190,
                "source": "const vec = new Vec2(12, 20)\nexpect(vec.divide(new Vec2(3, 4))).toBe(vec)\nexpect(vec.x).toBe(4)\nexpect(vec.y).toBe(5)"
              },
              {
                "title": "divideScalar",
                "line": 197,
                "source": "const vec = new Vec2(10, 20)\nexpect(vec.divideScalar(2)).toBe(vec)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(10)"
              }
            ],
            "describes": []
          },
          {
            "title": "vector operations",
            "line": 207,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "dot",
                "line": 209,
                "source": "const vec1 = new Vec2(2, 3)\nconst vec2 = new Vec2(4, 5)\nexpect(vec1.dot(vec2)).toBe(23)"
              },
              {
                "title": "cross",
                "line": 215,
                "source": "const vec1 = new Vec2(2, 3)\nconst vec2 = new Vec2(4, 5)\nexpect(vec1.cross(vec2)).toBe(-2)"
              },
              {
                "title": "lengthSq",
                "line": 221,
                "source": "const vec = new Vec2(3, 4)\nexpect(vec.lengthSq()).toBe(25)"
              },
              {
                "title": "length",
                "line": 226,
                "source": "const vec = new Vec2(3, 4)\nexpect(vec.length()).toBe(5)"
              },
              {
                "title": "manhattanLength",
                "line": 231,
                "source": "const vec = new Vec2(3, -4)\nexpect(vec.manhattanLength()).toBe(7)"
              },
              {
                "title": "normalize",
                "line": 236,
                "source": "const vec = new Vec2(3, 4)\nexpect(vec.normalize()).toBe(vec)\nexpect(vec.x).toBeCloseTo(0.6)\nexpect(vec.y).toBeCloseTo(0.8)\nexpect(vec.length()).toBeCloseTo(1)"
              },
              {
                "title": "normalize zero vector",
                "line": 244,
                "source": "const vec = new Vec2(0, 0)\nexpect(vec.normalize()).toBe(vec)\nexpect(vec.x).toBe(0)\nexpect(vec.y).toBe(0)"
              },
              {
                "title": "setLength",
                "line": 251,
                "source": "const vec = new Vec2(3, 4)\nexpect(vec.setLength(10)).toBe(vec)\nexpect(vec.length()).toBeCloseTo(10)\nexpect(vec.x).toBeCloseTo(6)\nexpect(vec.y).toBeCloseTo(8)"
              }
            ],
            "describes": []
          },
          {
            "title": "angles",
            "line": 262,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "angle",
                "line": 264,
                "source": "const vec = new Vec2(1, 0)\nexpect(vec.angle()).toBeCloseTo(0)\nconst vec2 = new Vec2(0, 1)\nexpect(vec2.angle()).toBeCloseTo(Math.PI / 2)"
              },
              {
                "title": "angleTo",
                "line": 271,
                "source": "const vec1 = new Vec2(1, 0)\nconst vec2 = new Vec2(0, 1)\nexpect(vec1.angleTo(vec2)).toBeCloseTo(Math.PI / 2)"
              },
              {
                "title": "angleTo parallel vectors",
                "line": 277,
                "source": "const vec1 = new Vec2(1, 0)\nconst vec2 = new Vec2(2, 0)\nexpect(vec1.angleTo(vec2)).toBeCloseTo(0)"
              }
            ],
            "describes": []
          },
          {
            "title": "distance",
            "line": 286,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "distanceTo",
                "line": 288,
                "source": "const vec1 = new Vec2(1, 2)\nconst vec2 = new Vec2(4, 6)\nexpect(vec1.distanceTo(vec2)).toBe(5)"
              },
              {
                "title": "distanceToSquared",
                "line": 294,
                "source": "const vec1 = new Vec2(1, 2)\nconst vec2 = new Vec2(4, 6)\nexpect(vec1.distanceToSquared(vec2)).toBe(25)"
              },
              {
                "title": "manhattanDistanceTo",
                "line": 300,
                "source": "const vec1 = new Vec2(1, 2)\nconst vec2 = new Vec2(4, 6)\nexpect(vec1.manhattanDistanceTo(vec2)).toBe(7)"
              }
            ],
            "describes": []
          },
          {
            "title": "interpolation",
            "line": 309,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "lerp",
                "line": 311,
                "source": "const vec = new Vec2(0, 0)\nexpect(vec.lerp(new Vec2(10, 20), 0.5)).toBe(vec)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(10)"
              },
              {
                "title": "lerp at 0",
                "line": 318,
                "source": "const vec = new Vec2(1, 2)\nvec.lerp(new Vec2(10, 20), 0)\nexpect(vec.x).toBe(1)\nexpect(vec.y).toBe(2)"
              },
              {
                "title": "lerp at 1",
                "line": 325,
                "source": "const vec = new Vec2(1, 2)\nvec.lerp(new Vec2(10, 20), 1)\nexpect(vec.x).toBe(10)\nexpect(vec.y).toBe(20)"
              },
              {
                "title": "lerpVectors",
                "line": 332,
                "source": "const vec = new Vec2()\nexpect(vec.lerpVectors(new Vec2(0, 0), new Vec2(10, 20), 0.5)).toBe(vec)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(10)"
              }
            ],
            "describes": []
          },
          {
            "title": "comparison",
            "line": 342,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "equals with Vec2",
                "line": 344,
                "source": "const vec1 = new Vec2(1, 2)\nconst vec2 = new Vec2(1, 2)\nconst vec3 = new Vec2(3, 4)\nexpect(vec1.equals(vec2)).toBe(true)\nexpect(vec1.equals(vec3)).toBe(false)"
              },
              {
                "title": "equals with object",
                "line": 352,
                "source": "const vec1 = new Vec2(1, 2)\nconst vec4 = {x: 1, y: 2, z: 0}\nexpect(vec1.equals(vec4)).toBe(true)"
              }
            ],
            "describes": []
          },
          {
            "title": "array conversion",
            "line": 361,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "fromArray",
                "line": 363,
                "source": "const vec = new Vec2()\nexpect(vec.fromArray([5, 6])).toBe(vec)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(6)"
              },
              {
                "title": "fromArray with offset",
                "line": 370,
                "source": "const vec = new Vec2()\nvec.fromArray([1, 2, 3, 4], 2)\nexpect(vec.x).toBe(3)\nexpect(vec.y).toBe(4)"
              },
              {
                "title": "toArray",
                "line": 377,
                "source": "const vec = new Vec2(7, 8)\nconst arr = vec.toArray()\nexpect(arr).toEqual([7, 8])"
              },
              {
                "title": "toArray with existing array",
                "line": 383,
                "source": "const vec = new Vec2(9, 10)\nconst arr = [1, 2, 3, 4]\nexpect(vec.toArray(arr, 2)).toBe(arr)\nexpect(arr).toEqual([1, 2, 9, 10])"
              }
            ],
            "describes": []
          },
          {
            "title": "negation and min/max",
            "line": 393,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "negate",
                "line": 395,
                "source": "const vec = new Vec2(3, -4)\nexpect(vec.negate()).toBe(vec)\nexpect(vec.x).toBe(-3)\nexpect(vec.y).toBe(4)"
              },
              {
                "title": "min",
                "line": 402,
                "source": "const vec = new Vec2(5, 2)\nexpect(vec.min(new Vec2(3, 4))).toBe(vec)\nexpect(vec.x).toBe(3)\nexpect(vec.y).toBe(2)"
              },
              {
                "title": "max",
                "line": 409,
                "source": "const vec = new Vec2(5, 2)\nexpect(vec.max(new Vec2(3, 4))).toBe(vec)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(4)"
              }
            ],
            "describes": []
          },
          {
            "title": "clamping",
            "line": 419,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "clamp",
                "line": 421,
                "source": "const vec = new Vec2(15, -5)\nexpect(vec.clamp(new Vec2(0, 0), new Vec2(10, 10))).toBe(vec)\nexpect(vec.x).toBe(10)\nexpect(vec.y).toBe(0)"
              },
              {
                "title": "clampScalar",
                "line": 428,
                "source": "const vec = new Vec2(15, -5)\nexpect(vec.clampScalar(0, 10)).toBe(vec)\nexpect(vec.x).toBe(10)\nexpect(vec.y).toBe(0)"
              },
              {
                "title": "clampLength min",
                "line": 435,
                "source": "const vec = new Vec2(1, 0)\nvec.clampLength(5, 10)\nexpect(vec.length()).toBeCloseTo(5)"
              },
              {
                "title": "clampLength max",
                "line": 441,
                "source": "const vec = new Vec2(20, 0)\nvec.clampLength(5, 10)\nexpect(vec.length()).toBeCloseTo(10)"
              },
              {
                "title": "clampLength in range",
                "line": 447,
                "source": "const vec = new Vec2(7, 0)\nvec.clampLength(5, 10)\nexpect(vec.length()).toBeCloseTo(7)"
              }
            ],
            "describes": []
          },
          {
            "title": "rounding",
            "line": 456,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "floor",
                "line": 458,
                "source": "const vec = new Vec2(1.7, 2.3)\nexpect(vec.floor()).toBe(vec)\nexpect(vec.x).toBe(1)\nexpect(vec.y).toBe(2)"
              },
              {
                "title": "ceil",
                "line": 465,
                "source": "const vec = new Vec2(1.3, 2.7)\nexpect(vec.ceil()).toBe(vec)\nexpect(vec.x).toBe(2)\nexpect(vec.y).toBe(3)"
              },
              {
                "title": "round",
                "line": 472,
                "source": "const vec = new Vec2(1.4, 2.6)\nexpect(vec.round()).toBe(vec)\nexpect(vec.x).toBe(1)\nexpect(vec.y).toBe(3)"
              },
              {
                "title": "roundToZero positive",
                "line": 479,
                "source": "const vec = new Vec2(1.9, 2.9)\nexpect(vec.roundToZero()).toBe(vec)\nexpect(vec.x).toBe(1)\nexpect(vec.y).toBe(2)"
              },
              {
                "title": "roundToZero negative",
                "line": 486,
                "source": "const vec = new Vec2(-1.9, -2.9)\nvec.roundToZero()\nexpect(vec.x).toBe(-1)\nexpect(vec.y).toBe(-2)"
              }
            ],
            "describes": []
          },
          {
            "title": "rotation",
            "line": 496,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "rotateAround",
                "line": 498,
                "source": "const vec = new Vec2(1, 0)\nconst center = new Vec2(0, 0)\nexpect(vec.rotateAround(center, Math.PI / 2)).toBe(vec)\nexpect(vec.x).toBeCloseTo(0)\nexpect(vec.y).toBeCloseTo(1)"
              },
              {
                "title": "rotateAround with offset center",
                "line": 506,
                "source": "const vec = new Vec2(2, 1)\nconst center = new Vec2(1, 1)\nvec.rotateAround(center, Math.PI / 2)\nexpect(vec.x).toBeCloseTo(1)\nexpect(vec.y).toBeCloseTo(2)"
              }
            ],
            "describes": []
          },
          {
            "title": "random and component access",
            "line": 517,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "random",
                "line": 519,
                "source": "const vec = new Vec2()\nexpect(vec.random()).toBe(vec)\nexpect(vec.x).toBeGreaterThanOrEqual(0)\nexpect(vec.x).toBeLessThan(1)\nexpect(vec.y).toBeGreaterThanOrEqual(0)\nexpect(vec.y).toBeLessThan(1)"
              },
              {
                "title": "getComponent",
                "line": 528,
                "source": "const vec = new Vec2(5, 7)\nexpect(vec.getComponent(0)).toBe(5)\nexpect(vec.getComponent(1)).toBe(7)"
              },
              {
                "title": "getComponent throws on invalid index",
                "line": 534,
                "source": "const vec = new Vec2()\nexpect(() => {\n    vec.getComponent(2)\n}).toThrow('index out of range: 2')"
              }
            ],
            "describes": []
          },
          {
            "title": "aliases",
            "line": 544,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "width getter",
                "line": 546,
                "source": "const vec = new Vec2(10, 20)\nexpect(vec.width).toBe(10)"
              },
              {
                "title": "width setter",
                "line": 551,
                "source": "const vec = new Vec2()\nvec.width = 15\nexpect(vec.x).toBe(15)"
              },
              {
                "title": "height getter",
                "line": 557,
                "source": "const vec = new Vec2(10, 20)\nexpect(vec.height).toBe(20)"
              },
              {
                "title": "height setter",
                "line": 562,
                "source": "const vec = new Vec2()\nvec.height = 25\nexpect(vec.y).toBe(25)"
              }
            ],
            "describes": []
          },
          {
            "title": "iteration",
            "line": 577,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "iterator",
                "line": 579,
                "source": "const vec = new Vec2(3, 4)\nconst [x, y] = vec\nexpect(x).toBe(3)\nexpect(y).toBe(4)"
              },
              {
                "title": "spread operator",
                "line": 586,
                "source": "const vec = new Vec2(5, 6)\nconst arr = [...vec]\nexpect(arr).toEqual([5, 6])"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/render/webgl_canvas_2d.doc.js": {
    "file": "/render/webgl_canvas_2d.test.js",
    "describes": [
      {
        "title": "WebGLCanvas2D",
        "line": 12,
        "beforeEach": {
          "line": 17,
          "source": "canvas = document.createElement('canvas')\ncanvas.width = 800\ncanvas.height = 600\nrenderer = new WebGLCanvas2D({canvas})"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "setPixelRatio updates viewport on pixel ratio change",
            "line": 276,
            "source": "expect(() => renderer.setPixelRatio(2)).not.toThrow()"
          },
          {
            "title": "dispose cleans up resources",
            "line": 281,
            "source": "renderer.dispose()\n\nexpect(renderer.gl).toBe(null)\nexpect(renderer.canvas).toBe(null)"
          }
        ],
        "describes": [
          {
            "title": "constructor",
            "line": 25,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "uses provided canvas",
                "line": 27,
                "source": "expect(renderer.canvas).toBe(canvas)"
              },
              {
                "title": "gets WebGL context",
                "line": 32,
                "source": "expect(renderer.gl).toBeDefined()"
              },
              {
                "title": "initializes camera",
                "line": 37,
                "source": "expect(renderer.camera).toBeInstanceOf(Camera2D)"
              },
              {
                "title": "has static $name",
                "line": 42,
                "source": "expect(WebGLCanvas2D.$name).toBe('webGLCanvas2D')"
              },
              {
                "title": "with provided camera",
                "line": 47,
                "source": "const camera = new Camera2D({x: 10, y: 20})\nconst r = new WebGLCanvas2D({canvas, camera})\nexpect(r.camera).toBe(camera)"
              },
              {
                "title": "with backgroundColor",
                "line": 54,
                "source": "const r = new WebGLCanvas2D({canvas, backgroundColor: '#FF0000'})\nexpect(r.backgroundColor).toBe('#FF0000')"
              },
              {
                "title": "with enableCulling",
                "line": 60,
                "source": "const r = new WebGLCanvas2D({canvas, enableCulling: true})\nexpect(r.enableCulling).toBe(true)"
              },
              {
                "title": "initializes stats",
                "line": 66,
                "source": "expect(renderer.stats).toBeDefined()\nexpect(renderer.stats.totalObjects).toBe(0)\nexpect(renderer.stats.renderedObjects).toBe(0)\nexpect(renderer.stats.culledObjects).toBe(0)"
              }
            ],
            "describes": []
          },
          {
            "title": "shaderRegistry",
            "line": 76,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "has shaderRegistry accessor",
                "line": 78,
                "source": "expect(renderer.shaderRegistry).toBeDefined()"
              },
              {
                "title": "can register custom shaders",
                "line": 83,
                "source": "const definition = {\n    vertex: 'void main() {}',\n    fragment: 'void main() {}',\n    uniforms: [],\n    attributes: []\n}\n\nconst program = renderer.registerShader('custom', definition)\nexpect(program).toBeDefined()"
              },
              {
                "title": "can get registered shader",
                "line": 96,
                "source": "const definition = {\n    vertex: 'void main() {}',\n    fragment: 'void main() {}',\n    uniforms: [],\n    attributes: []\n}\n\nrenderer.registerShader('test', definition)\nconst shader = renderer.getShader('test')\nexpect(shader).toBeDefined()"
              }
            ],
            "describes": []
          },
          {
            "title": "shaderEffectRegistry",
            "line": 112,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "has shaderEffectRegistry accessor",
                "line": 114,
                "source": "expect(renderer.shaderEffectRegistry).toBeDefined()"
              },
              {
                "title": "registerShaderEffect registers an effect class",
                "line": 119,
                "source": "class TestEffect {\n    static shader = {\n        params: [],\n        uniforms: [],\n        fragment: ''\n    }\n}\n\nexpect(() => renderer.registerShaderEffect(TestEffect)).not.toThrow()\nexpect(renderer.shaderEffectRegistry.has('TestEffect')).toBe(true)"
              },
              {
                "title": "setUniform stores uniform value",
                "line": 133,
                "source": "renderer.setUniform('uTime', 1.5)\nexpect(renderer.getUniform('uTime')).toBe(1.5)"
              },
              {
                "title": "setUniform with type stores uniform value and type",
                "line": 139,
                "source": "renderer.setUniform('uResolution', [800, 600], 'vec2')\nexpect(renderer.getUniform('uResolution')).toEqual([800, 600])"
              },
              {
                "title": "setUniform returns this for chaining",
                "line": 145,
                "source": "const result = renderer.setUniform('uTime', 1.0)\nexpect(result).toBe(renderer)"
              },
              {
                "title": "getUniform returns undefined for unknown uniform",
                "line": 151,
                "source": "expect(renderer.getUniform('uUnknown')).toBeUndefined()"
              }
            ],
            "describes": []
          },
          {
            "title": "postProcessor",
            "line": 158,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "has postProcessor accessor",
                "line": 160,
                "source": "expect(renderer.postProcessor).toBeDefined()"
              },
              {
                "title": "can add post pass",
                "line": 165,
                "source": "const mockPass = {\n    init: vi.fn(),\n    getShaderDefinition: () => ({\n        vertex: 'void main() {}',\n        fragment: 'void main() {}',\n        uniforms: [],\n        attributes: []\n    }),\n    enabled: true,\n    render: vi.fn(),\n    dispose: vi.fn()\n}\n\nrenderer.addPostPass(mockPass)\nexpect(renderer.postProcessor.passes.length).toBe(1)"
              },
              {
                "title": "can remove post pass",
                "line": 184,
                "source": "const mockPass = {\n    init: vi.fn(),\n    getShaderDefinition: () => ({\n        vertex: 'void main() {}',\n        fragment: 'void main() {}',\n        uniforms: [],\n        attributes: []\n    }),\n    enabled: true,\n    render: vi.fn(),\n    dispose: vi.fn()\n}\n\nrenderer.addPostPass(mockPass)\nrenderer.removePostPass(mockPass)\nexpect(renderer.postProcessor.passes.length).toBe(0)"
              }
            ],
            "describes": []
          },
          {
            "title": "render",
            "line": 206,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "renders empty scene without error",
                "line": 208,
                "source": "const scene = new Group2D()\nexpect(() => renderer.render(scene)).not.toThrow()"
              },
              {
                "title": "clears the canvas",
                "line": 214,
                "source": "const scene = new Group2D()\nexpect(() => renderer.render(scene)).not.toThrow()"
              },
              {
                "title": "updates world matrix",
                "line": 220,
                "source": "const scene = new Group2D()\nvi.spyOn(scene, 'updateWorldMatrix')\n\nrenderer.render(scene)\n\nexpect(scene.updateWorldMatrix).toHaveBeenCalledWith(false)"
              },
              {
                "title": "renders circle",
                "line": 230,
                "source": "const scene = new Group2D()\nconst circle = new Circle({radius: 1, color: '#FF0000'})\nscene.addChild(circle)\n\nexpect(() => renderer.render(scene)).not.toThrow()"
              },
              {
                "title": "renders rectangle",
                "line": 239,
                "source": "const scene = new Group2D()\nconst rect = new Rectangle({width: 2, height: 1, color: '#00FF00'})\nscene.addChild(rect)\n\nexpect(() => renderer.render(scene)).not.toThrow()"
              },
              {
                "title": "skips invisible objects",
                "line": 248,
                "source": "const scene = new Group2D()\nconst circle = new Circle({radius: 1, color: '#FF0000', visible: false})\nscene.addChild(circle)\n\nrenderer.render(scene)\nexpect(renderer.stats.totalObjects).toBe(1)"
              },
              {
                "title": "applies opacity inheritance",
                "line": 258,
                "source": "const scene = new Group2D({opacity: 0.5})\nconst circle = new Circle({radius: 1, color: '#FF0000', opacity: 0.5})\nscene.addChild(circle)\n\nexpect(() => renderer.render(scene)).not.toThrow()"
              },
              {
                "title": "renders with background color",
                "line": 267,
                "source": "renderer.backgroundColor = '#0000FF'\nconst scene = new Group2D()\nexpect(() => renderer.render(scene)).not.toThrow()"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  }
}