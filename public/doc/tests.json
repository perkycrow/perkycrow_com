{
  "/core/perky_module.doc.js": {
    "file": "/core/perky_module.test.js",
    "describes": [
      {
        "title": "PerkyModule",
        "line": 6,
        "beforeEach": {
          "line": 11,
          "source": "const childrenRegistry = new Registry()\nhost = {\n    started: false,\n    on: vi.fn(),\n    emit: vi.fn(),\n    childrenRegistry: childrenRegistry,\n    hasChild: vi.fn((name) => childrenRegistry.has(name)),\n    getChild: vi.fn((name) => childrenRegistry.get(name))\n}\n\nchild = new PerkyModule({$id: 'testChild'})"
        },
        "afterEach": {
          "line": 26,
          "source": "vi.restoreAllMocks()"
        },
        "tests": [
          {
            "title": "constructor",
            "line": 31,
            "source": "expect(child).toBeInstanceOf(PerkyModule)\nexpect(child.$id).toBe('testChild')\nexpect(child.options).toEqual({$id: 'testChild'})\nexpect(child.host).toBeNull()\nexpect(child.installed).toBe(false)"
          },
          {
            "title": "constructor with default name",
            "line": 40,
            "source": "class TestChild extends PerkyModule { }\nconst ext = new TestChild()\nexpect(ext.$id).toBe('TestChild')"
          },
          {
            "title": "install",
            "line": 47,
            "source": "const result = child.install(host, {})\n\nexpect(result).toBe(true)\nexpect(child.host).toBe(host)\nexpect(child.installed).toBe(true)"
          },
          {
            "title": "uninstall",
            "line": 56,
            "source": "child.install(host, {})\nconst result = child.uninstall()\n\nexpect(result).toBe(true)\nexpect(child.host).toBeNull()\nexpect(child.installed).toBe(false)"
          },
          {
            "title": "uninstall when not installed",
            "line": 66,
            "source": "const result = child.uninstall()\nexpect(result).toBe(false)"
          },
          {
            "title": "use with Child class",
            "line": 72,
            "source": "class TestChild extends PerkyModule { }\n\nconst result = child.create(TestChild, {\n    $id: 'test',\n    $category: 'test'\n})\n\nexpect(result).toBeInstanceOf(TestChild)\nexpect(result).toBe(child.getChild('test'))\nexpect(child.hasChild('test')).toBe(true)"
          },
          {
            "title": "auto-generates unique IDs when $id not provided",
            "line": 86,
            "source": "class Enemy extends PerkyModule { }\n\nconst enemy1 = child.create(Enemy, {$category: 'enemy'})\nconst enemy2 = child.create(Enemy, {$category: 'enemy'})\nconst enemy3 = child.create(Enemy, {$category: 'enemy'})\n\nexpect(child.hasChild('enemy')).toBe(true)\nexpect(child.getChild('enemy')).toBe(enemy1)\n\nexpect(child.hasChild('enemy_1')).toBe(true)\nexpect(child.getChild('enemy_1')).toBe(enemy2)\n\nexpect(child.hasChild('enemy_2')).toBe(true)\nexpect(child.getChild('enemy_2')).toBe(enemy3)"
          },
          {
            "title": "explicit $id creates single instance (replacement)",
            "line": 104,
            "source": "class Player extends PerkyModule { }\n\nconst player1 = child.create(Player, {\n    $id: 'player',\n    $category: 'player'\n})\n\nconst player2 = child.create(Player, {\n    $id: 'player',\n    $category: 'player'\n})\n\nexpect(child.hasChild('player')).toBe(true)\nexpect(child.getChild('player')).toBe(player2)\nexpect(child.getChild('player')).not.toBe(player1)\n\nexpect(child.hasChild('player_1')).toBe(false)"
          },
          {
            "title": "unique IDs work with different categories",
            "line": 125,
            "source": "class Enemy extends PerkyModule { }\nclass Projectile extends PerkyModule { }\n\nconst enemy1 = child.create(Enemy, {$category: 'enemy'})\nconst enemy1Name = child.childrenRegistry.keyFor(enemy1)\n\nconst projectile1 = child.create(Projectile, {$category: 'projectile'})\nconst projectile1Name = child.childrenRegistry.keyFor(projectile1)\n\nconst enemy2 = child.create(Enemy, {$category: 'enemy'})\nconst enemy2Name = child.childrenRegistry.keyFor(enemy2)\n\nconst projectile2 = child.create(Projectile, {$category: 'projectile'})\nconst projectile2Name = child.childrenRegistry.keyFor(projectile2)\n\nexpect(child.hasChild(enemy1Name)).toBe(true)\nexpect(child.hasChild(enemy2Name)).toBe(true)\nexpect(child.hasChild(projectile1Name)).toBe(true)\nexpect(child.hasChild(projectile2Name)).toBe(true)\n\nexpect(enemy1).not.toBe(enemy2)\nexpect(projectile1).not.toBe(projectile2)"
          },
          {
            "title": "listNamesFor - single category",
            "line": 302,
            "source": "class TestChild1 extends PerkyModule { }\nclass TestChild2 extends PerkyModule { }\n\nchild.create(TestChild1, {\n    $id: 'ext1',\n    $category: 'module'\n})\n\nchild.create(TestChild2, {\n    $id: 'ext2',\n    $category: 'module'\n})\n\nconst modules = child.listNamesFor('module')\n\nexpect(modules).toHaveLength(2)\nexpect(modules).toContain('ext1')\nexpect(modules).toContain('ext2')"
          },
          {
            "title": "listNamesFor - mixed categories",
            "line": 324,
            "source": "class TestChild1 extends PerkyModule { }\nclass TestChild2 extends PerkyModule { }\nclass TestChild3 extends PerkyModule { }\n\nchild.create(TestChild1, {\n    $id: 'ext1',\n    $category: 'module'\n})\n\nchild.create(TestChild2, {\n    $id: 'ext2',\n    $category: 'service'\n})\n\nchild.create(TestChild3, {\n    $id: 'ext3',\n    $category: 'module'\n})\n\nconst modules = child.listNamesFor('module')\nconst services = child.listNamesFor('service')\n\nexpect(modules).toHaveLength(2)\nexpect(modules).toContain('ext1')\nexpect(modules).toContain('ext3')\n\nexpect(services).toHaveLength(1)\nexpect(services).toContain('ext2')"
          },
          {
            "title": "listNamesFor - empty category",
            "line": 356,
            "source": "const parent = new PerkyModule()\n\nparent.create(PerkyModule, {$category: 'module'})\nparent.create(PerkyModule, {$category: 'module'})\n\nconst services = parent.listNamesFor('service')\nexpect(services).toEqual([])"
          },
          {
            "title": "listNamesFor - dynamic category update",
            "line": 367,
            "source": "const parent = new PerkyModule()\n\nconst childA = parent.create(PerkyModule, {$id: 'childA', $category: 'module'})\nparent.create(PerkyModule, {$id: 'childB', $category: 'service'})\n\nexpect(parent.listNamesFor('module')).toEqual(['childA'])\nexpect(parent.listNamesFor('service')).toEqual(['childB'])\n\nchildA.$category = 'service'\n\nexpect(parent.listNamesFor('module')).toEqual([])\nconst serviceChildren = parent.listNamesFor('service')\nexpect(serviceChildren).toHaveLength(2)\nexpect(serviceChildren).toContain('childA')\nexpect(serviceChildren).toContain('childB')"
          },
          {
            "title": "category index is automatically created",
            "line": 386,
            "source": "const registry = child.childrenRegistry\n\nexpect(registry.hasIndex('$category')).toBe(true)"
          },
          {
            "title": "category index is updated when children are added",
            "line": 393,
            "source": "class TestChild extends PerkyModule { }\nconst registry = child.childrenRegistry\n\nchild.create(TestChild, {\n    $id: 'ext1',\n    $category: 'module'\n})\n\nchild.create(TestChild, {\n    $id: 'ext2',\n    $category: 'service'\n})\n\nconst moduleChildren = registry.lookup('$category', 'module')\nconst serviceChildren = registry.lookup('$category', 'service')\n\nexpect(moduleChildren).toHaveLength(1)\nexpect(serviceChildren).toHaveLength(1)\nexpect(moduleChildren[0]).toBe(child.getChild('ext1'))\nexpect(serviceChildren[0]).toBe(child.getChild('ext2'))"
          },
          {
            "title": "category index is updated when children are removed",
            "line": 417,
            "source": "class TestChild extends PerkyModule { }\nconst registry = child.childrenRegistry\n\nchild.create(TestChild, {\n    $id: 'ext1',\n    $category: 'module'\n})\n\nchild.create(TestChild, {\n    $id: 'ext2',\n    $category: 'module'\n})\n\nlet moduleChildren = registry.lookup('$category', 'module')\nexpect(moduleChildren).toHaveLength(2)\n\nchild.removeChild('ext1')\n\nmoduleChildren = registry.lookup('$category', 'module')\nexpect(moduleChildren).toHaveLength(1)\nexpect(moduleChildren[0]).toBe(child.getChild('ext2'))"
          },
          {
            "title": "registry key is updated when child name changes",
            "line": 442,
            "source": "const parent = new PerkyModule()\n\nconst childModule = parent.create(PerkyModule, {\n    $id: 'oldName',\n    $category: 'module'\n})\n\nexpect(parent.hasChild('oldName')).toBe(true)\nexpect(parent.getChild('oldName')).toBe(childModule)\n\nchildModule.$id = 'newName'\n\nexpect(parent.hasChild('oldName')).toBe(false)\nexpect(parent.hasChild('newName')).toBe(true)\nexpect(parent.getChild('newName')).toBe(childModule)"
          },
          {
            "title": "use with binding",
            "line": 461,
            "source": "class TestChild extends PerkyModule { }\n\nchild.create(TestChild, {\n    $id: 'test',\n    $bind: 'testProperty'\n})\n\nexpect(child.testProperty).toBeInstanceOf(TestChild)"
          },
          {
            "title": "binding updates automatically when $bind changes",
            "line": 473,
            "source": "class TestChild extends PerkyModule { }\n\nconst testChild = child.create(TestChild, {\n    $id: 'test',\n    $bind: 'oldProperty'\n})\n\nexpect(child.oldProperty).toBe(testChild)\nexpect(child.newProperty).toBeUndefined()\n\ntestChild.$bind = 'newProperty'\n\nexpect(child.oldProperty).toBeUndefined()\nexpect(child.newProperty).toBe(testChild)"
          },
          {
            "title": "use with lifecycle disabled",
            "line": 491,
            "source": "class TestChild extends PerkyModule { }\nconst startSpy = vi.spyOn(TestChild.prototype, 'start')\n\nchild.create(TestChild, {\n    $id: 'test',\n    $lifecycle: false\n})\n\nchild.start()\n\nexpect(startSpy).not.toHaveBeenCalled()"
          },
          {
            "title": "use emits registration events",
            "line": 506,
            "source": "class TestChild extends PerkyModule { }\nconst emitSpy = vi.spyOn(child, 'emit')\n\nconst granchild = child.create(TestChild, {\n    $id: 'test',\n    $category: 'testCategory'\n})\n\nexpect(emitSpy).toHaveBeenCalledWith('testCategory:set', 'test', granchild)"
          },
          {
            "title": "removeChild",
            "line": 519,
            "source": "class TestChild extends PerkyModule { }\n\nconst instance = child.create(TestChild, {\n    $id: 'test',\n    $category: 'test'\n})\n\nconst uninstallSpy = vi.spyOn(instance, 'uninstall')\nconst disposeSpy = vi.spyOn(instance, 'dispose')\n\n\nconst result = child.removeChild('test')\n\nexpect(result).toBe(true)\nexpect(uninstallSpy).toHaveBeenCalled()\nexpect(disposeSpy).toHaveBeenCalled()"
          },
          {
            "title": "removeChild non-existent",
            "line": 539,
            "source": "const result = child.removeChild('nonexistent')\nexpect(result).toBe(false)"
          },
          {
            "title": "lifecycle cascade",
            "line": 545,
            "source": "class ChildChild extends PerkyModule { }\nnew ChildChild()\n\nconst childChild = child.create(ChildChild, {\n    $id: 'default',\n    $lifecycle: true\n})\n\nconst childStartSpy = vi.spyOn(childChild, 'start')\nconst childStopSpy = vi.spyOn(childChild, 'stop')\n\nchild.start()\nexpect(childStartSpy).toHaveBeenCalled()\n\nchild.stop()\nexpect(childStopSpy).toHaveBeenCalled()"
          },
          {
            "title": "delegateTo with methods",
            "line": 565,
            "source": "const hostModule = new PerkyModule({$id: 'host'})\nconst childModule = new PerkyModule({$id: 'child'})\n\nchildModule.method1 = vi.fn()\nchildModule.method2 = vi.fn()\n\nchildModule.delegateTo(hostModule, ['method1', 'method2'])\n\nexpect(hostModule.method1).toBeDefined()\nexpect(hostModule.method2).toBeDefined()\nexpect(typeof hostModule.method1).toBe('function')\nexpect(typeof hostModule.method2).toBe('function')"
          },
          {
            "title": "delegateTo with properties",
            "line": 581,
            "source": "const hostModule = new PerkyModule({$id: 'host'})\nconst childModule = new PerkyModule({$id: 'child'})\n\nchildModule.prop1 = 'value1'\nchildModule.prop2 = 'value2'\n\nchildModule.delegateTo(hostModule, ['prop1', 'prop2'])\n\nexpect(hostModule.prop1).toBe('value1')\nexpect(hostModule.prop2).toBe('value2')\n\nhostModule.prop1 = 'newValue'\nexpect(childModule.prop1).toBe('newValue')"
          },
          {
            "title": "delegateTo with mixed methods and properties",
            "line": 598,
            "source": "const hostModule = new PerkyModule({$id: 'host'})\nconst childModule = new PerkyModule({$id: 'child'})\n\nchildModule.count = 0\nchildModule.increment = function () {\n    this.count++\n}\nchildModule.decrement = function () {\n    this.count--\n}\n\nchildModule.delegateTo(hostModule, ['count', 'increment', 'decrement'])\n\nexpect(hostModule.count).toBe(0)\nexpect(typeof hostModule.increment).toBe('function')\nexpect(typeof hostModule.decrement).toBe('function')\n\nhostModule.increment()\nexpect(childModule.count).toBe(1)\nexpect(hostModule.count).toBe(1)\n\nhostModule.decrement()\nexpect(childModule.count).toBe(0)\nexpect(hostModule.count).toBe(0)"
          },
          {
            "title": "delegateTo with getters and setters",
            "line": 626,
            "source": "const hostModule = new PerkyModule({$id: 'host'})\nconst childModule = new PerkyModule({$id: 'child'})\n\nchildModule.internalValue = 10\nObject.defineProperty(childModule, 'value', {\n    get () {\n        return this.internalValue\n    },\n    set (newValue) {\n        this.internalValue = newValue\n    },\n    enumerable: true,\n    configurable: true\n})\n\nchildModule.delegateTo(hostModule, ['value'])\n\nexpect(hostModule.value).toBe(10)\n\nhostModule.value = 20\nexpect(childModule.value).toBe(20)\nexpect(hostModule.value).toBe(20)"
          },
          {
            "title": "delegateTo with object-based aliasing",
            "line": 652,
            "source": "const hostModule = new PerkyModule({$id: 'host'})\nconst childModule = new PerkyModule({$id: 'child'})\n\nchildModule.originalMethod = vi.fn(() => 'result')\nchildModule.originalProp = 'value'\n\nchildModule.delegateTo(hostModule, {\n    originalMethod: 'aliasedMethod',\n    originalProp: 'aliasedProp'\n})\n\nexpect(hostModule.aliasedMethod).toBeDefined()\nexpect(typeof hostModule.aliasedMethod).toBe('function')\nexpect(hostModule.aliasedMethod()).toBe('result')\nexpect(childModule.originalMethod).toHaveBeenCalled()\n\nexpect(hostModule.aliasedProp).toBe('value')\n\nhostModule.aliasedProp = 'new value'\nexpect(childModule.originalProp).toBe('new value')"
          },
          {
            "title": "delegateTo cleans up delegations on uninstall",
            "line": 676,
            "source": "const hostModule = new PerkyModule({$id: 'host'})\nconst childModule = hostModule.create(PerkyModule, {$id: 'child'})\n\nchildModule.getValue = vi.fn(() => 42)\nchildModule.someData = 'test'\n\nchildModule.delegateTo(hostModule, ['getValue', 'someData'])\n\nexpect(hostModule.getValue).toBeDefined()\nexpect(hostModule.getValue()).toBe(42)\nexpect(hostModule.someData).toBe('test')\n\nchildModule.uninstall()\n\nexpect(hostModule.getValue).toBeUndefined()\nexpect(hostModule.someData).toBeUndefined()"
          },
          {
            "title": "delegateTo cleans up delegations on dispose",
            "line": 696,
            "source": "const hostModule = new PerkyModule({$id: 'host'})\nconst childModule = hostModule.create(PerkyModule, {$id: 'child'})\n\nchildModule.doSomething = vi.fn()\n\nchildModule.delegateTo(hostModule, ['doSomething'])\n\nexpect(hostModule.doSomething).toBeDefined()\n\nchildModule.dispose()\n\nexpect(hostModule.doSomething).toBeUndefined()"
          },
          {
            "title": "delegateTo with object-based aliasing cleans up on uninstall",
            "line": 712,
            "source": "const hostModule = new PerkyModule({$id: 'host'})\nconst childModule = hostModule.create(PerkyModule, {$id: 'child'})\n\nchildModule.originalMethod = vi.fn(() => 'result')\n\nchildModule.delegateTo(hostModule, {originalMethod: 'aliasedMethod'})\n\nexpect(hostModule.aliasedMethod).toBeDefined()\nexpect(hostModule.aliasedMethod()).toBe('result')\n\nchildModule.uninstall()\n\nexpect(hostModule.aliasedMethod).toBeUndefined()"
          },
          {
            "title": "cleanDelegations removes all delegated properties",
            "line": 729,
            "source": "const hostModule = new PerkyModule({$id: 'host'})\nconst childModule = new PerkyModule({$id: 'child'})\n\nchildModule.method1 = vi.fn()\nchildModule.method2 = vi.fn()\nchildModule.prop1 = 'value1'\n\nchildModule.delegateTo(hostModule, ['method1', 'prop1'])\nchildModule.delegateTo(hostModule, ['method2'])\n\nexpect(hostModule.method1).toBeDefined()\nexpect(hostModule.method2).toBeDefined()\nexpect(hostModule.prop1).toBe('value1')\n\nchildModule.cleanDelegations()\n\nexpect(hostModule.method1).toBeUndefined()\nexpect(hostModule.method2).toBeUndefined()\nexpect(hostModule.prop1).toBeUndefined()"
          },
          {
            "title": "delegateEventsTo forwards events to host",
            "line": 752,
            "source": "const hostModule = new PerkyModule({$id: 'host'})\nconst childModule = hostModule.create(PerkyModule, {$id: 'child'})\n\nconst updateSpy = vi.fn()\nconst renderSpy = vi.fn()\n\nhostModule.on('update', updateSpy)\nhostModule.on('render', renderSpy)\n\nchildModule.delegateEventsTo(hostModule, ['update', 'render'])\n\nchildModule.emit('update', 0.16)\nchildModule.emit('render', 1.0)\n\nexpect(updateSpy).toHaveBeenCalledWith(0.16)\nexpect(renderSpy).toHaveBeenCalledWith(1.0)"
          },
          {
            "title": "delegateEventsTo with namespace prefixes events",
            "line": 772,
            "source": "const hostModule = new PerkyModule({$id: 'host'})\nconst childModule = hostModule.create(PerkyModule, {$id: 'child'})\n\nconst spy = vi.fn()\nhostModule.on('child:update', spy)\n\nchildModule.delegateEventsTo(hostModule, ['update'], 'child')\n\nchildModule.emit('update', 0.16)\n\nexpect(spy).toHaveBeenCalledWith(0.16)"
          },
          {
            "title": "delegateEventsTo cleans up on uninstall",
            "line": 787,
            "source": "const hostModule = new PerkyModule({$id: 'host'})\nconst childModule = hostModule.create(PerkyModule, {$id: 'child'})\n\nconst spy = vi.fn()\nhostModule.on('update', spy)\n\nchildModule.delegateEventsTo(hostModule, ['update'])\n\nchildModule.emit('update', 0.16)\nexpect(spy).toHaveBeenCalledTimes(1)\n\nchildModule.uninstall()\n\nchildModule.emit('update', 0.16)\nexpect(spy).toHaveBeenCalledTimes(1)"
          },
          {
            "title": "delegateEventsTo cleans up on dispose",
            "line": 806,
            "source": "const hostModule = new PerkyModule({$id: 'host'})\nconst childModule = hostModule.create(PerkyModule, {$id: 'child'})\n\nconst spy = vi.fn()\nhostModule.on('update', spy)\n\nchildModule.delegateEventsTo(hostModule, ['update'])\n\nchildModule.emit('update', 0.16)\nexpect(spy).toHaveBeenCalledTimes(1)\n\nchildModule.dispose()\n\nchildModule.emit('update', 0.16)\nexpect(spy).toHaveBeenCalledTimes(1)"
          },
          {
            "title": "dispose calls dispose on all children in cascade",
            "line": 825,
            "source": "class ChildChild1 extends PerkyModule { }\nclass ChildChild2 extends PerkyModule { }\n\nconst child1 = child.create(ChildChild1, {\n    $id: 'child1'\n})\n\nconst child2 = child.create(ChildChild2, {\n    $id: 'child2'\n})\n\nconst child1DisposeSpy = vi.spyOn(child1, 'dispose')\nconst child2DisposeSpy = vi.spyOn(child2, 'dispose')\n\nchild.dispose()\n\nexpect(child1DisposeSpy).toHaveBeenCalled()\nexpect(child2DisposeSpy).toHaveBeenCalled()\nexpect(child1.disposed).toBe(true)\nexpect(child2.disposed).toBe(true)\nexpect(child.disposed).toBe(true)"
          },
          {
            "title": "dispose with multiple nested children",
            "line": 850,
            "source": "class Level1Child extends PerkyModule { }\nclass Level2Child extends PerkyModule { }\n\nconst level1 = child.create(Level1Child, {\n    $id: 'level1'\n})\n\nconst level2 = child.create(Level2Child, {\n    $id: 'level2'\n})\n\nconst level1DisposeSpy = vi.spyOn(level1, 'dispose')\nconst level2DisposeSpy = vi.spyOn(level2, 'dispose')\n\nchild.dispose()\n\nexpect(level1DisposeSpy).toHaveBeenCalled()\nexpect(level2DisposeSpy).toHaveBeenCalled()\nexpect(level2.disposed).toBe(true)\nexpect(level1.disposed).toBe(true)\nexpect(child.disposed).toBe(true)"
          },
          {
            "title": "dispose skips already disposed children",
            "line": 875,
            "source": "class ChildChild extends PerkyModule { }\n\nconst childChild = new ChildChild()\nconst childDisposeSpy = vi.spyOn(child, 'dispose')\n\nchild.create(ChildChild, {\n    instance: childChild,\n    $id: 'default'\n})\n\nchild.dispose()\nexpect(childDisposeSpy).toHaveBeenCalledTimes(1)\nexpect(child.disposed).toBe(true)\n\nchildDisposeSpy.mockClear()\n\nchildChild.dispose()\n\nexpect(childDisposeSpy).not.toHaveBeenCalled()\nexpect(childChild.disposed).toBe(true)"
          },
          {
            "title": "dispose clears children registry after disposing all children",
            "line": 899,
            "source": "class ChildChild extends PerkyModule { }\n\nconst childChild = new ChildChild()\n\nchild.create(ChildChild, {\n    instance: childChild,\n    $id: 'default'\n})\n\nexpect(child.hasChild('default')).toBe(true)\n\nchild.dispose()\n\nexpect(child.hasChild('default')).toBe(false)\nexpect(child.childrenRegistry.size).toBe(0)"
          }
        ],
        "describes": [
          {
            "title": "addChild",
            "line": 151,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "adds a pre-created module",
                "line": 153,
                "source": "const module = new PerkyModule({$id: 'player', $category: 'entity'})\n\nconst result = child.addChild(module)\n\nexpect(result).toBe(module)\nexpect(child.hasChild('player')).toBe(true)\nexpect(child.getChild('player')).toBe(module)\nexpect(module.host).toBe(child)\nexpect(module.installed).toBe(true)"
              },
              {
                "title": "auto-generates unique ID on collision",
                "line": 166,
                "source": "child.create(PerkyModule, {$id: 'enemy'})\n\nconst module = new PerkyModule({$id: 'enemy', $name: 'enemy'})\nchild.addChild(module)\n\nexpect(module.$id).toBe('enemy_1')\nexpect(child.hasChild('enemy')).toBe(true)\nexpect(child.hasChild('enemy_1')).toBe(true)"
              },
              {
                "title": "auto-generates sequential IDs on multiple collisions",
                "line": 178,
                "source": "const m1 = new PerkyModule({$id: 'enemy', $name: 'enemy'})\nconst m2 = new PerkyModule({$id: 'enemy', $name: 'enemy'})\nconst m3 = new PerkyModule({$id: 'enemy', $name: 'enemy'})\n\nchild.addChild(m1)\nchild.addChild(m2)\nchild.addChild(m3)\n\nexpect(m1.$id).toBe('enemy')\nexpect(m2.$id).toBe('enemy_1')\nexpect(m3.$id).toBe('enemy_2')"
              },
              {
                "title": "throws if module is already installed",
                "line": 193,
                "source": "const parent1 = new PerkyModule({$id: 'parent1'})\nconst parent2 = new PerkyModule({$id: 'parent2'})\nconst module = new PerkyModule({$id: 'child'})\n\nparent1.addChild(module)\n\nexpect(() => parent2.addChild(module)).toThrow('Module is already installed in another parent')"
              },
              {
                "title": "throws if not a PerkyModule instance",
                "line": 204,
                "source": "expect(() => child.addChild({})).toThrow('addChild expects a PerkyModule instance')\nexpect(() => child.addChild(null)).toThrow('addChild expects a PerkyModule instance')\nexpect(() => child.addChild('test')).toThrow('addChild expects a PerkyModule instance')\nexpect(() => child.addChild(42)).toThrow('addChild expects a PerkyModule instance')"
              },
              {
                "title": "calls onInstall hook",
                "line": 212,
                "source": "const onInstallSpy = vi.fn()\n\nclass TestModule extends PerkyModule {\n    onInstall (installedHost) {\n        onInstallSpy(installedHost)\n    }\n}\n\nconst module = new TestModule({$id: 'test'})\nchild.addChild(module)\n\nexpect(onInstallSpy).toHaveBeenCalledWith(child)"
              },
              {
                "title": "sets up lifecycle binding",
                "line": 228,
                "source": "const module = new PerkyModule({$id: 'test'})\nchild.addChild(module)\n\nconst startSpy = vi.spyOn(module, 'start')\nconst stopSpy = vi.spyOn(module, 'stop')\n\nchild.start()\nexpect(startSpy).toHaveBeenCalled()\n\nchild.stop()\nexpect(stopSpy).toHaveBeenCalled()"
              },
              {
                "title": "respects $eagerStart when parent is already started",
                "line": 243,
                "source": "child.start()\n\nconst eager = new PerkyModule({$id: 'eager', $eagerStart: true})\nconst lazy = new PerkyModule({$id: 'lazy', $eagerStart: false})\n\nchild.addChild(eager)\nchild.addChild(lazy)\n\nexpect(eager.started).toBe(true)\nexpect(lazy.started).toBe(false)"
              },
              {
                "title": "emits registration events",
                "line": 257,
                "source": "const emitSpy = vi.spyOn(child, 'emit')\nconst module = new PerkyModule({$id: 'test', $category: 'entity'})\n\nchild.addChild(module)\n\nexpect(emitSpy).toHaveBeenCalledWith('entity:set', 'test', module)"
              },
              {
                "title": "works with $bind option",
                "line": 267,
                "source": "const module = new PerkyModule({$id: 'audio', $bind: 'audioSystem'})\n\nchild.addChild(module)\n\nexpect(child.audioSystem).toBe(module)"
              },
              {
                "title": "works with $bind: true using $name",
                "line": 276,
                "source": "const module = new PerkyModule({$id: 'audio', $name: 'audioSystem', $bind: true})\n\nchild.addChild(module)\n\nexpect(child.audioSystem).toBe(module)"
              },
              {
                "title": "respects $lifecycle: false",
                "line": 285,
                "source": "const module = new PerkyModule({$id: 'static', $lifecycle: false})\nchild.addChild(module)\n\nconst startSpy = vi.spyOn(module, 'start')\nconst stopSpy = vi.spyOn(module, 'stop')\n\nchild.start()\nexpect(startSpy).not.toHaveBeenCalled()\n\nchild.stop()\nexpect(stopSpy).not.toHaveBeenCalled()"
              }
            ],
            "describes": []
          },
          {
            "title": "static $category",
            "line": 918,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "uses PerkyModule default category \"perkyModule\" when not specified",
                "line": 919,
                "source": "const module = child.create(PerkyModule, {$id: 'test'})\nexpect(module.$category).toBe('perkyModule')"
              },
              {
                "title": "uses static $category from subclass",
                "line": 925,
                "source": "class GameController extends PerkyModule {\n    static $category = 'controller'\n}\n\nconst controller = child.create(GameController, {$id: 'game'})\nexpect(controller.$category).toBe('controller')"
              },
              {
                "title": "explicit $category overrides static $category",
                "line": 935,
                "source": "class GameController extends PerkyModule {\n    static $category = 'controller'\n}\n\nconst controller = child.create(GameController, {\n    $id: 'game',\n    $category: 'custom'\n})\n\nexpect(controller.$category).toBe('custom')"
              },
              {
                "title": "works with multiple levels of inheritance",
                "line": 949,
                "source": "class BaseController extends PerkyModule {\n    static $category = 'controller'\n}\n\nclass GameController extends BaseController {\n    static $category = 'gameController'\n}\n\nconst controller = child.create(GameController, {$id: 'game'})\nexpect(controller.$category).toBe('gameController')"
              },
              {
                "title": "subclass without static $category falls back to parent",
                "line": 963,
                "source": "class BaseController extends PerkyModule {\n    static $category = 'controller'\n}\n\nclass GameController extends BaseController {\n    // No static $category override\n}\n\nconst controller = child.create(GameController, {$id: 'game'})\nexpect(controller.$category).toBe('controller')"
              },
              {
                "title": "auto-generates unique IDs using static $category",
                "line": 977,
                "source": "class Monster extends PerkyModule {\n    static $category = 'monster'\n}\n\n// Use a fresh parent to ensure predictable ID generation\nconst parent = new PerkyModule()\nconst monster1 = parent.create(Monster)\nconst monster2 = parent.create(Monster)\nconst monster3 = parent.create(Monster)\n\nexpect(monster1.$category).toBe('monster')\nexpect(monster2.$category).toBe('monster')\nexpect(monster3.$category).toBe('monster')\n\nexpect(monster1.$id).toBe('monster')\nexpect(monster2.$id).toBe('monster_1')\nexpect(monster3.$id).toBe('monster_2')"
              },
              {
                "title": "emits correct event based on static $category",
                "line": 998,
                "source": "class GameController extends PerkyModule {\n    static $category = 'controller'\n}\n\nconst emitSpy = vi.spyOn(child, 'emit')\nconst controller = child.create(GameController, {$id: 'game'})\n\nexpect(emitSpy).toHaveBeenCalledWith('controller:set', 'game', controller)"
              },
              {
                "title": "listNamesFor works with static $category",
                "line": 1010,
                "source": "class GameController extends PerkyModule {\n    static $category = 'controller'\n}\n\nclass InputController extends PerkyModule {\n    static $category = 'controller'\n}\n\nchild.create(GameController, {$id: 'game'})\nchild.create(InputController, {$id: 'input'})\n\nconst controllers = child.listNamesFor('controller')\nexpect(controllers).toHaveLength(2)\nexpect(controllers).toContain('game')\nexpect(controllers).toContain('input')"
              }
            ],
            "describes": []
          },
          {
            "title": "$eagerStart",
            "line": 1030,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "default $eagerStart is true for PerkyModule",
                "line": 1031,
                "source": "const module = child.create(PerkyModule, {$id: 'test'})\nexpect(module.$eagerStart).toBe(true)"
              },
              {
                "title": "child starts eagerly when parent is already started",
                "line": 1037,
                "source": "child.start()\n\nconst module = child.create(PerkyModule, {$id: 'test'})\n\nexpect(module.started).toBe(true)"
              },
              {
                "title": "child does not start when parent is not started",
                "line": 1046,
                "source": "const module = child.create(PerkyModule, {$id: 'test'})\n\nexpect(module.started).toBe(false)"
              },
              {
                "title": "$eagerStart: false prevents automatic start",
                "line": 1053,
                "source": "child.start()\n\nconst module = child.create(PerkyModule, {\n    $id: 'test',\n    $eagerStart: false\n})\n\nexpect(module.started).toBe(false)"
              },
              {
                "title": "$eagerStart: true forces eager start",
                "line": 1065,
                "source": "child.start()\n\nconst module = child.create(PerkyModule, {\n    $id: 'test',\n    $eagerStart: true\n})\n\nexpect(module.started).toBe(true)"
              },
              {
                "title": "static $eagerStart is inherited from class",
                "line": 1077,
                "source": "class LazyModule extends PerkyModule {\n    static $eagerStart = false\n}\n\nchild.start()\n\nconst module = child.create(LazyModule, {$id: 'test'})\n\nexpect(module.$eagerStart).toBe(false)\nexpect(module.started).toBe(false)"
              },
              {
                "title": "explicit $eagerStart overrides static $eagerStart",
                "line": 1091,
                "source": "class LazyModule extends PerkyModule {\n    static $eagerStart = false\n}\n\nchild.start()\n\nconst module = child.create(LazyModule, {\n    $id: 'test',\n    $eagerStart: true\n})\n\nexpect(module.$eagerStart).toBe(true)\nexpect(module.started).toBe(true)"
              },
              {
                "title": "$eagerStart cascading: option > static > default",
                "line": 1108,
                "source": "class CustomModule extends PerkyModule {\n    static $eagerStart = false\n}\n\nconst module1 = child.create(CustomModule, {$id: 'test1'})\nexpect(module1.$eagerStart).toBe(false)\n\nconst module2 = child.create(CustomModule, {\n    $id: 'test2',\n    $eagerStart: true\n})\nexpect(module2.$eagerStart).toBe(true)\n\nconst module3 = child.create(PerkyModule, {$id: 'test3'})\nexpect(module3.$eagerStart).toBe(true)"
              },
              {
                "title": "$eagerStart works with $lifecycle: false",
                "line": 1127,
                "source": "child.start()\n\nconst module = child.create(PerkyModule, {\n    $id: 'test',\n    $eagerStart: true,\n    $lifecycle: false\n})\n\nexpect(module.started).toBe(false)"
              },
              {
                "title": "lazy module can be started manually later",
                "line": 1140,
                "source": "child.start()\n\nconst module = child.create(PerkyModule, {\n    $id: 'test',\n    $eagerStart: false\n})\n\nexpect(module.started).toBe(false)\n\nmodule.start()\n\nexpect(module.started).toBe(true)"
              },
              {
                "title": "multiple children with mixed $eagerStart",
                "line": 1156,
                "source": "child.start()\n\nconst eager1 = child.create(PerkyModule, {\n    $id: 'eager1',\n    $eagerStart: true\n})\n\nconst lazy1 = child.create(PerkyModule, {\n    $id: 'lazy1',\n    $eagerStart: false\n})\n\nconst eager2 = child.create(PerkyModule, {\n    $id: 'eager2'\n})\n\nexpect(eager1.started).toBe(true)\nexpect(lazy1.started).toBe(false)\nexpect(eager2.started).toBe(true)"
              },
              {
                "title": "eagerStart getter returns correct value",
                "line": 1179,
                "source": "const eager = child.create(PerkyModule, {\n    $id: 'eager',\n    $eagerStart: true\n})\n\nconst lazy = child.create(PerkyModule, {\n    $id: 'lazy',\n    $eagerStart: false\n})\nexpect(eager.$eagerStart).toBe(true)\nexpect(lazy.$eagerStart).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "$lifecycle",
            "line": 1195,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "$lifecycle is true by default",
                "line": 1197,
                "source": "const module = new PerkyModule()\nexpect(module.$lifecycle).toBe(true)"
              },
              {
                "title": "$lifecycle can be set to false via options",
                "line": 1203,
                "source": "const module = new PerkyModule({$lifecycle: false})\nexpect(module.$lifecycle).toBe(false)"
              },
              {
                "title": "$lifecycle is true when option is explicitly true",
                "line": 1209,
                "source": "const module = new PerkyModule({$lifecycle: true})\nexpect(module.$lifecycle).toBe(true)"
              }
            ],
            "describes": []
          },
          {
            "title": "$status",
            "line": 1217,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns \"stopped\" for new module",
                "line": 1219,
                "source": "const module = new PerkyModule()\nexpect(module.$status).toBe('stopped')"
              },
              {
                "title": "returns \"started\" when module is running",
                "line": 1225,
                "source": "const module = new PerkyModule()\nmodule.start()\nexpect(module.$status).toBe('started')"
              },
              {
                "title": "returns \"stopped\" after stopping a started module",
                "line": 1232,
                "source": "const module = new PerkyModule()\nmodule.start()\nmodule.stop()\nexpect(module.$status).toBe('stopped')"
              },
              {
                "title": "returns \"disposed\" when module is disposed",
                "line": 1240,
                "source": "const module = new PerkyModule()\nmodule.dispose()\nexpect(module.$status).toBe('disposed')"
              },
              {
                "title": "returns \"static\" when $lifecycle is false",
                "line": 1247,
                "source": "const module = new PerkyModule({$lifecycle: false})\nexpect(module.$status).toBe('static')"
              },
              {
                "title": "returns \"static\" even if started when $lifecycle is false",
                "line": 1253,
                "source": "const module = new PerkyModule({$lifecycle: false})\nmodule.start()\nexpect(module.$status).toBe('static')"
              },
              {
                "title": "disposed takes precedence over started",
                "line": 1260,
                "source": "const module = new PerkyModule()\nmodule.start()\nmodule.dispose()\nexpect(module.$status).toBe('disposed')"
              }
            ],
            "describes": []
          },
          {
            "title": "$tags",
            "line": 1270,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "initializes with empty tags by default",
                "line": 1272,
                "source": "const module = new PerkyModule()\nexpect(module.$tags).toEqual([])"
              },
              {
                "title": "initializes with tags from options",
                "line": 1278,
                "source": "const module = new PerkyModule({$tags: ['enemy', 'collidable']})\nexpect(module.$tags).toEqual(['enemy', 'collidable'])"
              },
              {
                "title": "$tags returns array copy",
                "line": 1284,
                "source": "const module = new PerkyModule({$tags: ['test']})\nconst tags1 = module.$tags\nconst tags2 = module.$tags\nexpect(tags1).not.toBe(tags2)\nexpect(tags1).toEqual(tags2)"
              },
              {
                "title": "tags property returns ObservableSet",
                "line": 1293,
                "source": "const module = new PerkyModule()\nexpect(module.tags).toBeDefined()\nexpect(module.tags.size).toBe(0)"
              },
              {
                "title": "can add tags via tags.add()",
                "line": 1300,
                "source": "const module = new PerkyModule()\nmodule.tags.add('enemy')\nmodule.tags.add('collidable')\n\nexpect(module.$tags).toEqual(['enemy', 'collidable'])\nexpect(module.tags.size).toBe(2)"
              },
              {
                "title": "can delete tags via tags.delete()",
                "line": 1310,
                "source": "const module = new PerkyModule({$tags: ['enemy', 'collidable', 'flying']})\n\nmodule.tags.delete('flying')\n\nexpect(module.$tags).toEqual(['enemy', 'collidable'])\nexpect(module.tags.size).toBe(2)"
              },
              {
                "title": "can clear tags via tags.clear()",
                "line": 1320,
                "source": "const module = new PerkyModule({$tags: ['enemy', 'collidable']})\n\nmodule.tags.clear()\n\nexpect(module.$tags).toEqual([])\nexpect(module.tags.size).toBe(0)"
              },
              {
                "title": "tags.add() emits add event",
                "line": 1330,
                "source": "const module = new PerkyModule()\nlet addedTag\n\nmodule.tags.on('add', (tag) => {\n    addedTag = tag\n})\n\nmodule.tags.add('enemy')\n\nexpect(addedTag).toBe('enemy')"
              },
              {
                "title": "tags.delete() emits delete event",
                "line": 1344,
                "source": "const module = new PerkyModule({$tags: ['enemy']})\nlet deletedTag\n\nmodule.tags.on('delete', (tag) => {\n    deletedTag = tag\n})\n\nmodule.tags.delete('enemy')\n\nexpect(deletedTag).toBe('enemy')"
              },
              {
                "title": "tags.clear() emits clear event",
                "line": 1358,
                "source": "const module = new PerkyModule({$tags: ['enemy', 'collidable']})\nlet clearedTags\n\nmodule.tags.on('clear', (tags) => {\n    clearedTags = tags\n})\n\nmodule.tags.clear()\n\nexpect(clearedTags).toEqual(['enemy', 'collidable'])"
              },
              {
                "title": "tags support chaining",
                "line": 1372,
                "source": "const module = new PerkyModule()\n\nmodule.tags.add('enemy').add('collidable').add('flying')\n\nexpect(module.$tags).toEqual(['enemy', 'collidable', 'flying'])"
              },
              {
                "title": "tags support iteration",
                "line": 1381,
                "source": "const module = new PerkyModule({$tags: ['a', 'b', 'c']})\n\nconst collected = []\nfor (const tag of module.tags) {\n    collected.push(tag)\n}\n\nexpect(collected).toEqual(['a', 'b', 'c'])"
              },
              {
                "title": "can set $tags with array",
                "line": 1393,
                "source": "const module = new PerkyModule({$tags: ['enemy', 'collidable']})\n\nmodule.$tags = ['friendly', 'flying']\n\nexpect(module.$tags).toEqual(['friendly', 'flying'])\nexpect(module.tags.size).toBe(2)"
              },
              {
                "title": "setting $tags clears old tags",
                "line": 1403,
                "source": "const module = new PerkyModule({$tags: ['a', 'b', 'c']})\n\nmodule.$tags = ['x', 'y']\n\nexpect(module.$tags).toEqual(['x', 'y'])\nexpect(module.tags.has('a')).toBe(false)\nexpect(module.tags.has('b')).toBe(false)"
              },
              {
                "title": "setting $tags emits clear and add events",
                "line": 1414,
                "source": "const module = new PerkyModule({$tags: ['old']})\nlet clearedTags\nlet addedTags = []\n\nmodule.tags.on('clear', (tags) => {\n    clearedTags = tags\n})\nmodule.tags.on('add', (tag) => {\n    addedTags.push(tag)\n})\n\nmodule.$tags = ['new1', 'new2']\n\nexpect(clearedTags).toEqual(['old'])\nexpect(addedTags).toEqual(['new1', 'new2'])"
              },
              {
                "title": "setting $tags to empty array clears all",
                "line": 1433,
                "source": "const module = new PerkyModule({$tags: ['a', 'b']})\n\nmodule.$tags = []\n\nexpect(module.$tags).toEqual([])\nexpect(module.tags.size).toBe(0)"
              },
              {
                "title": "hasTag returns true when tag exists",
                "line": 1443,
                "source": "const module = new PerkyModule({$tags: ['enemy', 'collidable']})\nexpect(module.hasTag('enemy')).toBe(true)\nexpect(module.hasTag('collidable')).toBe(true)"
              },
              {
                "title": "hasTag returns false when tag does not exist",
                "line": 1450,
                "source": "const module = new PerkyModule({$tags: ['enemy']})\nexpect(module.hasTag('friendly')).toBe(false)\nexpect(module.hasTag('collidable')).toBe(false)"
              },
              {
                "title": "hasTag returns false when no tags set",
                "line": 1457,
                "source": "const module = new PerkyModule()\nexpect(module.hasTag('enemy')).toBe(false)"
              },
              {
                "title": "addTag adds a tag",
                "line": 1463,
                "source": "const module = new PerkyModule()\nmodule.addTag('enemy')\nexpect(module.hasTag('enemy')).toBe(true)"
              },
              {
                "title": "addTag returns true when tag is new",
                "line": 1470,
                "source": "const module = new PerkyModule()\nexpect(module.addTag('enemy')).toBe(true)"
              },
              {
                "title": "addTag returns false when tag already exists",
                "line": 1476,
                "source": "const module = new PerkyModule({$tags: ['enemy']})\nexpect(module.addTag('enemy')).toBe(false)"
              },
              {
                "title": "removeTag removes a tag",
                "line": 1482,
                "source": "const module = new PerkyModule({$tags: ['enemy', 'collidable']})\nmodule.removeTag('enemy')\nexpect(module.hasTag('enemy')).toBe(false)\nexpect(module.hasTag('collidable')).toBe(true)"
              },
              {
                "title": "removeTag returns true when tag existed",
                "line": 1490,
                "source": "const module = new PerkyModule({$tags: ['enemy']})\nexpect(module.removeTag('enemy')).toBe(true)"
              },
              {
                "title": "removeTag returns false when tag did not exist",
                "line": 1496,
                "source": "const module = new PerkyModule()\nexpect(module.removeTag('enemy')).toBe(false)"
              },
              {
                "title": "hasTags returns true when all tags exist (array)",
                "line": 1502,
                "source": "const module = new PerkyModule({$tags: ['enemy', 'collidable', 'flying']})\nexpect(module.hasTags(['enemy', 'collidable'])).toBe(true)\nexpect(module.hasTags(['enemy'])).toBe(true)"
              },
              {
                "title": "hasTags returns false when some tags missing (array)",
                "line": 1509,
                "source": "const module = new PerkyModule({$tags: ['enemy', 'collidable']})\nexpect(module.hasTags(['enemy', 'flying'])).toBe(false)\nexpect(module.hasTags(['friendly', 'enemy'])).toBe(false)"
              },
              {
                "title": "hasTags returns false when no tags match (array)",
                "line": 1516,
                "source": "const module = new PerkyModule({$tags: ['enemy']})\nexpect(module.hasTags(['friendly', 'collidable'])).toBe(false)"
              },
              {
                "title": "hasTags fallback: accepts string and checks single tag",
                "line": 1522,
                "source": "const module = new PerkyModule({$tags: ['enemy', 'collidable']})\nexpect(module.hasTags('enemy')).toBe(true)\nexpect(module.hasTags('collidable')).toBe(true)\nexpect(module.hasTags('friendly')).toBe(false)"
              },
              {
                "title": "hasTags returns true for empty array",
                "line": 1530,
                "source": "const module = new PerkyModule({$tags: ['enemy']})\nexpect(module.hasTags([])).toBe(true)"
              },
              {
                "title": "hasTags returns false when no tags set",
                "line": 1536,
                "source": "const module = new PerkyModule()\nexpect(module.hasTags(['enemy'])).toBe(false)\nexpect(module.hasTags('enemy')).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "composite tag indexing",
            "line": 1545,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "childrenByTags returns children matching all tags (without index)",
                "line": 1547,
                "source": "const child1 = child.create(PerkyModule, {$id: 'c1', $tags: ['enemy', 'collidable', 'flying']})\nconst child2 = child.create(PerkyModule, {$id: 'c2', $tags: ['enemy', 'collidable']})\nchild.create(PerkyModule, {$id: 'c3', $tags: ['friendly', 'collidable']})\n\nconst enemyColliders = child.childrenByTags(['enemy', 'collidable'])\n\nexpect(enemyColliders).toHaveLength(2)\nexpect(enemyColliders).toContain(child1)\nexpect(enemyColliders).toContain(child2)"
              },
              {
                "title": "childrenByTags returns empty array for no matches",
                "line": 1560,
                "source": "child.create(PerkyModule, {$id: 'c1', $tags: ['enemy']})\n\nconst result = child.childrenByTags(['enemy', 'collidable'])\n\nexpect(result).toEqual([])"
              },
              {
                "title": "childrenByTags returns empty array for empty tags",
                "line": 1569,
                "source": "const result = child.childrenByTags()\n\nexpect(result).toEqual([])"
              },
              {
                "title": "addTagsIndex creates composite index",
                "line": 1576,
                "source": "const result = child.addTagsIndex(['enemy', 'collidable'])\n\nexpect(result).toBe(true)\nexpect(child.childrenRegistry.hasIndex('collidable_enemy')).toBe(true)"
              },
              {
                "title": "addTagsIndex normalizes tag order",
                "line": 1584,
                "source": "child.addTagsIndex(['collidable', 'enemy'])\n\nexpect(child.childrenRegistry.hasIndex('collidable_enemy')).toBe(true)"
              },
              {
                "title": "addTagsIndex returns false if already indexed",
                "line": 1591,
                "source": "const result1 = child.addTagsIndex(['enemy', 'collidable'])\nconst result2 = child.addTagsIndex(['enemy', 'collidable'])\n\nexpect(result1).toBe(true)\nexpect(result2).toBe(false)"
              },
              {
                "title": "addTagsIndex returns false for empty array",
                "line": 1600,
                "source": "const result = child.addTagsIndex([])\n\nexpect(result).toBe(false)"
              },
              {
                "title": "addTagsIndex returns false for non-array",
                "line": 1607,
                "source": "const result = child.addTagsIndex('invalid')\n\nexpect(result).toBe(false)"
              },
              {
                "title": "childrenByTags uses index when available",
                "line": 1614,
                "source": "const child1 = child.create(PerkyModule, {$id: 'c1', $tags: ['enemy', 'collidable']})\nchild.create(PerkyModule, {$id: 'c2', $tags: ['enemy']})\n\nchild.addTagsIndex(['enemy', 'collidable'])\n\nconst result = child.childrenByTags(['enemy', 'collidable'])\n\nexpect(result).toHaveLength(1)\nexpect(result).toContain(child1)"
              },
              {
                "title": "removeTagsIndex removes composite index",
                "line": 1627,
                "source": "child.addTagsIndex(['enemy', 'collidable'])\nconst result = child.removeTagsIndex(['enemy', 'collidable'])\n\nexpect(result).toBe(true)\nexpect(child.childrenRegistry.hasIndex('collidable_enemy')).toBe(false)"
              },
              {
                "title": "removeTagsIndex returns false if not indexed",
                "line": 1636,
                "source": "const result = child.removeTagsIndex(['enemy', 'collidable'])\n\nexpect(result).toBe(false)"
              },
              {
                "title": "index automatically updates when child tags change (add)",
                "line": 1643,
                "source": "const testChild = child.create(PerkyModule, {$id: 'test', $tags: ['enemy']})\nchild.addTagsIndex(['enemy', 'collidable'])\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(0)\n\ntestChild.tags.add('collidable')\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(1)\nexpect(child.childrenByTags(['enemy', 'collidable'])).toContain(testChild)"
              },
              {
                "title": "index automatically updates when child tags change (delete)",
                "line": 1655,
                "source": "const testChild = child.create(PerkyModule, {$id: 'test', $tags: ['enemy', 'collidable']})\nchild.addTagsIndex(['enemy', 'collidable'])\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(1)\n\ntestChild.tags.delete('collidable')\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(0)"
              },
              {
                "title": "index automatically updates when child tags change (clear)",
                "line": 1667,
                "source": "const testChild = child.create(PerkyModule, {$id: 'test', $tags: ['enemy', 'collidable']})\nchild.addTagsIndex(['enemy', 'collidable'])\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(1)\n\ntestChild.tags.clear()\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(0)"
              },
              {
                "title": "index updates when $tags is reassigned",
                "line": 1679,
                "source": "const testChild = child.create(PerkyModule, {$id: 'test', $tags: ['enemy']})\nchild.addTagsIndex(['enemy', 'collidable'])\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(0)\n\ntestChild.$tags = ['enemy', 'collidable']\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(1)"
              },
              {
                "title": "multiple composite indexes work independently",
                "line": 1691,
                "source": "const enemy = child.create(PerkyModule, {$id: 'enemy', $tags: ['enemy', 'collidable']})\nconst friendly = child.create(PerkyModule, {$id: 'friendly', $tags: ['friendly', 'collidable']})\n\nchild.addTagsIndex(['enemy', 'collidable'])\nchild.addTagsIndex(['friendly', 'collidable'])\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toEqual([enemy])\nexpect(child.childrenByTags(['friendly', 'collidable'])).toEqual([friendly])"
              },
              {
                "title": "events are cleaned up when child is removed",
                "line": 1703,
                "source": "const testChild = child.create(PerkyModule, {$id: 'test', $tags: ['enemy', 'collidable']})\nchild.addTagsIndex(['enemy', 'collidable'])\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(1)\n\nchild.removeChild('test')\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(0)\n\ntestChild.tags.add('flying')\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(0)"
              },
              {
                "title": "index hooks are added to existing children",
                "line": 1718,
                "source": "const testChild = child.create(PerkyModule, {$id: 'test', $tags: ['enemy']})\n\nchild.addTagsIndex(['enemy', 'collidable'])\n\ntestChild.tags.add('collidable')\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(1)"
              },
              {
                "title": "single tag query works",
                "line": 1729,
                "source": "const child1 = child.create(PerkyModule, {$id: 'c1', $tags: ['enemy']})\nconst child2 = child.create(PerkyModule, {$id: 'c2', $tags: ['enemy', 'flying']})\nchild.create(PerkyModule, {$id: 'c3', $tags: ['friendly']})\n\nconst enemies = child.childrenByTags('enemy')\n\nexpect(enemies).toHaveLength(2)\nexpect(enemies).toContain(child1)\nexpect(enemies).toContain(child2)"
              },
              {
                "title": "works with children without tags",
                "line": 1742,
                "source": "child.create(PerkyModule, {$id: 'c1'})\nconst child2 = child.create(PerkyModule, {$id: 'c2', $tags: ['enemy']})\n\nconst result = child.childrenByTags('enemy')\n\nexpect(result).toEqual([child2])"
              }
            ],
            "describes": []
          },
          {
            "title": "#setupTagIndexListeners",
            "line": 1754,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "listeners are set up when creating a child with tags and indexes exist",
                "line": 1756,
                "source": "child.addTagsIndex(['enemy', 'collidable'])\n\nconst testChild = child.create(PerkyModule, {$id: 'test', $tags: ['enemy']})\n\ntestChild.tags.add('collidable')\n\nconst result = child.childrenByTags(['enemy', 'collidable'])\nexpect(result).toHaveLength(1)\nexpect(result).toContain(testChild)"
              },
              {
                "title": "listeners ARE set up when addTagsIndex is called for existing children",
                "line": 1769,
                "source": "const testChild = child.create(PerkyModule, {$id: 'test', $tags: ['enemy']})\n\nchild.addTagsIndex(['enemy', 'collidable'])\n\ntestChild.tags.add('collidable')\n\nconst result = child.childrenByTags(['enemy', 'collidable'])\nexpect(result).toHaveLength(1)\nexpect(result).toContain(testChild)"
              },
              {
                "title": "listeners ARE set up for children even without initial tags",
                "line": 1782,
                "source": "child.addTagsIndex(['enemy', 'collidable'])\n\nconst testChild = child.create(PerkyModule, {$id: 'test'})\n\ntestChild.tags.add('enemy')\ntestChild.tags.add('collidable')\n\nconst result = child.childrenByTags(['enemy', 'collidable'])\nexpect(result).toHaveLength(1)\nexpect(result).toContain(testChild)"
              },
              {
                "title": "adding a tag triggers index update for all registered indexes",
                "line": 1796,
                "source": "child.addTagsIndex(['enemy', 'collidable'])\nchild.addTagsIndex(['enemy', 'flying'])\n\nconst testChild = child.create(PerkyModule, {$id: 'test', $tags: ['enemy']})\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(0)\nexpect(child.childrenByTags(['enemy', 'flying'])).toHaveLength(0)\n\ntestChild.tags.add('collidable')\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(1)\nexpect(child.childrenByTags(['enemy', 'flying'])).toHaveLength(0)\n\ntestChild.tags.add('flying')\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(1)\nexpect(child.childrenByTags(['enemy', 'flying'])).toHaveLength(1)"
              },
              {
                "title": "deleting a tag triggers index update for all registered indexes",
                "line": 1817,
                "source": "child.addTagsIndex(['enemy', 'collidable'])\nchild.addTagsIndex(['enemy', 'flying'])\n\nconst testChild = child.create(PerkyModule, {$id: 'test', $tags: ['enemy', 'collidable', 'flying']})\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(1)\nexpect(child.childrenByTags(['enemy', 'flying'])).toHaveLength(1)\n\ntestChild.tags.delete('collidable')\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(0)\nexpect(child.childrenByTags(['enemy', 'flying'])).toHaveLength(1)\n\ntestChild.tags.delete('flying')\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(0)\nexpect(child.childrenByTags(['enemy', 'flying'])).toHaveLength(0)"
              },
              {
                "title": "clearing tags triggers index update for all registered indexes",
                "line": 1838,
                "source": "child.addTagsIndex(['enemy', 'collidable'])\nchild.addTagsIndex(['enemy', 'flying'])\n\nconst testChild = child.create(PerkyModule, {$id: 'test', $tags: ['enemy', 'collidable', 'flying']})\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(1)\nexpect(child.childrenByTags(['enemy', 'flying'])).toHaveLength(1)\n\ntestChild.tags.clear()\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(0)\nexpect(child.childrenByTags(['enemy', 'flying'])).toHaveLength(0)"
              },
              {
                "title": "multiple children with different tag combinations",
                "line": 1854,
                "source": "child.addTagsIndex(['enemy', 'collidable'])\nchild.addTagsIndex(['friendly', 'collidable'])\n\nconst enemy = child.create(PerkyModule, {$id: 'enemy', $tags: ['enemy']})\nconst friendly = child.create(PerkyModule, {$id: 'friendly', $tags: ['friendly']})\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(0)\nexpect(child.childrenByTags(['friendly', 'collidable'])).toHaveLength(0)\n\nenemy.tags.add('collidable')\nfriendly.tags.add('collidable')\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(1)\nexpect(child.childrenByTags(['enemy', 'collidable'])).toContain(enemy)\n\nexpect(child.childrenByTags(['friendly', 'collidable'])).toHaveLength(1)\nexpect(child.childrenByTags(['friendly', 'collidable'])).toContain(friendly)"
              },
              {
                "title": "tag changes work correctly when adding index before creating children",
                "line": 1875,
                "source": "child.addTagsIndex(['enemy', 'collidable'])\n\nconst enemy1 = child.create(PerkyModule, {$id: 'enemy1', $tags: ['enemy']})\nconst enemy2 = child.create(PerkyModule, {$id: 'enemy2', $tags: ['enemy', 'collidable']})\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toEqual([enemy2])\n\nenemy1.tags.add('collidable')\n\nconst result = child.childrenByTags(['enemy', 'collidable'])\nexpect(result).toHaveLength(2)\nexpect(result).toContain(enemy1)\nexpect(result).toContain(enemy2)\n\nenemy2.tags.delete('enemy')\n\nconst result2 = child.childrenByTags(['enemy', 'collidable'])\nexpect(result2).toHaveLength(1)\nexpect(result2).toContain(enemy1)"
              },
              {
                "title": "listeners are set up for existing children when adding a new index",
                "line": 1898,
                "source": "const testChild = child.create(PerkyModule, {$id: 'test', $tags: ['enemy']})\n\nchild.addTagsIndex(['enemy', 'collidable'])\n\ntestChild.tags.add('collidable')\n\nconst result = child.childrenByTags(['enemy', 'collidable'])\nexpect(result).toHaveLength(1)\nexpect(result).toContain(testChild)"
              }
            ],
            "describes": []
          },
          {
            "title": "query and queryAll",
            "line": 1913,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "query finds direct child by id",
                "line": 1915,
                "source": "const player = child.create(PerkyModule, {$id: 'player'})\n\nconst result = child.query('#player')\n\nexpect(result).toBe(player)"
              },
              {
                "title": "query returns null when not found",
                "line": 1924,
                "source": "child.create(PerkyModule, {$id: 'player'})\n\nconst result = child.query('#enemy')\n\nexpect(result).toBeNull()"
              },
              {
                "title": "query finds child by tag",
                "line": 1933,
                "source": "const enemy = child.create(PerkyModule, {$id: 'e1', $tags: ['enemy']})\n\nconst result = child.query('.enemy')\n\nexpect(result).toBe(enemy)"
              },
              {
                "title": "query finds nested children",
                "line": 1942,
                "source": "const world = child.create(PerkyModule, {$id: 'world'})\nconst player = world.create(PerkyModule, {$id: 'player'})\n\nconst result = child.query('#world #player')\n\nexpect(result).toBe(player)"
              },
              {
                "title": "queryAll finds all matching children",
                "line": 1952,
                "source": "const enemy1 = child.create(PerkyModule, {$id: 'e1', $tags: ['enemy']})\nconst enemy2 = child.create(PerkyModule, {$id: 'e2', $tags: ['enemy']})\nchild.create(PerkyModule, {$id: 'player'})\n\nconst result = child.queryAll('.enemy')\n\nexpect(result).toHaveLength(2)\nexpect(result).toContain(enemy1)\nexpect(result).toContain(enemy2)"
              },
              {
                "title": "queryAll returns empty array when none found",
                "line": 1965,
                "source": "child.create(PerkyModule, {$id: 'player'})\n\nconst result = child.queryAll('.enemy')\n\nexpect(result).toEqual([])"
              },
              {
                "title": "queryAll finds nested children from multiple parents",
                "line": 1974,
                "source": "const scene1 = child.create(PerkyModule, {$id: 's1', $category: 'scene'})\nconst scene2 = child.create(PerkyModule, {$id: 's2', $category: 'scene'})\nconst enemy1 = scene1.create(PerkyModule, {$id: 'e1', $tags: ['enemy']})\nconst enemy2 = scene2.create(PerkyModule, {$id: 'e2', $tags: ['enemy']})\n\nconst result = child.queryAll('@scene .enemy')\n\nexpect(result).toHaveLength(2)\nexpect(result).toContain(enemy1)\nexpect(result).toContain(enemy2)"
              },
              {
                "title": "query with combined selectors",
                "line": 1988,
                "source": "child.create(PerkyModule, {$id: 'e1', $tags: ['enemy']})\nconst boss = child.create(PerkyModule, {$id: 'e2', $tags: ['enemy', 'boss']})\n\nconst result = child.query('.enemy.boss')\n\nexpect(result).toBe(boss)"
              }
            ],
            "describes": []
          },
          {
            "title": "childrenByCategory",
            "line": 2000,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns children matching category",
                "line": 2002,
                "source": "const controller1 = child.create(PerkyModule, {$id: 'c1', $category: 'controller'})\nconst controller2 = child.create(PerkyModule, {$id: 'c2', $category: 'controller'})\nchild.create(PerkyModule, {$id: 's1', $category: 'service'})\n\nconst controllers = child.childrenByCategory('controller')\n\nexpect(controllers).toHaveLength(2)\nexpect(controllers).toContain(controller1)\nexpect(controllers).toContain(controller2)"
              },
              {
                "title": "returns empty array for non-existent category",
                "line": 2015,
                "source": "child.create(PerkyModule, {$id: 'c1', $category: 'controller'})\n\nconst result = child.childrenByCategory('nonexistent')\n\nexpect(result).toEqual([])"
              }
            ],
            "describes": []
          },
          {
            "title": "cleanEventDelegations",
            "line": 2026,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "removes all event delegations",
                "line": 2028,
                "source": "const hostModule = new PerkyModule({$id: 'host'})\nconst childModule = hostModule.create(PerkyModule, {$id: 'child'})\n\nconst spy = vi.fn()\nhostModule.on('update', spy)\n\nchildModule.delegateEventsTo(hostModule, ['update'])\n\nchildModule.emit('update', 1)\nexpect(spy).toHaveBeenCalledTimes(1)\n\nchildModule.cleanEventDelegations()\n\nchildModule.emit('update', 2)\nexpect(spy).toHaveBeenCalledTimes(1)"
              },
              {
                "title": "cleanEventDelegations clears delegation list",
                "line": 2047,
                "source": "const hostModule = new PerkyModule({$id: 'host'})\nconst childModule = new PerkyModule({$id: 'child'})\n\nchildModule.delegateEventsTo(hostModule, ['update', 'render'])\n\nchildModule.cleanEventDelegations()\n\nchildModule.delegateEventsTo(hostModule, ['update'])\n\nconst spy = vi.fn()\nhostModule.on('update', spy)\nchildModule.emit('update')\nexpect(spy).toHaveBeenCalledTimes(1)"
              }
            ],
            "describes": []
          },
          {
            "title": "link / unlink",
            "line": 2066,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "link stores reference to another module",
                "line": 2068,
                "source": "const moduleA = new PerkyModule({$id: 'moduleA'})\nconst moduleB = new PerkyModule({$id: 'moduleB'})\n\nmoduleA.link(moduleB, 'linkedModule')\n\nexpect(moduleA.linked).toHaveLength(1)\nexpect(moduleA.getLinked('linkedModule')).toBe(moduleB)\nexpect(moduleA.hasLinked('linkedModule')).toBe(true)"
              },
              {
                "title": "link creates alias on the module",
                "line": 2080,
                "source": "const moduleA = new PerkyModule({$id: 'moduleA'})\nconst moduleB = new PerkyModule({$id: 'moduleB'})\n\nmoduleA.link(moduleB, 'myAlias')\n\nexpect(moduleA.myAlias).toBe(moduleB)"
              },
              {
                "title": "link uses $id as key and creates bind when no alias provided",
                "line": 2090,
                "source": "const moduleA = new PerkyModule({$id: 'moduleA'})\nconst moduleB = new PerkyModule({$id: 'moduleB'})\n\nmoduleA.link(moduleB)\n\nexpect(moduleA.getLinked('moduleB')).toBe(moduleB)\nexpect(moduleA.hasLinked('moduleB')).toBe(true)\nexpect(moduleA.moduleB).toBe(moduleB)"
              },
              {
                "title": "link with false alias does not create bind",
                "line": 2102,
                "source": "const moduleA = new PerkyModule({$id: 'moduleA'})\nconst moduleB = new PerkyModule({$id: 'moduleB'})\n\nmoduleA.link(moduleB, false)\n\nexpect(moduleA.getLinked('moduleB')).toBe(moduleB)\nexpect(moduleA.moduleB).toBeUndefined()"
              },
              {
                "title": "link emits link event",
                "line": 2113,
                "source": "const moduleA = new PerkyModule({$id: 'moduleA'})\nconst moduleB = new PerkyModule({$id: 'moduleB'})\nconst spy = vi.fn()\n\nmoduleA.on('link', spy)\nmoduleA.link(moduleB, 'linkedModule')\n\nexpect(spy).toHaveBeenCalledWith('linkedModule', moduleB)"
              },
              {
                "title": "unlink removes the reference",
                "line": 2125,
                "source": "const moduleA = new PerkyModule({$id: 'moduleA'})\nconst moduleB = new PerkyModule({$id: 'moduleB'})\n\nmoduleA.link(moduleB, 'linkedModule')\nconst result = moduleA.unlink('linkedModule')\n\nexpect(result).toBe(true)\nexpect(moduleA.getLinked('linkedModule')).toBeNull()\nexpect(moduleA.hasLinked('linkedModule')).toBe(false)\nexpect(moduleA.linked).toHaveLength(0)"
              },
              {
                "title": "unlink removes the alias",
                "line": 2139,
                "source": "const moduleA = new PerkyModule({$id: 'moduleA'})\nconst moduleB = new PerkyModule({$id: 'moduleB'})\n\nmoduleA.link(moduleB, 'myAlias')\nmoduleA.unlink('myAlias')\n\nexpect(moduleA.myAlias).toBeUndefined()"
              },
              {
                "title": "unlink emits unlink event",
                "line": 2150,
                "source": "const moduleA = new PerkyModule({$id: 'moduleA'})\nconst moduleB = new PerkyModule({$id: 'moduleB'})\nconst spy = vi.fn()\n\nmoduleA.link(moduleB, 'linkedModule')\nmoduleA.on('unlink', spy)\nmoduleA.unlink('linkedModule')\n\nexpect(spy).toHaveBeenCalledWith('linkedModule', moduleB)"
              },
              {
                "title": "unlink returns false for non-existent key",
                "line": 2163,
                "source": "const moduleA = new PerkyModule({$id: 'moduleA'})\n\nconst result = moduleA.unlink('nonexistent')\n\nexpect(result).toBe(false)"
              },
              {
                "title": "linked module dispose triggers automatic unlink",
                "line": 2172,
                "source": "const moduleA = new PerkyModule({$id: 'moduleA'})\nconst moduleB = new PerkyModule({$id: 'moduleB'})\nconst spy = vi.fn()\n\nmoduleA.link(moduleB, 'linkedModule')\nmoduleA.on('unlink', spy)\n\nmoduleB.dispose()\n\nexpect(moduleA.getLinked('linkedModule')).toBeNull()\nexpect(moduleA.linked).toHaveLength(0)\nexpect(spy).toHaveBeenCalledWith('linkedModule', moduleB)"
              },
              {
                "title": "dispose cleans up all linked modules",
                "line": 2188,
                "source": "const moduleA = new PerkyModule({$id: 'moduleA'})\nconst moduleB = new PerkyModule({$id: 'moduleB'})\nconst moduleC = new PerkyModule({$id: 'moduleC'})\n\nmoduleA.link(moduleB, 'linkB')\nmoduleA.link(moduleC, 'linkC')\n\nmoduleA.dispose()\n\nexpect(moduleA.linked).toHaveLength(0)"
              },
              {
                "title": "unlinkAll removes all links",
                "line": 2202,
                "source": "const moduleA = new PerkyModule({$id: 'moduleA'})\nconst moduleB = new PerkyModule({$id: 'moduleB'})\nconst moduleC = new PerkyModule({$id: 'moduleC'})\n\nmoduleA.link(moduleB, 'linkB')\nmoduleA.link(moduleC, 'linkC')\n\nmoduleA.unlinkAll()\n\nexpect(moduleA.linked).toHaveLength(0)\nexpect(moduleA.linkB).toBeUndefined()\nexpect(moduleA.linkC).toBeUndefined()"
              },
              {
                "title": "link throws if not a PerkyModule",
                "line": 2218,
                "source": "const moduleA = new PerkyModule({$id: 'moduleA'})\n\nexpect(() => moduleA.link({}, 'notAModule')).toThrow('link expects a PerkyModule instance')"
              },
              {
                "title": "link replaces existing link with same key",
                "line": 2225,
                "source": "const moduleA = new PerkyModule({$id: 'moduleA'})\nconst moduleB = new PerkyModule({$id: 'moduleB'})\nconst moduleC = new PerkyModule({$id: 'moduleC'})\n\nmoduleA.link(moduleB, 'linkedModule')\nmoduleA.link(moduleC, 'linkedModule')\n\nexpect(moduleA.getLinked('linkedModule')).toBe(moduleC)\nexpect(moduleA.linked).toHaveLength(1)"
              },
              {
                "title": "linking does not affect the linked module lifecycle",
                "line": 2238,
                "source": "const moduleA = new PerkyModule({$id: 'moduleA'})\nconst moduleB = new PerkyModule({$id: 'moduleB'})\n\nmoduleA.link(moduleB, 'linkedModule')\n\n// moduleB should not be installed\nexpect(moduleB.installed).toBe(false)\nexpect(moduleB.host).toBeNull()\n\n// disposing moduleA should not dispose moduleB\nmoduleA.dispose()\n\nexpect(moduleB.disposed).toBe(false)"
              },
              {
                "title": "linked getter returns array of all linked modules",
                "line": 2255,
                "source": "const moduleA = new PerkyModule({$id: 'moduleA'})\nconst moduleB = new PerkyModule({$id: 'moduleB'})\nconst moduleC = new PerkyModule({$id: 'moduleC'})\n\nmoduleA.link(moduleB, 'linkB')\nmoduleA.link(moduleC, 'linkC')\n\nconst linked = moduleA.linked\nexpect(linked).toHaveLength(2)\nexpect(linked).toContain(moduleB)\nexpect(linked).toContain(moduleC)"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/core/utils.doc.js": {
    "file": "/core/utils.test.js",
    "describes": [
      {
        "title": "String Utils",
        "line": 26,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "toCamelCase",
            "line": 28,
            "source": "expect(toCamelCase('hello_world')).toEqual('helloWorld')\nexpect(toCamelCase('hello-world')).toEqual('helloWorld')\nexpect(toCamelCase('hello world')).toEqual('helloWorld')\nexpect(toCamelCase('HelloWorld')).toEqual('helloWorld')\nexpect(toCamelCase('Hello')).toEqual('hello')"
          },
          {
            "title": "toPascalCase",
            "line": 37,
            "source": "expect(toPascalCase('hello_world')).toEqual('HelloWorld')\nexpect(toPascalCase('hello-world')).toEqual('HelloWorld')\nexpect(toPascalCase('hello world')).toEqual('HelloWorld')\nexpect(toPascalCase('HelloWorld')).toEqual('HelloWorld')\nexpect(toPascalCase('Hello')).toEqual('Hello')"
          },
          {
            "title": "toSnakeCase",
            "line": 46,
            "source": "expect(toSnakeCase('helloWorld')).toEqual('hello_world')\nexpect(toSnakeCase('HelloWorld')).toEqual('hello_world')\nexpect(toSnakeCase('hello-world')).toEqual('hello_world')\nexpect(toSnakeCase('hello world')).toEqual('hello_world')\nexpect(toSnakeCase('Hello')).toEqual('hello')"
          },
          {
            "title": "toKebabCase",
            "line": 55,
            "source": "expect(toKebabCase('helloWorld')).toEqual('hello-world')\nexpect(toKebabCase('HelloWorld')).toEqual('hello-world')\nexpect(toKebabCase('hello_world')).toEqual('hello-world')\nexpect(toKebabCase('hello world')).toEqual('hello-world')\nexpect(toKebabCase('Hello')).toEqual('hello')"
          },
          {
            "title": "toHumanCase",
            "line": 64,
            "source": "expect(toHumanCase('GettingStarted')).toEqual('Getting Started')\nexpect(toHumanCase('helloWorld')).toEqual('hello World')\nexpect(toHumanCase('hello_world')).toEqual('hello world')\nexpect(toHumanCase('hello-world')).toEqual('hello world')\nexpect(toHumanCase('HTMLParser')).toEqual('HTML Parser')\nexpect(toHumanCase('Hello')).toEqual('Hello')"
          },
          {
            "title": "singularize",
            "line": 74,
            "source": "expect(singularize('books')).toEqual('book')\nexpect(singularize('cars')).toEqual('car')\nexpect(singularize('houses')).toEqual('house')\n\nexpect(singularize('boxes')).toEqual('box')\nexpect(singularize('dishes')).toEqual('dish')\nexpect(singularize('buses')).toEqual('bus')\nexpect(singularize('wishes')).toEqual('wish')\n\nexpect(singularize('cities')).toEqual('city')\nexpect(singularize('flies')).toEqual('fly')\nexpect(singularize('stories')).toEqual('story')\n\nexpect(singularize('leaves')).toEqual('leaf')\nexpect(singularize('lives')).toEqual('life')\nexpect(singularize('wolves')).toEqual('wolf')\n\nexpect(singularize('men')).toEqual('man')\nexpect(singularize('women')).toEqual('woman')\nexpect(singularize('children')).toEqual('child')\nexpect(singularize('people')).toEqual('person')\nexpect(singularize('mice')).toEqual('mouse')\nexpect(singularize('feet')).toEqual('foot')\nexpect(singularize('teeth')).toEqual('tooth')\nexpect(singularize('cacti')).toEqual('cactus')\n\nexpect(singularize('fish')).toEqual('fish')\nexpect(singularize('deer')).toEqual('deer')"
          },
          {
            "title": "pluralize",
            "line": 106,
            "source": "expect(pluralize('cat', 1)).toEqual('cat')\nexpect(pluralize('cat', 2)).toEqual('cats')\nexpect(pluralize('cat', 0)).toEqual('cats')\nexpect(pluralize('child', 1)).toEqual('child')\nexpect(pluralize('child', 5)).toEqual('children')\nexpect(pluralize('cat', 1, true)).toEqual('1 cat')\nexpect(pluralize('cat', 3, true)).toEqual('3 cats')"
          },
          {
            "title": "plural",
            "line": 117,
            "source": "expect(plural('cat')).toEqual('cats')\nexpect(plural('child')).toEqual('children')\nexpect(plural('person')).toEqual('people')\nexpect(plural('fish')).toEqual('fish')"
          },
          {
            "title": "isPlural",
            "line": 125,
            "source": "expect(isPlural('cats')).toBe(true)\nexpect(isPlural('children')).toBe(true)\nexpect(isPlural('cat')).toBe(false)\nexpect(isPlural('child')).toBe(false)"
          },
          {
            "title": "isSingular",
            "line": 133,
            "source": "expect(isSingular('cat')).toBe(true)\nexpect(isSingular('child')).toBe(true)\nexpect(isSingular('cats')).toBe(false)\nexpect(isSingular('children')).toBe(false)"
          },
          {
            "title": "uniqueId",
            "line": 141,
            "source": "beforeEach(() => {\n    resetUniqueId('testCollection')\n    resetUniqueId('anotherCollection')\n})\n\nconst id1 = uniqueId('testCollection', 'item')\nexpect(id1).toBe('item')\n\nconst id2 = uniqueId('testCollection', 'item')\nexpect(id2).toBe('item_1')\n\nconst id3 = uniqueId('testCollection', 'item')\nexpect(id3).toBe('item_2')\n\nconst user1 = uniqueId('testCollection', 'user')\nexpect(user1).toBe('user')\n\nconst user2 = uniqueId('testCollection', 'user')\nexpect(user2).toBe('user_1')\n\nconst product1 = uniqueId('anotherCollection', 'product')\nexpect(product1).toBe('product')\n\nconst product2 = uniqueId('anotherCollection', 'product')\nexpect(product2).toBe('product_1')\n\nconst single1 = uniqueId('single')\nexpect(single1).toBe('single')\n\nconst single2 = uniqueId('single')\nexpect(single2).toBe('single_1')\n\nconst single3 = uniqueId('single')\nexpect(single3).toBe('single_2')\n\nconst other1 = uniqueId('other')\nexpect(other1).toBe('other')\n\nconst other2 = uniqueId('other')\nexpect(other2).toBe('other_1')"
          },
          {
            "title": "resetUniqueId",
            "line": 185,
            "source": "// Start fresh\nresetUniqueId('testCollection')\n\nuniqueId('testCollection', 'item')\nuniqueId('testCollection', 'item')\nuniqueId('testCollection', 'user')\n\nresetUniqueId('testCollection', 'item')\n\nconst newItem = uniqueId('testCollection', 'item')\nexpect(newItem).toBe('item')\n\nconst newUser = uniqueId('testCollection', 'user')\nexpect(newUser).toBe('user_1')\n\nresetUniqueId('testCollection')\n\nconst resetItem = uniqueId('testCollection', 'item')\nexpect(resetItem).toBe('item')\n\nconst resetUser = uniqueId('testCollection', 'user')\nexpect(resetUser).toBe('user')"
          }
        ],
        "describes": []
      },
      {
        "title": "Object Utils",
        "line": 213,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "deepMerge",
            "line": 215,
            "source": "expect(deepMerge({a: 1}, {b: 2})).toEqual({a: 1, b: 2})\nexpect(deepMerge({a: 1, b: 2}, {b: 3})).toEqual({a: 1, b: 3})\n\nexpect(deepMerge(\n    {a: {b: 1, c: 2}},\n    {a: {c: 3, d: 4}}\n)).toEqual({a: {b: 1, c: 3, d: 4}})\n\nexpect(deepMerge(\n    {a: [1, 2]},\n    {a: [3, 4]}\n)).toEqual({a: [1, 2, 3, 4]})\n\nexpect(deepMerge({a: 1}, null)).toEqual({a: 1})\nexpect(deepMerge({a: 1}, undefined)).toEqual({a: 1})"
          },
          {
            "title": "deepMerge preserves class instances by reference",
            "line": 234,
            "source": "class Custom {\n    constructor (value) {\n        this.value = value\n    }\n}\n\nconst instance = new Custom(42)\nconst result = deepMerge({}, {a: instance, b: {nested: instance}})\n\nexpect(result.a).toBe(instance)\nexpect(result.a).toBeInstanceOf(Custom)\nexpect(result.a.value).toBe(42)\nexpect(result.b.nested).toBe(instance)"
          },
          {
            "title": "deepMerge handles circular references",
            "line": 251,
            "source": "const circular = {a: 1}\ncircular.self = circular\n\nexpect(() => {\n    deepMerge({}, circular)\n}).not.toThrow()\n\nconst result = deepMerge({b: 2}, circular)\nexpect(result.a).toBe(1)\nexpect(result.b).toBe(2)\nexpect(result.self).toBe(circular)"
          },
          {
            "title": "setDefaults",
            "line": 266,
            "source": "expect(setDefaults({a: 1}, {a: 0, b: 2})).toEqual({a: 1, b: 2})\n\nexpect(setDefaults(\n    {a: {b: 1}},\n    {a: {b: 0, c: 2}, d: 3}\n)).toEqual({a: {b: 1, c: 2}, d: 3})\n\nexpect(setDefaults({}, {a: 1, b: 2})).toEqual({a: 1, b: 2})\n\nexpect(setDefaults(null, {a: 1, b: 2})).toEqual({a: 1, b: 2})\nexpect(setDefaults(undefined, {a: 1, b: 2})).toEqual({a: 1, b: 2})"
          },
          {
            "title": "getNestedValue",
            "line": 281,
            "source": "const obj = {\n    a: 1,\n    b: {\n        c: 2,\n        d: {\n            e: 3\n        }\n    }\n}\n\nexpect(getNestedValue(obj, 'a')).toBe(1)\nexpect(getNestedValue(obj, 'b.c')).toBe(2)\nexpect(getNestedValue(obj, 'b.d.e')).toBe(3)\n\nexpect(getNestedValue(obj, 'x')).toBeUndefined()\nexpect(getNestedValue(obj, 'b.x')).toBeUndefined()\nexpect(getNestedValue(obj, 'b.d.x')).toBeUndefined()\n\nexpect(getNestedValue(obj)).toEqual(obj)"
          },
          {
            "title": "setNestedValue",
            "line": 304,
            "source": "const obj = {}\n\nsetNestedValue(obj, 'a', 1)\nexpect(obj).toEqual({a: 1})\n\nsetNestedValue(obj, 'b.c', 2)\nexpect(obj.b.c).toBe(2)\n\nsetNestedValue(obj, 'b.c', 3)\nexpect(obj.b.c).toBe(3)\n\nsetNestedValue(obj, 'b.d.e', 4)\nexpect(obj.b.d.e).toBe(4)\nexpect(obj).toEqual({a: 1, b: {c: 3, d: {e: 4}}})"
          }
        ],
        "describes": []
      },
      {
        "title": "delegateProperties",
        "line": 324,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "delegates methods with array notation",
            "line": 326,
            "source": "const source = {\n    method1: () => 'result1',\n    method2: () => 'result2'\n}\nconst receiver = {}\n\ndelegateProperties(receiver, source, ['method1', 'method2'])\n\nexpect(receiver.method1()).toBe('result1')\nexpect(receiver.method2()).toBe('result2')"
          },
          {
            "title": "delegates properties with array notation",
            "line": 340,
            "source": "const source = {prop1: 'value1', prop2: 'value2'}\nconst receiver = {}\n\ndelegateProperties(receiver, source, ['prop1', 'prop2'])\n\nexpect(receiver.prop1).toBe('value1')\nexpect(receiver.prop2).toBe('value2')"
          },
          {
            "title": "property changes reflect on source",
            "line": 351,
            "source": "const source = {prop: 'initial'}\nconst receiver = {}\n\ndelegateProperties(receiver, source, ['prop'])\n\nreceiver.prop = 'changed'\nexpect(source.prop).toBe('changed')"
          },
          {
            "title": "delegates with object notation (aliasing)",
            "line": 362,
            "source": "const source = {\n    originalMethod: () => 'result',\n    originalProp: 'value'\n}\nconst receiver = {}\n\ndelegateProperties(receiver, source, {\n    originalMethod: 'aliasedMethod',\n    originalProp: 'aliasedProp'\n})\n\nexpect(receiver.aliasedMethod()).toBe('result')\nexpect(receiver.aliasedProp).toBe('value')"
          },
          {
            "title": "delegates getters and setters",
            "line": 379,
            "source": "let internalValue = 10\nconst source = {}\nObject.defineProperty(source, 'value', {\n    get () {\n        return internalValue\n    },\n    set (newValue) {\n        internalValue = newValue\n    },\n    enumerable: true,\n    configurable: true\n})\n\nconst receiver = {}\ndelegateProperties(receiver, source, ['value'])\n\nexpect(receiver.value).toBe(10)\nreceiver.value = 20\nexpect(internalValue).toBe(20)\nexpect(receiver.value).toBe(20)"
          },
          {
            "title": "methods are bound to source context",
            "line": 403,
            "source": "const source = {\n    name: 'source',\n    getName () {\n        return this.name\n    }\n}\nconst receiver = {name: 'receiver'}\n\ndelegateProperties(receiver, source, ['getName'])\n\nexpect(receiver.getName()).toBe('source')"
          }
        ],
        "describes": []
      },
      {
        "title": "exportValue",
        "line": 420,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "returns primitive values as-is",
            "line": 422,
            "source": "expect(exportValue(42)).toBe(42)\nexpect(exportValue('hello')).toBe('hello')\nexpect(exportValue(true)).toBe(true)\nexpect(exportValue(null)).toBe(null)\nexpect(exportValue(undefined)).toBe(undefined)"
          },
          {
            "title": "calls export method if available",
            "line": 431,
            "source": "const obj = {\n    value: 42,\n    export () {\n        return {exported: this.value}\n    }\n}\n\nexpect(exportValue(obj)).toEqual({exported: 42})"
          },
          {
            "title": "recursively exports arrays",
            "line": 443,
            "source": "const arr = [1, 2, {value: 3, export: () => 'exported'}]\n\nexpect(exportValue(arr)).toEqual([1, 2, 'exported'])"
          },
          {
            "title": "recursively exports object properties",
            "line": 450,
            "source": "const obj = {\n    a: 1,\n    b: {\n        c: 2,\n        export: () => 'nested'\n    }\n}\n\nexpect(exportValue(obj)).toEqual({a: 1, b: 'nested'})"
          }
        ],
        "describes": []
      },
      {
        "title": "formatNumber",
        "line": 465,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "formats integers without decimals",
            "line": 467,
            "source": "expect(formatNumber(42)).toBe('42')\nexpect(formatNumber(1000)).toBe('1000')\nexpect(formatNumber(0)).toBe('0')"
          },
          {
            "title": "formats floats with 2 decimal places",
            "line": 474,
            "source": "expect(formatNumber(3.14159)).toBe('3.14')\nexpect(formatNumber(42.5)).toBe('42.50')\nexpect(formatNumber(0.123)).toBe('0.12')"
          },
          {
            "title": "handles non-numbers",
            "line": 481,
            "source": "expect(formatNumber('hello')).toBe('hello')\nexpect(formatNumber(null)).toBe('null')"
          }
        ],
        "describes": []
      },
      {
        "title": "formatBytes",
        "line": 489,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "formats 0 bytes",
            "line": 491,
            "source": "expect(formatBytes(0)).toBe('0 B')"
          },
          {
            "title": "formats bytes",
            "line": 496,
            "source": "expect(formatBytes(500)).toBe('500 B')\nexpect(formatBytes(1023)).toBe('1023 B')"
          },
          {
            "title": "formats kilobytes",
            "line": 502,
            "source": "expect(formatBytes(1024)).toBe('1 KB')\nexpect(formatBytes(2048)).toBe('2 KB')"
          },
          {
            "title": "formats megabytes",
            "line": 508,
            "source": "expect(formatBytes(1024 * 1024)).toBe('1.00 MB')\nexpect(formatBytes(1.5 * 1024 * 1024)).toBe('1.50 MB')"
          },
          {
            "title": "formats gigabytes",
            "line": 514,
            "source": "expect(formatBytes(1024 * 1024 * 1024)).toBe('1.00 GB')\nexpect(formatBytes(2.5 * 1024 * 1024 * 1024)).toBe('2.50 GB')"
          }
        ],
        "describes": []
      }
    ]
  },
  "/core/action_controller.doc.js": {
    "file": "/core/action_controller.test.js",
    "describes": [
      {
        "title": "ActionController",
        "line": 6,
        "beforeEach": {
          "line": 10,
          "source": "controller = new ActionController()"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor",
            "line": 15,
            "source": "expect(controller.getAction('any')).toBeUndefined()"
          },
          {
            "title": "static resources is empty by default",
            "line": 20,
            "source": "expect(ActionController.resources).toEqual([])"
          },
          {
            "title": "addAction and getAction",
            "line": 166,
            "source": "const action = vi.fn()\n\ncontroller.addAction('testAction', action)\n\nexpect(controller.getAction('testAction')).toBe(action)"
          },
          {
            "title": "removeAction",
            "line": 175,
            "source": "const action = vi.fn()\n\ncontroller.addAction('testAction', action)\ncontroller.removeAction('testAction')\n\nexpect(controller.getAction('testAction')).toBeUndefined()"
          },
          {
            "title": "hasAction - registered action",
            "line": 185,
            "source": "const action = vi.fn()\ncontroller.addAction('testAction', action)\n\nexpect(controller.hasAction('testAction')).toBe(true)"
          },
          {
            "title": "hasAction - method action",
            "line": 193,
            "source": "class TestController extends ActionController {\n    testMethod () { }\n}\n\nconst testController = new TestController()\nexpect(testController.hasAction('testMethod')).toBe(true)"
          },
          {
            "title": "hasAction - non-existent action",
            "line": 203,
            "source": "expect(controller.hasAction('nonExistent')).toBe(false)"
          },
          {
            "title": "shouldPropagate - default (no propagable)",
            "line": 208,
            "source": "expect(controller.shouldPropagate('anyAction')).toBe(false)"
          },
          {
            "title": "shouldPropagate - with propagable whitelist",
            "line": 213,
            "source": "class TestController extends ActionController {\n    static propagable = ['move', 'look']\n}\n\nconst testController = new TestController()\n\nexpect(testController.shouldPropagate('move')).toBe(true)\nexpect(testController.shouldPropagate('look')).toBe(true)\nexpect(testController.shouldPropagate('shoot')).toBe(false)"
          },
          {
            "title": "listActions - registered actions",
            "line": 226,
            "source": "controller.addAction('action1', vi.fn())\ncontroller.addAction('action2', vi.fn())\n\nconst actions = controller.listActions()\n\nexpect(actions).toContain('action1')\nexpect(actions).toContain('action2')"
          },
          {
            "title": "listActions - method actions",
            "line": 237,
            "source": "class TestController extends ActionController {\n    jump () { }\n    move () { }\n}\n\nconst testController = new TestController()\nconst actions = testController.listActions()\n\nexpect(actions).toContain('jump')\nexpect(actions).toContain('move')"
          },
          {
            "title": "listActions - excludes internal methods",
            "line": 251,
            "source": "const actions = controller.listActions()\n\nexpect(actions).not.toContain('start')\nexpect(actions).not.toContain('stop')\nexpect(actions).not.toContain('addAction')\nexpect(actions).not.toContain('execute')"
          },
          {
            "title": "listActionsWithParams - returns actions with parameters",
            "line": 261,
            "source": "const testController = new ActionController()\ntestController.addAction('jump', (height, force = 10) => [height, force])\ntestController.addAction('move', (x, y) => [x, y])\n\nconst actionsWithParams = testController.listActionsWithParams()\n\nconst jumpAction = actionsWithParams.find(a => a.name === 'jump')\nexpect(jumpAction).toBeDefined()\nexpect(jumpAction.params).toEqual([\n    {name: 'height', defaultValue: null},\n    {name: 'force', defaultValue: '10'}\n])\n\nconst moveAction = actionsWithParams.find(a => a.name === 'move')\nexpect(moveAction).toBeDefined()\nexpect(moveAction.params).toEqual([\n    {name: 'x', defaultValue: null},\n    {name: 'y', defaultValue: null}\n])"
          },
          {
            "title": "listActionsWithParams - includes registered actions",
            "line": 284,
            "source": "controller.addAction('customAction', (value) => value * 2)\n\nconst actionsWithParams = controller.listActionsWithParams()\n\nconst customAction = actionsWithParams.find(a => a.name === 'customAction')\nexpect(customAction).toBeDefined()\nexpect(customAction.params).toEqual([{name: 'value', defaultValue: null}])"
          },
          {
            "title": "listActionsWithParams - handles functions with no params",
            "line": 295,
            "source": "controller.addAction('noParams', () => {})\n\nconst actionsWithParams = controller.listActionsWithParams()\n\nconst noParamsAction = actionsWithParams.find(a => a.name === 'noParams')\nexpect(noParamsAction).toBeDefined()\nexpect(noParamsAction.params).toEqual([])"
          },
          {
            "title": "listActionsWithParams - handles rest parameters",
            "line": 306,
            "source": "controller.addAction('withRest', (first, ...rest) => [first, rest])\n\nconst actionsWithParams = controller.listActionsWithParams()\n\nconst action = actionsWithParams.find(a => a.name === 'withRest')\nexpect(action).toBeDefined()\nexpect(action.params).toEqual([{name: 'first', defaultValue: null}])"
          },
          {
            "title": "execute with existing registered action",
            "line": 317,
            "source": "const action = vi.fn()\nconst actionListener = vi.fn()\nconst genericListener = vi.fn()\n\ncontroller.addAction('testAction', action)\ncontroller.on('testAction', actionListener)\ncontroller.on('action', genericListener)\n\ncontroller.execute('testAction', 'arg1', 'arg2')\n\nexpect(action).toHaveBeenCalledWith('arg1', 'arg2')\nexpect(actionListener).toHaveBeenCalledWith('arg1', 'arg2')\nexpect(genericListener).toHaveBeenCalledWith('testAction', 'arg1', 'arg2')"
          },
          {
            "title": "execute with method action",
            "line": 334,
            "source": "const action = vi.fn()\nconst actionListener = vi.fn()\n\ncontroller.addAction('testMethod', action)\ncontroller.on('testMethod', actionListener)\n\ncontroller.execute('testMethod', 'arg1')\n\nexpect(action).toHaveBeenCalledWith('arg1')\nexpect(actionListener).toHaveBeenCalledWith('arg1')"
          },
          {
            "title": "execute with non-existent action still emits events",
            "line": 348,
            "source": "const actionListener = vi.fn()\nconst genericListener = vi.fn()\n\ncontroller.on('nonExistentAction', actionListener)\ncontroller.on('action', genericListener)\n\ncontroller.execute('nonExistentAction', 'arg1', 'arg2')\n\nexpect(actionListener).toHaveBeenCalledWith('arg1', 'arg2')\nexpect(genericListener).toHaveBeenCalledWith('nonExistentAction', 'arg1', 'arg2')"
          },
          {
            "title": "multiple event listeners",
            "line": 362,
            "source": "const action = vi.fn()\nconst listener1 = vi.fn()\nconst listener2 = vi.fn()\nconst genericListener = vi.fn()\n\ncontroller.addAction('testAction', action)\ncontroller.on('testAction', listener1)\ncontroller.on('testAction', listener2)\ncontroller.on('action', genericListener)\n\ncontroller.execute('testAction', 'arg')\n\nexpect(action).toHaveBeenCalledWith('arg')\nexpect(listener1).toHaveBeenCalledWith('arg')\nexpect(listener2).toHaveBeenCalledWith('arg')\nexpect(genericListener).toHaveBeenCalledWith('testAction', 'arg')"
          }
        ],
        "describes": [
          {
            "title": "engine",
            "line": 25,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "engine is null by default when no host",
                "line": 27,
                "source": "expect(controller.engine).toBeNull()"
              },
              {
                "title": "engine can be set explicitly",
                "line": 32,
                "source": "const mockEngine = {name: 'test'}\ncontroller.engine = mockEngine\n\nexpect(controller.engine).toBe(mockEngine)"
              },
              {
                "title": "engine falls back to host.engine",
                "line": 40,
                "source": "const mockEngine = {name: 'test'}\nconst dispatcher = new PerkyModule()\ndispatcher.engine = mockEngine\n\ndispatcher.addChild(controller)\n\nexpect(controller.engine).toBe(mockEngine)"
              },
              {
                "title": "engine falls back to host.host",
                "line": 51,
                "source": "const dispatcher = new PerkyModule()\nconst app = new PerkyModule()\n\napp.addChild(dispatcher)\ndispatcher.addChild(controller)\n\nexpect(controller.engine).toBe(app)"
              },
              {
                "title": "engine falls back to host",
                "line": 62,
                "source": "const host = new PerkyModule()\nhost.addChild(controller)\n\nexpect(controller.engine).toBe(host)"
              },
              {
                "title": "explicit engine takes priority",
                "line": 70,
                "source": "const explicitEngine = {name: 'explicit'}\nconst host = new PerkyModule()\nhost.engine = {name: 'host-engine'}\n\nhost.addChild(controller)\ncontroller.engine = explicitEngine\n\nexpect(controller.engine).toBe(explicitEngine)"
              }
            ],
            "describes": []
          },
          {
            "title": "resource getters",
            "line": 84,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates getters for static resources",
                "line": 86,
                "source": "class TestController extends ActionController {\n    static resources = ['world', 'renderer']\n}\n\nconst mockWorld = {name: 'world'}\nconst mockRenderer = {name: 'renderer'}\nconst mockEngine = {world: mockWorld, renderer: mockRenderer}\n\nconst testController = new TestController()\ntestController.engine = mockEngine\n\nexpect(testController.world).toBe(mockWorld)\nexpect(testController.renderer).toBe(mockRenderer)"
              },
              {
                "title": "getters are lazy - engine can be set after construction",
                "line": 103,
                "source": "class TestController extends ActionController {\n    static resources = ['world']\n}\n\nconst testController = new TestController()\nexpect(testController.world).toBeUndefined()\n\nconst mockWorld = {name: 'world'}\ntestController.engine = {world: mockWorld}\n\nexpect(testController.world).toBe(mockWorld)"
              },
              {
                "title": "getters reflect engine changes",
                "line": 118,
                "source": "class TestController extends ActionController {\n    static resources = ['world']\n}\n\nconst world1 = {name: 'world1'}\nconst world2 = {name: 'world2'}\n\nconst testController = new TestController()\ntestController.engine = {world: world1}\nexpect(testController.world).toBe(world1)\n\ntestController.engine = {world: world2}\nexpect(testController.world).toBe(world2)"
              },
              {
                "title": "can override getter with direct assignment",
                "line": 135,
                "source": "class TestController extends ActionController {\n    static resources = ['world']\n}\n\nconst engineWorld = {name: 'engine'}\nconst directWorld = {name: 'direct'}\n\nconst testController = new TestController()\ntestController.engine = {world: engineWorld}\ntestController.world = directWorld\n\nexpect(testController.world).toBe(directWorld)"
              },
              {
                "title": "skips resources already defined on instance",
                "line": 151,
                "source": "class TestController extends ActionController {\n    static resources = ['world']\n    world = {name: 'predefined'}\n}\n\nconst testController = new TestController()\ntestController.engine = {world: {name: 'engine'}}\n\nexpect(testController.world.name).toBe('predefined')"
              }
            ],
            "describes": []
          },
          {
            "title": "normalizeBindings",
            "line": 382,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "empty bindings",
                "line": 384,
                "source": "class TestController extends ActionController {\n    static bindings = {}\n}\n\nconst normalized = TestController.normalizeBindings('test')\nexpect(normalized).toEqual([])"
              },
              {
                "title": "simple string binding",
                "line": 394,
                "source": "class TestController extends ActionController {\n    static bindings = {\n        shoot: 'Space'\n    }\n}\n\nconst normalized = TestController.normalizeBindings('test')\nexpect(normalized).toEqual([\n    {\n        action: 'shoot',\n        key: 'Space',\n        scoped: false,\n        eventType: 'pressed',\n        controllerName: null\n    }\n])"
              },
              {
                "title": "array of keys binding",
                "line": 414,
                "source": "class TestController extends ActionController {\n    static bindings = {\n        moveUp: ['KeyW', 'ArrowUp']\n    }\n}\n\nconst normalized = TestController.normalizeBindings('test')\nexpect(normalized).toEqual([\n    {\n        action: 'moveUp',\n        key: 'KeyW',\n        scoped: false,\n        eventType: 'pressed',\n        controllerName: null\n    },\n    {\n        action: 'moveUp',\n        key: 'ArrowUp',\n        scoped: false,\n        eventType: 'pressed',\n        controllerName: null\n    }\n])"
              },
              {
                "title": "scoped binding",
                "line": 441,
                "source": "class TestController extends ActionController {\n    static bindings = {\n        shoot: {keys: 'Space', scoped: true}\n    }\n}\n\nconst normalized = TestController.normalizeBindings('game')\nexpect(normalized).toEqual([\n    {\n        action: 'shoot',\n        key: 'Space',\n        scoped: true,\n        eventType: 'pressed',\n        controllerName: 'game'\n    }\n])"
              },
              {
                "title": "scoped binding with multiple keys",
                "line": 461,
                "source": "class TestController extends ActionController {\n    static bindings = {\n        move: {keys: ['KeyW', 'KeyS'], scoped: true}\n    }\n}\n\nconst normalized = TestController.normalizeBindings('game')\nexpect(normalized).toEqual([\n    {\n        action: 'move',\n        key: 'KeyW',\n        scoped: true,\n        eventType: 'pressed',\n        controllerName: 'game'\n    },\n    {\n        action: 'move',\n        key: 'KeyS',\n        scoped: true,\n        eventType: 'pressed',\n        controllerName: 'game'\n    }\n])"
              },
              {
                "title": "custom eventType",
                "line": 488,
                "source": "class TestController extends ActionController {\n    static bindings = {\n        shoot: {keys: 'Space', eventType: 'released'}\n    }\n}\n\nconst normalized = TestController.normalizeBindings('test')\nexpect(normalized).toEqual([\n    {\n        action: 'shoot',\n        key: 'Space',\n        scoped: false,\n        eventType: 'released',\n        controllerName: null\n    }\n])"
              },
              {
                "title": "mixed binding formats",
                "line": 508,
                "source": "class TestController extends ActionController {\n    static bindings = {\n        shoot: 'Space',\n        moveUp: ['KeyW', 'ArrowUp'],\n        jump: {keys: 'KeyJ', scoped: true},\n        dash: {keys: ['KeyD', 'ShiftLeft'], scoped: false, eventType: 'released'}\n    }\n}\n\nconst normalized = TestController.normalizeBindings('player')\nexpect(normalized).toHaveLength(6)\n\nexpect(normalized).toContainEqual({\n    action: 'shoot',\n    key: 'Space',\n    scoped: false,\n    eventType: 'pressed',\n    controllerName: null\n})\n\nexpect(normalized).toContainEqual({\n    action: 'jump',\n    key: 'KeyJ',\n    scoped: true,\n    eventType: 'pressed',\n    controllerName: 'player'\n})"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/core/action_dispatcher.doc.js": {
    "file": "/core/action_dispatcher.test.js",
    "describes": [
      {
        "title": "ActionDispatcher",
        "line": 7,
        "beforeEach": {
          "line": 11,
          "source": "dispatcher = new ActionDispatcher()"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor",
            "line": 16,
            "source": "expect(dispatcher.getController('any')).toBeNull()\nexpect(dispatcher.getActive()).toEqual([])"
          },
          {
            "title": "register",
            "line": 22,
            "source": "const controller = dispatcher.register('main', ActionController)\n\nexpect(dispatcher.getController('main')).toBe(controller)"
          },
          {
            "title": "register with existing name",
            "line": 29,
            "source": "dispatcher.register('main', ActionController)\nconst controller2 = dispatcher.register('main', ActionController)\nexpect(dispatcher.getController('main')).toBe(controller2)"
          },
          {
            "title": "mainController returns null when no controllers registered",
            "line": 36,
            "source": "expect(dispatcher.mainController).toBeNull()"
          },
          {
            "title": "mainController returns first registered controller",
            "line": 41,
            "source": "dispatcher.register('game', ActionController)\ndispatcher.register('ui', ActionController)\n\nexpect(dispatcher.mainController).toBeInstanceOf(ActionController)\nexpect(dispatcher.mainController.$id).toBe('game')"
          },
          {
            "title": "unregister",
            "line": 50,
            "source": "dispatcher.register('main', ActionController)\nconst result = dispatcher.unregister('main')\n\nexpect(result).toBe(true)\nexpect(dispatcher.getController('main')).toBeNull()"
          },
          {
            "title": "unregister non-existent controller",
            "line": 59,
            "source": "const result = dispatcher.unregister('nonExistent')\n\nexpect(result).toBe(false)"
          },
          {
            "title": "unregister active controller",
            "line": 66,
            "source": "dispatcher.register('main', ActionController)\ndispatcher.setActive('main')\ndispatcher.unregister('main')\n\nexpect(dispatcher.getActive()).toEqual([])"
          },
          {
            "title": "unregister controller in stack",
            "line": 75,
            "source": "dispatcher.register('main', ActionController)\ndispatcher.pushActive('main')\n\nexpect(dispatcher.getActive()).toContain('main')\n\ndispatcher.unregister('main')\n\nexpect(dispatcher.getActive()).not.toContain('main')"
          },
          {
            "title": "getController",
            "line": 87,
            "source": "const controller = dispatcher.register('main', ActionController)\n\nexpect(dispatcher.getController('main')).toBe(controller)"
          },
          {
            "title": "setActive valid controller",
            "line": 94,
            "source": "dispatcher.register('main', ActionController)\nconst result = dispatcher.setActive('main')\n\nexpect(result).toBe(true)\nexpect(dispatcher.getActive()).toEqual(['main'])"
          },
          {
            "title": "setActive invalid controller",
            "line": 103,
            "source": "const consoleSpy = vi.spyOn(console, 'warn').mockImplementation(() => { })\n\nconst result = dispatcher.setActive('nonExistent')\n\nexpect(result).toBe(false)\nexpect(dispatcher.getActive()).toEqual([])\nexpect(consoleSpy).toHaveBeenCalled()\n\nconsoleSpy.mockRestore()"
          },
          {
            "title": "setActive with array",
            "line": 116,
            "source": "dispatcher.register('main', ActionController)\ndispatcher.register('pause', ActionController)\n\nconst result = dispatcher.setActive(['main', 'pause'])\n\nexpect(result).toBe(true)\nexpect(dispatcher.getActive()).toEqual(['main', 'pause'])"
          },
          {
            "title": "getActive returns array",
            "line": 127,
            "source": "dispatcher.register('main', ActionController)\ndispatcher.setActive('main')\n\nconst active = dispatcher.getActive()\nexpect(active).toEqual(['main'])\nexpect(Array.isArray(active)).toBe(true)"
          },
          {
            "title": "dispatch - single mode (default)",
            "line": 137,
            "source": "class TestController extends ActionController {\n    someAction = vi.fn()\n}\nconst controller = dispatcher.register('main', TestController)\ndispatcher.setActive('main')\n\ndispatcher.execute('someAction', 'arg1', 'arg2')\n\nexpect(controller.someAction).toHaveBeenCalledWith('arg1', 'arg2')"
          },
          {
            "title": "dispatch - no active controller",
            "line": 150,
            "source": "const consoleSpy = vi.spyOn(console, 'warn').mockImplementation(() => { })\n\ndispatcher.execute('someAction')\n\nexpect(consoleSpy).toHaveBeenCalled()\n\nconsoleSpy.mockRestore()"
          },
          {
            "title": "executeTo",
            "line": 161,
            "source": "class TestController extends PerkyModule {\n    someAction = vi.fn()\n}\nconst controller = dispatcher.register('main', TestController)\ndispatcher.setActive('main')\n\ndispatcher.executeTo('main', 'someAction', 'arg1', 'arg2')\n\nexpect(controller.someAction).toHaveBeenCalledWith('arg1', 'arg2')"
          },
          {
            "title": "dispatchAction",
            "line": 174,
            "source": "class TestController extends PerkyModule {\n    jump = vi.fn()\n}\nconst controller = dispatcher.register('game', TestController)\ndispatcher.setActive('game')\n\nconst binding = {\n    deviceName: 'keyboard',\n    controlName: 'Space',\n    actionName: 'jump',\n    controllerName: 'game'\n}\n\ndispatcher.dispatchAction(binding, 'event', 'device')\n\nexpect(controller.jump).toHaveBeenCalledWith('event', 'device')"
          },
          {
            "title": "dispatchAction - inactive controller does not call action",
            "line": 194,
            "source": "class TestController extends PerkyModule {\n    jump = vi.fn()\n}\n\nconst gameController = dispatcher.register('game', TestController)\ndispatcher.register('other', ActionController)\ndispatcher.register('game', TestController)\ndispatcher.register('other', ActionController)\ndispatcher.setActive('other')\n\nconst binding = {\n    deviceName: 'keyboard',\n    controlName: 'Space',\n    actionName: 'jump',\n    controllerName: 'game'\n}\n\ndispatcher.dispatchAction(binding, 'event', 'device')\n\nexpect(gameController.jump).not.toHaveBeenCalled()"
          },
          {
            "title": "dispatchAction - controller in stack works",
            "line": 218,
            "source": "class TestController extends PerkyModule {\n    jump = vi.fn()\n}\n\nconst gameController = dispatcher.register('game', TestController)\ndispatcher.register('pause', ActionController)\ndispatcher.pushActive('game')\ndispatcher.pushActive('pause')\n\nconst binding = {\n    deviceName: 'keyboard',\n    controlName: 'Space',\n    actionName: 'jump',\n    controllerName: 'game'\n}\n\ndispatcher.dispatchAction(binding, 'event', 'device')\n\nexpect(gameController.jump).toHaveBeenCalledWith('event', 'device')"
          },
          {
            "title": "dispatchAction - active controller fallback",
            "line": 241,
            "source": "class TestController extends ActionController {\n    jump = vi.fn()\n}\n\nconst controller = dispatcher.register('main', TestController)\ndispatcher.setActive('main')\n\nconst binding = {\n    deviceName: 'keyboard',\n    controlName: 'Space',\n    actionName: 'jump'\n}\n\ndispatcher.dispatchAction(binding, 'event', 'device')\n\nexpect(controller.jump).toHaveBeenCalledWith('event', 'device')"
          },
          {
            "title": "pushActive",
            "line": 261,
            "source": "dispatcher.register('main', ActionController)\n\ndispatcher.pushActive('main')\n\nexpect(dispatcher.getActive()).toEqual(['main'])"
          },
          {
            "title": "pushActive - non-existent controller",
            "line": 270,
            "source": "const consoleSpy = vi.spyOn(console, 'warn').mockImplementation(() => { })\n\nconst result = dispatcher.pushActive('nonExistent')\n\nexpect(result).toBe(false)\nexpect(consoleSpy).toHaveBeenCalled()\n\nconsoleSpy.mockRestore()"
          },
          {
            "title": "pushActive - prevents duplicate controller",
            "line": 282,
            "source": "dispatcher.register('main', ActionController)\n\ndispatcher.pushActive('main')\nexpect(dispatcher.getActive()).toEqual(['main'])\n\nconst result = dispatcher.pushActive('main')\n\nexpect(result).toBe(false)\nexpect(dispatcher.getActive()).toEqual(['main'])"
          },
          {
            "title": "pushActive - prevents duplicate even if not on top",
            "line": 295,
            "source": "dispatcher.register('main', ActionController)\ndispatcher.register('other', ActionController)\n\ndispatcher.pushActive('main')\ndispatcher.pushActive('other')\nconst result = dispatcher.pushActive('main')\n\nexpect(result).toBe(false)\nexpect(dispatcher.getActive()).toEqual(['main', 'other'])"
          },
          {
            "title": "popActive - returns popped controller",
            "line": 308,
            "source": "dispatcher.register('main', ActionController)\n\ndispatcher.pushActive('main')\nconst popped = dispatcher.popActive()\n\nexpect(popped).toBe('main')\nexpect(dispatcher.getActive()).toEqual([])"
          },
          {
            "title": "popActive - empty stack",
            "line": 319,
            "source": "const consoleSpy = vi.spyOn(console, 'warn').mockImplementation(() => { })\n\nconst result = dispatcher.popActive()\n\nexpect(result).toBeNull()\nexpect(consoleSpy).toHaveBeenCalled()\n\nconsoleSpy.mockRestore()"
          },
          {
            "title": "getActive - returns copy",
            "line": 331,
            "source": "dispatcher.register('main', ActionController)\n\ndispatcher.pushActive('main')\nconst stack = dispatcher.getActive()\n\nstack.push('other')\n\nexpect(dispatcher.getActive()).toEqual(['main'])"
          },
          {
            "title": "getActive - returns empty array when no active controllers",
            "line": 343,
            "source": "expect(dispatcher.getActive()).toEqual([])"
          },
          {
            "title": "clearActive",
            "line": 348,
            "source": "dispatcher.register('main', ActionController)\ndispatcher.register('pause', ActionController)\n\ndispatcher.pushActive('main')\ndispatcher.pushActive('pause')\n\ndispatcher.clearActive()\n\nexpect(dispatcher.getActive()).toEqual([])"
          },
          {
            "title": "dispatch - stack mode with propagation",
            "line": 361,
            "source": "class GameController extends ActionController {\n    static propagable = ['move']\n\n    move = vi.fn()\n    shoot = vi.fn()\n}\n\nclass PauseController extends ActionController {\n    resume = vi.fn()\n}\n\nconst gameController = dispatcher.register('game', GameController)\nconst pauseController = dispatcher.register('pause', PauseController)\n\ndispatcher.pushActive('game')\ndispatcher.pushActive('pause')\n\ndispatcher.execute('move')\nexpect(gameController.move).toHaveBeenCalled()\n\ndispatcher.execute('shoot')\nexpect(gameController.shoot).toHaveBeenCalled()\n\ndispatcher.execute('resume')\nexpect(pauseController.resume).toHaveBeenCalled()"
          },
          {
            "title": "dispatch - stack mode propagates to lower controller",
            "line": 390,
            "source": "class GameController extends ActionController {\n    static propagable = ['move']\n\n    move = vi.fn()\n}\n\nclass PauseController extends ActionController {\n    resume = vi.fn()\n}\n\nconst gameController = dispatcher.register('game', GameController)\ndispatcher.register('pause', PauseController)\n\ndispatcher.pushActive('game')\ndispatcher.pushActive('pause')\n\ndispatcher.execute('move')\n\nexpect(gameController.move).toHaveBeenCalled()"
          },
          {
            "title": "listControllers",
            "line": 413,
            "source": "dispatcher.register('main', ActionController)\ndispatcher.register('pause', ActionController)\n\nconst controllers = dispatcher.listControllers()\n\nexpect(controllers).toContain('main')\nexpect(controllers).toContain('pause')"
          },
          {
            "title": "listAllActions",
            "line": 424,
            "source": "class GameController extends ActionController {\n    jump () { }\n    move () { }\n}\n\nconst gameController = dispatcher.register('game', GameController)\ngameController.addAction('shoot', vi.fn())\n\nconst allActions = dispatcher.listAllActions()\nconst actionNames = allActions.get('game').map(a => a.name)\n\nexpect(actionNames).toContain('jump')\nexpect(actionNames).toContain('move')\nexpect(actionNames).toContain('shoot')"
          },
          {
            "title": "addAction delegates to main controller",
            "line": 442,
            "source": "const host = new PerkyModule()\nconst newDispatcher = new ActionDispatcher()\nnewDispatcher.install(host)\nnewDispatcher.register('main', ActionController)\n\nconst action = vi.fn()\nnewDispatcher.addAction('customAction', action)\n\nexpect(newDispatcher.mainController.getAction('customAction')).toBe(action)"
          },
          {
            "title": "addAction returns false without main controller",
            "line": 455,
            "source": "const consoleSpy = vi.spyOn(console, 'warn').mockImplementation(() => {})\n\nconst result = dispatcher.addAction('customAction', vi.fn())\n\nexpect(result).toBe(false)\nexpect(consoleSpy).toHaveBeenCalled()\n\nconsoleSpy.mockRestore()"
          },
          {
            "title": "removeAction delegates to main controller",
            "line": 467,
            "source": "const host = new PerkyModule()\nconst newDispatcher = new ActionDispatcher()\nnewDispatcher.install(host)\nnewDispatcher.register('main', ActionController)\n\nconst action = vi.fn()\nnewDispatcher.addAction('customAction', action)\nnewDispatcher.removeAction('customAction')\n\nexpect(newDispatcher.mainController.getAction('customAction')).toBeUndefined()"
          },
          {
            "title": "removeAction returns false without main controller",
            "line": 481,
            "source": "const consoleSpy = vi.spyOn(console, 'warn').mockImplementation(() => {})\n\nconst result = dispatcher.removeAction('customAction')\n\nexpect(result).toBe(false)\nexpect(consoleSpy).toHaveBeenCalled()\n\nconsoleSpy.mockRestore()"
          }
        ],
        "describes": []
      }
    ]
  },
  "/core/inflector.doc.js": {
    "file": "/core/inflector.test.js",
    "describes": [
      {
        "title": "Inflector",
        "line": 8,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "addPluralRule adds a custom plural rule",
            "line": 463,
            "source": "const customInflector = new Inflector()\ncustomInflector.addPluralRule(/zyx$/i, 'zyxes')\n\nexpect(customInflector.plural('zyx')).toBe('zyxes')"
          },
          {
            "title": "addSingularRule adds a custom singular rule",
            "line": 471,
            "source": "const customInflector = new Inflector()\ncustomInflector.addSingularRule(/zyxes$/i, 'zyx')\n\nexpect(customInflector.singular('zyxes')).toBe('zyx')"
          },
          {
            "title": "addUncountableRule adds an uncountable word",
            "line": 479,
            "source": "const customInflector = new Inflector()\ncustomInflector.addUncountableRule('customword')\n\nexpect(customInflector.plural('customword')).toBe('customword')\nexpect(customInflector.singular('customword')).toBe('customword')"
          },
          {
            "title": "addIrregularRule adds an irregular plural/singular pair",
            "line": 488,
            "source": "const customInflector = new Inflector()\ncustomInflector.addIrregularRule('customsingle', 'customplural')\n\nexpect(customInflector.plural('customsingle')).toBe('customplural')\nexpect(customInflector.singular('customplural')).toBe('customsingle')"
          }
        ],
        "describes": [
          {
            "title": "plural",
            "line": 10,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "regular plurals",
                "line": 12,
                "source": "expect(inflector.plural('cat')).toBe('cats')\nexpect(inflector.plural('dog')).toBe('dogs')\nexpect(inflector.plural('book')).toBe('books')\nexpect(inflector.plural('car')).toBe('cars')"
              },
              {
                "title": "words ending in s, x, z, ch, sh",
                "line": 20,
                "source": "expect(inflector.plural('bus')).toBe('buses')\nexpect(inflector.plural('box')).toBe('boxes')\nexpect(inflector.plural('quiz')).toBe('quizzes')\nexpect(inflector.plural('church')).toBe('churches')\nexpect(inflector.plural('dish')).toBe('dishes')"
              },
              {
                "title": "words ending in consonant + y",
                "line": 29,
                "source": "expect(inflector.plural('city')).toBe('cities')\nexpect(inflector.plural('fly')).toBe('flies')\nexpect(inflector.plural('story')).toBe('stories')"
              },
              {
                "title": "irregular plurals",
                "line": 36,
                "source": "expect(inflector.plural('child')).toBe('children')\nexpect(inflector.plural('person')).toBe('people')\nexpect(inflector.plural('man')).toBe('men')\nexpect(inflector.plural('woman')).toBe('women')\nexpect(inflector.plural('foot')).toBe('feet')\nexpect(inflector.plural('tooth')).toBe('teeth')\nexpect(inflector.plural('goose')).toBe('geese')\nexpect(inflector.plural('mouse')).toBe('mice')"
              },
              {
                "title": "words ending in f/fe become ves",
                "line": 48,
                "source": "expect(inflector.plural('knife')).toBe('knives')\nexpect(inflector.plural('wife')).toBe('wives')\nexpect(inflector.plural('life')).toBe('lives')\nexpect(inflector.plural('leaf')).toBe('leaves')\nexpect(inflector.plural('half')).toBe('halves')\nexpect(inflector.plural('wolf')).toBe('wolves')\nexpect(inflector.plural('thief')).toBe('thieves')"
              },
              {
                "title": "words ending in o",
                "line": 59,
                "source": "expect(inflector.plural('hero')).toBe('heroes')\nexpect(inflector.plural('potato')).toBe('potatoes')\nexpect(inflector.plural('tomato')).toBe('tomatoes')\nexpect(inflector.plural('echo')).toBe('echoes')\nexpect(inflector.plural('volcano')).toBe('volcanoes')\nexpect(inflector.plural('tornado')).toBe('tornadoes')"
              },
              {
                "title": "Latin/Greek endings",
                "line": 69,
                "source": "expect(inflector.plural('focus')).toBe('foci')\nexpect(inflector.plural('cactus')).toBe('cacti')\nexpect(inflector.plural('fungus')).toBe('fungi')\nexpect(inflector.plural('nucleus')).toBe('nuclei')\nexpect(inflector.plural('radius')).toBe('radii')\nexpect(inflector.plural('stimulus')).toBe('stimuli')\nexpect(inflector.plural('syllabus')).toBe('syllabi')\nexpect(inflector.plural('alumnus')).toBe('alumni')"
              },
              {
                "title": "words ending in -is become -es",
                "line": 81,
                "source": "expect(inflector.plural('analysis')).toBe('analyses')\nexpect(inflector.plural('basis')).toBe('bases')\nexpect(inflector.plural('crisis')).toBe('crises')\nexpect(inflector.plural('diagnosis')).toBe('diagnoses')\nexpect(inflector.plural('hypothesis')).toBe('hypotheses')\nexpect(inflector.plural('thesis')).toBe('theses')\nexpect(inflector.plural('axis')).toBe('axes')"
              },
              {
                "title": "words ending in -um become -a",
                "line": 92,
                "source": "expect(inflector.plural('datum')).toBe('data')\nexpect(inflector.plural('curriculum')).toBe('curricula')\nexpect(inflector.plural('symposium')).toBe('symposia')\nexpect(inflector.plural('bacterium')).toBe('bacteria')\nexpect(inflector.plural('millennium')).toBe('millennia')\nexpect(inflector.plural('addendum')).toBe('addenda')\nexpect(inflector.plural('erratum')).toBe('errata')"
              },
              {
                "title": "words ending in -on become -a",
                "line": 103,
                "source": "expect(inflector.plural('criterion')).toBe('criteria')\nexpect(inflector.plural('phenomenon')).toBe('phenomena')"
              },
              {
                "title": "words ending in -a become -ae",
                "line": 109,
                "source": "expect(inflector.plural('alumna')).toBe('alumnae')\nexpect(inflector.plural('vertebra')).toBe('vertebrae')\nexpect(inflector.plural('alga')).toBe('algae')"
              },
              {
                "title": "words ending in -ex/-ix become -ices",
                "line": 116,
                "source": "expect(inflector.plural('index')).toBe('indices')\nexpect(inflector.plural('appendix')).toBe('appendices')\nexpect(inflector.plural('matrix')).toBe('matrices')"
              },
              {
                "title": "pronouns and special irregulars",
                "line": 123,
                "source": "expect(inflector.plural('I')).toBe('WE')\nexpect(inflector.plural('me')).toBe('us')\nexpect(inflector.plural('he')).toBe('they')\nexpect(inflector.plural('she')).toBe('they')\nexpect(inflector.plural('this')).toBe('these')\nexpect(inflector.plural('that')).toBe('those')\nexpect(inflector.plural('is')).toBe('are')\nexpect(inflector.plural('was')).toBe('were')\nexpect(inflector.plural('has')).toBe('have')"
              }
            ],
            "describes": []
          },
          {
            "title": "singular",
            "line": 138,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "regular singulars",
                "line": 140,
                "source": "expect(inflector.singular('cats')).toBe('cat')\nexpect(inflector.singular('dogs')).toBe('dog')\nexpect(inflector.singular('books')).toBe('book')\nexpect(inflector.singular('cars')).toBe('car')"
              },
              {
                "title": "words ending in es",
                "line": 148,
                "source": "expect(inflector.singular('buses')).toBe('bus')\nexpect(inflector.singular('boxes')).toBe('box')\nexpect(inflector.singular('churches')).toBe('church')\nexpect(inflector.singular('dishes')).toBe('dish')"
              },
              {
                "title": "words ending in ies",
                "line": 156,
                "source": "expect(inflector.singular('cities')).toBe('city')\nexpect(inflector.singular('flies')).toBe('fly')\nexpect(inflector.singular('stories')).toBe('story')"
              },
              {
                "title": "irregular singulars",
                "line": 163,
                "source": "expect(inflector.singular('children')).toBe('child')\nexpect(inflector.singular('people')).toBe('person')\nexpect(inflector.singular('men')).toBe('man')\nexpect(inflector.singular('women')).toBe('woman')\nexpect(inflector.singular('feet')).toBe('foot')\nexpect(inflector.singular('teeth')).toBe('tooth')\nexpect(inflector.singular('geese')).toBe('goose')\nexpect(inflector.singular('mice')).toBe('mouse')"
              }
            ],
            "describes": []
          },
          {
            "title": "isPlural / isSingular",
            "line": 177,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "isPlural returns true for plural words",
                "line": 179,
                "source": "expect(inflector.isPlural('cats')).toBe(true)\nexpect(inflector.isPlural('children')).toBe(true)\nexpect(inflector.isPlural('people')).toBe(true)"
              },
              {
                "title": "isSingular returns true for singular words",
                "line": 186,
                "source": "expect(inflector.isSingular('cat')).toBe(true)\nexpect(inflector.isSingular('child')).toBe(true)\nexpect(inflector.isSingular('person')).toBe(true)"
              }
            ],
            "describes": []
          },
          {
            "title": "uncountables",
            "line": 195,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "uncountable words stay the same in plural",
                "line": 197,
                "source": "expect(inflector.plural('fish')).toBe('fish')\nexpect(inflector.plural('sheep')).toBe('sheep')\nexpect(inflector.plural('deer')).toBe('deer')\nexpect(inflector.plural('moose')).toBe('moose')"
              },
              {
                "title": "uncountable words stay the same in singular",
                "line": 205,
                "source": "expect(inflector.singular('fish')).toBe('fish')\nexpect(inflector.singular('sheep')).toBe('sheep')\nexpect(inflector.singular('deer')).toBe('deer')\nexpect(inflector.singular('moose')).toBe('moose')"
              }
            ],
            "describes": []
          },
          {
            "title": "pluralize with count",
            "line": 215,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns singular for count 1",
                "line": 217,
                "source": "expect(inflector.pluralize('cat', 1)).toBe('cat')\nexpect(inflector.pluralize('child', 1)).toBe('child')"
              },
              {
                "title": "returns plural for count != 1",
                "line": 223,
                "source": "expect(inflector.pluralize('cat', 0)).toBe('cats')\nexpect(inflector.pluralize('cat', 2)).toBe('cats')\nexpect(inflector.pluralize('child', 5)).toBe('children')"
              },
              {
                "title": "includes count when inclusive is true",
                "line": 230,
                "source": "expect(inflector.pluralize('cat', 1, true)).toBe('1 cat')\nexpect(inflector.pluralize('cat', 3, true)).toBe('3 cats')\nexpect(inflector.pluralize('child', 1, true)).toBe('1 child')\nexpect(inflector.pluralize('child', 5, true)).toBe('5 children')"
              }
            ],
            "describes": []
          },
          {
            "title": "case preservation",
            "line": 240,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "preserves lowercase",
                "line": 242,
                "source": "expect(inflector.plural('cat')).toBe('cats')"
              },
              {
                "title": "preserves uppercase",
                "line": 247,
                "source": "expect(inflector.plural('CAT')).toBe('CATS')"
              },
              {
                "title": "preserves title case",
                "line": 252,
                "source": "expect(inflector.plural('Cat')).toBe('Cats')"
              }
            ],
            "describes": []
          },
          {
            "title": "toCamelCase",
            "line": 259,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "converts snake_case",
                "line": 261,
                "source": "expect(inflector.toCamelCase('hello_world')).toBe('helloWorld')"
              },
              {
                "title": "converts kebab-case",
                "line": 266,
                "source": "expect(inflector.toCamelCase('hello-world')).toBe('helloWorld')"
              },
              {
                "title": "converts space separated",
                "line": 271,
                "source": "expect(inflector.toCamelCase('hello world')).toBe('helloWorld')"
              },
              {
                "title": "converts PascalCase",
                "line": 276,
                "source": "expect(inflector.toCamelCase('HelloWorld')).toBe('helloWorld')"
              },
              {
                "title": "handles single word",
                "line": 281,
                "source": "expect(inflector.toCamelCase('Hello')).toBe('hello')"
              }
            ],
            "describes": []
          },
          {
            "title": "toPascalCase",
            "line": 288,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "converts snake_case",
                "line": 290,
                "source": "expect(inflector.toPascalCase('hello_world')).toBe('HelloWorld')"
              },
              {
                "title": "converts kebab-case",
                "line": 295,
                "source": "expect(inflector.toPascalCase('hello-world')).toBe('HelloWorld')"
              },
              {
                "title": "converts space separated",
                "line": 300,
                "source": "expect(inflector.toPascalCase('hello world')).toBe('HelloWorld')"
              },
              {
                "title": "keeps PascalCase",
                "line": 305,
                "source": "expect(inflector.toPascalCase('HelloWorld')).toBe('HelloWorld')"
              },
              {
                "title": "handles single word",
                "line": 310,
                "source": "expect(inflector.toPascalCase('Hello')).toBe('Hello')"
              }
            ],
            "describes": []
          },
          {
            "title": "toSnakeCase",
            "line": 317,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "converts camelCase",
                "line": 319,
                "source": "expect(inflector.toSnakeCase('helloWorld')).toBe('hello_world')"
              },
              {
                "title": "converts PascalCase",
                "line": 324,
                "source": "expect(inflector.toSnakeCase('HelloWorld')).toBe('hello_world')"
              },
              {
                "title": "converts kebab-case",
                "line": 329,
                "source": "expect(inflector.toSnakeCase('hello-world')).toBe('hello_world')"
              },
              {
                "title": "converts space separated",
                "line": 334,
                "source": "expect(inflector.toSnakeCase('hello world')).toBe('hello_world')"
              },
              {
                "title": "handles single word",
                "line": 339,
                "source": "expect(inflector.toSnakeCase('Hello')).toBe('hello')"
              },
              {
                "title": "handles names ending with number and letter (2D suffix)",
                "line": 344,
                "source": "expect(inflector.toSnakeCase('Object2D')).toBe('object_2d')\nexpect(inflector.toSnakeCase('Group2D')).toBe('group_2d')"
              },
              {
                "title": "handles names with number followed by word",
                "line": 350,
                "source": "expect(inflector.toSnakeCase('Vec2Control')).toBe('vec2_control')\nexpect(inflector.toSnakeCase('Vec2Input')).toBe('vec2_input')"
              },
              {
                "title": "handles names ending with number only",
                "line": 356,
                "source": "expect(inflector.toSnakeCase('Vec2')).toBe('vec2')\nexpect(inflector.toSnakeCase('Vec3')).toBe('vec3')"
              }
            ],
            "describes": []
          },
          {
            "title": "toKebabCase",
            "line": 364,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "converts camelCase",
                "line": 366,
                "source": "expect(inflector.toKebabCase('helloWorld')).toBe('hello-world')"
              },
              {
                "title": "converts PascalCase",
                "line": 371,
                "source": "expect(inflector.toKebabCase('HelloWorld')).toBe('hello-world')"
              },
              {
                "title": "converts snake_case",
                "line": 376,
                "source": "expect(inflector.toKebabCase('hello_world')).toBe('hello-world')"
              },
              {
                "title": "converts space separated",
                "line": 381,
                "source": "expect(inflector.toKebabCase('hello world')).toBe('hello-world')"
              },
              {
                "title": "handles single word",
                "line": 386,
                "source": "expect(inflector.toKebabCase('Hello')).toBe('hello')"
              },
              {
                "title": "handles names ending with number and letter (2D suffix)",
                "line": 391,
                "source": "expect(inflector.toKebabCase('Object2D')).toBe('object-2d')\nexpect(inflector.toKebabCase('Group2D')).toBe('group-2d')"
              },
              {
                "title": "handles names with number followed by word",
                "line": 397,
                "source": "expect(inflector.toKebabCase('Vec2Control')).toBe('vec2-control')\nexpect(inflector.toKebabCase('Vec2Input')).toBe('vec2-input')"
              },
              {
                "title": "handles names ending with number only",
                "line": 403,
                "source": "expect(inflector.toKebabCase('Vec2')).toBe('vec2')\nexpect(inflector.toKebabCase('Vec3')).toBe('vec3')"
              }
            ],
            "describes": []
          },
          {
            "title": "toHumanCase",
            "line": 411,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "converts PascalCase",
                "line": 413,
                "source": "expect(inflector.toHumanCase('GettingStarted')).toBe('Getting Started')"
              },
              {
                "title": "converts camelCase",
                "line": 418,
                "source": "expect(inflector.toHumanCase('helloWorld')).toBe('hello World')"
              },
              {
                "title": "converts snake_case",
                "line": 423,
                "source": "expect(inflector.toHumanCase('hello_world')).toBe('hello world')"
              },
              {
                "title": "converts kebab-case",
                "line": 428,
                "source": "expect(inflector.toHumanCase('hello-world')).toBe('hello world')"
              },
              {
                "title": "handles consecutive uppercase",
                "line": 433,
                "source": "expect(inflector.toHumanCase('HTMLParser')).toBe('HTML Parser')"
              },
              {
                "title": "handles single word",
                "line": 438,
                "source": "expect(inflector.toHumanCase('Hello')).toBe('Hello')"
              },
              {
                "title": "handles names ending with number and letter (2D suffix)",
                "line": 443,
                "source": "expect(inflector.toHumanCase('Object2D')).toBe('Object 2D')\nexpect(inflector.toHumanCase('Group2D')).toBe('Group 2D')"
              },
              {
                "title": "handles names with number followed by word",
                "line": 449,
                "source": "expect(inflector.toHumanCase('Vec2Control')).toBe('Vec2 Control')\nexpect(inflector.toHumanCase('Vec2Input')).toBe('Vec2 Input')"
              },
              {
                "title": "handles names ending with number only",
                "line": 455,
                "source": "expect(inflector.toHumanCase('Vec2')).toBe('Vec2')\nexpect(inflector.toHumanCase('Vec3')).toBe('Vec3')"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/core/logger.doc.js": {
    "file": "/core/logger.test.js",
    "describes": [
      {
        "title": "Logger",
        "line": 6,
        "beforeEach": {
          "line": 8,
          "source": "logger.consoleOutput = false\nlogger.removeListeners()\nlogger.clearHistory()\nlogger.maxHistory = 100"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "is an instance of Notifier",
            "line": 16,
            "source": "expect(logger).toBeInstanceOf(Notifier)"
          },
          {
            "title": "is a singleton",
            "line": 21,
            "source": "const logger2 = (await import('./logger.js')).default\nexpect(logger2).toBe(logger)"
          },
          {
            "title": "clear emits clear event",
            "line": 124,
            "source": "const listener = vi.fn()\nlogger.on('clear', listener)\n\nlogger.clear()\n\nexpect(listener).toHaveBeenCalledTimes(1)"
          },
          {
            "title": "spacer emits spacer event",
            "line": 134,
            "source": "const listener = vi.fn()\nlogger.on('spacer', listener)\n\nlogger.spacer()\n\nexpect(listener).toHaveBeenCalledTimes(1)"
          },
          {
            "title": "title emits title event with title payload",
            "line": 144,
            "source": "const listener = vi.fn()\nlogger.on('title', listener)\n\nlogger.title('My Title')\n\nconst payload = listener.mock.calls[0][0]\nexpect(payload.title).toBe('My Title')\nexpect(payload.event).toBe('title')"
          }
        ],
        "describes": [
          {
            "title": "log",
            "line": 27,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "emits log event with notice type",
                "line": 28,
                "source": "const listener = vi.fn()\nlogger.on('log', listener)\n\nlogger.log('hello', 'world')\n\nexpect(listener).toHaveBeenCalledTimes(1)\nconst payload = listener.mock.calls[0][0]\nexpect(payload.type).toBe('notice')\nexpect(payload.items).toEqual(['hello', 'world'])\nexpect(payload.timestamp).toBeTypeOf('number')"
              },
              {
                "title": "handles objects in items",
                "line": 42,
                "source": "const listener = vi.fn()\nlogger.on('log', listener)\n\nconst obj = {foo: 'bar'}\nlogger.log('data:', obj)\n\nconst payload = listener.mock.calls[0][0]\nexpect(payload.items).toEqual(['data:', obj])"
              }
            ],
            "describes": []
          },
          {
            "title": "convenience methods",
            "line": 55,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "info calls log with type info",
                "line": 56,
                "source": "const listener = vi.fn()\nlogger.on('log', listener)\n\nlogger.info('message')\n\nconst payload = listener.mock.calls[0][0]\nexpect(payload.type).toBe('info')\nexpect(payload.items).toEqual(['message'])"
              },
              {
                "title": "notice calls log with type notice",
                "line": 68,
                "source": "const listener = vi.fn()\nlogger.on('log', listener)\n\nlogger.notice('message')\n\nconst payload = listener.mock.calls[0][0]\nexpect(payload.type).toBe('notice')"
              },
              {
                "title": "warn calls log with type warn",
                "line": 79,
                "source": "const listener = vi.fn()\nlogger.on('log', listener)\n\nlogger.warn('message')\n\nconst payload = listener.mock.calls[0][0]\nexpect(payload.type).toBe('warn')"
              },
              {
                "title": "error calls log with type error",
                "line": 90,
                "source": "const listener = vi.fn()\nlogger.on('log', listener)\n\nlogger.error('message')\n\nconst payload = listener.mock.calls[0][0]\nexpect(payload.type).toBe('error')"
              },
              {
                "title": "success calls log with type success",
                "line": 101,
                "source": "const listener = vi.fn()\nlogger.on('log', listener)\n\nlogger.success('message')\n\nconst payload = listener.mock.calls[0][0]\nexpect(payload.type).toBe('success')"
              },
              {
                "title": "convenience methods accept multiple arguments",
                "line": 112,
                "source": "const listener = vi.fn()\nlogger.on('log', listener)\n\nlogger.info('a', 'b', 'c')\n\nconst payload = listener.mock.calls[0][0]\nexpect(payload.items).toEqual(['a', 'b', 'c'])"
              }
            ],
            "describes": []
          },
          {
            "title": "history",
            "line": 156,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "stores log entries in history",
                "line": 157,
                "source": "logger.info('message 1')\nlogger.warn('message 2')\n\nexpect(logger.history).toHaveLength(2)\nexpect(logger.history[0].event).toBe('log')\nexpect(logger.history[0].type).toBe('info')\nexpect(logger.history[1].type).toBe('warn')"
              },
              {
                "title": "stores all event types in history",
                "line": 168,
                "source": "logger.info('log')\nlogger.clear()\nlogger.spacer()\nlogger.title('Title')\n\nexpect(logger.history).toHaveLength(4)\nexpect(logger.history[0].event).toBe('log')\nexpect(logger.history[1].event).toBe('clear')\nexpect(logger.history[2].event).toBe('spacer')\nexpect(logger.history[3].event).toBe('title')"
              },
              {
                "title": "respects maxHistory limit",
                "line": 182,
                "source": "logger.maxHistory = 3\n\nlogger.info('1')\nlogger.info('2')\nlogger.info('3')\nlogger.info('4')\n\nexpect(logger.history).toHaveLength(3)\nexpect(logger.history[0].items).toEqual(['2'])\nexpect(logger.history[2].items).toEqual(['4'])"
              },
              {
                "title": "clearHistory empties history",
                "line": 196,
                "source": "logger.info('message')\nexpect(logger.history).toHaveLength(1)\n\nlogger.clearHistory()\nexpect(logger.history).toHaveLength(0)"
              },
              {
                "title": "default maxHistory is 100",
                "line": 205,
                "source": "expect(logger.maxHistory).toBe(100)"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/core/notifier.doc.js": {
    "file": "/core/notifier.test.js",
    "describes": [
      {
        "title": "Notifier",
        "line": 5,
        "beforeEach": {
          "line": 9,
          "source": "notifier = new Notifier()"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor",
            "line": 14,
            "source": "expect(notifier.getListenersFor('any')).toBeUndefined()"
          },
          {
            "title": "getListenersFor",
            "line": 19,
            "source": "expect(notifier.getListenersFor('foo')).toBeUndefined()\n\nnotifier.on('foo', () => { })\nexpect(notifier.getListenersFor('foo')).toHaveLength(1)"
          },
          {
            "title": "on",
            "line": 27,
            "source": "const listener = () => { }\n\nexpect(notifier.on('foo', listener)).toBe(listener)\nexpect(notifier.getListenersFor('foo')).toEqual([listener])"
          },
          {
            "title": "once",
            "line": 35,
            "source": "const listener = vi.fn()\nconst wrapper = notifier.once('foo', listener)\n\nexpect(wrapper).not.toBe(listener)\nexpect(notifier.getListenersFor('foo')).toEqual([wrapper])\n\nnotifier.emit('foo', 1, 2, 3)\nexpect(listener).toHaveBeenCalledWith(1, 2, 3)\nexpect(notifier.getListenersFor('foo')).toEqual([])"
          },
          {
            "title": "off",
            "line": 48,
            "source": "const listener = () => { }\n\nexpect(notifier.off('foo', listener)).toBe(false)\n\nnotifier.on('foo', listener)\nexpect(notifier.off('foo', listener)).toBe(true)\nexpect(notifier.getListenersFor('foo')).toEqual([])"
          },
          {
            "title": "emit",
            "line": 59,
            "source": "const listener = vi.fn()\n\nnotifier.on('foo', listener)\nnotifier.emit('foo', 1, 2, 3)\nexpect(listener).toHaveBeenCalledWith(1, 2, 3)\n\nnotifier.emit('bar')\nexpect(listener).toHaveBeenCalledTimes(1)"
          },
          {
            "title": "removeListeners",
            "line": 71,
            "source": "notifier.on('foo', () => { })\nnotifier.on('bar', () => { })\n\nexpect(notifier.getListenersFor('foo')).toHaveLength(1)\nexpect(notifier.getListenersFor('bar')).toHaveLength(1)\n\nnotifier.removeListeners()\nexpect(notifier.getListenersFor('foo')).toBeUndefined()\nexpect(notifier.getListenersFor('bar')).toBeUndefined()"
          },
          {
            "title": "removeListenersFor",
            "line": 84,
            "source": "notifier.on('foo', () => { })\nnotifier.on('bar', () => { })\n\nexpect(notifier.getListenersFor('foo')).toHaveLength(1)\nexpect(notifier.getListenersFor('bar')).toHaveLength(1)\n\nnotifier.removeListenersFor('foo')\nexpect(notifier.getListenersFor('foo')).toBeUndefined()\nexpect(notifier.getListenersFor('bar')).toHaveLength(1)"
          },
          {
            "title": "instances have separate listeners",
            "line": 97,
            "source": "const notifier1 = new Notifier()\nconst notifier2 = new Notifier()\n\nnotifier1.on('test', () => { })\nexpect(notifier1.getListenersFor('test')).toHaveLength(1)\nexpect(notifier2.getListenersFor('test')).toBeUndefined()\n\nnotifier2.on('test', () => { })\nnotifier2.on('test', () => { })\nexpect(notifier1.getListenersFor('test')).toHaveLength(1)\nexpect(notifier2.getListenersFor('test')).toHaveLength(2)"
          },
          {
            "title": "emit passes notifier as this context to listeners",
            "line": 112,
            "source": "let receivedContext\n\nfunction listener () {\n    receivedContext = this\n}\n\nnotifier.on('test', listener)\nnotifier.emit('test', 'arg1', 'arg2')\n\nexpect(receivedContext).toBe(notifier)"
          }
        ],
        "describes": [
          {
            "title": "listenTo",
            "line": 126,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "registers listener on target",
                "line": 127,
                "source": "const target = new Notifier()\nconst listener = vi.fn()\n\nnotifier.listenTo(target, 'test', listener)\ntarget.emit('test', 1, 2, 3)\n\nexpect(listener).toHaveBeenCalledWith(1, 2, 3)"
              },
              {
                "title": "tracks multiple listeners on same target",
                "line": 137,
                "source": "const target = new Notifier()\nconst listener1 = vi.fn()\nconst listener2 = vi.fn()\n\nnotifier.listenTo(target, 'event1', listener1)\nnotifier.listenTo(target, 'event2', listener2)\n\ntarget.emit('event1', 'a')\ntarget.emit('event2', 'b')\n\nexpect(listener1).toHaveBeenCalledWith('a')\nexpect(listener2).toHaveBeenCalledWith('b')"
              },
              {
                "title": "tracks listeners on multiple targets",
                "line": 152,
                "source": "const target1 = new Notifier()\nconst target2 = new Notifier()\nconst listener1 = vi.fn()\nconst listener2 = vi.fn()\n\nnotifier.listenTo(target1, 'test', listener1)\nnotifier.listenTo(target2, 'test', listener2)\n\ntarget1.emit('test', 1)\ntarget2.emit('test', 2)\n\nexpect(listener1).toHaveBeenCalledWith(1)\nexpect(listener2).toHaveBeenCalledWith(2)"
              }
            ],
            "describes": []
          },
          {
            "title": "listenToOnce",
            "line": 170,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "registers one-time listener on target",
                "line": 171,
                "source": "const target = new Notifier()\nconst listener = vi.fn()\n\nnotifier.listenToOnce(target, 'test', listener)\n\ntarget.emit('test', 1, 2, 3)\nexpect(listener).toHaveBeenCalledWith(1, 2, 3)\nexpect(listener).toHaveBeenCalledTimes(1)\n\n// Should not be called again\ntarget.emit('test', 4, 5, 6)\nexpect(listener).toHaveBeenCalledTimes(1)"
              },
              {
                "title": "removes from tracking after execution",
                "line": 186,
                "source": "const target = new Notifier()\nconst listener = vi.fn()\n\nnotifier.listenToOnce(target, 'test', listener)\ntarget.emit('test', 'data')\n\n// Cleanup should not fail even if listener already executed\nexpect(() => notifier.cleanExternalListeners()).not.toThrow()"
              },
              {
                "title": "works with multiple one-time listeners",
                "line": 197,
                "source": "const target = new Notifier()\nconst listener1 = vi.fn()\nconst listener2 = vi.fn()\n\nnotifier.listenToOnce(target, 'event1', listener1)\nnotifier.listenToOnce(target, 'event2', listener2)\n\ntarget.emit('event1', 'a')\ntarget.emit('event2', 'b')\n\nexpect(listener1).toHaveBeenCalledWith('a')\nexpect(listener2).toHaveBeenCalledWith('b')\nexpect(listener1).toHaveBeenCalledTimes(1)\nexpect(listener2).toHaveBeenCalledTimes(1)"
              }
            ],
            "describes": []
          },
          {
            "title": "cleanExternalListeners",
            "line": 216,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "removes all tracked listeners",
                "line": 217,
                "source": "const target = new Notifier()\nconst listener1 = vi.fn()\nconst listener2 = vi.fn()\n\nnotifier.listenTo(target, 'event1', listener1)\nnotifier.listenTo(target, 'event2', listener2)\n\nnotifier.cleanExternalListeners()\n\n// Listeners should not be called after cleanup\ntarget.emit('event1', 'a')\ntarget.emit('event2', 'b')\n\nexpect(listener1).not.toHaveBeenCalled()\nexpect(listener2).not.toHaveBeenCalled()"
              },
              {
                "title": "removes listeners from multiple targets",
                "line": 235,
                "source": "const target1 = new Notifier()\nconst target2 = new Notifier()\nconst listener1 = vi.fn()\nconst listener2 = vi.fn()\n\nnotifier.listenTo(target1, 'test', listener1)\nnotifier.listenTo(target2, 'test', listener2)\n\nnotifier.cleanExternalListeners()\n\ntarget1.emit('test', 1)\ntarget2.emit('test', 2)\n\nexpect(listener1).not.toHaveBeenCalled()\nexpect(listener2).not.toHaveBeenCalled()"
              },
              {
                "title": "handles empty listener list",
                "line": 253,
                "source": "expect(() => notifier.cleanExternalListeners()).not.toThrow()"
              },
              {
                "title": "allows reusing notifier after cleanup",
                "line": 257,
                "source": "const target = new Notifier()\nconst listener1 = vi.fn()\nconst listener2 = vi.fn()\n\nnotifier.listenTo(target, 'test', listener1)\nnotifier.cleanExternalListeners()\nnotifier.listenTo(target, 'test', listener2)\n\ntarget.emit('test', 'data')\n\nexpect(listener1).not.toHaveBeenCalled()\nexpect(listener2).toHaveBeenCalledWith('data')"
              },
              {
                "title": "cleans up mix of listenTo and listenToOnce",
                "line": 272,
                "source": "const target = new Notifier()\nconst listener1 = vi.fn()\nconst listener2 = vi.fn()\n\nnotifier.listenTo(target, 'event1', listener1)\nnotifier.listenToOnce(target, 'event2', listener2)\n\nnotifier.cleanExternalListeners()\n\ntarget.emit('event1', 'a')\ntarget.emit('event2', 'b')\n\nexpect(listener1).not.toHaveBeenCalled()\nexpect(listener2).not.toHaveBeenCalled()"
              }
            ],
            "describes": []
          },
          {
            "title": "emitter",
            "line": 291,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns a function that emits the given event",
                "line": 292,
                "source": "const listener = vi.fn()\nnotifier.on('test', listener)\n\nconst emitTest = notifier.emitter('test')\nemitTest(1, 2, 3)\n\nexpect(listener).toHaveBeenCalledWith(1, 2, 3)"
              },
              {
                "title": "passes all arguments to emit",
                "line": 302,
                "source": "const listener = vi.fn()\nnotifier.on('foo', listener)\n\nconst emitFoo = notifier.emitter('foo')\nemitFoo('a', 'b', 'c', 'd')\n\nexpect(listener).toHaveBeenCalledWith('a', 'b', 'c', 'd')"
              },
              {
                "title": "works with no arguments",
                "line": 312,
                "source": "const listener = vi.fn()\nnotifier.on('bar', listener)\n\nconst emitBar = notifier.emitter('bar')\nemitBar()\n\nexpect(listener).toHaveBeenCalledWith()"
              },
              {
                "title": "creates different emitters for different events",
                "line": 322,
                "source": "const listener1 = vi.fn()\nconst listener2 = vi.fn()\nnotifier.on('event1', listener1)\nnotifier.on('event2', listener2)\n\nconst emit1 = notifier.emitter('event1')\nconst emit2 = notifier.emitter('event2')\n\nemit1('data1')\nemit2('data2')\n\nexpect(listener1).toHaveBeenCalledWith('data1')\nexpect(listener2).toHaveBeenCalledWith('data2')"
              }
            ],
            "describes": []
          },
          {
            "title": "delegateEvents",
            "line": 340,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "delegates events without namespace",
                "line": 341,
                "source": "const target = new Notifier()\nconst listener = vi.fn()\n\nnotifier.on('test', listener)\nnotifier.delegateEvents(target, ['test'])\n\ntarget.emit('test', 1, 2, 3)\nexpect(listener).toHaveBeenCalledWith(1, 2, 3)"
              },
              {
                "title": "delegates events with namespace prefix",
                "line": 352,
                "source": "const target = new Notifier()\nconst listener = vi.fn()\n\nnotifier.on('child:test', listener)\nnotifier.delegateEvents(target, ['test'], 'child')\n\ntarget.emit('test', 'data')\nexpect(listener).toHaveBeenCalledWith('data')"
              },
              {
                "title": "handles multiple events from array",
                "line": 363,
                "source": "const target = new Notifier()\nconst listener1 = vi.fn()\nconst listener2 = vi.fn()\n\nnotifier.on('event1', listener1)\nnotifier.on('event2', listener2)\nnotifier.delegateEvents(target, ['event1', 'event2'])\n\ntarget.emit('event1', 'a')\ntarget.emit('event2', 'b')\n\nexpect(listener1).toHaveBeenCalledWith('a')\nexpect(listener2).toHaveBeenCalledWith('b')"
              },
              {
                "title": "handles events object",
                "line": 379,
                "source": "const target = new Notifier()\nconst listener1 = vi.fn()\nconst listener2 = vi.fn()\n\nnotifier.on('foo', listener1)\nnotifier.on('bar', listener2)\nnotifier.delegateEvents(target, {foo: true, bar: true})\n\ntarget.emit('foo', 1)\ntarget.emit('bar', 2)\n\nexpect(listener1).toHaveBeenCalledWith(1)\nexpect(listener2).toHaveBeenCalledWith(2)"
              },
              {
                "title": "combines namespace with events object",
                "line": 395,
                "source": "const target = new Notifier()\nconst listener1 = vi.fn()\nconst listener2 = vi.fn()\n\nnotifier.on('ns:foo', listener1)\nnotifier.on('ns:bar', listener2)\nnotifier.delegateEvents(target, {foo: true, bar: true}, 'ns')\n\ntarget.emit('foo', 'x')\ntarget.emit('bar', 'y')\n\nexpect(listener1).toHaveBeenCalledWith('x')\nexpect(listener2).toHaveBeenCalledWith('y')"
              },
              {
                "title": "returns early if target is null",
                "line": 411,
                "source": "expect(() => notifier.delegateEvents(null, ['test'])).not.toThrow()"
              },
              {
                "title": "returns early if target is undefined",
                "line": 415,
                "source": "expect(() => notifier.delegateEvents(undefined, ['test'])).not.toThrow()"
              },
              {
                "title": "returns early if events is not array or object",
                "line": 419,
                "source": "const target = new Notifier()\nexpect(() => notifier.delegateEvents(target, 'string')).not.toThrow()\nexpect(() => notifier.delegateEvents(target, 123)).not.toThrow()"
              },
              {
                "title": "cleans up delegated listeners",
                "line": 425,
                "source": "const target = new Notifier()\nconst listener = vi.fn()\n\nnotifier.on('test', listener)\nnotifier.delegateEvents(target, ['test'])\n\ntarget.emit('test', 'before')\nexpect(listener).toHaveBeenCalledWith('before')\n\nnotifier.cleanExternalListeners()\n\ntarget.emit('test', 'after')\nexpect(listener).toHaveBeenCalledTimes(1)"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/core/observable_map.doc.js": {
    "file": "/core/observable_map.test.js",
    "describes": [
      {
        "title": "ObservableMap",
        "line": 5,
        "beforeEach": {
          "line": 9,
          "source": "observableMap = new ObservableMap()"
        },
        "afterEach": null,
        "tests": [],
        "describes": [
          {
            "title": "Constructor",
            "line": 14,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates empty map when no collection provided",
                "line": 16,
                "source": "const map = new ObservableMap()\nexpect(map.size).toBe(0)"
              },
              {
                "title": "creates map with initial collection from object",
                "line": 22,
                "source": "const map = new ObservableMap({a: 1, b: 2})\nexpect(map.size).toBe(2)\nexpect(map.get('a')).toBe(1)\nexpect(map.get('b')).toBe(2)"
              },
              {
                "title": "creates map with initial collection from Map",
                "line": 30,
                "source": "const map = new ObservableMap(new Map([['x', 10], ['y', 20]]))\nexpect(map.size).toBe(2)\nexpect(map.get('x')).toBe(10)\nexpect(map.get('y')).toBe(20)"
              }
            ],
            "describes": []
          },
          {
            "title": "set",
            "line": 40,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "sets key-value pair",
                "line": 42,
                "source": "observableMap.set('key', 'value')\nexpect(observableMap.get('key')).toBe('value')\nexpect(observableMap.size).toBe(1)"
              },
              {
                "title": "returns true",
                "line": 49,
                "source": "const result = observableMap.set('a', 1)\nexpect(result).toBe(true)"
              },
              {
                "title": "emits set event when value is added",
                "line": 55,
                "source": "let emittedKey\nlet emittedValue\nlet emittedOldValue\n\nobservableMap.on('set', (key, value, oldValue) => {\n    emittedKey = key\n    emittedValue = value\n    emittedOldValue = oldValue\n})\n\nobservableMap.set('test', 'value')\nexpect(emittedKey).toBe('test')\nexpect(emittedValue).toBe('value')\nexpect(emittedOldValue).toBe(undefined)"
              },
              {
                "title": "emits delete then set event when replacing value",
                "line": 73,
                "source": "const events = []\nobservableMap.on('delete', (key, value) => {\n    events.push({type: 'delete', key, value})\n})\nobservableMap.on('set', (key, value, oldValue) => {\n    events.push({type: 'set', key, value, oldValue})\n})\n\nobservableMap.set('key', 'value1')\nevents.length = 0 // Clear after initial set\n\nobservableMap.set('key', 'value2')\n\nexpect(events).toEqual([\n    {type: 'delete', key: 'key', value: 'value1'},\n    {type: 'set', key: 'key', value: 'value2', oldValue: 'value1'}\n])"
              },
              {
                "title": "does not emit delete event when setting same value",
                "line": 94,
                "source": "let deleteCount = 0\nobservableMap.on('delete', () => {\n    deleteCount++\n})\n\nobservableMap.set('key', 'value')\nobservableMap.set('key', 'value')\n\nexpect(deleteCount).toBe(0)"
              }
            ],
            "describes": []
          },
          {
            "title": "get",
            "line": 109,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns value for existing key",
                "line": 111,
                "source": "observableMap.set('test', 'value')\nexpect(observableMap.get('test')).toBe('value')"
              },
              {
                "title": "returns undefined for non-existent key",
                "line": 117,
                "source": "expect(observableMap.get('nonexistent')).toBe(undefined)"
              }
            ],
            "describes": []
          },
          {
            "title": "has",
            "line": 124,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns true for existing key",
                "line": 126,
                "source": "observableMap.set('test', 'value')\nexpect(observableMap.has('test')).toBe(true)"
              },
              {
                "title": "returns false for non-existent key",
                "line": 132,
                "source": "expect(observableMap.has('test')).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "delete",
            "line": 139,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "deletes key-value pair",
                "line": 141,
                "source": "observableMap.set('test', 'value')\nconst result = observableMap.delete('test')\n\nexpect(result).toBe(true)\nexpect(observableMap.has('test')).toBe(false)\nexpect(observableMap.size).toBe(0)"
              },
              {
                "title": "returns false when deleting non-existent key",
                "line": 151,
                "source": "const result = observableMap.delete('nonexistent')\nexpect(result).toBe(false)"
              },
              {
                "title": "emits delete event when key is deleted",
                "line": 157,
                "source": "let emittedKey\nlet emittedValue\n\nobservableMap.on('delete', (key, value) => {\n    emittedKey = key\n    emittedValue = value\n})\n\nobservableMap.set('test', 'value')\nobservableMap.delete('test')\nexpect(emittedKey).toBe('test')\nexpect(emittedValue).toBe('value')"
              },
              {
                "title": "does not emit delete event for non-existe>nt key",
                "line": 173,
                "source": "let callCount = 0\nobservableMap.on('delete', () => {\n    callCount++\n})\n\nobservableMap.delete('nonexistent')\nexpect(callCount).toBe(0)"
              }
            ],
            "describes": []
          },
          {
            "title": "clear",
            "line": 186,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "clears all key-value pairs",
                "line": 188,
                "source": "observableMap.set('a', 1)\nobservableMap.set('b', 2)\nobservableMap.clear()\n\nexpect(observableMap.size).toBe(0)\nexpect(observableMap.has('a')).toBe(false)"
              },
              {
                "title": "emits delete events for all entries then clear event",
                "line": 198,
                "source": "const events = []\nobservableMap.on('delete', (key, value) => {\n    events.push({type: 'delete', key, value})\n})\nobservableMap.on('clear', () => {\n    events.push({type: 'clear'})\n})\n\nobservableMap.set('a', 1)\nobservableMap.set('b', 2)\nevents.length = 0 // Clear after initial sets\n\nobservableMap.clear()\n\nexpect(events).toEqual([\n    {type: 'delete', key: 'a', value: 1},\n    {type: 'delete', key: 'b', value: 2},\n    {type: 'clear'}\n])"
              },
              {
                "title": "does not emit events when map is already empty",
                "line": 221,
                "source": "let callCount = 0\nobservableMap.on('delete', () => callCount++)\nobservableMap.on('clear', () => callCount++)\n\nobservableMap.clear()\nexpect(callCount).toBe(0)"
              }
            ],
            "describes": []
          },
          {
            "title": "size",
            "line": 233,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns 0 for empty map",
                "line": 235,
                "source": "expect(observableMap.size).toBe(0)"
              },
              {
                "title": "returns correct size after adding entries",
                "line": 240,
                "source": "observableMap.set('a', 1)\nobservableMap.set('b', 2)\nobservableMap.set('c', 3)\nexpect(observableMap.size).toBe(3)"
              },
              {
                "title": "updates size after deletion",
                "line": 248,
                "source": "observableMap.set('a', 1)\nobservableMap.set('b', 2)\nobservableMap.delete('a')\nexpect(observableMap.size).toBe(1)"
              }
            ],
            "describes": []
          },
          {
            "title": "updateKey",
            "line": 258,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "updates key for existing entry",
                "line": 260,
                "source": "observableMap.set('oldKey', 'value')\nconst result = observableMap.updateKey('oldKey', 'newKey')\n\nexpect(result).toBe(true)\nexpect(observableMap.has('oldKey')).toBe(false)\nexpect(observableMap.has('newKey')).toBe(true)\nexpect(observableMap.get('newKey')).toBe('value')"
              },
              {
                "title": "emits key:updated event",
                "line": 271,
                "source": "let emittedOldKey\nlet emittedNewKey\nlet emittedValue\n\nobservableMap.on('key:updated', (oldKey, newKey, value) => {\n    emittedOldKey = oldKey\n    emittedNewKey = newKey\n    emittedValue = value\n})\n\nobservableMap.set('oldKey', 'value')\nobservableMap.updateKey('oldKey', 'newKey')\n\nexpect(emittedOldKey).toBe('oldKey')\nexpect(emittedNewKey).toBe('newKey')\nexpect(emittedValue).toBe('value')"
              },
              {
                "title": "returns false when updating to same key",
                "line": 291,
                "source": "observableMap.set('key', 'value')\nconst result = observableMap.updateKey('key', 'key')\nexpect(result).toBe(false)"
              },
              {
                "title": "returns false when old key does not exist",
                "line": 298,
                "source": "const result = observableMap.updateKey('nonexistent', 'newKey')\nexpect(result).toBe(false)"
              },
              {
                "title": "validates item if provided",
                "line": 304,
                "source": "const value1 = {id: 1}\nconst value2 = {id: 2}\n\nobservableMap.set('key1', value1)\nobservableMap.set('key2', value2)\n\nexpect(observableMap.updateKey('key1', 'newKey1', value1)).toBe(true)\nexpect(observableMap.updateKey('key2', 'newKey2', value1)).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "hasValue",
            "line": 318,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns true for existing value",
                "line": 320,
                "source": "const value = {test: true}\nobservableMap.set('key', value)\nexpect(observableMap.hasValue(value)).toBe(true)"
              },
              {
                "title": "returns false for non-existent value",
                "line": 327,
                "source": "expect(observableMap.hasValue('nonexistent')).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "keyFor",
            "line": 334,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns key for existing value",
                "line": 336,
                "source": "const value = {test: true}\nobservableMap.set('key', value)\nexpect(observableMap.keyFor(value)).toBe('key')"
              },
              {
                "title": "returns undefined for non-existent value",
                "line": 343,
                "source": "expect(observableMap.keyFor('nonexistent')).toBe(undefined)"
              }
            ],
            "describes": []
          },
          {
            "title": "hasEntry",
            "line": 350,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns true when key-value pair exists",
                "line": 352,
                "source": "observableMap.set('key', 'value')\nexpect(observableMap.hasEntry('key', 'value')).toBe(true)"
              },
              {
                "title": "returns false when key exists but value differs",
                "line": 358,
                "source": "observableMap.set('key', 'value1')\nexpect(observableMap.hasEntry('key', 'value2')).toBe(false)"
              },
              {
                "title": "returns false when key does not exist",
                "line": 364,
                "source": "expect(observableMap.hasEntry('key', 'value')).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "isKeyOf",
            "line": 371,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns true when key matches value",
                "line": 373,
                "source": "const value = {test: true}\nobservableMap.set('key', value)\nexpect(observableMap.isKeyOf('key', value)).toBe(true)"
              },
              {
                "title": "returns false when key does not match value",
                "line": 380,
                "source": "const value = {test: true}\nobservableMap.set('key1', value)\nexpect(observableMap.isKeyOf('key2', value)).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "Iteration",
            "line": 389,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "keys returns iterator",
                "line": 391,
                "source": "observableMap.set('a', 1)\nobservableMap.set('b', 2)\nconst keys = Array.from(observableMap.keys)\nexpect(keys).toEqual(['a', 'b'])"
              },
              {
                "title": "values returns iterator",
                "line": 399,
                "source": "observableMap.set('a', 1)\nobservableMap.set('b', 2)\nconst values = Array.from(observableMap.values)\nexpect(values).toEqual([1, 2])"
              },
              {
                "title": "entries returns array",
                "line": 407,
                "source": "observableMap.set('a', 1)\nobservableMap.set('b', 2)\nexpect(observableMap.entries).toEqual([['a', 1], ['b', 2]])"
              },
              {
                "title": "forEach iterates over entries",
                "line": 414,
                "source": "observableMap.set('a', 1)\nobservableMap.set('b', 2)\n\nconst collected = []\nobservableMap.forEach((value, key) => {\n    collected.push({key, value})\n})\n\nexpect(collected).toEqual([\n    {key: 'a', value: 1},\n    {key: 'b', value: 2}\n])"
              },
              {
                "title": "forEach with thisArg",
                "line": 430,
                "source": "observableMap.set('test', 'value')\n\nconst context = {result: null}\nobservableMap.forEach(function (value, key) {\n    this.result = {key, value}\n}, context)\n\nexpect(context.result).toEqual({key: 'test', value: 'value'})"
              }
            ],
            "describes": []
          },
          {
            "title": "all",
            "line": 444,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns empty array for empty map",
                "line": 446,
                "source": "expect(observableMap.all).toEqual([])"
              },
              {
                "title": "returns array with all values",
                "line": 451,
                "source": "observableMap.set('a', 1)\nobservableMap.set('b', 2)\nexpect(observableMap.all).toEqual([1, 2])"
              }
            ],
            "describes": []
          },
          {
            "title": "toObject",
            "line": 460,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns empty object for empty map",
                "line": 462,
                "source": "expect(observableMap.toObject()).toEqual({})"
              },
              {
                "title": "returns object with all entries",
                "line": 467,
                "source": "const foo = {name: 'foo'}\nconst bar = {name: 'bar'}\n\nobservableMap.set('foo', foo)\nobservableMap.set('bar', bar)\n\nconst object = observableMap.toObject()\n\nexpect(object).toEqual({foo, bar})"
              },
              {
                "title": "returns new object each time",
                "line": 480,
                "source": "observableMap.set('a', 1)\nconst obj1 = observableMap.toObject()\nconst obj2 = observableMap.toObject()\nexpect(obj1).not.toBe(obj2)"
              }
            ],
            "describes": []
          },
          {
            "title": "addCollection",
            "line": 490,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "adds object entries",
                "line": 492,
                "source": "const collection = {\n    foo: 'bar',\n    baz: 'qux'\n}\n\nobservableMap.addCollection(collection)\nexpect(observableMap.get('foo')).toBe('bar')\nexpect(observableMap.get('baz')).toBe('qux')\nexpect(observableMap.size).toBe(2)"
              },
              {
                "title": "adds Map entries",
                "line": 505,
                "source": "const map = new Map([\n    ['one', 1],\n    ['two', 2]\n])\n\nobservableMap.addCollection(map)\nexpect(observableMap.get('one')).toBe(1)\nexpect(observableMap.get('two')).toBe(2)\nexpect(observableMap.size).toBe(2)"
              },
              {
                "title": "returns false for invalid collection",
                "line": 518,
                "source": "expect(observableMap.addCollection(null)).toBe(false)\nexpect(observableMap.addCollection(123)).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "Event composition",
            "line": 526,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "multiple listeners receive events",
                "line": 528,
                "source": "let count1 = 0\nlet count2 = 0\n\nobservableMap.on('set', () => count1++)\nobservableMap.on('set', () => count2++)\n\nobservableMap.set('test', 'value')\n\nexpect(count1).toBe(1)\nexpect(count2).toBe(1)"
              },
              {
                "title": "can unsubscribe from events",
                "line": 542,
                "source": "let count = 0\nconst listener = () => count++\n\nobservableMap.on('set', listener)\nobservableMap.set('a', 1)\n\nobservableMap.off('set', listener)\nobservableMap.set('b', 2)\n\nexpect(count).toBe(1)"
              }
            ],
            "describes": []
          },
          {
            "title": "Complex scenarios",
            "line": 558,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "handles different value types",
                "line": 560,
                "source": "const obj = {key: 'value'}\nconst arr = [1, 2, 3]\n\nobservableMap.set('num', 1)\nobservableMap.set('str', 'string')\nobservableMap.set('obj', obj)\nobservableMap.set('arr', arr)\nobservableMap.set('null', null)\nobservableMap.set('undefined', undefined)\n\nexpect(observableMap.size).toBe(6)\nexpect(observableMap.get('obj')).toBe(obj)\nexpect(observableMap.get('arr')).toBe(arr)"
              },
              {
                "title": "maintains map semantics with object references",
                "line": 577,
                "source": "const obj1 = {id: 1}\nconst obj2 = {id: 1}  // Different reference, same content\n\nobservableMap.set('key1', obj1)\nobservableMap.set('key2', obj2)\n\nexpect(observableMap.hasValue(obj1)).toBe(true)\nexpect(observableMap.hasValue(obj2)).toBe(true)\nexpect(observableMap.size).toBe(2)"
              }
            ],
            "describes": []
          },
          {
            "title": "hasValue with shared values",
            "line": 592,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "hasValue returns true when same value is used by multiple keys",
                "line": 594,
                "source": "const sharedValue = {shared: true}\n\nobservableMap.set('key1', sharedValue)\nobservableMap.set('key2', sharedValue)\n\nexpect(observableMap.hasValue(sharedValue)).toBe(true)\nexpect(observableMap.size).toBe(2)"
              },
              {
                "title": "hasValue still returns true after deleting one key when value is shared",
                "line": 605,
                "source": "const sharedValue = {shared: true}\n\nobservableMap.set('key1', sharedValue)\nobservableMap.set('key2', sharedValue)\n\nobservableMap.delete('key1')\n\nexpect(observableMap.hasValue(sharedValue)).toBe(true)\nexpect(observableMap.size).toBe(1)"
              },
              {
                "title": "hasValue returns false only after all keys with shared value are deleted",
                "line": 618,
                "source": "const sharedValue = {shared: true}\n\nobservableMap.set('key1', sharedValue)\nobservableMap.set('key2', sharedValue)\nobservableMap.set('key3', sharedValue)\n\nobservableMap.delete('key1')\nexpect(observableMap.hasValue(sharedValue)).toBe(true)\n\nobservableMap.delete('key2')\nexpect(observableMap.hasValue(sharedValue)).toBe(true)\n\nobservableMap.delete('key3')\nexpect(observableMap.hasValue(sharedValue)).toBe(false)"
              },
              {
                "title": "hasValue works correctly when replacing a shared value",
                "line": 636,
                "source": "const sharedValue = {shared: true}\nconst newValue = {new: true}\n\nobservableMap.set('key1', sharedValue)\nobservableMap.set('key2', sharedValue)\n\nobservableMap.set('key1', newValue)\n\nexpect(observableMap.hasValue(sharedValue)).toBe(true)\nexpect(observableMap.hasValue(newValue)).toBe(true)\n\nobservableMap.set('key2', newValue)\n\nexpect(observableMap.hasValue(sharedValue)).toBe(false)\nexpect(observableMap.hasValue(newValue)).toBe(true)"
              },
              {
                "title": "clear removes all values from hasValue tracking",
                "line": 655,
                "source": "const value1 = {id: 1}\nconst value2 = {id: 2}\n\nobservableMap.set('key1', value1)\nobservableMap.set('key2', value1)\nobservableMap.set('key3', value2)\n\nobservableMap.clear()\n\nexpect(observableMap.hasValue(value1)).toBe(false)\nexpect(observableMap.hasValue(value2)).toBe(false)"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/core/observable_set.doc.js": {
    "file": "/core/observable_set.test.js",
    "describes": [
      {
        "title": "ObservableSet",
        "line": 5,
        "beforeEach": {
          "line": 9,
          "source": "observableSet = new ObservableSet()"
        },
        "afterEach": null,
        "tests": [],
        "describes": [
          {
            "title": "Constructor",
            "line": 14,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates empty set when no values provided",
                "line": 16,
                "source": "const set = new ObservableSet()\nexpect(set.size).toBe(0)"
              },
              {
                "title": "creates set with initial values from array",
                "line": 22,
                "source": "const set = new ObservableSet(['a', 'b', 'c'])\nexpect(set.size).toBe(3)\nexpect(set.has('a')).toBe(true)\nexpect(set.has('b')).toBe(true)\nexpect(set.has('c')).toBe(true)"
              },
              {
                "title": "creates set with initial values from Set",
                "line": 31,
                "source": "const set = new ObservableSet(new Set([1, 2, 3]))\nexpect(set.size).toBe(3)\nexpect(set.has(1)).toBe(true)\nexpect(set.has(2)).toBe(true)\nexpect(set.has(3)).toBe(true)"
              },
              {
                "title": "deduplicates initial values",
                "line": 40,
                "source": "const set = new ObservableSet(['a', 'b', 'a', 'c', 'b'])\nexpect(set.size).toBe(3)"
              }
            ],
            "describes": []
          },
          {
            "title": "add",
            "line": 48,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "adds value to set",
                "line": 50,
                "source": "observableSet.add('test')\nexpect(observableSet.has('test')).toBe(true)\nexpect(observableSet.size).toBe(1)"
              },
              {
                "title": "returns this for chaining",
                "line": 57,
                "source": "const result = observableSet.add('a')\nexpect(result).toBe(observableSet)"
              },
              {
                "title": "allows chaining multiple adds",
                "line": 63,
                "source": "observableSet.add('a').add('b').add('c')\nexpect(observableSet.size).toBe(3)"
              },
              {
                "title": "does not add duplicate values",
                "line": 69,
                "source": "observableSet.add('test')\nobservableSet.add('test')\nexpect(observableSet.size).toBe(1)"
              },
              {
                "title": "emits add event when value is added",
                "line": 76,
                "source": "let emittedValue\nobservableSet.on('add', (value) => {\n    emittedValue = value\n})\n\nobservableSet.add('test')\nexpect(emittedValue).toBe('test')"
              },
              {
                "title": "does not emit add event for duplicate values",
                "line": 87,
                "source": "let callCount = 0\nobservableSet.on('add', () => {\n    callCount++\n})\n\nobservableSet.add('test')\nobservableSet.add('test')\nexpect(callCount).toBe(1)"
              }
            ],
            "describes": []
          },
          {
            "title": "delete",
            "line": 101,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "deletes value from set",
                "line": 103,
                "source": "observableSet.add('test')\nconst result = observableSet.delete('test')\n\nexpect(result).toBe(true)\nexpect(observableSet.has('test')).toBe(false)\nexpect(observableSet.size).toBe(0)"
              },
              {
                "title": "returns false when deleting non-existent value",
                "line": 113,
                "source": "const result = observableSet.delete('nonexistent')\nexpect(result).toBe(false)"
              },
              {
                "title": "emits delete event when value is deleted",
                "line": 119,
                "source": "let emittedValue\nobservableSet.on('delete', (value) => {\n    emittedValue = value\n})\n\nobservableSet.add('test')\nobservableSet.delete('test')\nexpect(emittedValue).toBe('test')"
              },
              {
                "title": "does not emit delete event for non-existent value",
                "line": 131,
                "source": "let callCount = 0\nobservableSet.on('delete', () => {\n    callCount++\n})\n\nobservableSet.delete('nonexistent')\nexpect(callCount).toBe(0)"
              }
            ],
            "describes": []
          },
          {
            "title": "clear",
            "line": 144,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "clears all values from set",
                "line": 146,
                "source": "observableSet.add('a').add('b').add('c')\nobservableSet.clear()\n\nexpect(observableSet.size).toBe(0)\nexpect(observableSet.has('a')).toBe(false)"
              },
              {
                "title": "emits clear event with all values",
                "line": 155,
                "source": "let clearedValues\nobservableSet.on('clear', (values) => {\n    clearedValues = values\n})\n\nobservableSet.add('a').add('b').add('c')\nobservableSet.clear()\n\nexpect(clearedValues).toEqual(['a', 'b', 'c'])"
              },
              {
                "title": "does not emit clear event when set is already empty",
                "line": 168,
                "source": "let callCount = 0\nobservableSet.on('clear', () => {\n    callCount++\n})\n\nobservableSet.clear()\nexpect(callCount).toBe(0)"
              }
            ],
            "describes": []
          },
          {
            "title": "has",
            "line": 181,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns true for existing value",
                "line": 183,
                "source": "observableSet.add('test')\nexpect(observableSet.has('test')).toBe(true)"
              },
              {
                "title": "returns false for non-existent value",
                "line": 189,
                "source": "expect(observableSet.has('test')).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "size",
            "line": 196,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns 0 for empty set",
                "line": 198,
                "source": "expect(observableSet.size).toBe(0)"
              },
              {
                "title": "returns correct size after adding values",
                "line": 203,
                "source": "observableSet.add('a').add('b').add('c')\nexpect(observableSet.size).toBe(3)"
              },
              {
                "title": "updates size after deletion",
                "line": 209,
                "source": "observableSet.add('a').add('b')\nobservableSet.delete('a')\nexpect(observableSet.size).toBe(1)"
              }
            ],
            "describes": []
          },
          {
            "title": "Iteration",
            "line": 218,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "values returns iterator",
                "line": 220,
                "source": "observableSet.add('a').add('b').add('c')\nconst values = Array.from(observableSet.values())\nexpect(values).toEqual(['a', 'b', 'c'])"
              },
              {
                "title": "keys returns iterator",
                "line": 227,
                "source": "observableSet.add('a').add('b')\nconst keys = Array.from(observableSet.keys())\nexpect(keys).toEqual(['a', 'b'])"
              },
              {
                "title": "entries returns iterator",
                "line": 234,
                "source": "observableSet.add('a').add('b')\nconst entries = Array.from(observableSet.entries())\nexpect(entries).toEqual([['a', 'a'], ['b', 'b']])"
              },
              {
                "title": "forEach iterates over values",
                "line": 241,
                "source": "observableSet.add('a').add('b').add('c')\n\nconst collected = []\nobservableSet.forEach((value) => {\n    collected.push(value)\n})\n\nexpect(collected).toEqual(['a', 'b', 'c'])"
              },
              {
                "title": "forEach with thisArg",
                "line": 253,
                "source": "observableSet.add('test')\n\nconst context = {result: null}\nobservableSet.forEach(function (value) {\n    this.result = value\n}, context)\n\nexpect(context.result).toBe('test')"
              },
              {
                "title": "is iterable with for...of",
                "line": 265,
                "source": "observableSet.add('a').add('b').add('c')\n\nconst values = []\nfor (const value of observableSet) {\n    values.push(value)\n}\n\nexpect(values).toEqual(['a', 'b', 'c'])"
              },
              {
                "title": "spread operator works",
                "line": 277,
                "source": "observableSet.add('a').add('b').add('c')\nconst values = [...observableSet]\nexpect(values).toEqual(['a', 'b', 'c'])"
              }
            ],
            "describes": []
          },
          {
            "title": "toArray",
            "line": 286,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns empty array for empty set",
                "line": 288,
                "source": "expect(observableSet.toArray()).toEqual([])"
              },
              {
                "title": "returns array with all values",
                "line": 293,
                "source": "observableSet.add('a').add('b').add('c')\nexpect(observableSet.toArray()).toEqual(['a', 'b', 'c'])"
              },
              {
                "title": "returns new array each time",
                "line": 299,
                "source": "observableSet.add('a')\nconst arr1 = observableSet.toArray()\nconst arr2 = observableSet.toArray()\nexpect(arr1).not.toBe(arr2)"
              }
            ],
            "describes": []
          },
          {
            "title": "Event composition",
            "line": 309,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "multiple listeners receive events",
                "line": 311,
                "source": "let count1 = 0\nlet count2 = 0\n\nobservableSet.on('add', () => count1++)\nobservableSet.on('add', () => count2++)\n\nobservableSet.add('test')\n\nexpect(count1).toBe(1)\nexpect(count2).toBe(1)"
              },
              {
                "title": "can unsubscribe from events",
                "line": 325,
                "source": "let count = 0\nconst listener = () => count++\n\nobservableSet.on('add', listener)\nobservableSet.add('a')\n\nobservableSet.off('add', listener)\nobservableSet.add('b')\n\nexpect(count).toBe(1)"
              }
            ],
            "describes": []
          },
          {
            "title": "Complex scenarios",
            "line": 341,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "handles different value types",
                "line": 343,
                "source": "const obj = {key: 'value'}\nconst arr = [1, 2, 3]\n\nobservableSet.add(1)\nobservableSet.add('string')\nobservableSet.add(obj)\nobservableSet.add(arr)\nobservableSet.add(null)\nobservableSet.add(undefined)\n\nexpect(observableSet.size).toBe(6)\nexpect(observableSet.has(obj)).toBe(true)\nexpect(observableSet.has(arr)).toBe(true)"
              },
              {
                "title": "maintains set semantics with object references",
                "line": 360,
                "source": "const obj1 = {id: 1}\nconst obj2 = {id: 1}  // Different reference, same content\n\nobservableSet.add(obj1)\nobservableSet.add(obj2)\n\nexpect(observableSet.size).toBe(2)  // Different objects"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/core/perky_query.doc.js": {
    "file": "/core/perky_query.test.js",
    "describes": [
      {
        "title": "parseSelector",
        "line": 6,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "parses single id selector",
            "line": 8,
            "source": "const result = parseSelector('#player')\n\nexpect(result).toEqual([\n    [{type: 'id', value: 'player'}]\n])"
          },
          {
            "title": "parses single tag selector",
            "line": 17,
            "source": "const result = parseSelector('.enemy')\n\nexpect(result).toEqual([\n    [{type: 'tag', value: 'enemy'}]\n])"
          },
          {
            "title": "parses single name selector",
            "line": 26,
            "source": "const result = parseSelector('$GameRenderer')\n\nexpect(result).toEqual([\n    [{type: 'name', value: 'GameRenderer'}]\n])"
          },
          {
            "title": "parses single category selector",
            "line": 35,
            "source": "const result = parseSelector('@controller')\n\nexpect(result).toEqual([\n    [{type: 'category', value: 'controller'}]\n])"
          },
          {
            "title": "parses combined selectors (same level)",
            "line": 44,
            "source": "const result = parseSelector('#player.alive')\n\nexpect(result).toEqual([\n    [\n        {type: 'id', value: 'player'},\n        {type: 'tag', value: 'alive'}\n    ]\n])"
          },
          {
            "title": "parses multiple tags combined",
            "line": 56,
            "source": "const result = parseSelector('.enemy.boss.flying')\n\nexpect(result).toEqual([\n    [\n        {type: 'tag', value: 'enemy'},\n        {type: 'tag', value: 'boss'},\n        {type: 'tag', value: 'flying'}\n    ]\n])"
          },
          {
            "title": "parses descendant selectors (space separated)",
            "line": 69,
            "source": "const result = parseSelector('#world .enemy')\n\nexpect(result).toEqual([\n    [{type: 'id', value: 'world'}],\n    [{type: 'tag', value: 'enemy'}]\n])"
          },
          {
            "title": "parses multi-level descendants",
            "line": 79,
            "source": "const result = parseSelector('#world #player .weapon')\n\nexpect(result).toEqual([\n    [{type: 'id', value: 'world'}],\n    [{type: 'id', value: 'player'}],\n    [{type: 'tag', value: 'weapon'}]\n])"
          },
          {
            "title": "parses complex mixed selector",
            "line": 90,
            "source": "const result = parseSelector('@scene#main .enemy.boss')\n\nexpect(result).toEqual([\n    [\n        {type: 'category', value: 'scene'},\n        {type: 'id', value: 'main'}\n    ],\n    [\n        {type: 'tag', value: 'enemy'},\n        {type: 'tag', value: 'boss'}\n    ]\n])"
          },
          {
            "title": "handles extra whitespace",
            "line": 106,
            "source": "const result = parseSelector('  #world   .enemy  ')\n\nexpect(result).toEqual([\n    [{type: 'id', value: 'world'}],\n    [{type: 'tag', value: 'enemy'}]\n])"
          },
          {
            "title": "returns empty array for empty selector",
            "line": 116,
            "source": "const result = parseSelector('')\n\nexpect(result).toEqual([])"
          },
          {
            "title": "returns empty array for whitespace only",
            "line": 123,
            "source": "const result = parseSelector('   ')\n\nexpect(result).toEqual([])"
          },
          {
            "title": "parses selector with hyphens in values",
            "line": 130,
            "source": "const result = parseSelector('#game-loop')\n\nexpect(result).toEqual([\n    [{type: 'id', value: 'game-loop'}]\n])"
          },
          {
            "title": "parses selector with underscores in values",
            "line": 139,
            "source": "const result = parseSelector('#game_loop')\n\nexpect(result).toEqual([\n    [{type: 'id', value: 'game_loop'}]\n])"
          }
        ],
        "describes": []
      },
      {
        "title": "matchesConditions",
        "line": 150,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "matches id condition",
            "line": 152,
            "source": "const module = new PerkyModule({$id: 'player'})\nconst conditions = [{type: 'id', value: 'player'}]\n\nexpect(matchesConditions(module, conditions)).toBe(true)"
          },
          {
            "title": "does not match wrong id",
            "line": 160,
            "source": "const module = new PerkyModule({$id: 'enemy'})\nconst conditions = [{type: 'id', value: 'player'}]\n\nexpect(matchesConditions(module, conditions)).toBe(false)"
          },
          {
            "title": "matches tag condition",
            "line": 168,
            "source": "const module = new PerkyModule({$tags: ['enemy', 'collidable']})\nconst conditions = [{type: 'tag', value: 'enemy'}]\n\nexpect(matchesConditions(module, conditions)).toBe(true)"
          },
          {
            "title": "does not match missing tag",
            "line": 176,
            "source": "const module = new PerkyModule({$tags: ['friendly']})\nconst conditions = [{type: 'tag', value: 'enemy'}]\n\nexpect(matchesConditions(module, conditions)).toBe(false)"
          },
          {
            "title": "matches name condition",
            "line": 184,
            "source": "const module = new PerkyModule({$name: 'GameRenderer'})\nconst conditions = [{type: 'name', value: 'GameRenderer'}]\n\nexpect(matchesConditions(module, conditions)).toBe(true)"
          },
          {
            "title": "does not match wrong name",
            "line": 192,
            "source": "const module = new PerkyModule({$name: 'OtherRenderer'})\nconst conditions = [{type: 'name', value: 'GameRenderer'}]\n\nexpect(matchesConditions(module, conditions)).toBe(false)"
          },
          {
            "title": "matches category condition",
            "line": 200,
            "source": "const module = new PerkyModule({$category: 'controller'})\nconst conditions = [{type: 'category', value: 'controller'}]\n\nexpect(matchesConditions(module, conditions)).toBe(true)"
          },
          {
            "title": "does not match wrong category",
            "line": 208,
            "source": "const module = new PerkyModule({$category: 'renderer'})\nconst conditions = [{type: 'category', value: 'controller'}]\n\nexpect(matchesConditions(module, conditions)).toBe(false)"
          },
          {
            "title": "matches multiple conditions (AND)",
            "line": 216,
            "source": "const module = new PerkyModule({\n    $id: 'player',\n    $tags: ['alive', 'controllable']\n})\nconst conditions = [\n    {type: 'id', value: 'player'},\n    {type: 'tag', value: 'alive'}\n]\n\nexpect(matchesConditions(module, conditions)).toBe(true)"
          },
          {
            "title": "fails if any condition does not match",
            "line": 230,
            "source": "const module = new PerkyModule({\n    $id: 'player',\n    $tags: ['dead']\n})\nconst conditions = [\n    {type: 'id', value: 'player'},\n    {type: 'tag', value: 'alive'}\n]\n\nexpect(matchesConditions(module, conditions)).toBe(false)"
          },
          {
            "title": "matches empty conditions",
            "line": 244,
            "source": "const module = new PerkyModule()\nconst conditions = []\n\nexpect(matchesConditions(module, conditions)).toBe(true)"
          },
          {
            "title": "returns false for unknown condition type",
            "line": 252,
            "source": "const module = new PerkyModule({$id: 'test'})\nconst conditions = [{type: 'unknown', value: 'test'}]\n\nexpect(matchesConditions(module, conditions)).toBe(false)"
          }
        ],
        "describes": []
      },
      {
        "title": "query",
        "line": 262,
        "beforeEach": {
          "line": 265,
          "source": "root = new PerkyModule({$id: 'root'})"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "finds child by id",
            "line": 270,
            "source": "const player = root.create(PerkyModule, {$id: 'player'})\n\nconst result = query(root, '#player')\n\nexpect(result).toBe(player)"
          },
          {
            "title": "returns null when not found",
            "line": 279,
            "source": "root.create(PerkyModule, {$id: 'player'})\n\nconst result = query(root, '#enemy')\n\nexpect(result).toBeNull()"
          },
          {
            "title": "finds child by tag",
            "line": 288,
            "source": "const enemy = root.create(PerkyModule, {$id: 'enemy1', $tags: ['enemy']})\n\nconst result = query(root, '.enemy')\n\nexpect(result).toBe(enemy)"
          },
          {
            "title": "finds child by name",
            "line": 297,
            "source": "class GameRenderer extends PerkyModule {\n    static $name = 'GameRenderer'\n}\nconst renderer = root.create(GameRenderer, {$id: 'renderer'})\n\nconst result = query(root, '$GameRenderer')\n\nexpect(result).toBe(renderer)"
          },
          {
            "title": "finds child by category",
            "line": 309,
            "source": "const controller = root.create(PerkyModule, {\n    $id: 'gameCtrl',\n    $category: 'controller'\n})\n\nconst result = query(root, '@controller')\n\nexpect(result).toBe(controller)"
          },
          {
            "title": "finds child with combined selectors",
            "line": 321,
            "source": "root.create(PerkyModule, {$id: 'player', $tags: ['dead']})\nconst alivePlayer = root.create(PerkyModule, {$id: 'player2', $tags: ['alive']})\n\nconst result = query(root, '.alive')\n\nexpect(result).toBe(alivePlayer)"
          },
          {
            "title": "finds nested child (descendant)",
            "line": 331,
            "source": "const world = root.create(PerkyModule, {$id: 'world'})\nconst player = world.create(PerkyModule, {$id: 'player'})\n\nconst result = query(root, '#world #player')\n\nexpect(result).toBe(player)"
          },
          {
            "title": "finds deeply nested child",
            "line": 341,
            "source": "const world = root.create(PerkyModule, {$id: 'world'})\nconst player = world.create(PerkyModule, {$id: 'player'})\nconst weapon = player.create(PerkyModule, {$id: 'sword', $tags: ['weapon']})\n\nconst result = query(root, '#world #player .weapon')\n\nexpect(result).toBe(weapon)"
          },
          {
            "title": "returns null for partial match",
            "line": 352,
            "source": "const world = root.create(PerkyModule, {$id: 'world'})\nworld.create(PerkyModule, {$id: 'enemy'})\n\nconst result = query(root, '#world #player')\n\nexpect(result).toBeNull()"
          },
          {
            "title": "returns first match when multiple exist",
            "line": 362,
            "source": "const enemy1 = root.create(PerkyModule, {$id: 'enemy1', $tags: ['enemy']})\nroot.create(PerkyModule, {$id: 'enemy2', $tags: ['enemy']})\n\nconst result = query(root, '.enemy')\n\nexpect(result).toBe(enemy1)"
          },
          {
            "title": "returns null for empty selector",
            "line": 372,
            "source": "root.create(PerkyModule, {$id: 'player'})\n\nconst result = query(root, '')\n\nexpect(result).toBeNull()"
          },
          {
            "title": "does not search deeper than specified",
            "line": 381,
            "source": "const world = root.create(PerkyModule, {$id: 'world'})\nworld.create(PerkyModule, {$id: 'player'})\n\nconst result = query(root, '#player')\n\nexpect(result).toBeNull()"
          }
        ],
        "describes": []
      },
      {
        "title": "queryAll",
        "line": 393,
        "beforeEach": {
          "line": 396,
          "source": "root = new PerkyModule({$id: 'root'})"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "finds all children by tag",
            "line": 401,
            "source": "const enemy1 = root.create(PerkyModule, {$id: 'enemy1', $tags: ['enemy']})\nconst enemy2 = root.create(PerkyModule, {$id: 'enemy2', $tags: ['enemy']})\nroot.create(PerkyModule, {$id: 'player', $tags: ['player']})\n\nconst result = queryAll(root, '.enemy')\n\nexpect(result).toHaveLength(2)\nexpect(result).toContain(enemy1)\nexpect(result).toContain(enemy2)"
          },
          {
            "title": "returns empty array when none found",
            "line": 414,
            "source": "root.create(PerkyModule, {$id: 'player'})\n\nconst result = queryAll(root, '.enemy')\n\nexpect(result).toEqual([])"
          },
          {
            "title": "finds all children by category",
            "line": 423,
            "source": "const ctrl1 = root.create(PerkyModule, {$id: 'ctrl1', $category: 'controller'})\nconst ctrl2 = root.create(PerkyModule, {$id: 'ctrl2', $category: 'controller'})\nroot.create(PerkyModule, {$id: 'renderer', $category: 'renderer'})\n\nconst result = queryAll(root, '@controller')\n\nexpect(result).toHaveLength(2)\nexpect(result).toContain(ctrl1)\nexpect(result).toContain(ctrl2)"
          },
          {
            "title": "finds all with combined selectors",
            "line": 436,
            "source": "const boss1 = root.create(PerkyModule, {$id: 'boss1', $tags: ['enemy', 'boss']})\nconst boss2 = root.create(PerkyModule, {$id: 'boss2', $tags: ['enemy', 'boss']})\nroot.create(PerkyModule, {$id: 'minion', $tags: ['enemy']})\n\nconst result = queryAll(root, '.enemy.boss')\n\nexpect(result).toHaveLength(2)\nexpect(result).toContain(boss1)\nexpect(result).toContain(boss2)"
          },
          {
            "title": "finds all nested children",
            "line": 449,
            "source": "const world = root.create(PerkyModule, {$id: 'world'})\nconst enemy1 = world.create(PerkyModule, {$id: 'enemy1', $tags: ['enemy']})\nconst enemy2 = world.create(PerkyModule, {$id: 'enemy2', $tags: ['enemy']})\n\nconst result = queryAll(root, '#world .enemy')\n\nexpect(result).toHaveLength(2)\nexpect(result).toContain(enemy1)\nexpect(result).toContain(enemy2)"
          },
          {
            "title": "finds deeply nested children",
            "line": 462,
            "source": "const world = root.create(PerkyModule, {$id: 'world'})\nconst player = world.create(PerkyModule, {$id: 'player'})\nconst sword = player.create(PerkyModule, {$id: 'sword', $tags: ['weapon']})\nconst shield = player.create(PerkyModule, {$id: 'shield', $tags: ['weapon']})\n\nconst result = queryAll(root, '#world #player .weapon')\n\nexpect(result).toHaveLength(2)\nexpect(result).toContain(sword)\nexpect(result).toContain(shield)"
          },
          {
            "title": "returns empty array for empty selector",
            "line": 476,
            "source": "root.create(PerkyModule, {$id: 'player'})\n\nconst result = queryAll(root, '')\n\nexpect(result).toEqual([])"
          },
          {
            "title": "branches correctly with multiple parents",
            "line": 485,
            "source": "const scene1 = root.create(PerkyModule, {$id: 'scene1', $category: 'scene'})\nconst scene2 = root.create(PerkyModule, {$id: 'scene2', $category: 'scene'})\n\nconst enemy1 = scene1.create(PerkyModule, {$id: 'e1', $tags: ['enemy']})\nconst enemy2 = scene2.create(PerkyModule, {$id: 'e2', $tags: ['enemy']})\n\nconst result = queryAll(root, '@scene .enemy')\n\nexpect(result).toHaveLength(2)\nexpect(result).toContain(enemy1)\nexpect(result).toContain(enemy2)"
          },
          {
            "title": "does not search deeper than specified",
            "line": 500,
            "source": "const world = root.create(PerkyModule, {$id: 'world'})\nconst area = world.create(PerkyModule, {$id: 'area'})\narea.create(PerkyModule, {$id: 'enemy', $tags: ['enemy']})\n\nconst result = queryAll(root, '#world .enemy')\n\nexpect(result).toEqual([])"
          }
        ],
        "describes": []
      }
    ]
  },
  "/core/registry.doc.js": {
    "file": "/core/registry.test.js",
    "describes": [
      {
        "title": "Registry",
        "line": 5,
        "beforeEach": {
          "line": 9,
          "source": "registry = new Registry()"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "set",
            "line": 14,
            "source": "const spy = vi.spyOn(registry, 'emit')\n\nregistry.set('key', 'value')\n\nexpect(registry.get('key')).toBe('value')\nexpect(spy).toHaveBeenCalledWith('set', 'key', 'value', undefined)\n\nspy.mockClear()\nregistry.set('key', 'newValue')\n\nexpect(registry.get('key')).toBe('newValue')\n\nexpect(spy).toHaveBeenCalledTimes(2)\nexpect(spy).toHaveBeenNthCalledWith(1, 'delete', 'key', 'value')\nexpect(spy).toHaveBeenNthCalledWith(2, 'set', 'key', 'newValue', 'value')"
          },
          {
            "title": "set with same value does not emit delete",
            "line": 33,
            "source": "const spy = vi.spyOn(registry, 'emit')\n\nregistry.set('key', 'value')\nspy.mockClear()\n\nregistry.set('key', 'value')\n\nexpect(spy).toHaveBeenCalledTimes(1)\nexpect(spy).toHaveBeenCalledWith('set', 'key', 'value', 'value')"
          },
          {
            "title": "delete",
            "line": 46,
            "source": "const spy = vi.spyOn(registry, 'emit')\n\nregistry.set('key', 'value')\nspy.mockClear()\n\nconst result = registry.delete('key')\n\nexpect(result).toBe(true)\nexpect(registry.has('key')).toBe(false)\nexpect(spy).toHaveBeenCalledWith('delete', 'key', 'value')\nexpect(spy).toHaveBeenCalledTimes(1)"
          },
          {
            "title": "delete non-existent",
            "line": 61,
            "source": "const spy = vi.spyOn(registry, 'emit')\nconst result = registry.delete('nonexistent')\nexpect(result).toBe(false)\nexpect(spy).not.toHaveBeenCalled()"
          },
          {
            "title": "updateKey",
            "line": 69,
            "source": "const spy = vi.spyOn(registry, 'emit')\n\nregistry.set('oldKey', 'value')\nspy.mockClear()\n\nconst result = registry.updateKey('oldKey', 'newKey')\n\nexpect(result).toBe(true)\nexpect(registry.has('oldKey')).toBe(false)\nexpect(registry.has('newKey')).toBe(true)\nexpect(registry.get('newKey')).toBe('value')\nexpect(spy).toHaveBeenCalledWith('key:updated', 'oldKey', 'newKey', 'value')\nexpect(spy).toHaveBeenCalledTimes(1)"
          },
          {
            "title": "updateKey with same key does nothing",
            "line": 86,
            "source": "const spy = vi.spyOn(registry, 'emit')\n\nregistry.set('key', 'value')\nspy.mockClear()\n\nconst result = registry.updateKey('key', 'key')\n\nexpect(result).toBe(false)\nexpect(registry.has('key')).toBe(true)\nexpect(registry.get('key')).toBe('value')\nexpect(spy).not.toHaveBeenCalled()"
          },
          {
            "title": "updateKey with item verification",
            "line": 101,
            "source": "const value1 = 'value1'\nconst value2 = 'value2'\n\nregistry.set('key1', value1)\nregistry.set('key2', value2)\n\nexpect(registry.updateKey('key1', 'newKey1', value1)).toBe(true)\nexpect(registry.has('key1')).toBe(false)\nexpect(registry.get('newKey1')).toBe(value1)\n\nexpect(registry.updateKey('key2', 'newKey2', value1)).toBe(false)\nexpect(registry.has('key2')).toBe(true)\nexpect(registry.get('key2')).toBe(value2)"
          },
          {
            "title": "updateKey with non-existent key returns false",
            "line": 118,
            "source": "const result = registry.updateKey('nonexistent', 'newKey')\nexpect(result).toBe(false)"
          },
          {
            "title": "clear",
            "line": 124,
            "source": "registry.set('key1', 'value1')\nregistry.set('key2', 'value2')\nregistry.clear()\n\nexpect(registry.size).toBe(0)"
          },
          {
            "title": "clear empty",
            "line": 133,
            "source": "const spy = vi.spyOn(registry, 'emit')\nregistry.clear()\nexpect(registry.size).toBe(0)\nexpect(spy).not.toHaveBeenCalled()"
          },
          {
            "title": "addCollection object",
            "line": 141,
            "source": "const spy = vi.spyOn(registry, 'emit')\nconst collection = {\n    foo: 'bar',\n    baz: 'qux'\n}\n\nregistry.addCollection(collection)\nexpect(registry.get('foo')).toBe('bar')\nexpect(registry.get('baz')).toBe('qux')\nexpect(registry.size).toBe(2)\nexpect(spy).toHaveBeenCalledTimes(2)\nexpect(spy).toHaveBeenCalledWith('set', 'foo', 'bar', undefined)\nexpect(spy).toHaveBeenCalledWith('set', 'baz', 'qux', undefined)"
          },
          {
            "title": "addCollection map",
            "line": 158,
            "source": "const spy = vi.spyOn(registry, 'emit')\nconst map = new Map([\n    ['one', 1],\n    ['two', 2]\n])\n\nregistry.addCollection(map)\nexpect(registry.get('one')).toBe(1)\nexpect(registry.get('two')).toBe(2)\nexpect(registry.size).toBe(2)\nexpect(spy).toHaveBeenCalledTimes(2)\nexpect(spy).toHaveBeenCalledWith('set', 'one', 1, undefined)\nexpect(spy).toHaveBeenCalledWith('set', 'two', 2, undefined)"
          },
          {
            "title": "addCollection invalid",
            "line": 175,
            "source": "expect(registry.addCollection(null)).toBe(false)\nexpect(registry.addCollection(123)).toBe(false)"
          },
          {
            "title": "toObject",
            "line": 181,
            "source": "const foo = {name: 'foo'}\nconst bar = {name: 'bar'}\n\nregistry.set('foo', foo)\nregistry.set('bar', bar)\n\nconst object = registry.toObject()\n\nexpect(object).toEqual({\n    foo,\n    bar\n})\nexpect(registry.toObject()).not.toBe(registry.map)"
          },
          {
            "title": "keys",
            "line": 198,
            "source": "registry.set('a', 1)\nregistry.set('b', 2)\n\nexpect(Array.from(registry.keys)).toEqual(['a', 'b'])"
          },
          {
            "title": "values",
            "line": 206,
            "source": "registry.set('a', 1)\nregistry.set('b', 2)\n\nexpect(Array.from(registry.values)).toEqual([1, 2])"
          },
          {
            "title": "entries",
            "line": 214,
            "source": "registry.set('a', 1)\nregistry.set('b', 2)\n\nexpect(Array.from(registry.entries)).toEqual([['a', 1], ['b', 2]])"
          },
          {
            "title": "hasValue",
            "line": 222,
            "source": "registry.set('a', 1)\nregistry.set('b', 2)\n\nexpect(registry.hasValue(1)).toBe(true)\nexpect(registry.hasValue(3)).toBe(false)"
          },
          {
            "title": "keyFor",
            "line": 231,
            "source": "registry.set('a', 1)\nregistry.set('b', 2)\n\nexpect(registry.keyFor(1)).toBe('a')\nexpect(registry.keyFor(3)).toBe(undefined)"
          },
          {
            "title": "Map methods",
            "line": 240,
            "source": "registry.set('a', 1)\nregistry.set('b', 2)\n\nexpect(registry.size).toBe(2)\nexpect(registry.has('a')).toBe(true)\nexpect(registry.has('c')).toBe(false)\n\nconst results = []\nregistry.forEach((value, key) => {\n    results.push({key, value})\n})\nexpect(results).toEqual([{key: 'a', value: 1}, {key: 'b', value: 2}])"
          },
          {
            "title": "constructor with default collection",
            "line": 256,
            "source": "const collection = {\n    key1: 'value1',\n    key2: 'value2'\n}\n\nconst registryWithCollection = new Registry(collection)\n\nexpect(registryWithCollection.size).toBe(2)\nexpect(registryWithCollection.get('key1')).toBe('value1')\nexpect(registryWithCollection.get('key2')).toBe('value2')"
          }
        ],
        "describes": [
          {
            "title": "Indexing",
            "line": 270,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "addIndex creates a new index",
                "line": 272,
                "source": "registry.addIndex('byName', (item) => item.name)\nexpect(registry.hasIndex('byName')).toBe(true)"
              },
              {
                "title": "addIndex with property name string",
                "line": 278,
                "source": "registry.addIndex('byName', 'name')\n\nregistry.set('1', {name: 'Alice', age: 30})\nregistry.set('2', {name: 'Bob', age: 25})\n\nexpect(registry.lookup('byName', 'Alice')).toEqual([{name: 'Alice', age: 30}])\nexpect(registry.lookup('byName', 'Bob')).toEqual([{name: 'Bob', age: 25}])"
              },
              {
                "title": "addIndex with single argument (property name)",
                "line": 289,
                "source": "registry.addIndex('name')\n\nregistry.set('1', {name: 'Alice', age: 30})\nregistry.set('2', {name: 'Bob', age: 25})\n\nexpect(registry.lookup('name', 'Alice')).toEqual([{name: 'Alice', age: 30}])\nexpect(registry.lookup('name', 'Bob')).toEqual([{name: 'Bob', age: 25}])"
              },
              {
                "title": "addIndex returns false if keyFunction is invalid type",
                "line": 300,
                "source": "expect(registry.addIndex('test', 123)).toBe(false)\nexpect(registry.addIndex('test', null)).toBe(false)"
              },
              {
                "title": "lookup returns empty array for non-existent key",
                "line": 306,
                "source": "registry.addIndex('byName', (item) => item.name)\nexpect(registry.lookup('byName', 'John')).toEqual([])"
              },
              {
                "title": "lookup throws if index does not exist",
                "line": 312,
                "source": "expect(() => registry.lookup('nonExistent', 'key')).toThrow()"
              },
              {
                "title": "items are automatically added to index on set",
                "line": 317,
                "source": "registry.addIndex('byName', (item) => item.name)\n\nregistry.set('1', {name: 'Alice', age: 30})\nregistry.set('2', {name: 'Bob', age: 25})\n\nexpect(registry.lookup('byName', 'Alice')).toEqual([{name: 'Alice', age: 30}])\nexpect(registry.lookup('byName', 'Bob')).toEqual([{name: 'Bob', age: 25}])"
              },
              {
                "title": "multiple items with same key are stored in index",
                "line": 328,
                "source": "registry.addIndex('byAge', (item) => item.age)\n\nregistry.set('1', {name: 'Alice', age: 30})\nregistry.set('2', {name: 'Bob', age: 30})\nregistry.set('3', {name: 'Charlie', age: 25})\n\nconst age30 = registry.lookup('byAge', 30)\nexpect(age30).toHaveLength(2)\nexpect(age30).toContainEqual({name: 'Alice', age: 30})\nexpect(age30).toContainEqual({name: 'Bob', age: 30})"
              },
              {
                "title": "items are removed from index on delete",
                "line": 342,
                "source": "registry.addIndex('byName', (item) => item.name)\n\nregistry.set('1', {name: 'Alice', age: 30})\nexpect(registry.lookup('byName', 'Alice')).toHaveLength(1)\n\nregistry.delete('1')\nexpect(registry.lookup('byName', 'Alice')).toEqual([])"
              },
              {
                "title": "items are updated in index when replaced",
                "line": 353,
                "source": "registry.addIndex('byName', (item) => item.name)\n\nregistry.set('1', {name: 'Alice', age: 30})\nexpect(registry.lookup('byName', 'Alice')).toHaveLength(1)\n\nregistry.set('1', {name: 'Bob', age: 30})\nexpect(registry.lookup('byName', 'Alice')).toEqual([])\nexpect(registry.lookup('byName', 'Bob')).toHaveLength(1)"
              },
              {
                "title": "index can be added after items are inserted",
                "line": 365,
                "source": "registry.set('1', {name: 'Alice', age: 30})\nregistry.set('2', {name: 'Bob', age: 25})\n\nregistry.addIndex('byName', (item) => item.name)\n\nexpect(registry.lookup('byName', 'Alice')).toHaveLength(1)\nexpect(registry.lookup('byName', 'Bob')).toHaveLength(1)"
              },
              {
                "title": "multiple indexes can coexist",
                "line": 376,
                "source": "registry.addIndex('byName', (item) => item.name)\nregistry.addIndex('byAge', (item) => item.age)\n\nregistry.set('1', {name: 'Alice', age: 30})\nregistry.set('2', {name: 'Bob', age: 30})\n\nexpect(registry.lookup('byName', 'Alice')).toHaveLength(1)\nexpect(registry.lookup('byAge', 30)).toHaveLength(2)"
              },
              {
                "title": "keyFunction can return array of keys",
                "line": 388,
                "source": "registry.addIndex('byTags', (item) => item.tags)\n\nregistry.set('1', {name: 'Post1', tags: ['javascript', 'testing']})\nregistry.set('2', {name: 'Post2', tags: ['javascript', 'nodejs']})\n\nconst jsPosts = registry.lookup('byTags', 'javascript')\nexpect(jsPosts).toHaveLength(2)\n\nconst testingPosts = registry.lookup('byTags', 'testing')\nexpect(testingPosts).toHaveLength(1)\nexpect(testingPosts[0].name).toBe('Post1')"
              },
              {
                "title": "keyFunction returning null/undefined is ignored",
                "line": 403,
                "source": "registry.addIndex('byOptional', (item) => item.optional)\n\nregistry.set('1', {name: 'Item1', optional: null})\nregistry.set('2', {name: 'Item2', optional: undefined})\nregistry.set('3', {name: 'Item3', optional: 'value'})\n\nexpect(registry.lookup('byOptional', null)).toEqual([])\nexpect(registry.lookup('byOptional', undefined)).toEqual([])\nexpect(registry.lookup('byOptional', 'value')).toHaveLength(1)"
              },
              {
                "title": "removeIndex removes an index",
                "line": 416,
                "source": "registry.addIndex('byName', (item) => item.name)\nexpect(registry.hasIndex('byName')).toBe(true)\n\nregistry.removeIndex('byName')\nexpect(registry.hasIndex('byName')).toBe(false)"
              },
              {
                "title": "complex index key function",
                "line": 425,
                "source": "registry.addIndex('byActionEvent', (item) =>\n    `${item.action}:${item.event}`)\n\nregistry.set('1', {action: 'jump', event: 'pressed'})\nregistry.set('2', {action: 'jump', event: 'released'})\nregistry.set('3', {action: 'run', event: 'pressed'})\n\nconst jumpPressed = registry.lookup('byActionEvent', 'jump:pressed')\nexpect(jumpPressed).toHaveLength(1)\nexpect(jumpPressed[0].action).toBe('jump')\nexpect(jumpPressed[0].event).toBe('pressed')"
              },
              {
                "title": "index updated on clear",
                "line": 440,
                "source": "registry.addIndex('byName', (item) => item.name)\n\nregistry.set('1', {name: 'Alice', age: 30})\nregistry.set('2', {name: 'Bob', age: 25})\n\nexpect(registry.lookup('byName', 'Alice')).toHaveLength(1)\n\nregistry.clear()\n\nexpect(registry.lookup('byName', 'Alice')).toEqual([])\nexpect(registry.lookup('byName', 'Bob')).toEqual([])"
              },
              {
                "title": "updateIndexFor moves item from old key to new key",
                "line": 455,
                "source": "registry.addIndex('byCategory', (item) => item.$category)\n\nconst item = {name: 'Item', $category: 'foo'}\nregistry.set('1', item)\n\nexpect(registry.lookup('byCategory', 'foo')).toHaveLength(1)\nexpect(registry.lookup('byCategory', 'bar')).toHaveLength(0)\n\nitem.$category = 'bar'\nregistry.updateIndexFor(item, 'byCategory', 'foo', 'bar')\n\nexpect(registry.lookup('byCategory', 'foo')).toHaveLength(0)\nexpect(registry.lookup('byCategory', 'bar')).toHaveLength(1)"
              },
              {
                "title": "updateIndexFor handles array keys",
                "line": 472,
                "source": "registry.addIndex('byTags', (item) => item.tags)\n\nconst item = {name: 'Post', tags: ['javascript', 'testing']}\nregistry.set('1', item)\n\nexpect(registry.lookup('byTags', 'javascript')).toHaveLength(1)\nexpect(registry.lookup('byTags', 'testing')).toHaveLength(1)\n\nitem.tags = ['react', 'hooks']\nregistry.updateIndexFor(item, 'byTags', ['javascript', 'testing'], ['react', 'hooks'])\n\nexpect(registry.lookup('byTags', 'javascript')).toHaveLength(0)\nexpect(registry.lookup('byTags', 'testing')).toHaveLength(0)\nexpect(registry.lookup('byTags', 'react')).toHaveLength(1)\nexpect(registry.lookup('byTags', 'hooks')).toHaveLength(1)"
              },
              {
                "title": "updateIndexFor returns false if value not in registry",
                "line": 491,
                "source": "registry.addIndex('byCategory', (item) => item.$category)\nconst item = {name: 'Item', category: 'foo'}\n\nexpect(registry.updateIndexFor(item, 'byCategory', 'foo', 'bar')).toBe(false)"
              },
              {
                "title": "updateIndexFor returns false if index does not exist",
                "line": 499,
                "source": "const item = {name: 'Item', category: 'foo'}\nregistry.set('1', item)\n\nexpect(registry.updateIndexFor(item, 'nonExistent', 'foo', 'bar')).toBe(false)"
              },
              {
                "title": "refreshIndexFor recalculates index automatically",
                "line": 507,
                "source": "registry.addIndex('byCategory', (item) => item.$category)\n\nconst item = {name: 'Item', $category: 'foo'}\nregistry.set('1', item)\n\nexpect(registry.lookup('byCategory', 'foo')).toHaveLength(1)\nexpect(registry.lookup('byCategory', 'bar')).toHaveLength(0)\n\nitem.$category = 'bar'\nregistry.refreshIndexFor(item, 'byCategory')\n\nexpect(registry.lookup('byCategory', 'foo')).toHaveLength(0)\nexpect(registry.lookup('byCategory', 'bar')).toHaveLength(1)"
              },
              {
                "title": "refreshIndexFor handles array values",
                "line": 524,
                "source": "registry.addIndex('byTags', (item) => item.tags)\n\nconst item = {name: 'Post', tags: ['javascript', 'testing']}\nregistry.set('1', item)\n\nexpect(registry.lookup('byTags', 'javascript')).toHaveLength(1)\n\nitem.tags = ['react', 'hooks']\nregistry.refreshIndexFor(item, 'byTags')\n\nexpect(registry.lookup('byTags', 'javascript')).toHaveLength(0)\nexpect(registry.lookup('byTags', 'react')).toHaveLength(1)"
              },
              {
                "title": "refreshIndexFor returns false if value not in registry",
                "line": 540,
                "source": "registry.addIndex('byCategory', (item) => item.$category)\nconst item = {name: 'Item', category: 'foo'}\n\nexpect(registry.refreshIndexFor(item, 'byCategory')).toBe(false)"
              },
              {
                "title": "refreshIndexFor returns false if index does not exist",
                "line": 548,
                "source": "const item = {name: 'Item', category: 'foo'}\nregistry.set('1', item)\n\nexpect(registry.refreshIndexFor(item, 'nonExistent')).toBe(false)"
              },
              {
                "title": "lookupKeys returns keys for indexed value",
                "line": 556,
                "source": "registry.addIndex('byCategory', (item) => item.category)\n\nregistry.set('item1', {name: 'Item1', category: 'electronics'})\nregistry.set('item2', {name: 'Item2', category: 'electronics'})\nregistry.set('item3', {name: 'Item3', category: 'clothing'})\n\nconst electronicKeys = registry.lookupKeys('byCategory', 'electronics')\n\nexpect(electronicKeys).toHaveLength(2)\nexpect(electronicKeys).toContain('item1')\nexpect(electronicKeys).toContain('item2')"
              },
              {
                "title": "lookupKeys returns empty array for non-existent value",
                "line": 571,
                "source": "registry.addIndex('byCategory', (item) => item.category)\n\nregistry.set('item1', {name: 'Item1', category: 'electronics'})\n\nconst result = registry.lookupKeys('byCategory', 'nonexistent')\n\nexpect(result).toEqual([])"
              },
              {
                "title": "lookupKeys throws for non-existent index",
                "line": 582,
                "source": "expect(() => registry.lookupKeys('nonExistent', 'value')).toThrow()"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/application/application.doc.js": {
    "file": "/application/application.test.js",
    "describes": [
      {
        "title": "Application",
        "line": 12,
        "beforeEach": {
          "line": 17,
          "source": "mockManifest = {\n    getAsset: vi.fn(),\n    getSource: vi.fn(),\n    getConfig: vi.fn(),\n    setConfig: vi.fn()\n}\n\nvi.spyOn(Manifest.prototype, 'getAsset').mockImplementation((...args) => {\n    return mockManifest.getAsset(...args)\n})\n\nvi.spyOn(Manifest.prototype, 'getSource').mockImplementation((...args) => {\n    return mockManifest.getSource(...args)\n})\n\nvi.spyOn(Manifest.prototype, 'getConfig').mockImplementation((path) => {\n    return mockManifest.getConfig(path)\n})\n\nvi.spyOn(Manifest.prototype, 'setConfig').mockImplementation((path, value) => {\n    return mockManifest.setConfig(path, value)\n})\n\nconst mockPerkyViewElement = document.createElement('div')\nmockPerkyViewElement.exitFullscreenMode = vi.fn()\nmockPerkyViewElement.enterFullscreenMode = vi.fn()\nvi.spyOn(PerkyView.prototype, 'mount').mockReturnValue(null)\nvi.spyOn(PerkyView, 'defaultElement').mockReturnValue(mockPerkyViewElement)\n\napplication = new Application()"
        },
        "afterEach": {
          "line": 51,
          "source": "vi.restoreAllMocks()"
        },
        "tests": [
          {
            "title": "constructor",
            "line": 56,
            "source": "expect(application).toBeInstanceOf(PerkyModule)\nexpect(application.manifest).toBeInstanceOf(Manifest)\nexpect(application.actionDispatcher).toBeDefined()\nexpect(application.loaders).toBeInstanceOf(Registry)\nexpect(application.perkyView).toBeInstanceOf(PerkyView)\nexpect(application.sourceManager).toBeDefined()"
          },
          {
            "title": "constructor with custom manifest",
            "line": 66,
            "source": "vi.restoreAllMocks()\n\nconst customManifestData = {\n    config: {name: 'Test App'}\n}\n\nconst customApp = new Application({manifest: customManifestData})\n\nexpect(customApp.manifest).toBeDefined()\nexpect(customApp.manifest.getConfig('name')).toBe('Test App')"
          },
          {
            "title": "constructor with manifest instance",
            "line": 80,
            "source": "vi.restoreAllMocks()\n\nconst manifest = new Manifest({\n    data: {\n        config: {name: 'Test App Instance'}\n    }\n})\nconst customApp = new Application({manifest})\n\nexpect(customApp.manifest).toBeInstanceOf(Manifest)\nexpect(customApp.manifest.getConfig('name')).toBe('Test App Instance')"
          },
          {
            "title": "constructor with static manifest",
            "line": 95,
            "source": "vi.restoreAllMocks()\n\nclass CustomApp extends Application {\n    static manifest = {\n        config: {name: 'Static Manifest App'}\n    }\n}\n\nconst customApp = new CustomApp()\n\nexpect(customApp.manifest).toBeInstanceOf(Manifest)\nexpect(customApp.manifest.getConfig('name')).toBe('Static Manifest App')"
          },
          {
            "title": "constructor registers keyboard and mouse devices",
            "line": 111,
            "source": "const testApp = new Application()\n\nexpect(testApp.getDevice('keyboard')).toBeInstanceOf(KeyboardDevice)\nexpect(testApp.getDevice('mouse')).toBeInstanceOf(MouseDevice)"
          },
          {
            "title": "constructor calls configure if defined",
            "line": 119,
            "source": "class ConfiguredApp extends Application {\n    constructor () {\n        super()\n    }\n\n    configureApplication () {\n        this.configureCalled = true\n    }\n}\n\nconst app = new ConfiguredApp()\nexpect(app.configureCalled).toBe(true)"
          },
          {
            "title": "loadAsset",
            "line": 136,
            "source": "vi.spyOn(application, 'loadAsset').mockResolvedValue('loaded')\n\nconst promise = application.loadAsset('logo')\n\nexpect(application.loadAsset).toHaveBeenCalledWith('logo')\nawait expect(promise).resolves.toBe('loaded')"
          },
          {
            "title": "loadTag",
            "line": 146,
            "source": "vi.spyOn(application, 'loadTag').mockResolvedValue('loaded')\n\nconst promise = application.loadTag('mainScene')\n\nexpect(application.loadTag).toHaveBeenCalledWith('mainScene')\nawait expect(promise).resolves.toBe('loaded')"
          },
          {
            "title": "loadAll",
            "line": 156,
            "source": "vi.spyOn(application, 'loadAll').mockResolvedValue('loaded')\n\nconst promise = application.loadAll()\n\nexpect(application.loadAll).toHaveBeenCalled()\nawait expect(promise).resolves.toBe('loaded')"
          },
          {
            "title": "getSource",
            "line": 166,
            "source": "application.getSource('logo')\n\nexpect(mockManifest.getSource).toHaveBeenCalledWith('logo')"
          },
          {
            "title": "config",
            "line": 173,
            "source": "application.setConfig('debug', true)\n\nexpect(mockManifest.setConfig).toHaveBeenCalledWith('debug', true)"
          },
          {
            "title": "dispose calls perkyView.dispose() which dismounts",
            "line": 180,
            "source": "const perkyView = application.perkyView\nvi.spyOn(perkyView, 'dispose')\nvi.spyOn(perkyView, 'dismount')\n\napplication.dispose()\n\nexpect(perkyView.dispose).toHaveBeenCalled()\nexpect(perkyView.dismount).toHaveBeenCalled()"
          },
          {
            "title": "input event handling integration",
            "line": 192,
            "source": "class TestController extends PerkyModule {\n    jump = vi.fn()\n}\n\nconst testApp = new Application()\nconst controller = testApp.registerController('game', TestController)\ntestApp.setActiveControllers('game')\ntestApp.bindInput({\n    deviceName: 'keyboard',\n    controlName: 'Space',\n    actionName: 'jump',\n    controllerName: 'game'\n})\n\nconst keyboardDevice = testApp.getDevice('keyboard')\nexpect(keyboardDevice).toBeDefined()\n\nconst spaceControl = keyboardDevice.getControl('Space') || keyboardDevice.findOrCreateControl(ButtonControl, {name: 'Space'})\n\nspaceControl.press({code: 'Space'})\n\nawait new Promise(resolve => setTimeout(resolve, 0))\nexpect(controller.jump).toHaveBeenCalled()"
          },
          {
            "title": "inputSystem alias provides access to InputSystem",
            "line": 219,
            "source": "expect(application.inputSystem.getDevice('keyboard')).toBeDefined()\nexpect(application.inputSystem.getDevice('mouse')).toBeDefined()"
          },
          {
            "title": "inputSystem and inputBinder getters",
            "line": 225,
            "source": "expect(application.inputSystem).toBeDefined()\nexpect(application.inputBinder).toBeDefined()"
          },
          {
            "title": "bind and unbind",
            "line": 231,
            "source": "const binding = application.bindInput({\n    deviceName: 'keyboard',\n    controlName: 'Enter',\n    actionName: 'select'\n})\n\nexpect(binding).toBeDefined()\nexpect(binding.actionName).toBe('select')\nexpect(application.getAllBindings()).toHaveLength(1)\n\nconst result = application.unbind({actionName: 'select'})\nexpect(result).toBe(true)\nexpect(application.getAllBindings()).toHaveLength(0)"
          },
          {
            "title": "getBinding and hasBinding",
            "line": 248,
            "source": "application.bindInput({\n    deviceName: 'keyboard',\n    controlName: 'Tab',\n    actionName: 'nextTab'\n})\n\nexpect(application.hasBinding({actionName: 'nextTab'})).toBe(true)\n\nconst binding = application.getBinding({actionName: 'nextTab'})\nexpect(binding).toBeDefined()\nexpect(binding.actionName).toBe('nextTab')\n\nexpect(application.hasBinding({actionName: 'nonExistent'})).toBe(false)\nexpect(application.getBinding({actionName: 'nonExistent'})).toBeNull()"
          },
          {
            "title": "getBindingsForInput",
            "line": 266,
            "source": "application.bindInput({\n    deviceName: 'keyboard',\n    controlName: 'F1',\n    actionName: 'help'\n})\n\nconst bindings = application.getBindingsForInput({\n    deviceName: 'keyboard',\n    controlName: 'F1',\n    eventType: 'pressed'\n})\n\nexpect(bindings).toHaveLength(1)\nexpect(bindings[0].actionName).toBe('help')"
          },
          {
            "title": "clearBindings",
            "line": 284,
            "source": "application.bindInput({deviceName: 'keyboard', controlName: 'A', actionName: 'action1'})\napplication.bindInput({deviceName: 'keyboard', controlName: 'B', actionName: 'action2'})\n\nexpect(application.getAllBindings()).toHaveLength(2)\n\napplication.clearBindings()\nexpect(application.getAllBindings()).toHaveLength(0)"
          },
          {
            "title": "device management",
            "line": 295,
            "source": "expect(application.registerDevice).toBeDefined()\nexpect(application.getDevice).toBeDefined()\n\nconst keyboardDevice = application.getDevice('keyboard')\nconst mouseDevice = application.getDevice('mouse')\nexpect(keyboardDevice).toBeInstanceOf(KeyboardDevice)\nexpect(mouseDevice).toBeInstanceOf(MouseDevice)\nexpect(application.getDevice('nonExistent')).toBeNull()"
          },
          {
            "title": "input state queries",
            "line": 307,
            "source": "expect(application.isPressed('keyboard', 'Space')).toBe(false)\nexpect(application.isPressedAny('Jump')).toBe(false)\nexpect(application.getInputValue('mouse', 'leftButton')).toBe(0)\nexpect(application.getInputValueAny('Fire')).toBeUndefined()\nexpect(application.getControl('keyboard', 'Space')).toBeNull()\nexpect(application.getControlAny('Jump')).toBeNull()"
          },
          {
            "title": "input state shortcuts - isKeyPressed and isMousePressed",
            "line": 317,
            "source": "expect(application.isKeyPressed('Space')).toBe(false)\nexpect(application.isKeyPressed('ArrowLeft')).toBe(false)\nexpect(application.isKeyPressed('KeyW')).toBe(false)\n\nexpect(application.isMousePressed('leftButton')).toBe(false)\nexpect(application.isMousePressed('rightButton')).toBe(false)\nexpect(application.isMousePressed('middleButton')).toBe(false)\n\nexpect(application.isKeyPressed('Space')).toBe(application.isPressed('keyboard', 'Space'))\nexpect(application.isMousePressed('leftButton')).toBe(application.isPressed('mouse', 'leftButton'))"
          },
          {
            "title": "input value shortcuts - getKeyValue and getMouseValue",
            "line": 331,
            "source": "expect(application.getKeyValue('Space')).toBeUndefined()\nexpect(application.getKeyValue('ArrowLeft')).toBeUndefined()\nexpect(application.getKeyValue('KeyW')).toBeUndefined()\n\nexpect(application.getMouseValue('leftButton')).toBe(application.getInputValue('mouse', 'leftButton'))\nexpect(application.getMouseValue('rightButton')).toBe(application.getInputValue('mouse', 'rightButton'))\nexpect(application.getMouseValue('position')).toBe(application.getInputValue('mouse', 'position'))\n\nexpect(application.getKeyValue('Space')).toBe(application.getInputValue('keyboard', 'Space'))\nexpect(application.getMouseValue('leftButton')).toBe(application.getInputValue('mouse', 'leftButton'))\nexpect(application.getMouseValue('unknownControl')).toBe(application.getInputValue('mouse', 'unknownControl'))"
          },
          {
            "title": "input shortcuts with simulated key presses",
            "line": 346,
            "source": "const keyboardDevice = application.getDevice('keyboard')\nconst mouseDevice = application.getDevice('mouse')\n\nconst spaceControl = keyboardDevice.findOrCreateControl(ButtonControl, {name: 'Space'})\nspaceControl.press()\n\nexpect(application.isKeyPressed('Space')).toBe(true)\nexpect(application.getKeyValue('Space')).toBe(1)\nexpect(application.isPressed('keyboard', 'Space')).toBe(true)\n\nconst leftButtonControl = mouseDevice.findOrCreateControl(ButtonControl, {name: 'leftButton'})\nleftButtonControl.press()\n\nexpect(application.isMousePressed('leftButton')).toBe(true)\nexpect(application.getMouseValue('leftButton')).toBe(1)\nexpect(application.isPressed('mouse', 'leftButton')).toBe(true)\n\nspaceControl.release()\nleftButtonControl.release()\n\nexpect(application.isKeyPressed('Space')).toBe(false)\nexpect(application.getKeyValue('Space')).toBe(0)\nexpect(application.isMousePressed('leftButton')).toBe(false)\nexpect(application.getMouseValue('leftButton')).toBe(0)"
          },
          {
            "title": "input shortcuts consistency verification",
            "line": 374,
            "source": "const testCases = [\n    {key: 'Space', device: 'keyboard'},\n    {key: 'ArrowLeft', device: 'keyboard'},\n    {key: 'KeyW', device: 'keyboard'},\n    {key: 'leftButton', device: 'mouse'},\n    {key: 'rightButton', device: 'mouse'},\n    {key: 'unknownControl', device: 'keyboard'},\n    {key: 'unknownControl', device: 'mouse'}\n]\n\ntestCases.forEach(({key, device}) => {\n    if (device === 'keyboard') {\n        expect(application.isKeyPressed(key)).toBe(application.isPressed('keyboard', key))\n        expect(application.getKeyValue(key)).toBe(application.getInputValue('keyboard', key))\n    } else {\n        expect(application.isMousePressed(key)).toBe(application.isPressed('mouse', key))\n        expect(application.getMouseValue(key)).toBe(application.getInputValue('mouse', key))\n    }\n})\n\nexpect(application.isKeyPressed('NonExistentKey')).toBe(false)\nexpect(application.isMousePressed('NonExistentButton')).toBe(false)"
          },
          {
            "title": "bindKey convenience method",
            "line": 400,
            "source": "const binding = application.bindInput({controlName: 'Escape', actionName: 'pause'})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('keyboard')\nexpect(binding.controlName).toBe('Escape')\nexpect(binding.actionName).toBe('pause')\nexpect(binding.eventType).toBe('pressed')\n\nconst releasedBinding = application.bindInput({controlName: 'Escape', actionName: 'resume', eventType: 'released'})\nexpect(releasedBinding.eventType).toBe('released')"
          },
          {
            "title": "bindMouse convenience method",
            "line": 414,
            "source": "const binding = application.bindInput({controlName: 'leftButton', actionName: 'shoot'})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('mouse')\nexpect(binding.controlName).toBe('leftButton')\nexpect(binding.actionName).toBe('shoot')\nexpect(binding.eventType).toBe('pressed')\n\nconst releasedBinding = application.bindInput({controlName: 'rightButton', actionName: 'aim', eventType: 'released'})\nexpect(releasedBinding.eventType).toBe('released')"
          },
          {
            "title": "addControl",
            "line": 428,
            "source": "const control = application.addControl('keyboard', ButtonControl, {name: 'CustomKey'})\n\nexpect(control).toBeInstanceOf(ButtonControl)\nexpect(control.name).toBe('CustomKey')\n\nconst keyboardDevice = application.getDevice('keyboard')\nexpect(keyboardDevice.getControl('CustomKey')).toBe(control)"
          },
          {
            "title": "use method installs child class",
            "line": 439,
            "source": "class TestChild extends PerkyModule {\n    constructor (options) {\n        super({...options, $id: 'testChild'})\n    }\n}\n\napplication.create(TestChild, {$id: 'testChild', $category: 'default'})\n\nexpect(application.hasChild('testChild')).toBe(true)"
          },
          {
            "title": "use method installs child instance",
            "line": 452,
            "source": "class TestChild extends PerkyModule {\n    constructor (options) {\n        super({...options, $id: 'testChild'})\n    }\n}\n\napplication.create(TestChild, {\n    $id: 'testChild',\n    $category: 'default'\n})\n\nexpect(application.hasChild('testChild')).toBe(true)"
          },
          {
            "title": "use method with options",
            "line": 468,
            "source": "class TestChild extends PerkyModule {\n    constructor (options) {\n        super({...options, $id: 'testChild'})\n    }\n}\n\napplication.create(TestChild, {\n    $id: 'testChild',\n    $category: 'default',\n    someOption: true\n})\n\nconst child = application.getChild('testChild')\nexpect(child.options.someOption).toBe(true)"
          }
        ],
        "describes": [
          {
            "title": "bindKey flexible API",
            "line": 486,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "parameter format with controllerName",
                "line": 488,
                "source": "const binding = application.bindInput({controlName: 'KeyF', actionName: 'fire', eventType: 'pressed', controllerName: 'player1'})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('keyboard')\nexpect(binding.controlName).toBe('KeyF')\nexpect(binding.actionName).toBe('fire')\nexpect(binding.eventType).toBe('pressed')\nexpect(binding.controllerName).toBe('player1')"
              },
              {
                "title": "parameter format with eventType and no controllerName",
                "line": 499,
                "source": "const binding = application.bindInput({controlName: 'KeyG', actionName: 'grenade', eventType: 'released'})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('keyboard')\nexpect(binding.controlName).toBe('KeyG')\nexpect(binding.actionName).toBe('grenade')\nexpect(binding.eventType).toBe('released')\nexpect(binding.controllerName).toBeNull()"
              },
              {
                "title": "object format with actionName only",
                "line": 510,
                "source": "const binding = application.bindInput({controlName: 'KeyH', actionName: 'heal'})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('keyboard')\nexpect(binding.controlName).toBe('KeyH')\nexpect(binding.actionName).toBe('heal')\nexpect(binding.eventType).toBe('pressed')\nexpect(binding.controllerName).toBeNull()"
              },
              {
                "title": "object format with actionName and eventType",
                "line": 521,
                "source": "const binding = application.bindInput({\n    controlName: 'KeyI',\n    actionName: 'inventory',\n    eventType: 'released'\n})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('keyboard')\nexpect(binding.controlName).toBe('KeyI')\nexpect(binding.actionName).toBe('inventory')\nexpect(binding.eventType).toBe('released')\nexpect(binding.controllerName).toBeNull()"
              },
              {
                "title": "object format with all options",
                "line": 536,
                "source": "const binding = application.bindInput({\n    controlName: 'KeyJ',\n    actionName: 'jump',\n    eventType: 'pressed',\n    controllerName: 'player2'\n})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('keyboard')\nexpect(binding.controlName).toBe('KeyJ')\nexpect(binding.actionName).toBe('jump')\nexpect(binding.eventType).toBe('pressed')\nexpect(binding.controllerName).toBe('player2')"
              },
              {
                "title": "object format with partial options uses defaults",
                "line": 552,
                "source": "const binding = application.bindInput({\n    controlName: 'KeyK',\n    actionName: 'kick',\n    controllerName: 'player3'\n})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('keyboard')\nexpect(binding.controlName).toBe('KeyK')\nexpect(binding.actionName).toBe('kick')\nexpect(binding.eventType).toBe('pressed')\nexpect(binding.controllerName).toBe('player3')"
              },
              {
                "title": "backwards compatibility - original format still works",
                "line": 567,
                "source": "const binding = application.bindInput({controlName: 'KeyL', actionName: 'look'})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('keyboard')\nexpect(binding.controlName).toBe('KeyL')\nexpect(binding.actionName).toBe('look')\nexpect(binding.eventType).toBe('pressed')\nexpect(binding.controllerName).toBeNull()"
              }
            ],
            "describes": []
          },
          {
            "title": "bindMouse flexible API",
            "line": 581,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "parameter format with controllerName",
                "line": 583,
                "source": "const binding = application.bindInput({controlName: 'middleButton', actionName: 'zoom', eventType: 'pressed', controllerName: 'camera'})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('mouse')\nexpect(binding.controlName).toBe('middleButton')\nexpect(binding.actionName).toBe('zoom')\nexpect(binding.eventType).toBe('pressed')\nexpect(binding.controllerName).toBe('camera')"
              },
              {
                "title": "parameter format with eventType and no controllerName",
                "line": 594,
                "source": "const binding = application.bindInput({controlName: 'rightButton', actionName: 'context', eventType: 'released'})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('mouse')\nexpect(binding.controlName).toBe('rightButton')\nexpect(binding.actionName).toBe('context')\nexpect(binding.eventType).toBe('released')\nexpect(binding.controllerName).toBeNull()"
              },
              {
                "title": "object format with actionName only",
                "line": 605,
                "source": "const binding = application.bindInput({controlName: 'leftButton', actionName: 'select'})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('mouse')\nexpect(binding.controlName).toBe('leftButton')\nexpect(binding.actionName).toBe('select')\nexpect(binding.eventType).toBe('pressed')\nexpect(binding.controllerName).toBeNull()"
              },
              {
                "title": "object format with actionName and eventType",
                "line": 616,
                "source": "const binding = application.bindInput({\n    controlName: 'rightButton',\n    actionName: 'menu',\n    eventType: 'released'\n})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('mouse')\nexpect(binding.controlName).toBe('rightButton')\nexpect(binding.actionName).toBe('menu')\nexpect(binding.eventType).toBe('released')\nexpect(binding.controllerName).toBeNull()"
              },
              {
                "title": "object format with all options",
                "line": 631,
                "source": "const binding = application.bindInput({\n    controlName: 'leftButton',\n    actionName: 'fire',\n    eventType: 'pressed',\n    controllerName: 'weapon'\n})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('mouse')\nexpect(binding.controlName).toBe('leftButton')\nexpect(binding.actionName).toBe('fire')\nexpect(binding.eventType).toBe('pressed')\nexpect(binding.controllerName).toBe('weapon')"
              },
              {
                "title": "object format with partial options uses defaults",
                "line": 647,
                "source": "const binding = application.bindInput({\n    controlName: 'middleButton',\n    actionName: 'special',\n    controllerName: 'ui'\n})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('mouse')\nexpect(binding.controlName).toBe('middleButton')\nexpect(binding.actionName).toBe('special')\nexpect(binding.eventType).toBe('pressed')\nexpect(binding.controllerName).toBe('ui')"
              },
              {
                "title": "backwards compatibility - original format still works",
                "line": 662,
                "source": "const binding = application.bindInput({controlName: 'rightButton', actionName: 'aim'})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('mouse')\nexpect(binding.controlName).toBe('rightButton')\nexpect(binding.actionName).toBe('aim')\nexpect(binding.eventType).toBe('pressed')\nexpect(binding.controllerName).toBeNull()"
              },
              {
                "title": "object format validation - empty object should throw",
                "line": 673,
                "source": "expect(() => {\n    application.bindMouse('leftButton', {})\n}).toThrow()"
              },
              {
                "title": "object format validation - undefined actionName should throw",
                "line": 679,
                "source": "expect(() => {\n    application.bindMouse('rightButton', {actionName: undefined})\n}).toThrow()"
              },
              {
                "title": "parameter format validation - undefined actionName should throw",
                "line": 685,
                "source": "expect(() => {\n    application.bindMouse('middleButton', undefined)\n}).toThrow()"
              }
            ],
            "describes": []
          },
          {
            "title": "flexible API edge cases",
            "line": 694,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "mixed usage in same application",
                "line": 696,
                "source": "const binding1 = application.bindInput({controlName: 'Digit1', actionName: 'slot1', eventType: 'pressed', controllerName: 'inventory'})\n\nconst binding2 = application.bindInput({\n    controlName: 'Digit2',\n    actionName: 'slot2',\n    eventType: 'pressed',\n    controllerName: 'inventory'\n})\n\nexpect(binding1.actionName).toBe('slot1')\nexpect(binding1.controllerName).toBe('inventory')\nexpect(binding2.actionName).toBe('slot2')\nexpect(binding2.controllerName).toBe('inventory')\n\nconst allBindings = application.getAllBindings()\nconst inventoryBindings = allBindings.filter(b => b.controllerName === 'inventory')\nexpect(inventoryBindings).toHaveLength(2)"
              },
              {
                "title": "object format with empty object defaults everything",
                "line": 716,
                "source": "expect(() => {\n    application.bindKey('KeyEmpty', {})\n}).toThrow()"
              },
              {
                "title": "object format with undefined actionName",
                "line": 722,
                "source": "expect(() => {\n    application.bindKey('KeyUndef', {actionName: undefined})\n}).toThrow()"
              },
              {
                "title": "object format with null actionName",
                "line": 728,
                "source": "expect(() => {\n    application.bindKey('KeyNull', {actionName: null})\n}).toThrow()"
              },
              {
                "title": "object format with empty string actionName",
                "line": 734,
                "source": "expect(() => {\n    application.bindKey('KeyEmpty', {actionName: ''})\n}).toThrow()"
              },
              {
                "title": "parameter format with undefined actionName",
                "line": 740,
                "source": "expect(() => {\n    application.bindKey('KeyParamUndef', undefined)\n}).toThrow()"
              },
              {
                "title": "parameter format with null actionName",
                "line": 746,
                "source": "expect(() => {\n    application.bindKey('KeyParamNull', null)\n}).toThrow()"
              }
            ],
            "describes": []
          },
          {
            "title": "bindCombo",
            "line": 755,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "accepts string format with auto-detection",
                "line": 757,
                "source": "const combo = application.bindCombo(['ShiftLeft', 'leftButton'], 'shiftClick')\n\nexpect(combo).toBeDefined()\nexpect(combo.controls).toHaveLength(2)\nexpect(combo.controls[0].deviceName).toBe('keyboard')\nexpect(combo.controls[0].controlName).toBe('ShiftLeft')\nexpect(combo.controls[1].deviceName).toBe('mouse')\nexpect(combo.controls[1].controlName).toBe('leftButton')\nexpect(combo.actionName).toBe('shiftClick')"
              },
              {
                "title": "accepts object format",
                "line": 770,
                "source": "const combo = application.bindCombo([\n    {deviceName: 'keyboard', controlName: 'ControlLeft'},\n    {deviceName: 'mouse', controlName: 'rightButton'}\n], 'ctrlRightClick')\n\nexpect(combo.controls).toHaveLength(2)\nexpect(combo.controls[0].deviceName).toBe('keyboard')\nexpect(combo.controls[1].deviceName).toBe('mouse')"
              },
              {
                "title": "accepts mixed string and object formats",
                "line": 782,
                "source": "const combo = application.bindCombo([\n    'ControlLeft',\n    {deviceName: 'mouse', controlName: 'leftButton'}\n], 'mixedCombo')\n\nexpect(combo.controls).toHaveLength(2)\nexpect(combo.controls[0].deviceName).toBe('keyboard')\nexpect(combo.controls[0].controlName).toBe('ControlLeft')\nexpect(combo.controls[1].deviceName).toBe('mouse')\nexpect(combo.controls[1].controlName).toBe('leftButton')"
              },
              {
                "title": "works with keyboard-only combinations",
                "line": 796,
                "source": "const combo = application.bindCombo(['ControlLeft', 'KeyS'], 'save')\n\nexpect(combo.controls).toHaveLength(2)\nexpect(combo.controls.every(c => c.deviceName === 'keyboard')).toBe(true)"
              },
              {
                "title": "works with mouse-only combinations",
                "line": 804,
                "source": "const combo = application.bindCombo(['leftButton', 'rightButton'], 'bothButtons')\n\nexpect(combo.controls).toHaveLength(2)\nexpect(combo.controls.every(c => c.deviceName === 'mouse')).toBe(true)"
              },
              {
                "title": "supports controller and eventType",
                "line": 812,
                "source": "const combo = application.bindCombo(\n    ['AltLeft', 'middleButton'],\n    'special',\n    'editor',\n    'released'\n)\n\nexpect(combo.controllerName).toBe('editor')\nexpect(combo.eventType).toBe('released')"
              },
              {
                "title": "integration test - triggers when all controls are pressed",
                "line": 825,
                "source": "class TestController extends PerkyModule {\n    smartCombo = vi.fn()\n}\n\nconst testApp = new Application()\n\n\nconst controller = testApp.registerController('editor', TestController)\ntestApp.setActiveControllers('editor')\ntestApp.bindCombo(['ControlLeft', 'leftButton'], 'smartCombo', 'editor')\n\nconst keyboardDevice = testApp.getDevice('keyboard')\nconst mouseDevice = testApp.getDevice('mouse')\n\nconst ctrlControl = keyboardDevice.findOrCreateControl(ButtonControl, {name: 'ControlLeft'})\nconst leftButtonControl = mouseDevice.findOrCreateControl(ButtonControl, {name: 'leftButton'})\n\nctrlControl.press({code: 'ControlLeft'})\nawait new Promise(resolve => setTimeout(resolve, 0))\nexpect(controller.smartCombo).not.toHaveBeenCalled()\n\nleftButtonControl.press()\nawait new Promise(resolve => setTimeout(resolve, 0))\nexpect(controller.smartCombo).toHaveBeenCalled()"
              }
            ],
            "describes": []
          },
          {
            "title": "isActionPressed and getActionControls",
            "line": 855,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "isActionPressed - returns false when action not bound",
                "line": 857,
                "source": "expect(application.isActionPressed('nonExistent')).toBe(false)"
              },
              {
                "title": "isActionPressed - returns false when control not pressed",
                "line": 862,
                "source": "application.bindInput({controlName: 'Space', actionName: 'jump'})\nexpect(application.isActionPressed('jump')).toBe(false)"
              },
              {
                "title": "isActionPressed - returns true when control is pressed",
                "line": 868,
                "source": "application.bindInput({controlName: 'Space', actionName: 'jump'})\n\nconst keyboardDevice = application.getDevice('keyboard')\nconst spaceControl = keyboardDevice.findOrCreateControl(ButtonControl, {name: 'Space'})\nspaceControl.press()\n\nexpect(application.isActionPressed('jump')).toBe(true)"
              },
              {
                "title": "isActionPressed - works with multiple bindings for same action",
                "line": 879,
                "source": "application.bindInput({controlName: 'Space', actionName: 'jump'})\napplication.bindInput({controlName: 'KeyW', actionName: 'jump'})\n\nconst keyboardDevice = application.getDevice('keyboard')\nconst wControl = keyboardDevice.findOrCreateControl(ButtonControl, {name: 'KeyW'})\nwControl.press()\n\nexpect(application.isActionPressed('jump')).toBe(true)"
              },
              {
                "title": "isActionPressed - filters by controllerName",
                "line": 891,
                "source": "application.bindInput({controlName: 'Space', actionName: 'jump', eventType: 'pressed', controllerName: 'player1'})\napplication.bindInput({controlName: 'KeyW', actionName: 'jump', eventType: 'pressed', controllerName: 'player2'})\n\nconst keyboardDevice = application.getDevice('keyboard')\nconst spaceControl = keyboardDevice.findOrCreateControl(ButtonControl, {name: 'Space'})\nspaceControl.press()\n\nexpect(application.isActionPressed('jump', 'player1')).toBe(true)\nexpect(application.isActionPressed('jump', 'player2')).toBe(false)\nexpect(application.isActionPressed('jump')).toBe(true)"
              },
              {
                "title": "isActionPressed - works with composite bindings",
                "line": 905,
                "source": "application.bindCombo(['ControlLeft', 'KeyS'], 'save')\n\nconst keyboardDevice = application.getDevice('keyboard')\nconst ctrlControl = keyboardDevice.findOrCreateControl(ButtonControl, {name: 'ControlLeft'})\nconst sControl = keyboardDevice.findOrCreateControl(ButtonControl, {name: 'KeyS'})\n\nctrlControl.press()\nexpect(application.isActionPressed('save')).toBe(false)\n\nsControl.press()\nexpect(application.isActionPressed('save')).toBe(true)\n\nctrlControl.release()\nexpect(application.isActionPressed('save')).toBe(false)"
              },
              {
                "title": "getActionControls - returns empty array when action not bound",
                "line": 923,
                "source": "const controls = application.getActionControls('nonExistent')\nexpect(controls).toHaveLength(0)"
              },
              {
                "title": "getActionControls - returns control for simple binding",
                "line": 929,
                "source": "application.bindInput({controlName: 'Space', actionName: 'jump'})\n\nconst keyboardDevice = application.getDevice('keyboard')\nconst spaceControl = keyboardDevice.findOrCreateControl(ButtonControl, {name: 'Space'})\n\nconst controls = application.getActionControls('jump')\nexpect(controls).toHaveLength(1)\nexpect(controls[0]).toBe(spaceControl)"
              },
              {
                "title": "getActionControls - returns multiple controls for multiple bindings",
                "line": 941,
                "source": "application.bindInput({controlName: 'Space', actionName: 'jump', eventType: 'pressed', controllerName: 'player1'})\napplication.bindInput({controlName: 'KeyW', actionName: 'jump', eventType: 'pressed', controllerName: 'player2'})\n\nconst keyboardDevice = application.getDevice('keyboard')\nconst spaceControl = keyboardDevice.findOrCreateControl(ButtonControl, {name: 'Space'})\nconst wControl = keyboardDevice.findOrCreateControl(ButtonControl, {name: 'KeyW'})\n\nconst controls = application.getActionControls('jump')\nexpect(controls).toHaveLength(2)\nexpect(controls).toContain(spaceControl)\nexpect(controls).toContain(wControl)"
              },
              {
                "title": "getActionControls - filters by controllerName",
                "line": 956,
                "source": "application.bindInput({controlName: 'Space', actionName: 'jump', eventType: 'pressed', controllerName: 'player1'})\napplication.bindInput({controlName: 'KeyW', actionName: 'jump', eventType: 'pressed', controllerName: 'player2'})\n\nconst keyboardDevice = application.getDevice('keyboard')\nkeyboardDevice.findOrCreateControl(ButtonControl, {name: 'Space'})\nkeyboardDevice.findOrCreateControl(ButtonControl, {name: 'KeyW'})\n\nconst player1Controls = application.getActionControls('jump', 'player1')\nexpect(player1Controls).toHaveLength(1)\nexpect(player1Controls[0].name).toBe('Space')\n\nconst player2Controls = application.getActionControls('jump', 'player2')\nexpect(player2Controls).toHaveLength(1)\nexpect(player2Controls[0].name).toBe('KeyW')\n\nconst allControls = application.getActionControls('jump')\nexpect(allControls).toHaveLength(2)"
              },
              {
                "title": "getActionControls - works with composite bindings",
                "line": 977,
                "source": "application.bindCombo(['ControlLeft', 'KeyS'], 'save')\n\nconst keyboardDevice = application.getDevice('keyboard')\nconst ctrlControl = keyboardDevice.findOrCreateControl(ButtonControl, {name: 'ControlLeft'})\nconst sControl = keyboardDevice.findOrCreateControl(ButtonControl, {name: 'KeyS'})\n\nconst controls = application.getActionControls('save')\nexpect(controls).toHaveLength(2)\nexpect(controls).toContain(ctrlControl)\nexpect(controls).toContain(sControl)"
              },
              {
                "title": "getActionControls - handles non-existent controls gracefully",
                "line": 991,
                "source": "application.bindInput({controlName: 'Space', actionName: 'jump'})\n\nconst controls = application.getActionControls('jump')\nexpect(controls).toHaveLength(0)"
              },
              {
                "title": "getActionControls - works with cross-device bindings",
                "line": 999,
                "source": "application.bindInput({controlName: 'Space', actionName: 'action', eventType: 'pressed', controllerName: 'keyboard-input'})\napplication.bindInput({controlName: 'leftButton', actionName: 'action', eventType: 'pressed', controllerName: 'mouse-input'})\n\nconst keyboardDevice = application.getDevice('keyboard')\nconst mouseDevice = application.getDevice('mouse')\nconst spaceControl = keyboardDevice.findOrCreateControl(ButtonControl, {name: 'Space'})\nconst leftButtonControl = mouseDevice.findOrCreateControl(ButtonControl, {name: 'leftButton'})\n\nconst controls = application.getActionControls('action')\nexpect(controls).toHaveLength(2)\nexpect(controls).toContain(spaceControl)\nexpect(controls).toContain(leftButtonControl)"
              }
            ],
            "describes": []
          },
          {
            "title": "controller bindings auto-registration",
            "line": 1017,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "registers simple bindings when controller is registered",
                "line": 1019,
                "source": "class TestController extends PerkyModule {\n    static bindings = {\n        shoot: 'Space',\n        jump: 'KeyJ'\n    }\n\n    static normalizeBindings () {\n        return [\n            {action: 'shoot', key: 'Space', scoped: false, eventType: 'pressed', controllerName: null},\n            {action: 'jump', key: 'KeyJ', scoped: false, eventType: 'pressed', controllerName: null}\n        ]\n    }\n}\n\nconst beforeBindings = application.getAllBindings()\nexpect(beforeBindings.filter(b => b.actionName === 'shoot')).toHaveLength(0)\n\napplication.registerController('game', TestController)\n\nconst afterBindings = application.getAllBindings()\nconst shootBinding = afterBindings.find(b => b.actionName === 'shoot')\nconst jumpBinding = afterBindings.find(b => b.actionName === 'jump')\n\nexpect(shootBinding).toBeDefined()\nexpect(shootBinding.controlName).toBe('Space')\nexpect(shootBinding.controllerName).toBeNull()\n\nexpect(jumpBinding).toBeDefined()\nexpect(jumpBinding.controlName).toBe('KeyJ')\nexpect(jumpBinding.controllerName).toBeNull()"
              },
              {
                "title": "registers scoped bindings with controllerName",
                "line": 1053,
                "source": "class TestController extends PerkyModule {\n    static bindings = {\n        shoot: {keys: 'Space', scoped: true}\n    }\n\n    static normalizeBindings (controllerName) {\n        return [\n            {action: 'shoot', key: 'Space', scoped: true, eventType: 'pressed', controllerName}\n        ]\n    }\n}\n\napplication.registerController('player', TestController)\n\nconst bindings = application.getAllBindings()\nconst shootBinding = bindings.find(b => b.actionName === 'shoot' && b.controllerName === 'player')\n\nexpect(shootBinding).toBeDefined()\nexpect(shootBinding.controlName).toBe('Space')\nexpect(shootBinding.controllerName).toBe('player')"
              },
              {
                "title": "registers multiple keys for same action",
                "line": 1077,
                "source": "class TestController extends PerkyModule {\n    static bindings = {\n        moveUp: ['KeyW', 'ArrowUp']\n    }\n\n    static normalizeBindings () {\n        return [\n            {action: 'moveUp', key: 'KeyW', scoped: false, eventType: 'pressed', controllerName: null},\n            {action: 'moveUp', key: 'ArrowUp', scoped: false, eventType: 'pressed', controllerName: null}\n        ]\n    }\n}\n\napplication.registerController('game', TestController)\n\nconst bindings = application.getAllBindings()\nconst moveUpBindings = bindings.filter(b => b.actionName === 'moveUp')\n\nexpect(moveUpBindings.length).toBeGreaterThanOrEqual(2)\nexpect(moveUpBindings.some(b => b.controlName === 'KeyW')).toBe(true)\nexpect(moveUpBindings.some(b => b.controlName === 'ArrowUp')).toBe(true)"
              },
              {
                "title": "registers bindings with custom eventType",
                "line": 1102,
                "source": "class TestController extends PerkyModule {\n    static bindings = {\n        boost: {keys: 'ShiftLeft', eventType: 'released'}\n    }\n\n    static normalizeBindings () {\n        return [\n            {action: 'boost', key: 'ShiftLeft', scoped: false, eventType: 'released', controllerName: null}\n        ]\n    }\n}\n\napplication.registerController('game', TestController)\n\nconst bindings = application.getAllBindings()\nconst boostBinding = bindings.find(b => b.actionName === 'boost')\n\nexpect(boostBinding).toBeDefined()\nexpect(boostBinding.eventType).toBe('released')"
              },
              {
                "title": "allows multiple controllers with same keys (different scopes)",
                "line": 1125,
                "source": "class GameController extends PerkyModule {\n    static bindings = {\n        move: {keys: 'ArrowUp', scoped: true}\n    }\n\n    static normalizeBindings (controllerName) {\n        return [\n            {action: 'move', key: 'ArrowUp', scoped: true, eventType: 'pressed', controllerName}\n        ]\n    }\n}\n\nclass MenuController extends PerkyModule {\n    static bindings = {\n        navigate: {keys: 'ArrowUp', scoped: true}\n    }\n\n    static normalizeBindings (controllerName) {\n        return [\n            {action: 'navigate', key: 'ArrowUp', scoped: true, eventType: 'pressed', controllerName}\n        ]\n    }\n}\n\napplication.registerController('game', GameController)\napplication.registerController('menu', MenuController)\n\nconst bindings = application.getAllBindings()\nconst arrowUpBindings = bindings.filter(b => b.controlName === 'ArrowUp')\n\nexpect(arrowUpBindings.length).toBeGreaterThanOrEqual(2)\n\nconst gameBinding = arrowUpBindings.find(b => b.controllerName === 'game')\nconst menuBinding = arrowUpBindings.find(b => b.controllerName === 'menu')\n\nexpect(gameBinding).toBeDefined()\nexpect(gameBinding.actionName).toBe('move')\n\nexpect(menuBinding).toBeDefined()\nexpect(menuBinding.actionName).toBe('navigate')"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/application/application_manager.doc.js": {
    "file": "/application/application_manager.test.js",
    "describes": [
      {
        "title": "ApplicationManager",
        "line": 37,
        "beforeEach": {
          "line": 41,
          "source": "appManager = new ApplicationManager()\nMockApp = MockApplication"
        },
        "afterEach": {
          "line": 46,
          "source": "vi.restoreAllMocks()"
        },
        "tests": [
          {
            "title": "constructor",
            "line": 51,
            "source": "expect(appManager).toBeInstanceOf(PerkyModule)\nexpect(appManager.constructors).toBeInstanceOf(Registry)"
          },
          {
            "title": "constructor initializes children registry",
            "line": 57,
            "source": "expect(appManager.childrenRegistry).toBeInstanceOf(Registry)\nexpect(appManager.childrenRegistry.size).toBe(0)"
          },
          {
            "title": "register",
            "line": 63,
            "source": "appManager.register('testApp', MockApp)\n\nexpect(appManager.constructors.has('testApp')).toBe(true)\nexpect(appManager.constructors.get('testApp')).toBe(MockApp)"
          },
          {
            "title": "register duplicate name throws error",
            "line": 71,
            "source": "appManager.register('testApp', MockApp)\n\nexpect(() => {\n    appManager.register('testApp', MockApp)\n}).toThrow('Application \"testApp\" is already registered.')"
          },
          {
            "title": "unregister",
            "line": 80,
            "source": "appManager.register('testApp', MockApp)\nexpect(appManager.constructors.has('testApp')).toBe(true)\n\nappManager.unregister('testApp')\nexpect(appManager.constructors.has('testApp')).toBe(false)"
          },
          {
            "title": "unregister non-existent app",
            "line": 89,
            "source": "expect(() => {\n    appManager.unregister('nonExistent')\n}).not.toThrow()\n\nexpect(appManager.constructors.has('nonExistent')).toBe(false)"
          },
          {
            "title": "createApp",
            "line": 98,
            "source": "appManager.register('testApp', MockApp)\n\nconst app = appManager.createApp('testApp', {$name: 'TestInstance'})\n\nexpect(app).toBeInstanceOf(MockApp)\nexpect(app.$id).toBeTruthy()\nexpect(app.$name).toBe('TestInstance')\nexpect(app.$category).toBe('application')\nexpect(appManager.childrenRegistry.has(app.$id)).toBe(true)\nexpect(appManager.getChild(app.$id)).toBe(app)"
          },
          {
            "title": "createApp with default params",
            "line": 112,
            "source": "appManager.register('testApp', MockApp)\n\nconst app = appManager.createApp('testApp')\n\nexpect(app).toBeInstanceOf(MockApp)\nexpect(app.$id).toBeTruthy()\nexpect(app.$name).toBe('application')"
          },
          {
            "title": "createApp generates unique names",
            "line": 123,
            "source": "appManager.register('testApp', MockApp)\n\nconst app1 = appManager.createApp('testApp')\nconst app2 = appManager.createApp('testApp')\nconst app3 = appManager.createApp('testApp')\n\nexpect(app1.$id).toBeTruthy()\nexpect(app2.$id).toBeTruthy()\nexpect(app3.$id).toBeTruthy()\nexpect(app1.$id).not.toBe(app2.$id)\nexpect(app2.$id).not.toBe(app3.$id)"
          },
          {
            "title": "createApp unregistered app throws error",
            "line": 138,
            "source": "expect(() => {\n    appManager.createApp('nonExistent')\n}).toThrow('Application \"nonExistent\" is not registered.')"
          },
          {
            "title": "spawn",
            "line": 145,
            "source": "appManager.register('testApp', MockApp)\n\nconst app = await appManager.spawn('testApp', {$name: 'SpawnedApp'})\n\nexpect(app).toBeInstanceOf(MockApp)\nexpect(app.$id).toBeTruthy()\nexpect(app.$name).toBe('SpawnedApp')\nexpect(app.mockStart).toHaveBeenCalled()\nexpect(appManager.childrenRegistry.has(app.$id)).toBe(true)"
          },
          {
            "title": "startApp",
            "line": 158,
            "source": "appManager.register('testApp', MockApp)\nconst app = appManager.createApp('testApp')\n\nappManager.startApp(app.$id)\n\nexpect(app.mockStart).toHaveBeenCalled()"
          },
          {
            "title": "startApp non-existent app",
            "line": 168,
            "source": "expect(() => {\n    appManager.startApp('nonExistent')\n}).not.toThrow()"
          },
          {
            "title": "stopApp",
            "line": 175,
            "source": "appManager.register('testApp', MockApp)\nconst app = await appManager.spawn('testApp')\n\nappManager.stopApp(app.$id)\n\nexpect(app.mockStop).toHaveBeenCalled()"
          },
          {
            "title": "stopApp non-existent app",
            "line": 185,
            "source": "expect(() => {\n    appManager.stopApp('nonExistent')\n}).not.toThrow()"
          },
          {
            "title": "execute",
            "line": 192,
            "source": "appManager = new ApplicationManager()\nappManager.register('TestApp', Application)\n\nconst app = appManager.createApp('TestApp')\nconst actionSpy = vi.fn()\napp.mainController.testAction = actionSpy\n\nappManager.execute(app.$id, 'testAction', 'arg1', 'arg2')\n\nexpect(actionSpy).toHaveBeenCalledWith('arg1', 'arg2')"
          },
          {
            "title": "execute non-existent app",
            "line": 206,
            "source": "expect(() => {\n    appManager.execute('nonExistent', 'testAction')\n}).not.toThrow()"
          },
          {
            "title": "disposeApp",
            "line": 213,
            "source": "appManager.register('testApp', MockApp)\nconst app = await appManager.spawn('testApp')\nconst appName = app.$id\n\nappManager.disposeApp(appName)\n\nexpect(app.mockDispose).toHaveBeenCalled()\nexpect(appManager.childrenRegistry.has(appName)).toBe(false)"
          },
          {
            "title": "disposeApp non-existent app",
            "line": 225,
            "source": "expect(() => {\n    appManager.disposeApp('nonExistent')\n}).not.toThrow()"
          },
          {
            "title": "disposeApp calls app.dispose() which triggers dismount",
            "line": 232,
            "source": "appManager.register('testApp', MockApp)\nconst container = document.createElement('div')\nconst app = await appManager.spawn('testApp', {container})\nconst appName = app.$id\n\nexpect(app.perkyView.mounted).toBe(true)\nconst dismountSpy = vi.spyOn(app.perkyView, 'dismount')\n\nappManager.disposeApp(appName)\n\nexpect(app.mockDispose).toHaveBeenCalled()\nexpect(dismountSpy).toHaveBeenCalledTimes(1)\nexpect(appManager.childrenRegistry.has(appName)).toBe(false)"
          },
          {
            "title": "disposeApp vs stopApp - disposeApp should call app.dispose(), not just stop()",
            "line": 249,
            "source": "appManager.register('testApp', MockApp)\nconst container = document.createElement('div')\nconst app = await appManager.spawn('testApp', {container})\nconst appName = app.$id\n\nappManager.stopApp(appName)\nexpect(app.mockStop).toHaveBeenCalledTimes(1)\nexpect(app.mockDispose).not.toHaveBeenCalled()\nexpect(appManager.childrenRegistry.has(appName)).toBe(true)\n\nconst dismountSpy = vi.spyOn(app.perkyView, 'dismount')\nappManager.disposeApp(appName)\nexpect(app.mockDispose).toHaveBeenCalled()\nexpect(dismountSpy).toHaveBeenCalledTimes(1)\nexpect(appManager.childrenRegistry.has(appName)).toBe(false)"
          },
          {
            "title": "list all apps",
            "line": 268,
            "source": "appManager.register('testApp', MockApp)\n\nconst app1 = appManager.createApp('testApp', {$name: 'App1'})\nconst app2 = appManager.createApp('testApp', {$name: 'App2'})\nconst app3 = appManager.createApp('testApp', {$name: 'Different'})\n\nconst allApps = appManager.list()\n\nexpect(allApps).toHaveLength(3)\nexpect(allApps).toContain(app1)\nexpect(allApps).toContain(app2)\nexpect(allApps).toContain(app3)"
          },
          {
            "title": "list with grep filter",
            "line": 284,
            "source": "appManager.register('testApp', MockApp)\n\nconst app1 = appManager.createApp('testApp', {$name: 'GameApp'})\nconst app2 = appManager.createApp('testApp', {$name: 'MenuApp'})\nconst app3 = appManager.createApp('testApp', {$name: 'SettingsApp'})\n\nconst gameApps = appManager.list('Game')\nconst menuApps = appManager.list('Menu')\nconst appApps = appManager.list('App')\n\nexpect(gameApps).toHaveLength(1)\nexpect(gameApps).toContain(app1)\n\nexpect(menuApps).toHaveLength(1)\nexpect(menuApps).toContain(app2)\n\nexpect(appApps).toHaveLength(3)\nexpect(appApps).toContain(app1)\nexpect(appApps).toContain(app2)\nexpect(appApps).toContain(app3)"
          },
          {
            "title": "list with no matches",
            "line": 308,
            "source": "appManager.register('testApp', MockApp)\nappManager.createApp('testApp', {$name: 'TestApp'})\n\nconst noMatches = appManager.list('NonExistent')\n\nexpect(noMatches).toHaveLength(0)"
          },
          {
            "title": "list empty registry",
            "line": 318,
            "source": "const emptyList = appManager.list()\n\nexpect(emptyList).toHaveLength(0)\nexpect(emptyList).toEqual([])"
          },
          {
            "title": "integration scenario - preload then title then game",
            "line": 326,
            "source": "class PreloadApp extends MockApp {\n    constructor (params) {\n        super({...params, $name: 'Preload'})\n    }\n}\n\nclass TitleApp extends MockApp {\n    constructor (params) {\n        super({...params, $name: 'TitleScreen'})\n    }\n}\n\nclass GameApp extends MockApp {\n    constructor (params) {\n        super({...params, $name: 'Game'})\n    }\n}\n\nappManager.register('preload', PreloadApp)\nappManager.register('title', TitleApp)\nappManager.register('game', GameApp)\n\nconst preload = await appManager.spawn('preload')\nexpect(preload.mockStart).toHaveBeenCalled()\n\nappManager.stopApp(preload.$id)\nexpect(preload.mockStop).toHaveBeenCalled()\n\nconst title = await appManager.spawn('title')\nexpect(title.mockStart).toHaveBeenCalled()\n\nappManager.stopApp(title.$id)\nawait appManager.spawn('game')\n\nexpect(appManager.list()).toHaveLength(3)\nexpect(appManager.list('Game')).toHaveLength(1)\nexpect(appManager.list('Title')).toHaveLength(1)"
          },
          {
            "title": "integration scenario - settings overlay",
            "line": 367,
            "source": "class GameApp extends MockApp {\n    constructor (params) {\n        super({...params, $name: 'Game'})\n    }\n}\n\nclass SettingsApp extends MockApp {\n    constructor (params) {\n        super({...params, $name: 'Settings'})\n    }\n}\n\nappManager.register('game', GameApp)\nappManager.register('settings', SettingsApp)\n\nconst game = await appManager.spawn('game')\nconst settings = await appManager.spawn('settings')\n\nexpect(game.mockStart).toHaveBeenCalled()\nexpect(settings.mockStart).toHaveBeenCalled()\n\nconst runningApps = appManager.list()\nexpect(runningApps).toHaveLength(2)\n\nappManager.disposeApp(settings.$id)\nexpect(settings.mockDispose).toHaveBeenCalled()\nexpect(appManager.childrenRegistry.has(settings.$id)).toBe(false)\nexpect(appManager.childrenRegistry.has(game.$id)).toBe(true)"
          },
          {
            "title": "multiple instances of same app type",
            "line": 399,
            "source": "appManager.register('dialog', MockApp)\n\nconst dialog1 = appManager.createApp('dialog', {$name: 'ConfirmDialog'})\nconst dialog2 = appManager.createApp('dialog', {$name: 'AlertDialog'})\nconst dialog3 = appManager.createApp('dialog', {$name: 'InputDialog'})\n\nexpect(dialog1.$id).toBeTruthy()\nexpect(dialog2.$id).toBeTruthy()\nexpect(dialog3.$id).toBeTruthy()\nexpect(dialog1.$id).not.toBe(dialog2.$id)\nexpect(dialog2.$id).not.toBe(dialog3.$id)\n\nexpect(appManager.list()).toHaveLength(3)\nexpect(appManager.list('Dialog')).toHaveLength(3)\n\nappManager.disposeApp(dialog2.$id)\nexpect(appManager.list()).toHaveLength(2)\nexpect(appManager.childrenRegistry.has(dialog1.$id)).toBe(true)\nexpect(appManager.childrenRegistry.has(dialog2.$id)).toBe(false)\nexpect(appManager.childrenRegistry.has(dialog3.$id)).toBe(true)"
          },
          {
            "title": "app lifecycle management",
            "line": 423,
            "source": "appManager.register('testApp', MockApp)\n\nconst app = appManager.createApp('testApp')\nconst startSpy = vi.spyOn(app, 'start')\nconst stopSpy = vi.spyOn(app, 'stop')\n\nexpect(startSpy).not.toHaveBeenCalled()\nexpect(stopSpy).not.toHaveBeenCalled()\n\nappManager.startApp(app.$id)\nexpect(startSpy).toHaveBeenCalledTimes(1)\n\nappManager.stopApp(app.$id)\nexpect(app.mockStop).toHaveBeenCalledTimes(1)\n\nappManager.startApp(app.$id)\nexpect(startSpy).toHaveBeenCalledTimes(2)\n\nappManager.disposeApp(app.$id)\nexpect(app.mockDispose).toHaveBeenCalled()\nexpect(appManager.childrenRegistry.has(app.$id)).toBe(false)"
          },
          {
            "title": "app self-dispose should be intercepted by manager",
            "line": 448,
            "source": "appManager.register('testApp', MockApp)\n\nconst app = appManager.createApp('testApp')\nconst appName = app.$id\n\nexpect(appManager.childrenRegistry.has(appName)).toBe(true)\nexpect(appManager.list()).toHaveLength(1)\n\napp.dispose()\n\nexpect(appManager.childrenRegistry.has(appName)).toBe(false)\nexpect(appManager.list()).toHaveLength(0)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/application/asset.doc.js": {
    "file": "/application/asset.test.js",
    "describes": [
      {
        "title": "Asset",
        "line": 5,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "constructor with parameters",
            "line": 7,
            "source": "const params = {\n    type: 'image',\n    name: 'example',\n    id: 'test_id',\n    url: '/path/to/file.jpg',\n    source: {key: 'value'},\n    tags: ['titleScreen', 'mainScene'],\n    config: {width: 100, height: 100}\n}\n\nconst asset = new Asset(params)\n\nexpect(asset.type).toBe('image')\nexpect(asset.name).toBe('example')\nexpect(asset.id).toBe('test_id')\nexpect(asset.url).toBe('/path/to/file.jpg')\nexpect(asset.source).toEqual({key: 'value'})\nexpect(asset.tags).toEqual(['titleScreen', 'mainScene'])\nexpect(asset.config).toEqual({width: 100, height: 100})"
          },
          {
            "title": "constructor name defaults to id",
            "line": 30,
            "source": "const asset = new Asset({\n    type: 'video',\n    id: 'custom_id'\n})\n\nexpect(asset.id).toBe('custom_id')\nexpect(asset.name).toBe('custom_id')"
          },
          {
            "title": "loaded returns true when source exists",
            "line": 41,
            "source": "const asset = new Asset({\n    type: 'json',\n    id: 'test_id',\n    source: {content: 'source'}\n})\n\nexpect(asset.loaded).toBe(true)"
          },
          {
            "title": "loaded returns false when source is missing",
            "line": 52,
            "source": "const asset = new Asset({\n    type: 'text',\n    id: 'test_id',\n    url: '/path/to/text.txt'\n})\n\nexpect(asset.loaded).toBe(false)"
          },
          {
            "title": "hasTag returns true for existing tags",
            "line": 63,
            "source": "const asset = new Asset({\n    type: 'image',\n    id: 'test_id',\n    tags: ['titleScreen', 'mainScene']\n})\n\nexpect(asset.hasTag('titleScreen')).toBe(true)\nexpect(asset.hasTag('mainScene')).toBe(true)\nexpect(asset.hasTag('endingScene')).toBe(false)"
          },
          {
            "title": "hasTag returns false when tags are empty",
            "line": 76,
            "source": "const asset = new Asset({\n    type: 'image',\n    id: 'test_id'\n})\n\nexpect(asset.hasTag('titleScreen')).toBe(false)"
          },
          {
            "title": "export with url",
            "line": 86,
            "source": "const asset = new Asset({\n    type: 'image',\n    name: 'example',\n    id: 'test_id',\n    url: '/path/to/file.jpg',\n    tags: ['titleScreen'],\n    config: {width: 100}\n})\n\nconst exported = asset.export()\n\nexpect(exported).toEqual({\n    type: 'image',\n    id: 'test_id',\n    name: 'example',\n    url: '/path/to/file.jpg',\n    tags: ['titleScreen'],\n    config: {width: 100}\n})\nexpect(exported.source).toBeUndefined()"
          },
          {
            "title": "export with source",
            "line": 110,
            "source": "const asset = new Asset({\n    type: 'json',\n    name: 'config',\n    id: 'config_id',\n    source: {settings: true},\n    tags: ['config', 'settings'],\n    config: {parse: true}\n})\n\nconst exported = asset.export()\n\nexpect(exported).toEqual({\n    type: 'json',\n    id: 'config_id',\n    name: 'config',\n    source: {settings: true},\n    tags: ['config', 'settings'],\n    config: {parse: true}\n})\nexpect(exported.path).toBeUndefined()"
          },
          {
            "title": "default tags and config",
            "line": 134,
            "source": "const asset = new Asset({\n    type: 'audio',\n    id: 'audio_id'\n})\n\nexpect(asset.tags).toEqual([])\nexpect(asset.config).toEqual({})"
          }
        ],
        "describes": []
      }
    ]
  },
  "/application/dom_utils.doc.js": {
    "file": "/application/dom_utils.test.js",
    "describes": [
      {
        "title": "dom_utils",
        "line": 11,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "createStyleSheet returns CSSStyleSheet",
            "line": 208,
            "source": "const css = '.test { color: red; }'\nconst sheet = createStyleSheet(css)\nexpect(sheet).toBeInstanceOf(CSSStyleSheet)"
          }
        ],
        "describes": [
          {
            "title": "createElement",
            "line": 13,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates element with tag name",
                "line": 15,
                "source": "const el = createElement('div')\nexpect(el.tagName).toBe('DIV')"
              },
              {
                "title": "sets className with class option",
                "line": 21,
                "source": "const el = createElement('div', {class: 'my-class'})\nexpect(el.className).toBe('my-class')"
              },
              {
                "title": "sets className with className option",
                "line": 27,
                "source": "const el = createElement('div', {className: 'my-class'})\nexpect(el.className).toBe('my-class')"
              },
              {
                "title": "sets id",
                "line": 33,
                "source": "const el = createElement('div', {id: 'my-id'})\nexpect(el.id).toBe('my-id')"
              },
              {
                "title": "sets direct attributes",
                "line": 39,
                "source": "const el = createElement('a', {\n    href: 'https://example.com',\n    title: 'Example Link'\n})\nexpect(el.href).toBe('https://example.com/')\nexpect(el.title).toBe('Example Link')"
              },
              {
                "title": "sets input attributes",
                "line": 49,
                "source": "const el = createElement('input', {\n    type: 'text',\n    name: 'username',\n    value: 'test',\n    placeholder: 'Enter username'\n})\nexpect(el.type).toBe('text')\nexpect(el.name).toBe('username')\nexpect(el.value).toBe('test')\nexpect(el.placeholder).toBe('Enter username')"
              },
              {
                "title": "sets image attributes",
                "line": 63,
                "source": "const el = createElement('img', {\n    src: 'image.png',\n    alt: 'Test image'\n})\nexpect(el.src).toContain('image.png')\nexpect(el.alt).toBe('Test image')"
              },
              {
                "title": "sets textContent with text option",
                "line": 73,
                "source": "const el = createElement('span', {text: 'Hello'})\nexpect(el.textContent).toBe('Hello')"
              },
              {
                "title": "sets innerHTML with html option",
                "line": 79,
                "source": "const el = createElement('div', {html: '<span>Test</span>'})\nexpect(el.innerHTML).toBe('<span>Test</span>')"
              },
              {
                "title": "sets attributes via attrs option",
                "line": 85,
                "source": "const el = createElement('input', {\n    attrs: {type: 'text', dataValue: '42'}\n})\nexpect(el.getAttribute('type')).toBe('text')\nexpect(el.getAttribute('data-value')).toBe('42')"
              },
              {
                "title": "sets styles via style option with object",
                "line": 94,
                "source": "const el = createElement('div', {style: {display: 'flex', marginTop: '10px'}})\nexpect(el.style.display).toBe('flex')\nexpect(el.style.marginTop).toBe('10px')"
              },
              {
                "title": "sets styles via style option with string",
                "line": 101,
                "source": "const el = createElement('div', {style: 'display: block; padding: 5px;'})\nexpect(el.style.display).toBe('block')\nexpect(el.style.padding).toBe('5px')"
              },
              {
                "title": "combines multiple options",
                "line": 108,
                "source": "const el = createElement('button', {\n    class: 'btn primary',\n    id: 'submit-btn',\n    text: 'Submit',\n    attrs: {type: 'submit'}\n})\n\nexpect(el.className).toBe('btn primary')\nexpect(el.id).toBe('submit-btn')\nexpect(el.textContent).toBe('Submit')\nexpect(el.getAttribute('type')).toBe('submit')"
              }
            ],
            "describes": []
          },
          {
            "title": "setAttributes",
            "line": 125,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "sets single attribute",
                "line": 127,
                "source": "const el = document.createElement('div')\nsetAttributes(el, {id: 'test'})\nexpect(el.getAttribute('id')).toBe('test')"
              },
              {
                "title": "sets multiple attributes",
                "line": 134,
                "source": "const el = document.createElement('input')\nsetAttributes(el, {type: 'text', name: 'username'})\nexpect(el.getAttribute('type')).toBe('text')\nexpect(el.getAttribute('name')).toBe('username')"
              },
              {
                "title": "converts camelCase to kebab-case",
                "line": 142,
                "source": "const el = document.createElement('div')\nsetAttributes(el, {dataValue: '42', ariaLabel: 'test'})\nexpect(el.getAttribute('data-value')).toBe('42')\nexpect(el.getAttribute('aria-label')).toBe('test')"
              },
              {
                "title": "preserves kebab-case keys",
                "line": 150,
                "source": "const el = document.createElement('div')\nsetAttributes(el, {'data-id': '123', 'aria-hidden': 'true'})\nexpect(el.getAttribute('data-id')).toBe('123')\nexpect(el.getAttribute('aria-hidden')).toBe('true')"
              },
              {
                "title": "handles empty string values",
                "line": 158,
                "source": "const el = document.createElement('input')\nsetAttributes(el, {noValue: '', disabled: ''})\nexpect(el.getAttribute('no-value')).toBe('')\nexpect(el.getAttribute('disabled')).toBe('')"
              }
            ],
            "describes": []
          },
          {
            "title": "setStyle",
            "line": 168,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "sets single style",
                "line": 170,
                "source": "const el = document.createElement('div')\nsetStyle(el, {display: 'flex'})\nexpect(el.style.display).toBe('flex')"
              },
              {
                "title": "sets multiple styles",
                "line": 177,
                "source": "const el = document.createElement('div')\nsetStyle(el, {\n    display: 'flex',\n    justifyContent: 'center',\n    alignItems: 'center'\n})\nexpect(el.style.display).toBe('flex')\nexpect(el.style.justifyContent).toBe('center')\nexpect(el.style.alignItems).toBe('center')"
              },
              {
                "title": "handles pixel values",
                "line": 190,
                "source": "const el = document.createElement('div')\nsetStyle(el, {marginTop: '16px', padding: '8px'})\nexpect(el.style.marginTop).toBe('16px')\nexpect(el.style.padding).toBe('8px')"
              },
              {
                "title": "sets styles from string",
                "line": 198,
                "source": "const el = document.createElement('div')\nsetStyle(el, 'display: flex; justify-content: center;')\nexpect(el.style.display).toBe('flex')\nexpect(el.style.justifyContent).toBe('center')"
              }
            ],
            "describes": []
          },
          {
            "title": "adoptStyleSheets",
            "line": 215,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "applies styles to shadow root",
                "line": 217,
                "source": "const host = document.createElement('div')\nconst shadowRoot = host.attachShadow({mode: 'open'})\n\nconst sheet = createStyleSheet('.test { color: red; }')\nadoptStyleSheets(shadowRoot, sheet)\n\nexpect(shadowRoot.adoptedStyleSheets.length).toBe(1)"
              },
              {
                "title": "filters out null/undefined sheets",
                "line": 228,
                "source": "const host = document.createElement('div')\nconst shadowRoot = host.attachShadow({mode: 'open'})\n\nconst sheet = createStyleSheet('.test { color: red; }')\nadoptStyleSheets(shadowRoot, null, sheet, undefined)\n\nexpect(shadowRoot.adoptedStyleSheets.length).toBe(1)"
              },
              {
                "title": "handles multiple sheets",
                "line": 239,
                "source": "const host = document.createElement('div')\nconst shadowRoot = host.attachShadow({mode: 'open'})\n\nconst sheet1 = createStyleSheet('.a { color: red; }')\nconst sheet2 = createStyleSheet('.b { color: blue; }')\nadoptStyleSheets(shadowRoot, sheet1, sheet2)\n\nexpect(shadowRoot.adoptedStyleSheets.length).toBe(2)"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/application/loaders.doc.js": {
    "file": "/application/loaders.test.js",
    "describes": [
      {
        "title": "Loaders",
        "line": 4,
        "beforeEach": {
          "line": 15,
          "source": "vi.resetModules()\n\nmockResponse = {\n    ok: true,\n    blob: vi.fn(),\n    text: vi.fn(),\n    json: vi.fn(),\n    arrayBuffer: vi.fn()\n}\nmockFetch = vi.fn().mockResolvedValue(mockResponse)\nglobal.fetch = mockFetch\n\nmockBlob = new Blob(['test'], {type: 'text/plain'})\nmockResponse.blob.mockResolvedValue(mockBlob)\n\nglobal.Image = vi.fn(() => {\n    const img = {}\n    function triggerOnload () {\n        if (img.onload) {\n            img.onload()\n        }\n    }\n    function triggerOnerror () {\n        if (img.onerror) {\n            img.onerror()\n        }\n    }\n    Object.defineProperty(img, 'src', {\n        set () {\n            if (triggerLoad) {\n                setTimeout(triggerOnload, 0)\n            }\n            if (triggerError) {\n                setTimeout(triggerOnerror, 0)\n            }\n        }\n    })\n    img.onload = null\n    img.onerror = null\n    lastCreatedImage = img\n    return img\n})\n\nglobal.URL = {\n    createObjectURL: vi.fn(),\n    revokeObjectURL: vi.fn()\n}\n\nmockAudioContext = {\n    decodeAudioData: vi.fn(),\n    close: vi.fn()\n}\nglobal.AudioContext = vi.fn().mockImplementation(() => mockAudioContext)\nglobal.webkitAudioContext = vi.fn().mockImplementation(() => mockAudioContext)\n\nmockFontFace = {\n    load: vi.fn()\n}\nglobal.FontFace = vi.fn().mockImplementation(() => mockFontFace)\ndocument.fonts = {\n    add: vi.fn()\n}\n\nloaders = await import('./loaders.js')"
        },
        "afterEach": {
          "line": 83,
          "source": "vi.restoreAllMocks()"
        },
        "tests": [
          {
            "title": "loadResponse with string",
            "line": 88,
            "source": "const url = 'http://example.com'\n\nawait loaders.loadResponse(url)\n\nexpect(mockFetch).toHaveBeenCalledWith(url, {})"
          },
          {
            "title": "loadResponse with object",
            "line": 97,
            "source": "const params = {\n    url: 'http://example.com',\n    config: {method: 'POST'}\n}\n\nawait loaders.loadResponse(params)\n\nexpect(mockFetch).toHaveBeenCalledWith(params.url, params.config)"
          },
          {
            "title": "loadBlob success",
            "line": 109,
            "source": "const result = await loaders.loadBlob('http://example.com')\n\nexpect(mockResponse.blob).toHaveBeenCalled()\nexpect(result).toBe(mockBlob)"
          },
          {
            "title": "loadBlob error",
            "line": 117,
            "source": "mockResponse.ok = false\nmockResponse.status = 404\n\nawait expect(loaders.loadBlob('http://example.com')).rejects.toThrow('HTTP Error 404')"
          },
          {
            "title": "loadImage success",
            "line": 125,
            "source": "triggerLoad = true\ntriggerError = false\nconst blob = new Blob(['test'], {type: 'image/png'})\nmockResponse.blob.mockResolvedValue(blob)\nglobal.URL.createObjectURL.mockReturnValue('blob:test')\n\nconst loadPromise = loaders.loadImage('http://example.com')\nconst result = await loadPromise\n\nexpect(global.URL.createObjectURL).toHaveBeenCalledWith(blob)\nexpect(result).toBe(lastCreatedImage)"
          },
          {
            "title": "loadImage error",
            "line": 140,
            "source": "triggerLoad = false\ntriggerError = true\nconst blob = new Blob(['test'], {type: 'image/png'})\nmockResponse.blob.mockResolvedValue(blob)\nglobal.URL.createObjectURL.mockReturnValue('blob:test')\n\nconst loadPromise = loaders.loadImage('http://example.com')\nawait expect(loadPromise).rejects.toThrow('Failed to load image')\nexpect(global.URL.revokeObjectURL).toHaveBeenCalledWith('blob:test')"
          },
          {
            "title": "loadText success",
            "line": 153,
            "source": "const text = 'Hello World'\nmockResponse.text.mockResolvedValue(text)\n\nconst result = await loaders.loadText('http://example.com')\n\nexpect(mockResponse.text).toHaveBeenCalled()\nexpect(result).toBe(text)"
          },
          {
            "title": "loadText error",
            "line": 164,
            "source": "mockResponse.ok = false\nmockResponse.status = 404\n\nawait expect(loaders.loadText('http://example.com')).rejects.toThrow('HTTP Error 404')"
          },
          {
            "title": "loadJson success",
            "line": 172,
            "source": "const json = {message: 'Hello World'}\nmockResponse.json.mockResolvedValue(json)\n\nconst result = await loaders.loadJson('http://example.com')\n\nexpect(mockResponse.json).toHaveBeenCalled()\nexpect(result).toEqual(json)"
          },
          {
            "title": "loadJson error",
            "line": 183,
            "source": "mockResponse.ok = false\nmockResponse.status = 404\n\nawait expect(loaders.loadJson('http://example.com')).rejects.toThrow('HTTP Error 404')"
          },
          {
            "title": "loadArrayBuffer success",
            "line": 191,
            "source": "const buffer = new ArrayBuffer(8)\nmockResponse.arrayBuffer.mockResolvedValue(buffer)\n\nconst result = await loaders.loadArrayBuffer('http://example.com')\n\nexpect(mockResponse.arrayBuffer).toHaveBeenCalled()\nexpect(result).toBe(buffer)"
          },
          {
            "title": "loadArrayBuffer error",
            "line": 202,
            "source": "mockResponse.ok = false\nmockResponse.status = 404\n\nawait expect(loaders.loadArrayBuffer('http://example.com')).rejects.toThrow('HTTP Error 404')"
          },
          {
            "title": "loadAudio success",
            "line": 210,
            "source": "const result = await loaders.loadAudio('http://example.com/audio.mp3')\n\nexpect(result).toEqual({\n    type: 'deferred_audio',\n    url: 'http://example.com/audio.mp3'\n})"
          },
          {
            "title": "loadAudio with object params",
            "line": 220,
            "source": "const result = await loaders.loadAudio({\n    url: 'http://example.com/audio.mp3',\n    config: {some: 'config'}\n})\n\nexpect(result).toEqual({\n    type: 'deferred_audio',\n    url: 'http://example.com/audio.mp3'\n})"
          },
          {
            "title": "loadFont success",
            "line": 233,
            "source": "mockFontFace.load.mockResolvedValue(mockFontFace)\n\nconst result = await loaders.loadFont({\n    url: 'http://example.com/font.woff2',\n    config: {name: 'TestFont'}\n})\n\nexpect(global.FontFace).toHaveBeenCalledWith('TestFont', 'url(http://example.com/font.woff2)', {style: 'normal', weight: 'normal'})\nexpect(mockFontFace.load).toHaveBeenCalled()\nexpect(document.fonts.add).toHaveBeenCalledWith(mockFontFace)\nexpect(result).toBe(mockFontFace)"
          },
          {
            "title": "loadFont with family config",
            "line": 248,
            "source": "mockFontFace.load.mockResolvedValue(mockFontFace)\n\nawait loaders.loadFont({\n    url: 'http://example.com/font.woff2',\n    config: {family: 'CustomFamily', style: 'italic', weight: 'bold'}\n})\n\nexpect(global.FontFace).toHaveBeenCalledWith('CustomFamily', 'url(http://example.com/font.woff2)', {style: 'italic', weight: 'bold'})"
          },
          {
            "title": "loadFont error",
            "line": 260,
            "source": "mockFontFace.load.mockRejectedValue(new Error('Load failed'))\n\nawait expect(loaders.loadFont({\n    url: 'http://example.com/font.woff2',\n    config: {name: 'TestFont'}\n})).rejects.toThrow('Failed to load font \"TestFont\": Load failed')"
          }
        ],
        "describes": [
          {
            "title": "normalizeParams",
            "line": 270,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "normalizeParams with string",
                "line": 271,
                "source": "const result = loaders.normalizeParams('http://example.com')\n\nexpect(result).toEqual({url: 'http://example.com', config: {}})"
              },
              {
                "title": "normalizeParams with object",
                "line": 278,
                "source": "const result = loaders.normalizeParams({\n    url: 'http://example.com',\n    config: {method: 'POST'}\n})\n\nexpect(result).toEqual({url: 'http://example.com', config: {method: 'POST'}})"
              },
              {
                "title": "normalizeParams with object without config",
                "line": 288,
                "source": "const result = loaders.normalizeParams({url: 'http://example.com'})\n\nexpect(result).toEqual({url: 'http://example.com', config: {}})"
              }
            ],
            "describes": []
          },
          {
            "title": "loadSpritesheet",
            "line": 296,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "loads JSON and images from spritesheet",
                "line": 297,
                "source": "triggerLoad = true\ntriggerError = false\n\nconst spritesheetData = {\n    meta: {\n        images: [\n            {filename: 'sprite-0.png'},\n            {filename: 'sprite-1.png'}\n        ]\n    },\n    frames: {}\n}\nmockResponse.json.mockResolvedValue(spritesheetData)\n\nconst imageBlob = new Blob(['test'], {type: 'image/png'})\nmockResponse.blob.mockResolvedValue(imageBlob)\nglobal.URL.createObjectURL.mockReturnValue('blob:test')\n\nconst result = await loaders.loadSpritesheet('http://example.com/assets/spritesheet.json')\n\nexpect(mockFetch).toHaveBeenCalledWith('http://example.com/assets/spritesheet.json', {})\nexpect(result.data).toEqual(spritesheetData)\nexpect(result.images).toHaveLength(2)"
              },
              {
                "title": "loads spritesheet with object params",
                "line": 324,
                "source": "triggerLoad = true\ntriggerError = false\n\nconst spritesheetData = {\n    meta: {\n        images: [{filename: 'sprite.png'}]\n    }\n}\nmockResponse.json.mockResolvedValue(spritesheetData)\n\nconst imageBlob = new Blob(['test'], {type: 'image/png'})\nmockResponse.blob.mockResolvedValue(imageBlob)\nglobal.URL.createObjectURL.mockReturnValue('blob:test')\n\nconst result = await loaders.loadSpritesheet({url: 'http://example.com/sprites/data.json'})\n\nexpect(mockFetch).toHaveBeenCalledWith('http://example.com/sprites/data.json', {})\nexpect(result.data).toEqual(spritesheetData)\nexpect(result.images).toHaveLength(1)"
              }
            ],
            "describes": []
          },
          {
            "title": "Utility Functions",
            "line": 348,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "replaceUrlFilename",
                "line": 349,
                "source": "expect(loaders.replaceUrlFilename('/path/to/file.json', 'newfile.json'))\n    .toBe('/path/to/newfile.json')\n\nexpect(loaders.replaceUrlFilename('http://example.com/assets/sprite.json', 'sprite-1.json'))\n    .toBe('http://example.com/assets/sprite-1.json')\n\nexpect(loaders.replaceUrlFilename('file.json', 'other.json'))\n    .toBe('other.json')"
              },
              {
                "title": "removeFileExtension",
                "line": 360,
                "source": "expect(loaders.removeFileExtension('file.png')).toBe('file')\nexpect(loaders.removeFileExtension('complex.name.jpg')).toBe('complex.name')\nexpect(loaders.removeFileExtension('noextension')).toBe('noextension')\nexpect(loaders.removeFileExtension('path/to/file.txt')).toBe('path/to/file')\nexpect(loaders.removeFileExtension('')).toBe('')"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/application/manifest.doc.js": {
    "file": "/application/manifest.test.js",
    "describes": [
      {
        "title": "Manifest",
        "line": 5,
        "beforeEach": {
          "line": 8,
          "source": "manifest = new Manifest()"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor",
            "line": 13,
            "source": "expect(manifest.getConfig()).toEqual({})\nexpect(manifest.getAllAssets()).toEqual([])"
          },
          {
            "title": "constructor with data",
            "line": 19,
            "source": "const customManifest = new Manifest({\n    data: {\n        config: {name: 'Test Manifest'}\n    }\n})\n\nexpect(customManifest.getConfig('name')).toBe('Test Manifest')\nexpect(customManifest.getAllAssets()).toEqual([])"
          },
          {
            "title": "import with JSON string",
            "line": 31,
            "source": "const jsonData = JSON.stringify({\n    config: {debug: true},\n    assets: {\n        logo: {type: 'image', url: '/assets/logo.png', tags: ['preload']}\n    }\n})\n\nmanifest.import(jsonData)\n\nexpect(manifest.getConfig('debug')).toBe(true)\nexpect(manifest.getAsset('logo').id).toBe('logo')\nexpect(manifest.getAsset('logo').type).toBe('image')"
          },
          {
            "title": "import with object",
            "line": 47,
            "source": "const data = {\n    config: {version: '1.0.0'}\n}\n\nmanifest.import(data)\n\nexpect(manifest.getConfig('version')).toBe('1.0.0')"
          },
          {
            "title": "import clears existing assets",
            "line": 58,
            "source": "manifest.addAsset({id: 'old', type: 'image', url: '/old.png'})\n\nmanifest.import({\n    config: {},\n    assets: {\n        new: {type: 'image', url: '/new.png'}\n    }\n})\n\nexpect(manifest.getAsset('old')).toBeNull()\nexpect(manifest.getAsset('new')).not.toBeNull()"
          },
          {
            "title": "export",
            "line": 73,
            "source": "manifest.setConfig('version', '1.0.0')\nmanifest.addAsset({id: 'logo', type: 'image', url: '/logo.png'})\n\nconst exported = manifest.export()\n\nexpect(exported.config.version).toBe('1.0.0')\nexpect(exported.assets.logo.id).toBe('logo')"
          },
          {
            "title": "getConfig",
            "line": 84,
            "source": "manifest.setConfig('debug', true)\nmanifest.setConfig('logging.level', 'info')\n\nexpect(manifest.getConfig()).toEqual({debug: true, logging: {level: 'info'}})"
          },
          {
            "title": "getConfig with path",
            "line": 92,
            "source": "manifest.setConfig('debug', true)\nmanifest.setConfig('logging.level', 'info')\n\nexpect(manifest.getConfig('logging.level')).toBe('info')"
          },
          {
            "title": "setConfig",
            "line": 100,
            "source": "const result = manifest.setConfig('logging.level', 'debug')\n\nexpect(manifest.getConfig('logging.level')).toBe('debug')\nexpect(result).toBe(manifest)"
          },
          {
            "title": "addAsset",
            "line": 108,
            "source": "manifest.addAsset({id: 'logo', type: 'image', url: '/assets/logo.png'})\n\nexpect(manifest.getAllAssets()).toHaveLength(1)\nexpect(manifest.getAsset('logo').id).toBe('logo')"
          },
          {
            "title": "addAsset updates existing",
            "line": 116,
            "source": "manifest.addAsset({id: 'logo', type: 'image', url: '/assets/logo.png'})\nmanifest.addAsset({id: 'logo', type: 'image', url: '/assets/new-logo.png'})\n\nexpect(manifest.getAllAssets()).toHaveLength(1)\nexpect(manifest.getAsset('logo').url).toBe('/assets/new-logo.png')"
          },
          {
            "title": "addAsset with Asset instance",
            "line": 125,
            "source": "const asset = new Asset({id: 'logo', type: 'image', url: '/logo.png'})\nmanifest.addAsset(asset)\n\nexpect(manifest.getAsset('logo')).toBe(asset)"
          },
          {
            "title": "getAsset returns null for missing",
            "line": 133,
            "source": "expect(manifest.getAsset('nonexistent')).toBeNull()"
          },
          {
            "title": "getAsset",
            "line": 138,
            "source": "const assetData = {id: 'logo', type: 'image', url: '/assets/logo.png'}\nmanifest.addAsset(assetData)\n\nconst asset = manifest.getAsset('logo')\nexpect(asset).toBeInstanceOf(Asset)\nexpect(asset.id).toBe(assetData.id)\nexpect(asset.url).toBe(assetData.url)"
          },
          {
            "title": "getSource",
            "line": 149,
            "source": "const assetData = {id: 'logo', type: 'image', url: '/assets/logo.png', source: 'fakeImage'}\nmanifest.addAsset(assetData)\n\nconst source = manifest.getSource('logo')\nexpect(source).toBe('fakeImage')"
          },
          {
            "title": "getSource returns null for missing",
            "line": 158,
            "source": "expect(manifest.getSource('nonexistent')).toBeNull()"
          },
          {
            "title": "getAssetsByType",
            "line": 163,
            "source": "manifest.addAsset({id: 'logo', type: 'image', url: '/logo.png'})\nmanifest.addAsset({id: 'icon', type: 'image', url: '/icon.png'})\nmanifest.addAsset({id: 'music', type: 'audio', url: '/music.mp3'})\n\nconst images = manifest.getAssetsByType('image')\nexpect(images).toHaveLength(2)\nexpect(images.map(a => a.id)).toContain('logo')\nexpect(images.map(a => a.id)).toContain('icon')"
          },
          {
            "title": "getAssetsByTag",
            "line": 175,
            "source": "manifest.addAsset({id: 'logo', type: 'image', url: '/logo.png', tags: ['titleScreen']})\nmanifest.addAsset({id: 'icon', type: 'image', url: '/icon.png', tags: ['mainScene']})\n\nconst titleScreenAssets = manifest.getAssetsByTag('titleScreen')\nexpect(titleScreenAssets).toHaveLength(1)\nexpect(titleScreenAssets[0].id).toBe('logo')"
          },
          {
            "title": "getAssetsByTag multiple types",
            "line": 185,
            "source": "manifest.addAsset({id: 'icon', type: 'image', url: '/icon.png', tags: ['titleScreen']})\nmanifest.addAsset({id: 'music', type: 'audio', url: '/music.mp3', tags: ['titleScreen']})\n\nconst titleScreenAssets = manifest.getAssetsByTag('titleScreen')\nexpect(titleScreenAssets).toHaveLength(2)"
          },
          {
            "title": "getAssetsByTag multiple tags",
            "line": 194,
            "source": "manifest.addAsset({id: 'icon', type: 'image', url: '/icon.png', tags: ['titleScreen', 'mainScene', 'endingScene']})\nmanifest.addAsset({id: 'logo', type: 'image', url: '/logo.png', tags: ['endingScene']})\n\nconst titleScreenAssets = manifest.getAssetsByTag('titleScreen')\nexpect(titleScreenAssets).toHaveLength(1)\nexpect(titleScreenAssets[0].id).toBe('icon')\n\nconst endingSceneAssets = manifest.getAssetsByTag('endingScene')\nexpect(endingSceneAssets).toHaveLength(2)"
          },
          {
            "title": "getAssetsByTag no assets",
            "line": 207,
            "source": "const tagAssets = manifest.getAssetsByTag('titleScreen')\nexpect(tagAssets).toHaveLength(0)"
          },
          {
            "title": "getAssetsByTag invalid tag",
            "line": 213,
            "source": "expect(manifest.getAssetsByTag(null)).toEqual([])\nexpect(manifest.getAssetsByTag('')).toEqual([])\nexpect(manifest.getAssetsByTag(123)).toEqual([])"
          },
          {
            "title": "getAllAssets",
            "line": 220,
            "source": "manifest.addAsset({id: 'logo', type: 'image', url: '/logo.png'})\nmanifest.addAsset({id: 'music', type: 'audio', url: '/music.mp3'})\n\nconst allAssets = manifest.getAllAssets()\nexpect(allAssets).toHaveLength(2)"
          },
          {
            "title": "getAssets is alias for getAllAssets",
            "line": 229,
            "source": "manifest.addAsset({id: 'logo', type: 'image', url: '/logo.png'})\n\nexpect(manifest.getAssets()).toEqual(manifest.getAllAssets())"
          },
          {
            "title": "hasAsset",
            "line": 236,
            "source": "manifest.addAsset({id: 'logo', type: 'image', url: '/logo.png'})\n\nexpect(manifest.hasAsset('logo')).toBe(true)\nexpect(manifest.hasAsset('nonexistent')).toBe(false)"
          },
          {
            "title": "removeAsset",
            "line": 244,
            "source": "manifest.addAsset({id: 'logo', type: 'image', url: '/logo.png'})\n\nexpect(manifest.removeAsset('logo')).toBe(true)\nexpect(manifest.getAsset('logo')).toBeNull()"
          },
          {
            "title": "removeAsset nonexistent",
            "line": 252,
            "source": "expect(manifest.removeAsset('nonexistent')).toBe(false)"
          },
          {
            "title": "assets registry has type index",
            "line": 257,
            "source": "manifest.addAsset({id: 'logo', type: 'image', url: '/logo.png'})\n\nexpect(manifest.assets.hasIndex('type')).toBe(true)\nexpect(manifest.assets.lookup('type', 'image')).toHaveLength(1)"
          },
          {
            "title": "assets registry has tags index",
            "line": 265,
            "source": "manifest.addAsset({id: 'logo', type: 'image', url: '/logo.png', tags: ['preload']})\n\nexpect(manifest.assets.hasIndex('tags')).toBe(true)\nexpect(manifest.assets.lookup('tags', 'preload')).toHaveLength(1)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/application/perky_element.doc.js": {
    "file": "/application/perky_element.test.js",
    "describes": [
      {
        "title": "PerkyElement",
        "line": 6,
        "beforeEach": null,
        "afterEach": {
          "line": 17,
          "source": "registeredElements = []"
        },
        "tests": [
          {
            "title": "shadowRoot creates shadowRoot on construction",
            "line": 22,
            "source": "registerElement('test-shadow', class extends PerkyElement {})\nconst el = document.createElement('test-shadow')\nexpect(el.shadowRoot).toBeTruthy()\nexpect(el.shadowRoot.mode).toBe('open')"
          },
          {
            "title": "static styles - string converts string styles to CSSStyleSheet",
            "line": 30,
            "source": "class TestStyles extends PerkyElement {\n    static styles = '.test { color: red; }'\n}\nregisterElement('test-string-styles', TestStyles)\n\nconst el = document.createElement('test-string-styles')\ndocument.body.appendChild(el)\n\nexpect(el.shadowRoot.adoptedStyleSheets.length).toBe(1)\nexpect(el.shadowRoot.adoptedStyleSheets[0]).toBeInstanceOf(CSSStyleSheet)\n\ndocument.body.removeChild(el)"
          },
          {
            "title": "static styles - CSSStyleSheet uses CSSStyleSheet directly",
            "line": 46,
            "source": "const sheet = createStyleSheet('.test { color: blue; }')\n\nclass TestSheet extends PerkyElement {\n    static styles = sheet\n}\nregisterElement('test-sheet-styles', TestSheet)\n\nconst el = document.createElement('test-sheet-styles')\ndocument.body.appendChild(el)\n\nexpect(el.shadowRoot.adoptedStyleSheets.length).toBe(1)\nexpect(el.shadowRoot.adoptedStyleSheets[0]).toBe(sheet)\n\ndocument.body.removeChild(el)"
          },
          {
            "title": "sheet caching reuses same sheet between instances",
            "line": 197,
            "source": "class Cached extends PerkyElement {\n    static styles = '.cached {}'\n}\nregisterElement('test-cache', Cached)\n\nconst el1 = document.createElement('test-cache')\nconst el2 = document.createElement('test-cache')\ndocument.body.appendChild(el1)\ndocument.body.appendChild(el2)\n\nexpect(el1.shadowRoot.adoptedStyleSheets[0])\n    .toBe(el2.shadowRoot.adoptedStyleSheets[0])\n\ndocument.body.removeChild(el1)\ndocument.body.removeChild(el2)"
          },
          {
            "title": "cleanListeners allows manual cleanup",
            "line": 376,
            "source": "const mockTarget = {\n    on: vi.fn(),\n    off: vi.fn()\n}\n\nclass TestManual extends PerkyElement {}\nregisterElement('test-manual', TestManual)\n\nconst el = document.createElement('test-manual')\nel.listenTo(mockTarget, 'test', () => {})\nel.cleanListeners()\n\nexpect(mockTarget.off).toHaveBeenCalled()"
          },
          {
            "title": "no styles works without static styles",
            "line": 393,
            "source": "class NoStyles extends PerkyElement {}\nregisterElement('test-no-styles', NoStyles)\n\nconst el = document.createElement('test-no-styles')\ndocument.body.appendChild(el)\n\nexpect(el.shadowRoot.adoptedStyleSheets.length).toBe(0)\n\ndocument.body.removeChild(el)"
          }
        ],
        "describes": [
          {
            "title": "static styles - array",
            "line": 64,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "supports array of strings",
                "line": 66,
                "source": "class TestArray extends PerkyElement {\n    static styles = ['.a {}', '.b {}']\n}\nregisterElement('test-array-strings', TestArray)\n\nconst el = document.createElement('test-array-strings')\ndocument.body.appendChild(el)\n\nexpect(el.shadowRoot.adoptedStyleSheets.length).toBe(2)\n\ndocument.body.removeChild(el)"
              },
              {
                "title": "supports array with mixed types",
                "line": 81,
                "source": "const sharedSheet = createStyleSheet('.shared {}')\n\nclass TestMixed extends PerkyElement {\n    static styles = [sharedSheet, '.local {}']\n}\nregisterElement('test-array-mixed', TestMixed)\n\nconst el = document.createElement('test-array-mixed')\ndocument.body.appendChild(el)\n\nexpect(el.shadowRoot.adoptedStyleSheets.length).toBe(2)\nexpect(el.shadowRoot.adoptedStyleSheets[0]).toBe(sharedSheet)\n\ndocument.body.removeChild(el)"
              },
              {
                "title": "shared sheet is reused across components",
                "line": 99,
                "source": "const sharedSheet = createStyleSheet('.shared {}')\n\nclass CompA extends PerkyElement {\n    static styles = [sharedSheet, '.a {}']\n}\n\nclass CompB extends PerkyElement {\n    static styles = [sharedSheet, '.b {}']\n}\n\nregisterElement('test-shared-a', CompA)\nregisterElement('test-shared-b', CompB)\n\nconst elA = document.createElement('test-shared-a')\nconst elB = document.createElement('test-shared-b')\ndocument.body.appendChild(elA)\ndocument.body.appendChild(elB)\n\nexpect(elA.shadowRoot.adoptedStyleSheets[0]).toBe(sharedSheet)\nexpect(elB.shadowRoot.adoptedStyleSheets[0]).toBe(sharedSheet)\n\ndocument.body.removeChild(elA)\ndocument.body.removeChild(elB)"
              }
            ],
            "describes": []
          },
          {
            "title": "style inheritance",
            "line": 128,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "accumulates styles from parent to child",
                "line": 130,
                "source": "class Parent extends PerkyElement {\n    static styles = '.parent { color: red; }'\n}\n\nclass Child extends Parent {\n    static styles = '.child { color: blue; }'\n}\nregisterElement('test-inheritance', Child)\n\nconst el = document.createElement('test-inheritance')\ndocument.body.appendChild(el)\n\nexpect(el.shadowRoot.adoptedStyleSheets.length).toBe(2)\n\ndocument.body.removeChild(el)"
              },
              {
                "title": "parent styles come before child styles",
                "line": 149,
                "source": "const parentSheet = createStyleSheet('.parent {}')\nconst childSheet = createStyleSheet('.child {}')\n\nclass Parent extends PerkyElement {\n    static styles = parentSheet\n}\n\nclass Child extends Parent {\n    static styles = childSheet\n}\nregisterElement('test-order', Child)\n\nconst el = document.createElement('test-order')\ndocument.body.appendChild(el)\n\nexpect(el.shadowRoot.adoptedStyleSheets[0]).toBe(parentSheet)\nexpect(el.shadowRoot.adoptedStyleSheets[1]).toBe(childSheet)\n\ndocument.body.removeChild(el)"
              },
              {
                "title": "skips classes without styles",
                "line": 172,
                "source": "class Parent extends PerkyElement {\n    static styles = '.parent {}'\n}\n\nclass Middle extends Parent {\n    // no styles\n}\n\nclass Child extends Middle {\n    static styles = '.child {}'\n}\nregisterElement('test-skip', Child)\n\nconst el = document.createElement('test-skip')\ndocument.body.appendChild(el)\n\nexpect(el.shadowRoot.adoptedStyleSheets.length).toBe(2)\n\ndocument.body.removeChild(el)"
              }
            ],
            "describes": []
          },
          {
            "title": "lifecycle hooks",
            "line": 216,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "calls onInit in constructor before connection",
                "line": 218,
                "source": "const spy = vi.fn()\n\nclass TestInit extends PerkyElement {\n    onInit () {\n        spy()\n    }\n}\nregisterElement('test-init', TestInit)\n\nconst el = document.createElement('test-init')\nexpect(spy).toHaveBeenCalledOnce()\nexpect(el.isConnected).toBe(false)"
              },
              {
                "title": "onInit has access to shadowRoot",
                "line": 234,
                "source": "let shadowRootInInit = null\n\nclass TestInitShadow extends PerkyElement {\n    onInit () {\n        shadowRootInInit = this.shadowRoot\n    }\n}\nregisterElement('test-init-shadow', TestInitShadow)\n\ndocument.createElement('test-init-shadow')\nexpect(shadowRootInInit).toBeTruthy()\nexpect(shadowRootInInit.mode).toBe('open')"
              },
              {
                "title": "onInit is called before onConnected",
                "line": 250,
                "source": "const order = []\n\nclass TestOrder extends PerkyElement {\n    onInit () {\n        order.push('init')\n    }\n\n    onConnected () {\n        order.push('connected')\n    }\n}\nregisterElement('test-init-order', TestOrder)\n\nconst el = document.createElement('test-init-order')\nexpect(order).toEqual(['init'])\n\ndocument.body.appendChild(el)\nexpect(order).toEqual(['init', 'connected'])\n\ndocument.body.removeChild(el)"
              },
              {
                "title": "calls onConnected when connected",
                "line": 274,
                "source": "const spy = vi.fn()\n\nclass TestConnected extends PerkyElement {\n    onConnected () {\n        spy()\n    }\n}\nregisterElement('test-connected', TestConnected)\n\nconst el = document.createElement('test-connected')\nexpect(spy).not.toHaveBeenCalled()\n\ndocument.body.appendChild(el)\nexpect(spy).toHaveBeenCalledOnce()\n\ndocument.body.removeChild(el)"
              },
              {
                "title": "calls onDisconnected when disconnected",
                "line": 294,
                "source": "const spy = vi.fn()\n\nclass TestDisconnected extends PerkyElement {\n    onDisconnected () {\n        spy()\n    }\n}\nregisterElement('test-disconnected', TestDisconnected)\n\nconst el = document.createElement('test-disconnected')\ndocument.body.appendChild(el)\nexpect(spy).not.toHaveBeenCalled()\n\ndocument.body.removeChild(el)\nexpect(spy).toHaveBeenCalledOnce()"
              }
            ],
            "describes": []
          },
          {
            "title": "listenTo",
            "line": 315,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "registers listener on target",
                "line": 317,
                "source": "const mockTarget = {\n    on: vi.fn(),\n    off: vi.fn()\n}\nconst callback = vi.fn()\n\nclass TestListen extends PerkyElement {}\nregisterElement('test-listen', TestListen)\n\nconst el = document.createElement('test-listen')\nel.listenTo(mockTarget, 'change', callback)\n\nexpect(mockTarget.on).toHaveBeenCalledWith('change', callback)"
              },
              {
                "title": "cleans up listeners on disconnect",
                "line": 334,
                "source": "const mockTarget = {\n    on: vi.fn(),\n    off: vi.fn()\n}\nconst callback = vi.fn()\n\nclass TestCleanup extends PerkyElement {}\nregisterElement('test-cleanup', TestCleanup)\n\nconst el = document.createElement('test-cleanup')\ndocument.body.appendChild(el)\n\nel.listenTo(mockTarget, 'update', callback)\n\ndocument.body.removeChild(el)\nexpect(mockTarget.off).toHaveBeenCalledWith('update', callback)"
              },
              {
                "title": "cleans up multiple listeners",
                "line": 354,
                "source": "const target1 = {on: vi.fn(), off: vi.fn()}\nconst target2 = {on: vi.fn(), off: vi.fn()}\n\nclass TestMulti extends PerkyElement {}\nregisterElement('test-multi', TestMulti)\n\nconst el = document.createElement('test-multi')\ndocument.body.appendChild(el)\n\nel.listenTo(target1, 'event1', () => {})\nel.listenTo(target2, 'event2', () => {})\n\ndocument.body.removeChild(el)\n\nexpect(target1.off).toHaveBeenCalledOnce()\nexpect(target2.off).toHaveBeenCalledOnce()"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/application/perky_view.doc.js": {
    "file": "/application/perky_view.test.js",
    "describes": [
      {
        "title": "PerkyView",
        "line": 6,
        "beforeEach": {
          "line": 11,
          "source": "element = document.createElement('div')\nelement.id = 'test-view'\n\ncontainer = document.createElement('div')\ncontainer.id = 'test-container'\ndocument.body.appendChild(container)\n\nvi.spyOn(element, 'offsetWidth', 'get').mockReturnValue(0)\nvi.spyOn(element, 'offsetHeight', 'get').mockReturnValue(0)\nvi.spyOn(element, 'getBoundingClientRect').mockReturnValue({\n    left: 0,\n    top: 0,\n    width: 0,\n    height: 0,\n    right: 0,\n    bottom: 0,\n    x: 0,\n    y: 0\n})\n\nvi.spyOn(PerkyModule.prototype, 'emit')\n\nview = new PerkyView({element})"
        },
        "afterEach": {
          "line": 38,
          "source": "vi.restoreAllMocks()\ndocument.body.innerHTML = ''"
        },
        "tests": [
          {
            "title": "constructor with element",
            "line": 44,
            "source": "expect(view.element).toBe(element)"
          },
          {
            "title": "constructor with container",
            "line": 49,
            "source": "const viewWithContainer = new PerkyView({\n    element,\n    container\n})\n\nexpect(container.contains(element)).toBe(true)\nexpect(viewWithContainer.container).toBe(container)"
          },
          {
            "title": "constructor with default element",
            "line": 60,
            "source": "const defaultView = new PerkyView()\n\nexpect(defaultView.element.tagName).toBe('DIV')\nexpect(defaultView.element.className).toBe('perky-view')"
          },
          {
            "title": "html getter",
            "line": 68,
            "source": "element.innerHTML = '<div>test content</div>'\nexpect(view.html).toBe('<div>test content</div>')"
          },
          {
            "title": "width getter",
            "line": 74,
            "source": "element.style.width = '300px'\nvi.spyOn(element, 'offsetWidth', 'get').mockReturnValue(300)\nexpect(view.width).toBe(300)"
          },
          {
            "title": "height getter",
            "line": 81,
            "source": "element.style.height = '400px'\nvi.spyOn(element, 'offsetHeight', 'get').mockReturnValue(400)\nexpect(view.height).toBe(400)"
          },
          {
            "title": "aspectRatio getter",
            "line": 88,
            "source": "element.style.width = '300px'\nelement.style.height = '400px'\nvi.spyOn(element, 'offsetWidth', 'get').mockReturnValue(300)\nvi.spyOn(element, 'offsetHeight', 'get').mockReturnValue(400)\nexpect(view.aspectRatio).toBe(300 / 400)"
          },
          {
            "title": "size getter",
            "line": 97,
            "source": "element.style.width = '300px'\nelement.style.height = '400px'\nvi.spyOn(element, 'offsetWidth', 'get').mockReturnValue(300)\nvi.spyOn(element, 'offsetHeight', 'get').mockReturnValue(400)\nexpect(view.size).toEqual({\n    width: 300,\n    height: 400\n})"
          },
          {
            "title": "addClass",
            "line": 109,
            "source": "view.addClass('test-class')\nexpect(element.classList.contains('test-class')).toBe(true)"
          },
          {
            "title": "removeClass",
            "line": 115,
            "source": "element.classList.add('test-class')\nview.removeClass('test-class')\nexpect(element.classList.contains('test-class')).toBe(false)"
          },
          {
            "title": "hasClass",
            "line": 122,
            "source": "element.classList.add('test-class')\nexpect(view.hasClass('test-class')).toBe(true)"
          },
          {
            "title": "setSize",
            "line": 128,
            "source": "view.setSize({width: 100, height: 200})\n\nexpect(element.style.width).toBe('100px')\nexpect(element.style.height).toBe('200px')"
          },
          {
            "title": "setSize with custom unit",
            "line": 136,
            "source": "view.setSize({width: 100, height: 200, unit: '%'})\n\nexpect(element.style.width).toBe('100%')\nexpect(element.style.height).toBe('200%')"
          },
          {
            "title": "fit",
            "line": 144,
            "source": "container.style.width = '500px'\ncontainer.style.height = '600px'\ncontainer.appendChild(element)\n\nvi.spyOn(container, 'getBoundingClientRect').mockReturnValue({\n    width: 500,\n    height: 600,\n    left: 0,\n    top: 0,\n    right: 500,\n    bottom: 600,\n    x: 0,\n    y: 0\n})\n\nview.fit()\n\nexpect(element.style.width).toBe('500px')\nexpect(element.style.height).toBe('600px')"
          },
          {
            "title": "mount",
            "line": 167,
            "source": "view.mount(container)\n\nexpect(container.contains(element)).toBe(true)\nexpect(view.container).toBe(container)\nexpect(view.emit).toHaveBeenCalledWith('mount', {container})"
          },
          {
            "title": "isVisible",
            "line": 176,
            "source": "element.style.display = 'block'\nexpect(view.isVisible()).toBe(true)\n\nelement.style.display = 'none'\nexpect(view.isVisible()).toBe(false)"
          },
          {
            "title": "display getter and setter",
            "line": 185,
            "source": "view.display = 'flex'\nexpect(element.style.display).toBe('flex')\nexpect(view.display).toBe('flex')\nexpect(view.display = 'flex').toBe('flex')"
          },
          {
            "title": "hide",
            "line": 193,
            "source": "element.style.display = 'flex'\nview.hide()\n\nexpect(element.style.display).toBe('none')"
          },
          {
            "title": "show restores previous display",
            "line": 201,
            "source": "element.style.display = 'flex'\nview.hide()\nview.show()\n\nexpect(element.style.display).toBe('flex')"
          },
          {
            "title": "show without previous display",
            "line": 210,
            "source": "view.show()\nexpect(element.style.display).toBe('')"
          },
          {
            "title": "dismount removes element from container",
            "line": 216,
            "source": "view.mount(container)\nexpect(container.contains(element)).toBe(true)\n\nview.dismount()\n\nexpect(container.contains(element)).toBe(false)\nexpect(view.emit).toHaveBeenCalledWith('dismount', {container: null})"
          },
          {
            "title": "dismount when not mounted does nothing",
            "line": 227,
            "source": "view.dismount()\n\nexpect(view.emit).not.toHaveBeenCalledWith('dismount', expect.anything())"
          },
          {
            "title": "setDisplayMode normal calls exitFullscreenMode",
            "line": 234,
            "source": "vi.spyOn(view, 'exitFullscreenMode')\n\nview.setDisplayMode('normal')\n\nexpect(view.exitFullscreenMode).toHaveBeenCalled()"
          },
          {
            "title": "setDisplayMode fullscreen calls enterFullscreenMode",
            "line": 243,
            "source": "vi.spyOn(view, 'enterFullscreenMode')\n\nview.setDisplayMode('fullscreen')\n\nexpect(view.enterFullscreenMode).toHaveBeenCalled()"
          },
          {
            "title": "setDisplayMode with invalid mode does nothing",
            "line": 252,
            "source": "vi.spyOn(view, 'enterFullscreenMode')\nvi.spyOn(view, 'exitFullscreenMode')\n\nview.setDisplayMode('invalid')\n\nexpect(view.enterFullscreenMode).not.toHaveBeenCalled()\nexpect(view.exitFullscreenMode).not.toHaveBeenCalled()"
          },
          {
            "title": "enterFullscreenMode sets fullscreen styles",
            "line": 263,
            "source": "element.requestFullscreen = vi.fn()\n\nview.enterFullscreenMode()\n\nexpect(view.displayMode).toBe('fullscreen')\nexpect(element.style.position).toBe('fixed')\nexpect(element.style.top).toBe('0px')\nexpect(element.style.left).toBe('0px')\nexpect(element.style.width).toBe('100vw')\nexpect(element.style.height).toBe('100vh')\nexpect(element.style.zIndex).toBe('10000')\nexpect(document.body.classList.contains('fullscreen-mode')).toBe(true)\nexpect(element.requestFullscreen).toHaveBeenCalled()"
          },
          {
            "title": "enterFullscreenMode does nothing if already fullscreen",
            "line": 280,
            "source": "element.requestFullscreen = vi.fn()\nview.displayMode = 'fullscreen'\n\nview.enterFullscreenMode()\n\nexpect(element.requestFullscreen).not.toHaveBeenCalled()"
          },
          {
            "title": "exitFullscreenMode restores previous styles",
            "line": 290,
            "source": "element.requestFullscreen = vi.fn()\nelement.style.position = 'relative'\nelement.style.width = '200px'\nelement.style.height = '300px'\n\nview.enterFullscreenMode()\nview.exitFullscreenMode()\n\nexpect(view.displayMode).toBe('normal')\nexpect(element.style.position).toBe('relative')\nexpect(element.style.width).toBe('200px')\nexpect(element.style.height).toBe('300px')\nexpect(document.body.classList.contains('fullscreen-mode')).toBe(false)"
          },
          {
            "title": "exitFullscreenMode does nothing if already normal",
            "line": 307,
            "source": "view.displayMode = 'normal'\n\nview.exitFullscreenMode()\n\nexpect(view.displayMode).toBe('normal')"
          },
          {
            "title": "toggleFullscreen enters fullscreen from normal",
            "line": 316,
            "source": "vi.spyOn(view, 'enterFullscreenMode')\n\nview.toggleFullscreen()\n\nexpect(view.enterFullscreenMode).toHaveBeenCalled()"
          },
          {
            "title": "toggleFullscreen exits fullscreen from fullscreen",
            "line": 325,
            "source": "vi.spyOn(view, 'exitFullscreenMode')\nview.displayMode = 'fullscreen'\n\nview.toggleFullscreen()\n\nexpect(view.exitFullscreenMode).toHaveBeenCalled()"
          }
        ],
        "describes": []
      }
    ]
  },
  "/application/source_loader.doc.js": {
    "file": "/application/source_loader.test.js",
    "describes": [
      {
        "title": "SourceLoader",
        "line": 6,
        "beforeEach": {
          "line": 11,
          "source": "loaders = {\n    image: vi.fn().mockResolvedValue('loaded image'),\n    audio: vi.fn().mockResolvedValue('loaded audio'),\n    text: vi.fn().mockResolvedValue('loaded text')\n}\n\nassets = [\n    {type: 'image', id: 'logo', url: '/assets/logo.png'},\n    {type: 'audio', id: 'music', url: '/assets/music.mp3'},\n    {type: 'text', id: 'config', url: '/assets/config.json'}\n]\n\nloader = new SourceLoader(assets, loaders)"
        },
        "afterEach": {
          "line": 28,
          "source": "vi.clearAllMocks()"
        },
        "tests": [
          {
            "title": "constructor",
            "line": 33,
            "source": "expect(loader).toBeInstanceOf(PerkyModule)\nexpect(loader.assets).toBe(assets)\nexpect(loader.progress).toBe(0)"
          },
          {
            "title": "assetCount",
            "line": 40,
            "source": "expect(loader.assetCount).toBe(3)"
          },
          {
            "title": "loadedCount",
            "line": 45,
            "source": "assets[0].source = 'image data'\nassets[0].loaded = true\nassets[1].source = 'audio data'\nassets[1].loaded = true\n\nexpect(loader.loadedCount).toBe(2)"
          },
          {
            "title": "progress",
            "line": 55,
            "source": "expect(loader.progress).toBe(0)\n\nassets[0].source = 'image data'\nassets[0].loaded = true\n\nexpect(loader.progress).toBe(1 / 3)\n\nassets[1].source = 'audio data'\nassets[1].loaded = true\n\nexpect(loader.progress).toBe(2 / 3)\n\nassets[2].source = 'text data'\nassets[2].loaded = true\n\nexpect(loader.progress).toBe(1)"
          },
          {
            "title": "load",
            "line": 75,
            "source": "const emitSpy = vi.spyOn(loader, 'emit')\nconst loadAssetSpy = vi.spyOn(loader, 'loadAsset')\n    .mockResolvedValueOnce({type: 'image', id: 'logo', loaded: true})\n    .mockResolvedValueOnce({type: 'audio', id: 'music', loaded: true})\n    .mockResolvedValueOnce({type: 'text', id: 'config', loaded: true})\n\nconst result = await loader.load()\n\nexpect(loader.loading).toBe(false)\nexpect(loadAssetSpy).toHaveBeenCalledTimes(3)\nexpect(emitSpy).toHaveBeenCalledWith('complete', assets)\nexpect(result).toBe(assets)"
          },
          {
            "title": "load already loading",
            "line": 91,
            "source": "loader.loading = true\n\nconst result = await loader.load()\n\nexpect(result).toBe(false)"
          },
          {
            "title": "loadAsset already loaded",
            "line": 100,
            "source": "const asset = {type: 'image', id: 'logo', loaded: true, source: 'image data'}\n\nconst result = await loader.loadAsset(asset)\n\nexpect(result).toBe(asset)\nexpect(loaders.image).not.toHaveBeenCalled()"
          },
          {
            "title": "loadAsset already loading",
            "line": 110,
            "source": "const asset = {type: 'image', id: 'logo', url: '/assets/logo.png'}\n\nconst loadPromise1 = loader.loadAsset(asset)\nconst loadPromise2 = loader.loadAsset(asset)\n\nconst result1 = await loadPromise1\nconst result2 = await loadPromise2\n\nexpect(result1).toBe(result2)\nexpect(loaders.image).toHaveBeenCalledTimes(1)\nexpect(result1.source).toBe('loaded image')"
          },
          {
            "title": "loadAsset no loader",
            "line": 125,
            "source": "const asset = {type: 'video', id: 'intro'}\n\nawait expect(loader.loadAsset(asset)).rejects.toThrow('No loader found for asset type: video')"
          },
          {
            "title": "loadAsset with url",
            "line": 132,
            "source": "const emitSpy = vi.spyOn(loader, 'emit')\nconst asset = {type: 'image', id: 'logo', url: '/assets/logo.png'}\n\nconst result = await loader.loadAsset(asset)\n\nexpect(loaders.image).toHaveBeenCalledWith({\n    url: asset.url,\n    config: {}\n})\nexpect(asset.source).toBe('loaded image')\nexpect(emitSpy).toHaveBeenCalledWith('progress', expect.any(Number), {\n    asset,\n    source: 'loaded image'\n})\nexpect(result).toBe(asset)"
          },
          {
            "title": "loadAsset without url",
            "line": 151,
            "source": "const asset = {type: 'image', id: 'logo'}\n\nawait loader.loadAsset(asset)\n\nexpect(loaders.image).toHaveBeenCalledWith(asset)"
          },
          {
            "title": "loadAsset error",
            "line": 160,
            "source": "const emitSpy = vi.spyOn(loader, 'emit')\nconst asset = {type: 'image', id: 'logo', url: '/assets/logo.png'}\nconst error = new Error('Loading failed')\nloaders.image.mockRejectedValueOnce(error)\n\nawait expect(loader.loadAsset(asset)).rejects.toThrow('Loading failed')\nexpect(emitSpy).toHaveBeenCalledWith('error', asset, error)\n\nloaders.image.mockResolvedValueOnce('loaded image after error')\nconst result = await loader.loadAsset(asset)\nexpect(result.source).toBe('loaded image after error')"
          }
        ],
        "describes": []
      }
    ]
  },
  "/application/source_manager.doc.js": {
    "file": "/application/source_manager.test.js",
    "describes": [
      {
        "title": "SourceManager",
        "line": 7,
        "beforeEach": {
          "line": 12,
          "source": "loaders = {\n    image: vi.fn().mockResolvedValue('loaded image'),\n    audio: vi.fn().mockResolvedValue('loaded audio')\n}\n\nmanifest = {\n    getAsset: vi.fn(),\n    getAssetsByTag: vi.fn(),\n    getAllAssets: vi.fn()\n}\n\nmanager = new SourceManager({loaders, manifest})"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor",
            "line": 28,
            "source": "expect(manager).toBeInstanceOf(PerkyModule)\nexpect(manager.manifest).toBe(manifest)"
          },
          {
            "title": "loadAsset success",
            "line": 34,
            "source": "const asset = {type: 'image', id: 'logo', url: '/assets/logo.png'}\nmanifest.getAsset.mockReturnValueOnce(asset)\n\nconst result = await manager.loadAsset('logo')\n\nexpect(manifest.getAsset).toHaveBeenCalledWith('logo')\nexpect(result).toBeInstanceOf(SourceLoader)\nexpect(result.assets).toEqual([asset])"
          },
          {
            "title": "loadAsset not found",
            "line": 46,
            "source": "manifest.getAsset.mockReturnValueOnce(null)\n\nawait expect(manager.loadAsset('nonexistent')).rejects.toThrow('Asset not found: nonexistent')\nexpect(manifest.getAsset).toHaveBeenCalledWith('nonexistent')"
          },
          {
            "title": "loadTag success",
            "line": 54,
            "source": "const assets = [\n    {type: 'image', id: 'logo', url: '/assets/logo.png', tags: ['ui']},\n    {type: 'image', id: 'background', url: '/assets/bg.png', tags: ['ui']}\n]\nmanifest.getAssetsByTag.mockReturnValueOnce(assets)\n\nconst result = await manager.loadTag('ui')\n\nexpect(manifest.getAssetsByTag).toHaveBeenCalledWith('ui')\nexpect(result).toBeInstanceOf(SourceLoader)\nexpect(result.assets).toBe(assets)"
          },
          {
            "title": "loadTag empty result",
            "line": 69,
            "source": "manifest.getAssetsByTag.mockReturnValueOnce([])\n\nconst result = await manager.loadTag('nonexistent')\n\nexpect(manifest.getAssetsByTag).toHaveBeenCalledWith('nonexistent')\nexpect(result).toBeInstanceOf(SourceLoader)\nexpect(result.assets).toEqual([])"
          },
          {
            "title": "loadAll success",
            "line": 80,
            "source": "const assets = [\n    {type: 'image', id: 'logo', url: '/assets/logo.png'},\n    {type: 'audio', id: 'music', url: '/assets/music.mp3'}\n]\nmanifest.getAllAssets.mockReturnValueOnce(assets)\n\nconst result = await manager.loadAll()\n\nexpect(manifest.getAllAssets).toHaveBeenCalled()\nexpect(result).toBeInstanceOf(SourceLoader)\nexpect(result.assets).toBe(assets)"
          },
          {
            "title": "loadAll empty result",
            "line": 95,
            "source": "manifest.getAllAssets.mockReturnValueOnce([])\n\nconst result = await manager.loadAll()\n\nexpect(manifest.getAllAssets).toHaveBeenCalled()\nexpect(result).toBeInstanceOf(SourceLoader)\nexpect(result.assets).toEqual([])"
          }
        ],
        "describes": []
      }
    ]
  },
  "/game/game.doc.js": {
    "file": "/game/game.test.js",
    "describes": [
      {
        "title": "Game",
        "line": 13,
        "beforeEach": {
          "line": 18,
          "source": "mockRequestAnimationFrame = global.requestAnimationFrame\nmockPerformanceNow = global.performance?.now\n\nglobal.requestAnimationFrame = vi.fn(() => 1)\nglobal.performance = {now: vi.fn(() => 0)}\n\ngame = new Game()"
        },
        "afterEach": {
          "line": 29,
          "source": "if (mockRequestAnimationFrame) {\n    global.requestAnimationFrame = mockRequestAnimationFrame\n}\nif (mockPerformanceNow) {\n    global.performance.now = mockPerformanceNow\n}"
        },
        "tests": [
          {
            "title": "extends Application",
            "line": 39,
            "source": "expect(game).toBeInstanceOf(Application)"
          },
          {
            "title": "automatically creates GameLoop",
            "line": 44,
            "source": "expect(game.gameLoop).toBeInstanceOf(GameLoop)"
          },
          {
            "title": "GameLoop is bound to game instance",
            "line": 49,
            "source": "expect(game.gameLoop).toBeDefined()\nexpect(game.gameLoop.host).toBe(game)"
          },
          {
            "title": "calls update on active controllers when GameLoop emits update",
            "line": 55,
            "source": "class TestController extends ActionController {\n    update = vi.fn()\n}\n\ngame.registerController('test', TestController)\ngame.setActiveControllers(['test'])\n\ngame.gameLoop.emit('update', 0.016)\n\nconst controller = game.getController('test')\nexpect(controller.update).toHaveBeenCalledWith(game, 0.016)"
          },
          {
            "title": "skips controllers without update method",
            "line": 70,
            "source": "class TestController extends ActionController {\n    someOtherMethod = vi.fn()\n}\n\ngame.registerController('test', TestController)\ngame.setActiveControllers(['test'])\n\nexpect(() => {\n    game.gameLoop.emit('update', 0.016)\n}).not.toThrow()\n\nconst controller = game.getController('test')\nexpect(controller.someOtherMethod).not.toHaveBeenCalled()"
          },
          {
            "title": "only updates active controllers",
            "line": 87,
            "source": "class ActiveController extends ActionController {\n    update = vi.fn()\n}\nclass InactiveController extends ActionController {\n    update = vi.fn()\n}\n\ngame.registerController('active', ActiveController)\ngame.registerController('inactive', InactiveController)\ngame.setActiveControllers(['active'])\n\ngame.gameLoop.emit('update', 0.016)\n\nconst activeController = game.getController('active')\nconst inactiveController = game.getController('inactive')\n\nexpect(activeController.update).toHaveBeenCalledWith(game, 0.016)\nexpect(inactiveController.update).not.toHaveBeenCalled()"
          },
          {
            "title": "updates multiple active controllers in order",
            "line": 109,
            "source": "class Controller1 extends ActionController {\n    update = vi.fn()\n}\nclass Controller2 extends ActionController {\n    update = vi.fn()\n}\n\ngame.registerController('controller1', Controller1)\ngame.registerController('controller2', Controller2)\ngame.setActiveControllers(['controller1', 'controller2'])\n\ngame.gameLoop.emit('update', 0.016)\n\nconst controller1 = game.getController('controller1')\nconst controller2 = game.getController('controller2')\n\nexpect(controller1.update).toHaveBeenCalledWith(game, 0.016)\nexpect(controller2.update).toHaveBeenCalledWith(game, 0.016)"
          },
          {
            "title": "passes params to Application constructor",
            "line": 131,
            "source": "const testManifest = {\n    sources: {\n        images: []\n    }\n}\nconst customGame = new Game({\n    manifest: testManifest\n})\n\nexpect(customGame.manifest).toBeDefined()"
          },
          {
            "title": "automatically creates RenderSystem",
            "line": 145,
            "source": "expect(game.renderSystem).toBeInstanceOf(RenderSystem)"
          },
          {
            "title": "RenderSystem is bound to game instance",
            "line": 150,
            "source": "expect(game.renderSystem).toBeDefined()\nexpect(game.renderSystem.host).toBe(game)"
          },
          {
            "title": "passes renderSystem options through to RenderSystem",
            "line": 156,
            "source": "const customGame = new Game({\n    renderSystem: {\n        width: 1024,\n        height: 768\n    }\n})\n\nexpect(customGame.renderSystem.layerWidth).toBe(1024)\nexpect(customGame.renderSystem.layerHeight).toBe(768)"
          },
          {
            "title": "delegates createLayer method to host",
            "line": 169,
            "source": "const container = document.createElement('div')\ngame.mount(container)\n\nconst layer = game.createLayer('test', 'canvas')\n\nexpect(layer).toBeDefined()\nexpect(game.renderSystem.getLayer('test')).toBe(layer)"
          },
          {
            "title": "delegates getLayer method to host",
            "line": 180,
            "source": "const container = document.createElement('div')\ngame.mount(container)\n\nconst layer = game.getLayer('game')\n\nexpect(layer).toBeDefined()\nexpect(layer.$id).toBe('game')"
          },
          {
            "title": "setStage creates stage as child",
            "line": 191,
            "source": "class TestStage extends Stage {\n    static World = World\n}\n\ngame.setStage(TestStage)\n\nexpect(game.stage).toBeInstanceOf(TestStage)"
          },
          {
            "title": "setStage delegates world from stage",
            "line": 202,
            "source": "class TestStage extends Stage {\n    static World = World\n}\n\ngame.setStage(TestStage)\n\nexpect(game.world).toBeInstanceOf(World)\nexpect(game.world).toBe(game.stage.world)"
          },
          {
            "title": "setStage delegates worldView from stage",
            "line": 214,
            "source": "class TestStage extends Stage {\n    static World = World\n}\n\ngame.setStage(TestStage)\n\nexpect(game.worldView).toBeInstanceOf(WorldView)\nexpect(game.worldView).toBe(game.stage.worldView)"
          },
          {
            "title": "setStage passes game to stage",
            "line": 226,
            "source": "class TestStage extends Stage {\n    static World = World\n}\n\ngame.setStage(TestStage)\n\nexpect(game.stage.game).toBe(game)"
          },
          {
            "title": "setStage passes options to stage",
            "line": 237,
            "source": "class TestStage extends Stage {\n    static World = World\n}\n\ngame.setStage(TestStage, {foo: 'bar'})\n\nexpect(game.stage.options.foo).toBe('bar')"
          },
          {
            "title": "setStage disposes previous stage",
            "line": 248,
            "source": "class StageA extends Stage {\n    static World = World\n}\nclass StageB extends Stage {\n    static World = World\n}\n\ngame.setStage(StageA)\nconst stageA = game.stage\nconst worldA = game.world\n\ngame.setStage(StageB)\n\nexpect(stageA.disposed).toBe(true)\nexpect(worldA.disposed).toBe(true)\nexpect(game.stage).toBeInstanceOf(StageB)"
          },
          {
            "title": "setStage clears world and worldView when switching",
            "line": 268,
            "source": "class StageWithWorld extends Stage {\n    static World = World\n}\nclass StageWithoutWorld extends Stage {}\n\ngame.setStage(StageWithWorld)\nexpect(game.world).toBeInstanceOf(World)\n\ngame.setStage(StageWithoutWorld)\nexpect(game.world).toBeNull()\nexpect(game.worldView).toBeNull()"
          },
          {
            "title": "stage update is called on game loop update",
            "line": 283,
            "source": "class TestStage extends Stage {\n    update = vi.fn()\n}\n\ngame.setStage(TestStage)\n\ngame.gameLoop.emit('update', 0.016)\n\nexpect(game.stage.update).toHaveBeenCalledWith(0.016)"
          },
          {
            "title": "stage render is called on game loop render",
            "line": 296,
            "source": "class TestStage extends Stage {\n    render = vi.fn()\n}\n\ngame.setStage(TestStage)\n\ngame.gameLoop.emit('render')\n\nexpect(game.stage.render).toHaveBeenCalled()"
          },
          {
            "title": "no error when no stage is set during update",
            "line": 309,
            "source": "expect(() => {\n    game.gameLoop.emit('update', 0.016)\n}).not.toThrow()"
          },
          {
            "title": "no error when no stage is set during render",
            "line": 316,
            "source": "expect(() => {\n    game.gameLoop.emit('render')\n}).not.toThrow()"
          },
          {
            "title": "setStage registers stage controller",
            "line": 323,
            "source": "class FooController extends ActionController {}\nclass TestStage extends Stage {\n    static ActionController = FooController\n}\n\ngame.setStage(TestStage)\n\nexpect(game.getController('foo')).toBeDefined()"
          },
          {
            "title": "setStage activates stage controller",
            "line": 335,
            "source": "class FooController extends ActionController {}\nclass TestStage extends Stage {\n    static ActionController = FooController\n}\n\ngame.setStage(TestStage)\n\nconst active = game.getActiveControllers()\nexpect(active).toContain('foo')"
          },
          {
            "title": "setStage unregisters previous stage controller",
            "line": 348,
            "source": "class FooController extends ActionController {}\nclass BarController extends ActionController {}\nclass StageA extends Stage {\n    static ActionController = FooController\n}\nclass StageB extends Stage {\n    static ActionController = BarController\n}\n\ngame.setStage(StageA)\nexpect(game.getController('foo')).toBeDefined()\n\ngame.setStage(StageB)\nexpect(game.getController('foo')).toBeNull()\nexpect(game.getController('bar')).toBeDefined()"
          },
          {
            "title": "setStage works without stage controller",
            "line": 367,
            "source": "class TestStage extends Stage {}\n\ngame.setStage(TestStage)\n\nexpect(game.stage).toBeInstanceOf(TestStage)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/game/auto_view.doc.js": {
    "file": "/game/auto_view.test.js",
    "describes": [
      {
        "title": "AutoView",
        "line": 8,
        "beforeEach": null,
        "afterEach": null,
        "tests": [],
        "describes": [
          {
            "title": "constructor",
            "line": 28,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates Object2D instance with entity position",
                "line": 30,
                "source": "const entity = createEntity({x: 10, y: 20})\nconst context = createContext(Circle, {radius: 0.5})\n\nconst view = new AutoView(entity, context)\n\nexpect(view.root).toBeInstanceOf(Circle)\nexpect(view.root.x).toBe(10)\nexpect(view.root.y).toBe(20)"
              },
              {
                "title": "passes config options to Object2D",
                "line": 42,
                "source": "const entity = createEntity()\nconst context = createContext(Circle, {radius: 0.8, color: '#ff0000'})\n\nconst view = new AutoView(entity, context)\n\nexpect(view.root.radius).toBe(0.8)\nexpect(view.root.color).toBe('#ff0000')"
              },
              {
                "title": "does not pass sync to Object2D constructor",
                "line": 53,
                "source": "const entity = createEntity()\nconst context = createContext(Circle, {radius: 0.5, sync: {opacity: 'health'}})\n\nconst view = new AutoView(entity, context)\n\nexpect(view.root.sync).toBeUndefined()"
              },
              {
                "title": "works with Sprite",
                "line": 63,
                "source": "const mockImage = {width: 100, height: 100}\nconst entity = createEntity({x: 5, y: 10})\nconst context = createContext(Sprite, {image: mockImage, width: 1, height: 1})\n\nconst view = new AutoView(entity, context)\n\nexpect(view.root).toBeInstanceOf(Sprite)\nexpect(view.root.image).toBe(mockImage)"
              }
            ],
            "describes": []
          },
          {
            "title": "sync",
            "line": 77,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "syncs x and y from entity",
                "line": 79,
                "source": "const entity = createEntity({x: 0, y: 0})\nconst context = createContext(Circle, {radius: 0.5})\nconst view = new AutoView(entity, context)\n\nentity.x = 15\nentity.y = 25\nview.sync()\n\nexpect(view.root.x).toBe(15)\nexpect(view.root.y).toBe(25)"
              },
              {
                "title": "syncs string binding (property name)",
                "line": 93,
                "source": "const entity = createEntity({health: 0.75})\nconst context = createContext(Circle, {\n    radius: 0.5,\n    sync: {opacity: 'health'}\n})\nconst view = new AutoView(entity, context)\n\nview.sync()\n\nexpect(view.root.opacity).toBe(0.75)"
              },
              {
                "title": "syncs function binding",
                "line": 107,
                "source": "const entity = createEntity({health: 50})\nconst context = createContext(Circle, {\n    radius: 0.5,\n    sync: {scaleX: (e) => e.health / 100}\n})\nconst view = new AutoView(entity, context)\n\nview.sync()\n\nexpect(view.root.scaleX).toBe(0.5)"
              },
              {
                "title": "calls function binding with entity",
                "line": 121,
                "source": "const syncFn = vi.fn((entity) => entity.health * 2)\nconst entity = createEntity({health: 0.5})\nconst context = createContext(Circle, {\n    radius: 0.5,\n    sync: {opacity: syncFn}\n})\nconst view = new AutoView(entity, context)\n\nview.sync()\n\nexpect(syncFn).toHaveBeenCalledWith(entity)\nexpect(view.root.opacity).toBe(1)"
              },
              {
                "title": "ignores x and y in sync bindings (already handled)",
                "line": 137,
                "source": "const entity = createEntity({x: 10, y: 20, customX: 100})\nconst context = createContext(Circle, {\n    radius: 0.5,\n    sync: {x: 'customX'}\n})\nconst view = new AutoView(entity, context)\n\nview.sync()\n\nexpect(view.root.x).toBe(10)"
              },
              {
                "title": "does nothing if root is null",
                "line": 151,
                "source": "const entity = createEntity()\nconst context = createContext(Circle, {radius: 0.5})\nconst view = new AutoView(entity, context)\n\nview.root = null\n\nexpect(() => view.sync()).not.toThrow()"
              }
            ],
            "describes": []
          },
          {
            "title": "dispose",
            "line": 166,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "clears references",
                "line": 168,
                "source": "const entity = createEntity()\nconst context = createContext(Circle, {radius: 0.5})\nconst view = new AutoView(entity, context)\n\nview.dispose()\n\nexpect(view.root).toBeNull()\nexpect(view.entity).toBeNull()\nexpect(view.context).toBeNull()"
              },
              {
                "title": "removes root from group if present",
                "line": 181,
                "source": "const entity = createEntity()\nconst context = createContext(Circle, {radius: 0.5})\nconst view = new AutoView(entity, context)\n\ncontext.group.add(view.root)\nexpect(context.group.children.length).toBe(1)\n\nview.dispose()\n\nexpect(context.group.children.length).toBe(0)"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/game/collision_box_view.doc.js": {
    "file": "/game/collision_box_view.test.js",
    "describes": [
      {
        "title": "CollisionBoxView",
        "line": 23,
        "beforeEach": {
          "line": 29,
          "source": "entity = new MockEntity(10, 20)\ncontext = new MockContext()\nview = new CollisionBoxView(entity, context)"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "sync updates rectangle position from entity",
            "line": 118,
            "source": "entity.x = 100\nentity.y = 200\nview.sync()\n\nexpect(view.root.x).toBe(100)\nexpect(view.root.y).toBe(200)"
          },
          {
            "title": "dispose cleans up properly",
            "line": 128,
            "source": "context.group.addChild(view.root)\nview.dispose()\n\nexpect(view.root).toBeNull()\nexpect(view.entity).toBeNull()"
          }
        ],
        "describes": [
          {
            "title": "constructor",
            "line": 36,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "extends EntityView",
                "line": 38,
                "source": "expect(view.entity).toBe(entity)\nexpect(view.context).toBe(context)"
              },
              {
                "title": "creates a Rectangle as root",
                "line": 44,
                "source": "expect(view.root).toBeInstanceOf(Rectangle)"
              },
              {
                "title": "positions rectangle at entity position",
                "line": 49,
                "source": "expect(view.root.x).toBe(10)\nexpect(view.root.y).toBe(20)"
              },
              {
                "title": "uses default dimensions of 1x1",
                "line": 55,
                "source": "expect(view.root.width).toBe(1)\nexpect(view.root.height).toBe(1)"
              },
              {
                "title": "has transparent fill color",
                "line": 61,
                "source": "expect(view.root.color).toBe('transparent')"
              },
              {
                "title": "uses default red stroke color",
                "line": 66,
                "source": "expect(view.root.strokeColor).toBe('#ff0000')"
              },
              {
                "title": "uses default stroke width of 2",
                "line": 71,
                "source": "expect(view.root.strokeWidth).toBe(2)"
              }
            ],
            "describes": []
          },
          {
            "title": "config options",
            "line": 78,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "accepts custom dimensions",
                "line": 80,
                "source": "const customContext = new MockContext({width: 2.5, height: 3.0})\nconst customView = new CollisionBoxView(entity, customContext)\n\nexpect(customView.root.width).toBe(2.5)\nexpect(customView.root.height).toBe(3.0)"
              },
              {
                "title": "accepts custom stroke color",
                "line": 89,
                "source": "const customContext = new MockContext({strokeColor: '#00ff00'})\nconst customView = new CollisionBoxView(entity, customContext)\n\nexpect(customView.root.strokeColor).toBe('#00ff00')"
              },
              {
                "title": "accepts custom stroke width",
                "line": 97,
                "source": "const customContext = new MockContext({strokeWidth: 5})\nconst customView = new CollisionBoxView(entity, customContext)\n\nexpect(customView.root.strokeWidth).toBe(5)"
              },
              {
                "title": "handles missing config gracefully",
                "line": 105,
                "source": "const noConfigContext = {group: new Group2D()}\nconst noConfigView = new CollisionBoxView(entity, noConfigContext)\n\nexpect(noConfigView.root.width).toBe(1)\nexpect(noConfigView.root.height).toBe(1)\nexpect(noConfigView.root.strokeColor).toBe('#ff0000')\nexpect(noConfigView.root.strokeWidth).toBe(2)"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/game/entity.doc.js": {
    "file": "/game/entity.test.js",
    "describes": [
      {
        "title": "Entity",
        "line": 6,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "has static $category \"entity\"",
            "line": 8,
            "source": "expect(Entity.$category).toBe('entity')"
          },
          {
            "title": "can be instantiated with tags",
            "line": 13,
            "source": "const entity = new Entity({$tags: ['enemy', 'collidable']})\n\nexpect(entity.$category).toBe('entity')\nexpect(entity.$tags).toEqual(['enemy', 'collidable'])"
          },
          {
            "title": "has default position at origin",
            "line": 21,
            "source": "const entity = new Entity()\n\nexpect(entity.position).toBeInstanceOf(Vec2)\nexpect(entity.x).toBe(0)\nexpect(entity.y).toBe(0)"
          },
          {
            "title": "accepts initial position",
            "line": 30,
            "source": "const entity = new Entity({x: 5, y: 10})\n\nexpect(entity.x).toBe(5)\nexpect(entity.y).toBe(10)"
          },
          {
            "title": "has default velocity at zero",
            "line": 38,
            "source": "const entity = new Entity()\n\nexpect(entity.velocity).toBeInstanceOf(Vec2)\nexpect(entity.velocity.x).toBe(0)\nexpect(entity.velocity.y).toBe(0)"
          },
          {
            "title": "x and y setters update position",
            "line": 47,
            "source": "const entity = new Entity()\n\nentity.x = 42\nentity.y = 84\n\nexpect(entity.position.x).toBe(42)\nexpect(entity.position.y).toBe(84)"
          },
          {
            "title": "has update method",
            "line": 58,
            "source": "const entity = new Entity()\n\nexpect(typeof entity.update).toBe('function')"
          }
        ],
        "describes": []
      }
    ]
  },
  "/game/entity_view.doc.js": {
    "file": "/game/entity_view.test.js",
    "describes": [
      {
        "title": "EntityView",
        "line": 22,
        "beforeEach": {
          "line": 28,
          "source": "entity = new MockEntity(10, 20)\ncontext = new MockContext()\nview = new EntityView(entity, context)"
        },
        "afterEach": null,
        "tests": [],
        "describes": [
          {
            "title": "constructor",
            "line": 35,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "stores entity reference",
                "line": 37,
                "source": "expect(view.entity).toBe(entity)"
              },
              {
                "title": "stores context reference",
                "line": 42,
                "source": "expect(view.context).toBe(context)"
              },
              {
                "title": "initializes root as null",
                "line": 47,
                "source": "expect(view.root).toBeNull()"
              }
            ],
            "describes": []
          },
          {
            "title": "sync",
            "line": 54,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "does nothing when root is null",
                "line": 56,
                "source": "expect(() => view.sync()).not.toThrow()"
              },
              {
                "title": "syncs root position from entity",
                "line": 61,
                "source": "view.root = {x: 0, y: 0}\n\nentity.x = 100\nentity.y = 200\nview.sync()\n\nexpect(view.root.x).toBe(100)\nexpect(view.root.y).toBe(200)"
              },
              {
                "title": "updates root when entity moves",
                "line": 73,
                "source": "view.root = {x: 0, y: 0}\n\nview.sync()\nexpect(view.root.x).toBe(10)\nexpect(view.root.y).toBe(20)\n\nentity.x = 50\nentity.y = 75\nview.sync()\n\nexpect(view.root.x).toBe(50)\nexpect(view.root.y).toBe(75)"
              }
            ],
            "describes": []
          },
          {
            "title": "dispose",
            "line": 91,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "removes root from context group",
                "line": 93,
                "source": "const mockRoot = new Group2D()\ncontext.group.addChild(mockRoot)\nview.root = mockRoot\n\nexpect(context.group.children).toContain(mockRoot)\n\nview.dispose()\n\nexpect(context.group.children).not.toContain(mockRoot)"
              },
              {
                "title": "sets root to null",
                "line": 106,
                "source": "view.root = {x: 0, y: 0}\nview.dispose()\n\nexpect(view.root).toBeNull()"
              },
              {
                "title": "sets entity to null",
                "line": 114,
                "source": "view.dispose()\nexpect(view.entity).toBeNull()"
              },
              {
                "title": "sets context to null",
                "line": 120,
                "source": "view.dispose()\nexpect(view.context).toBeNull()"
              },
              {
                "title": "handles null root gracefully",
                "line": 126,
                "source": "view.root = null\nexpect(() => view.dispose()).not.toThrow()"
              },
              {
                "title": "handles null context.group gracefully",
                "line": 132,
                "source": "view.root = {x: 0, y: 0}\ncontext.group = null\n\nexpect(() => view.dispose()).not.toThrow()"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/game/game_controller.doc.js": {
    "file": "/game/game_controller.test.js",
    "describes": [
      {
        "title": "GameController",
        "line": 7,
        "beforeEach": {
          "line": 11,
          "source": "controller = new GameController()"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "has default resources",
            "line": 16,
            "source": "expect(GameController.resources).toEqual(['world', 'renderer', 'camera'])"
          },
          {
            "title": "game getter returns engine",
            "line": 21,
            "source": "const mockEngine = {name: 'test-engine'}\ncontroller.engine = mockEngine\n\nexpect(controller.game).toBe(mockEngine)"
          }
        ],
        "describes": [
          {
            "title": "spawn",
            "line": 29,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns undefined when no world",
                "line": 31,
                "source": "const result = controller.spawn(Entity)\n\nexpect(result).toBeUndefined()"
              },
              {
                "title": "creates entity in world",
                "line": 38,
                "source": "const world = new World()\ncontroller.world = world\n\nconst entity = controller.spawn(Entity, {$id: 'test-entity'})\n\nexpect(entity).toBeInstanceOf(Entity)\nexpect(entity.$id).toBe('test-entity')\nexpect(world.entities).toContain(entity)"
              },
              {
                "title": "passes options to entity",
                "line": 50,
                "source": "const world = new World()\ncontroller.world = world\n\nconst entity = controller.spawn(Entity, {x: 100, y: 200})\n\nexpect(entity.x).toBe(100)\nexpect(entity.y).toBe(200)"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/game/game_loop.doc.js": {
    "file": "/game/game_loop.test.js",
    "describes": [
      {
        "title": "GameLoop",
        "line": 6,
        "beforeEach": {
          "line": 12,
          "source": "originalRequestAnimationFrame = global.requestAnimationFrame\noriginalPerformanceNow = global.performance.now\nanimationCallbacks = []\n\nlet time = 0\nglobal.performance.now = vi.fn(() => {\n    time += 16.7 // ~60fps\n    return time\n})\n\nglobal.requestAnimationFrame = vi.fn(callback => {\n    animationCallbacks.push(callback)\n    return 1 // Return a dummy ID\n})\n\nvi.spyOn(PerkyModule.prototype, 'emit')\n\ngameLoop = new GameLoop()"
        },
        "afterEach": {
          "line": 34,
          "source": "vi.restoreAllMocks()\nglobal.requestAnimationFrame = originalRequestAnimationFrame\nglobal.performance.now = originalPerformanceNow\nanimationCallbacks = []"
        },
        "tests": [
          {
            "title": "constructor",
            "line": 42,
            "source": "expect(gameLoop).toBeInstanceOf(PerkyModule)\nexpect(gameLoop.frameInterval).toBe(1000 / 60)\nexpect(gameLoop.paused).toBe(false)\nexpect(gameLoop.maxFrameSkip).toBe(5)"
          },
          {
            "title": "constructor with custom params",
            "line": 50,
            "source": "const customLoop = new GameLoop({\n    fps: 30,\n    maxFrameSkip: 3\n})\n\nexpect(customLoop.frameInterval).toBe(1000 / 30)\nexpect(customLoop.maxFrameSkip).toBe(3)"
          },
          {
            "title": "running getter",
            "line": 61,
            "source": "expect(gameLoop.running).toBe(false)\n\ngameLoop.start()\nexpect(gameLoop.running).toBe(true)\n\ngameLoop.paused = true\nexpect(gameLoop.running).toBe(false)"
          },
          {
            "title": "start",
            "line": 72,
            "source": "gameLoop.start()\n\nexpect(gameLoop.started).toBe(true)\nexpect(gameLoop.lastTime).toBeDefined()\nexpect(gameLoop.accumulator).toBe(0)\nexpect(gameLoop.frameCount).toBe(0)\nexpect(global.requestAnimationFrame).toHaveBeenCalled()"
          },
          {
            "title": "start with already started",
            "line": 83,
            "source": "gameLoop.start()\n\nvi.clearAllMocks()\nconst result = gameLoop.start()\n\nexpect(result).toBe(false)\nexpect(requestAnimationFrame).not.toHaveBeenCalled()"
          },
          {
            "title": "pause",
            "line": 94,
            "source": "gameLoop.start()\ngameLoop.paused = false\n\nconst result = gameLoop.pause('param')\n\nexpect(result).toBe(true)\nexpect(gameLoop.paused).toBe(true)\nexpect(gameLoop.emit).toHaveBeenCalledWith('pause', 'param')"
          },
          {
            "title": "pause when not running",
            "line": 106,
            "source": "vi.clearAllMocks()\n\nconst result = gameLoop.pause()\n\nexpect(result).toBe(false)\nexpect(gameLoop.emit).not.toHaveBeenCalled()"
          },
          {
            "title": "resume",
            "line": 116,
            "source": "gameLoop.start()\ngameLoop.paused = true\n\nconst result = gameLoop.resume('param')\n\nexpect(result).toBe(true)\nexpect(gameLoop.paused).toBe(false)\nexpect(gameLoop.emit).toHaveBeenCalledWith('resume', 'param')\nexpect(requestAnimationFrame).toHaveBeenCalled()"
          },
          {
            "title": "resume when not paused",
            "line": 129,
            "source": "gameLoop.start()\ngameLoop.paused = false\n\nvi.clearAllMocks()\n\nconst result = gameLoop.resume()\n\nexpect(result).toBe(false)\nexpect(gameLoop.emit).not.toHaveBeenCalled()"
          },
          {
            "title": "setFps and getFps",
            "line": 142,
            "source": "gameLoop.setFps(30)\n\nexpect(gameLoop.frameInterval).toBe(1000 / 30)\nexpect(gameLoop.getFps()).toBe(30)"
          },
          {
            "title": "getCurrentFps",
            "line": 150,
            "source": "expect(gameLoop.getCurrentFps()).toBe(0)\n\ngameLoop.currentFps = 59\nexpect(gameLoop.getCurrentFps()).toBe(59)"
          },
          {
            "title": "update function emits events",
            "line": 158,
            "source": "const testLoop = new GameLoop()\nconst update = vi.fn()\nconst render = vi.fn()\n\ntestLoop.on('update', update)\ntestLoop.on('render', render)\n\ntestLoop.start()\nexpect(animationCallbacks.length).toBeGreaterThan(0)\n\ntestLoop.lastTime = performance.now() - 50 // 50ms ago\n\nconst updateFn = animationCallbacks[0]\nupdateFn(performance.now())\n\nexpect(update).toHaveBeenCalled()\n\nexpect(render).toHaveBeenCalled()"
          },
          {
            "title": "update function with paused loop",
            "line": 179,
            "source": "const testLoop = new GameLoop()\nconst update = vi.fn()\nconst render = vi.fn()\n\ntestLoop.on('update', update)\ntestLoop.on('render', render)\n\ntestLoop.start()\nexpect(animationCallbacks.length).toBeGreaterThan(0)\n\ntestLoop.paused = true\n\nconst updateFn = animationCallbacks[0]\nconst result = updateFn(performance.now())\n\nexpect(result).toBe(false)\nexpect(update).not.toHaveBeenCalled()\nexpect(render).not.toHaveBeenCalled()"
          },
          {
            "title": "getScreenFps",
            "line": 201,
            "source": "expect(gameLoop.getScreenFps()).toBe(0)\n\ngameLoop.screenFps = 120\nexpect(gameLoop.getScreenFps()).toBe(120)"
          },
          {
            "title": "setFpsLimited",
            "line": 209,
            "source": "expect(gameLoop.fpsLimited).toBe(false)\n\ngameLoop.setFpsLimited(true)\n\nexpect(gameLoop.fpsLimited).toBe(true)\nexpect(gameLoop.emit).toHaveBeenCalledWith('changed:fpsLimited', true)"
          },
          {
            "title": "constructor with fpsLimited param",
            "line": 219,
            "source": "const limitedLoop = new GameLoop({fpsLimited: true})\n\nexpect(limitedLoop.fpsLimited).toBe(true)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/game/stage.doc.js": {
    "file": "/game/stage.test.js",
    "describes": [
      {
        "title": "Stage",
        "line": 8,
        "beforeEach": {
          "line": 12,
          "source": "stage = new Stage({game: {}})"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "extends PerkyModule",
            "line": 17,
            "source": "expect(stage).toBeInstanceOf(PerkyModule)"
          },
          {
            "title": "has stage category",
            "line": 22,
            "source": "expect(Stage.$category).toBe('stage')"
          },
          {
            "title": "stores game reference",
            "line": 27,
            "source": "const game = {name: 'testGame'}\nconst s = new Stage({game})\n\nexpect(s.game).toBe(game)"
          },
          {
            "title": "has null World by default",
            "line": 35,
            "source": "expect(Stage.World).toBe(null)"
          },
          {
            "title": "has WorldView by default",
            "line": 40,
            "source": "expect(Stage.WorldView).toBe(WorldView)"
          },
          {
            "title": "has null ActionController by default",
            "line": 45,
            "source": "expect(Stage.ActionController).toBe(null)"
          },
          {
            "title": "does not create world when World is null",
            "line": 50,
            "source": "expect(stage.world).toBeUndefined()"
          },
          {
            "title": "does not create worldView when no world",
            "line": 55,
            "source": "expect(stage.worldView).toBeUndefined()"
          },
          {
            "title": "creates world when World is defined",
            "line": 60,
            "source": "class TestStage extends Stage {\n    static World = World\n}\n\nconst s = new TestStage({game: {}})\n\nexpect(s.world).toBeInstanceOf(World)"
          },
          {
            "title": "creates worldView when World is defined",
            "line": 71,
            "source": "class TestStage extends Stage {\n    static World = World\n}\n\nconst game = {}\nconst s = new TestStage({game})\n\nexpect(s.worldView).toBeInstanceOf(WorldView)"
          },
          {
            "title": "worldView receives world and game",
            "line": 83,
            "source": "class TestStage extends Stage {\n    static World = World\n}\n\nconst game = {}\nconst s = new TestStage({game})\n\nexpect(s.worldView.world).toBe(s.world)\nexpect(s.worldView.game).toBe(game)"
          },
          {
            "title": "does not create worldView when WorldView is null",
            "line": 96,
            "source": "class TestStage extends Stage {\n    static World = World\n    static WorldView = null\n}\n\nconst s = new TestStage({game: {}})\n\nexpect(s.world).toBeInstanceOf(World)\nexpect(s.worldView).toBeUndefined()"
          },
          {
            "title": "world is child of stage",
            "line": 109,
            "source": "class TestStage extends Stage {\n    static World = World\n}\n\nconst s = new TestStage({game: {}})\n\nexpect(s.getChild('world')).toBe(s.world)"
          },
          {
            "title": "worldView is child of stage",
            "line": 120,
            "source": "class TestStage extends Stage {\n    static World = World\n}\n\nconst s = new TestStage({game: {}})\n\nexpect(s.getChild('worldView')).toBe(s.worldView)"
          },
          {
            "title": "update calls worldView.updateViews when worldView exists",
            "line": 131,
            "source": "class TestStage extends Stage {\n    static World = World\n}\n\nconst s = new TestStage({game: {}})\ns.worldView.updateViews = vi.fn()\n\ns.update(0.016)\n\nexpect(s.worldView.updateViews).toHaveBeenCalledWith(0.016)"
          },
          {
            "title": "update does not throw when no worldView",
            "line": 145,
            "source": "expect(() => stage.update(0.016)).not.toThrow()"
          },
          {
            "title": "render is a no-op by default",
            "line": 150,
            "source": "expect(() => stage.render()).not.toThrow()"
          },
          {
            "title": "subclass can override update",
            "line": 155,
            "source": "const updateSpy = vi.fn()\n\nclass TestStage extends Stage {\n    update (deltaTime) {\n        updateSpy(deltaTime)\n    }\n}\n\nconst s = new TestStage({game: {}})\ns.update(0.016)\n\nexpect(updateSpy).toHaveBeenCalledWith(0.016)"
          },
          {
            "title": "subclass can override render",
            "line": 171,
            "source": "const renderSpy = vi.fn()\n\nclass TestStage extends Stage {\n    render () {\n        renderSpy()\n    }\n}\n\nconst s = new TestStage({game: {}})\ns.render()\n\nexpect(renderSpy).toHaveBeenCalled()"
          },
          {
            "title": "disposing stage disposes world and worldView",
            "line": 187,
            "source": "class TestStage extends Stage {\n    static World = World\n}\n\nconst s = new TestStage({game: {}})\nconst world = s.world\nconst worldView = s.worldView\n\ns.dispose()\n\nexpect(world.disposed).toBe(true)\nexpect(worldView.disposed).toBe(true)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/game/world.doc.js": {
    "file": "/game/world.test.js",
    "describes": [
      {
        "title": "World",
        "line": 6,
        "beforeEach": {
          "line": 10,
          "source": "world = new World()"
        },
        "afterEach": null,
        "tests": [],
        "describes": [
          {
            "title": "static properties",
            "line": 15,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "has correct $category",
                "line": 17,
                "source": "expect(World.$category).toBe('world')"
              },
              {
                "title": "extends PerkyModule",
                "line": 22,
                "source": "expect(world.constructor.name).toBe('World')"
              }
            ],
            "describes": []
          },
          {
            "title": "entities",
            "line": 29,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns empty array when no entities",
                "line": 31,
                "source": "expect(world.entities).toEqual([])"
              },
              {
                "title": "returns entities created in world",
                "line": 36,
                "source": "const entity1 = world.create(Entity, {$id: 'entity-1'})\nconst entity2 = world.create(Entity, {$id: 'entity-2'})\n\nconst entities = world.entities\n\nexpect(entities).toContain(entity1)\nexpect(entities).toContain(entity2)\nexpect(entities.length).toBe(2)"
              },
              {
                "title": "does not return non-entity children",
                "line": 48,
                "source": "world.create(Entity, {$id: 'entity-1'})\n\n// Create a non-entity child\nclass NonEntity extends Entity {\n    static $category = 'other'\n}\nworld.create(NonEntity, {$id: 'non-entity'})\n\nconst entities = world.entities\n\nexpect(entities.length).toBe(1)\nexpect(entities[0].$id).toBe('entity-1')"
              }
            ],
            "describes": []
          },
          {
            "title": "update",
            "line": 66,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "does not call preUpdate when not started",
                "line": 68,
                "source": "let called = false\nworld.preUpdate = () => {\n    called = true\n}\n\nworld.update(0.016, {})\n\nexpect(called).toBe(false)"
              },
              {
                "title": "calls preUpdate when started",
                "line": 80,
                "source": "let called = false\nworld.preUpdate = () => {\n    called = true\n}\n\nworld.start()\nworld.update(0.016, {})\n\nexpect(called).toBe(true)"
              },
              {
                "title": "calls postUpdate when started",
                "line": 93,
                "source": "let called = false\nworld.postUpdate = () => {\n    called = true\n}\n\nworld.start()\nworld.update(0.016, {})\n\nexpect(called).toBe(true)"
              },
              {
                "title": "passes deltaTime and context to preUpdate",
                "line": 106,
                "source": "let receivedDeltaTime\nlet receivedContext\nconst context = {foo: 'bar'}\nworld.preUpdate = (dt, ctx) => {\n    receivedDeltaTime = dt\n    receivedContext = ctx\n}\n\nworld.start()\nworld.update(0.016, context)\n\nexpect(receivedDeltaTime).toBe(0.016)\nexpect(receivedContext).toBe(context)"
              },
              {
                "title": "passes deltaTime and context to postUpdate",
                "line": 123,
                "source": "let receivedDeltaTime\nlet receivedContext\nconst context = {foo: 'bar'}\nworld.postUpdate = (dt, ctx) => {\n    receivedDeltaTime = dt\n    receivedContext = ctx\n}\n\nworld.start()\nworld.update(0.016, context)\n\nexpect(receivedDeltaTime).toBe(0.016)\nexpect(receivedContext).toBe(context)"
              },
              {
                "title": "calls update on started entities",
                "line": 140,
                "source": "let updateCalled = false\nclass TestEntity extends Entity {\n    update () {  \n        updateCalled = true\n    }\n}\n\nworld.start()\nconst entity = world.create(TestEntity, {$id: 'test'})\nentity.start()\n\nworld.update(0.016, {})\n\nexpect(updateCalled).toBe(true)"
              },
              {
                "title": "does not call update on non-started entities",
                "line": 158,
                "source": "let updateCalled = false\nclass TestEntity extends Entity {\n    update () {  \n        updateCalled = true\n    }\n}\n\nworld.start()\nworld.create(TestEntity, {$id: 'test', $eagerStart: false})\n\nworld.update(0.016, {})\n\nexpect(updateCalled).toBe(false)"
              },
              {
                "title": "passes deltaTime to entity update",
                "line": 175,
                "source": "let receivedDeltaTime\nclass TestEntity extends Entity {\n    update (deltaTime) {  \n        receivedDeltaTime = deltaTime\n    }\n}\n\nworld.start()\nconst entity = world.create(TestEntity, {$id: 'test'})\nentity.start()\n\nworld.update(0.033, {})\n\nexpect(receivedDeltaTime).toBe(0.033)"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/game/world_view.doc.js": {
    "file": "/game/world_view.test.js",
    "describes": [
      {
        "title": "WorldView",
        "line": 69,
        "beforeEach": {
          "line": 76,
          "source": "mockWorld = new MockWorld()\nconst mockRenderer = {\n    setRenderGroups: vi.fn(),\n    appendRenderGroup: vi.fn()\n}\nmockCanvas = {}\nmockGame = {\n    getSource: vi.fn(),\n    getRenderer: vi.fn().mockReturnValue(mockRenderer),\n    getLayer: vi.fn().mockReturnValue(mockCanvas),\n    clock: {deltaTime: 0.016}\n}\n\nworldView = new WorldView({\n    world: mockWorld,\n    game: mockGame\n})"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "clearRegistry clears all registrations",
            "line": 190,
            "source": "worldView.register(MockEntity, MockEntityView)\nworldView.register(AnotherMockEntity, MockEntityView)\n\nconst result = worldView.clearRegistry()\n\nexpect(result).toBe(worldView)"
          },
          {
            "title": "onStop disposes all views",
            "line": 260,
            "source": "worldView.register(MockEntity, MockEntityView)\nworldView.onStart()\n\nconst entity = new MockEntity({$id: 'stop-test'})\nmockWorld.addEntity(entity)\n\nconst views = worldView.getViews('stop-test')\nexpect(views.length).toBe(1)\n\nworldView.onStop()\n\nexpect(worldView.getViews('stop-test').length).toBe(0)"
          },
          {
            "title": "sync calls sync on all views",
            "line": 276,
            "source": "worldView.register(MockEntity, MockEntityView)\nworldView.onStart()\n\nconst entity1 = new MockEntity({$id: 'sync-1'})\nconst entity2 = new MockEntity({$id: 'sync-2'})\nmockWorld.addEntity(entity1)\nmockWorld.addEntity(entity2)\n\nworldView.sync()\n\nconst views1 = worldView.getViews('sync-1')\nconst views2 = worldView.getViews('sync-2')\n\nexpect(views1[0].syncCalled).toBe(true)\nexpect(views2[0].syncCalled).toBe(true)"
          }
        ],
        "describes": [
          {
            "title": "constructor",
            "line": 97,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "initializes with world and game references",
                "line": 99,
                "source": "expect(worldView.world).toBe(mockWorld)\nexpect(worldView.game).toBe(mockGame)"
              },
              {
                "title": "creates a rootGroup",
                "line": 105,
                "source": "expect(worldView.rootGroup).toBeInstanceOf(Group2D)"
              },
              {
                "title": "has correct $category",
                "line": 110,
                "source": "expect(WorldView.$category).toBe('worldView')"
              }
            ],
            "describes": []
          },
          {
            "title": "register",
            "line": 117,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "registers a view by class",
                "line": 119,
                "source": "worldView.register(MockEntity, MockEntityView)\n\nconst entity = new MockEntity({$id: 'test-1'})\nmockWorld.addEntity(entity)\nworldView.onStart()\n\nexpect(worldView.getViews('test-1').length).toBe(1)"
              },
              {
                "title": "registers a view by matcher function",
                "line": 130,
                "source": "const matcher = (entity) => entity.hasTag('enemy')\nworldView.register(matcher, MockEntityView)\n\nconst entity = new MockEntity({$id: 'test-2', entityTags: ['enemy']})\nmockWorld.addEntity(entity)\nworldView.onStart()\n\nexpect(worldView.getViews('test-2').length).toBe(1)"
              },
              {
                "title": "registers with config",
                "line": 142,
                "source": "const config = {color: 'red', size: 10}\nworldView.register(MockEntity, MockEntityView, config)\n\nconst entity = new MockEntity({$id: 'test-3'})\nmockWorld.addEntity(entity)\nworldView.onStart()\n\nconst views = worldView.getViews('test-3')\nexpect(views[0].context.config).toEqual(config)"
              },
              {
                "title": "returns this for chaining",
                "line": 155,
                "source": "const result = worldView.register(MockEntity, MockEntityView)\nexpect(result).toBe(worldView)"
              }
            ],
            "describes": []
          },
          {
            "title": "unregister",
            "line": 163,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "unregisters a class registration",
                "line": 165,
                "source": "worldView.register(MockEntity, MockEntityView)\nconst result = worldView.unregister(MockEntity)\n\nexpect(result).toBe(true)"
              },
              {
                "title": "unregisters a matcher registration",
                "line": 173,
                "source": "const matcher = (entity) => entity.hasTag('test')\nworldView.register(matcher, MockEntityView)\nconst result = worldView.unregister(matcher)\n\nexpect(result).toBe(true)"
              },
              {
                "title": "returns false for non-existent registration",
                "line": 182,
                "source": "const result = worldView.unregister(MockEntity)\nexpect(result).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "onStart",
            "line": 200,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "listens to world entity:set events",
                "line": 202,
                "source": "worldView.register(MockEntity, MockEntityView)\nworldView.onStart()\n\nconst entity = new MockEntity({$id: 'dynamic-1'})\nmockWorld.addEntity(entity)\n\nexpect(worldView.getViews('dynamic-1').length).toBe(1)"
              },
              {
                "title": "listens to world entity:delete events",
                "line": 213,
                "source": "worldView.register(MockEntity, MockEntityView)\nworldView.onStart()\n\nconst entity = new MockEntity({$id: 'to-delete'})\nmockWorld.addEntity(entity)\n\nexpect(worldView.getViews('to-delete').length).toBe(1)\n\nmockWorld.removeEntity('to-delete')\n\nexpect(worldView.getViews('to-delete').length).toBe(0)"
              },
              {
                "title": "processes existing entities on start",
                "line": 228,
                "source": "const entity = new MockEntity({$id: 'existing-1'})\nmockWorld.addEntity(entity)\n\nworldView.register(MockEntity, MockEntityView)\nworldView.onStart()\n\nexpect(worldView.getViews('existing-1').length).toBe(1)"
              },
              {
                "title": "does nothing if no world",
                "line": 239,
                "source": "const noWorldView = new WorldView({game: mockGame})\nexpect(() => noWorldView.onStart()).not.toThrow()"
              },
              {
                "title": "setupRenderGroups configures renderer",
                "line": 245,
                "source": "const mockRenderer = mockGame.getRenderer('game')\n\nworldView.onStart()\nworldView.setupRenderGroups()\n\nexpect(mockRenderer.appendRenderGroup).toHaveBeenCalledWith({\n    $name: 'entities',\n    content: worldView.rootGroup\n})"
              }
            ],
            "describes": []
          },
          {
            "title": "updateViews",
            "line": 295,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "calls update on all views with deltaTime",
                "line": 297,
                "source": "class ViewWithUpdate {\n    constructor () {\n        this.root = new Group2D()\n        this.updateCalled = false\n        this.lastDeltaTime = null\n    }\n\n    update (deltaTime) {\n        this.updateCalled = true\n        this.lastDeltaTime = deltaTime\n    }\n\n    sync () {}\n\n    dispose () {\n        this.root = null\n    }\n}\n\nworldView.register(MockEntity, ViewWithUpdate)\nworldView.onStart()\n\nconst entity = new MockEntity({$id: 'update-test'})\nmockWorld.addEntity(entity)\n\nworldView.updateViews(0.016)\n\nconst views = worldView.getViews('update-test')\nexpect(views[0].updateCalled).toBe(true)\nexpect(views[0].lastDeltaTime).toBe(0.016)"
              },
              {
                "title": "skips views without update method",
                "line": 331,
                "source": "worldView.register(MockEntity, MockEntityView)\nworldView.onStart()\n\nconst entity = new MockEntity({$id: 'no-update'})\nmockWorld.addEntity(entity)\n\nexpect(() => worldView.updateViews(0.016)).not.toThrow()"
              },
              {
                "title": "updates multiple entities",
                "line": 342,
                "source": "class ViewWithUpdate {\n    constructor () {\n        this.root = new Group2D()\n        this.updateCount = 0\n    }\n\n    update () {\n        this.updateCount++\n    }\n\n    sync () {}\n\n    dispose () {\n        this.root = null\n    }\n}\n\nworldView.register(MockEntity, ViewWithUpdate)\nworldView.onStart()\n\nmockWorld.addEntity(new MockEntity({$id: 'multi-1'}))\nmockWorld.addEntity(new MockEntity({$id: 'multi-2'}))\nmockWorld.addEntity(new MockEntity({$id: 'multi-3'}))\n\nworldView.updateViews(0.016)\n\nexpect(worldView.getViews('multi-1')[0].updateCount).toBe(1)\nexpect(worldView.getViews('multi-2')[0].updateCount).toBe(1)\nexpect(worldView.getViews('multi-3')[0].updateCount).toBe(1)"
              }
            ],
            "describes": []
          },
          {
            "title": "syncViews",
            "line": 377,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "calls sync on all views",
                "line": 379,
                "source": "worldView.register(MockEntity, MockEntityView)\nworldView.onStart()\n\nconst entity = new MockEntity({$id: 'sync-test'})\nmockWorld.addEntity(entity)\n\nworldView.syncViews()\n\nexpect(worldView.getViews('sync-test')[0].syncCalled).toBe(true)"
              },
              {
                "title": "syncs multiple entities",
                "line": 392,
                "source": "worldView.register(MockEntity, MockEntityView)\nworldView.onStart()\n\nmockWorld.addEntity(new MockEntity({$id: 'multi-sync-1'}))\nmockWorld.addEntity(new MockEntity({$id: 'multi-sync-2'}))\n\nworldView.syncViews()\n\nexpect(worldView.getViews('multi-sync-1')[0].syncCalled).toBe(true)\nexpect(worldView.getViews('multi-sync-2')[0].syncCalled).toBe(true)"
              }
            ],
            "describes": []
          },
          {
            "title": "getViews",
            "line": 408,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns empty array for unknown entity",
                "line": 410,
                "source": "expect(worldView.getViews('unknown')).toEqual([])"
              },
              {
                "title": "returns views for known entity",
                "line": 415,
                "source": "worldView.register(MockEntity, MockEntityView)\nworldView.onStart()\n\nconst entity = new MockEntity({$id: 'get-test'})\nmockWorld.addEntity(entity)\n\nconst views = worldView.getViews('get-test')\nexpect(views.length).toBe(1)\nexpect(views[0]).toBeInstanceOf(MockEntityView)"
              }
            ],
            "describes": []
          },
          {
            "title": "events",
            "line": 430,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "emits view:added when entity is added",
                "line": 432,
                "source": "const addedHandler = vi.fn()\nworldView.on('view:added', addedHandler)\n\nworldView.register(MockEntity, MockEntityView)\nworldView.onStart()\n\nconst entity = new MockEntity({$id: 'event-add'})\nmockWorld.addEntity(entity)\n\nexpect(addedHandler).toHaveBeenCalledWith('event-add', expect.any(Array))"
              },
              {
                "title": "emits view:removed when entity is deleted",
                "line": 446,
                "source": "const removedHandler = vi.fn()\nworldView.on('view:removed', removedHandler)\n\nworldView.register(MockEntity, MockEntityView)\nworldView.onStart()\n\nconst entity = new MockEntity({$id: 'event-remove'})\nmockWorld.addEntity(entity)\nmockWorld.removeEntity('event-remove')\n\nexpect(removedHandler).toHaveBeenCalledWith('event-remove', expect.any(Array))"
              }
            ],
            "describes": []
          },
          {
            "title": "view root integration",
            "line": 463,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "adds view root to rootGroup",
                "line": 465,
                "source": "worldView.register(MockEntity, MockEntityView)\nworldView.onStart()\n\nconst entity = new MockEntity({$id: 'root-test'})\nmockWorld.addEntity(entity)\n\nexpect(worldView.rootGroup.children.length).toBe(1)"
              },
              {
                "title": "sets $entity on view root",
                "line": 476,
                "source": "worldView.register(MockEntity, MockEntityView)\nworldView.onStart()\n\nconst entity = new MockEntity({$id: 'meta-test'})\nmockWorld.addEntity(entity)\n\nconst child = worldView.rootGroup.children[0]\nexpect(child.$entity).toBe(entity)"
              },
              {
                "title": "sets $view and $viewName on view root",
                "line": 488,
                "source": "worldView.register(MockEntity, MockEntityView)\nworldView.onStart()\n\nconst entity = new MockEntity({$id: 'view-meta'})\nmockWorld.addEntity(entity)\n\nconst child = worldView.rootGroup.children[0]\nexpect(child.$view).toBeInstanceOf(MockEntityView)\nexpect(child.$viewName).toBe('MockEntityView')"
              }
            ],
            "describes": []
          },
          {
            "title": "AutoView (Object2D registration)",
            "line": 503,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "registers an Object2D class directly",
                "line": 505,
                "source": "worldView.register(MockEntity, Circle, {radius: 0.5, color: '#ff0000'})\nworldView.onStart()\n\nconst entity = new MockEntity({$id: 'circle-1', x: 10, y: 20})\nmockWorld.addEntity(entity)\n\nconst views = worldView.getViews('circle-1')\nexpect(views.length).toBe(1)\nexpect(views[0].root).toBeInstanceOf(Circle)\nexpect(views[0].root.radius).toBe(0.5)\nexpect(views[0].root.color).toBe('#ff0000')"
              },
              {
                "title": "auto-syncs x and y from entity",
                "line": 520,
                "source": "worldView.register(MockEntity, Circle, {radius: 0.5})\nworldView.onStart()\n\nconst entity = new MockEntity({$id: 'sync-xy', x: 5, y: 10})\nmockWorld.addEntity(entity)\n\nconst view = worldView.getViews('sync-xy')[0]\nexpect(view.root.x).toBe(5)\nexpect(view.root.y).toBe(10)\n\nentity.x = 15\nentity.y = 25\nworldView.sync()\n\nexpect(view.root.x).toBe(15)\nexpect(view.root.y).toBe(25)"
              },
              {
                "title": "supports custom sync bindings with string property name",
                "line": 540,
                "source": "worldView.register(MockEntity, Circle, {\n    radius: 0.5,\n    sync: {\n        opacity: 'health'\n    }\n})\nworldView.onStart()\n\nconst entity = new MockEntity({$id: 'sync-string', x: 0, y: 0})\nentity.health = 0.75\nmockWorld.addEntity(entity)\n\nworldView.sync()\n\nconst view = worldView.getViews('sync-string')[0]\nexpect(view.root.opacity).toBe(0.75)"
              },
              {
                "title": "supports custom sync bindings with function",
                "line": 560,
                "source": "worldView.register(MockEntity, Circle, {\n    radius: 0.5,\n    sync: {\n        scaleX: (entity) => entity.health / 100\n    }\n})\nworldView.onStart()\n\nconst entity = new MockEntity({$id: 'sync-fn', x: 0, y: 0})\nentity.health = 50\nmockWorld.addEntity(entity)\n\nworldView.sync()\n\nconst view = worldView.getViews('sync-fn')[0]\nexpect(view.root.scaleX).toBe(0.5)"
              },
              {
                "title": "calls sync function with entity",
                "line": 580,
                "source": "const syncFn = vi.fn((entity) => entity.health * 2)\nworldView.register(MockEntity, Circle, {\n    radius: 0.5,\n    sync: {\n        opacity: syncFn\n    }\n})\nworldView.onStart()\n\nconst entity = new MockEntity({$id: 'sync-dt', x: 0, y: 0, health: 0.5})\nmockWorld.addEntity(entity)\n\nworldView.sync()\n\nexpect(syncFn).toHaveBeenCalledWith(entity)"
              },
              {
                "title": "sets $viewName to Object2D class name",
                "line": 599,
                "source": "worldView.register(MockEntity, Circle, {radius: 0.5})\nworldView.onStart()\n\nconst entity = new MockEntity({$id: 'viewname-test'})\nmockWorld.addEntity(entity)\n\nconst child = worldView.rootGroup.children[0]\nexpect(child.$viewName).toBe('Circle')"
              },
              {
                "title": "works with Sprite",
                "line": 611,
                "source": "const mockImage = {width: 100, height: 100}\nworldView.register(MockEntity, Sprite, {image: mockImage, width: 1, height: 1})\nworldView.onStart()\n\nconst entity = new MockEntity({$id: 'image-test', x: 0, y: 0})\nmockWorld.addEntity(entity)\n\nconst view = worldView.getViews('image-test')[0]\nexpect(view.root).toBeInstanceOf(Sprite)\nexpect(view.root.image).toBe(mockImage)"
              },
              {
                "title": "disposes correctly",
                "line": 625,
                "source": "worldView.register(MockEntity, Circle, {radius: 0.5})\nworldView.onStart()\n\nconst entity = new MockEntity({$id: 'dispose-test'})\nmockWorld.addEntity(entity)\n\nexpect(worldView.rootGroup.children.length).toBe(1)\n\nmockWorld.removeEntity('dispose-test')\n\nexpect(worldView.getViews('dispose-test').length).toBe(0)"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/math/random.doc.js": {
    "file": "/math/random.test.js",
    "describes": [
      {
        "title": "Random",
        "line": 4,
        "beforeEach": {
          "line": 7,
          "source": "random = new Random('testSeed')"
        },
        "afterEach": null,
        "tests": [],
        "describes": [
          {
            "title": "constructor",
            "line": 12,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates instance with default seed",
                "line": 14,
                "source": "const randomWithDefaultSeed = new Random()\nexpect(randomWithDefaultSeed).toBeInstanceOf(Random)\nexpect(randomWithDefaultSeed.getSeed()).toBeDefined()"
              },
              {
                "title": "creates instance with custom seed",
                "line": 21,
                "source": "const randomWithCustomSeed = new Random('mySeed')\nexpect(randomWithCustomSeed).toBeInstanceOf(Random)\nexpect(randomWithCustomSeed.getSeed()).toEqual('mySeed')"
              }
            ],
            "describes": []
          },
          {
            "title": "determinism",
            "line": 30,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "same seed produces same sequence",
                "line": 32,
                "source": "const random1 = new Random('same-seed')\nconst random2 = new Random('same-seed')\n\nfor (let i = 0; i < 10; i++) {\n    expect(random1.between(0, 1)).toBe(random2.between(0, 1))\n}"
              },
              {
                "title": "different seeds produce different sequences",
                "line": 42,
                "source": "const random1 = new Random('seed-a')\nconst random2 = new Random('seed-b')\n\nconst sequence1 = Array.from({length: 5}, () => random1.between(0, 1))\nconst sequence2 = Array.from({length: 5}, () => random2.between(0, 1))\n\nexpect(sequence1).not.toEqual(sequence2)"
              },
              {
                "title": "returns numbers between 0 and 1",
                "line": 53,
                "source": "const testRandom = new Random('test')\nfor (let i = 0; i < 100; i++) {\n    const value = testRandom.between(0, 1)\n    expect(value).toBeGreaterThanOrEqual(0)\n    expect(value).toBeLessThan(1)\n}"
              }
            ],
            "describes": []
          },
          {
            "title": "setSeed & getSeed",
            "line": 65,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "gets and sets seed",
                "line": 67,
                "source": "expect(random.getSeed()).toEqual('testSeed')\n\nrandom.setSeed('newSeed')\nexpect(random.getSeed()).toEqual('newSeed')"
              },
              {
                "title": "setSeed resets the generator",
                "line": 75,
                "source": "const firstSequence = [\n    random.between(0, 1),\n    random.between(0, 1),\n    random.between(0, 1)\n]\n\nrandom.setSeed('testSeed')\n\nconst resetSequence = [\n    random.between(0, 1),\n    random.between(0, 1),\n    random.between(0, 1)\n]\n\nexpect(resetSequence).toEqual(firstSequence)"
              },
              {
                "title": "setSeed returns this for chaining",
                "line": 94,
                "source": "expect(random.setSeed('newSeed')).toBe(random)"
              }
            ],
            "describes": []
          },
          {
            "title": "setState & getState",
            "line": 101,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "getState returns current state with all properties",
                "line": 103,
                "source": "const state = random.getState()\n\nexpect(state).toHaveProperty('c')\nexpect(state).toHaveProperty('s0')\nexpect(state).toHaveProperty('s1')\nexpect(state).toHaveProperty('s2')"
              },
              {
                "title": "state changes after generating numbers",
                "line": 113,
                "source": "const initialState = random.getState()\n\nrandom.between(0, 10)\n\nconst newState = random.getState()\nexpect(newState).not.toEqual(initialState)"
              },
              {
                "title": "setState restores state",
                "line": 123,
                "source": "random.between(0, 1)\nrandom.between(0, 1)\nrandom.between(0, 1)\n\nconst savedState = random.getState()\n\nconst afterSave = [\n    random.between(0, 1),\n    random.between(0, 1),\n    random.between(0, 1)\n]\n\nrandom.setState(savedState)\n\nconst afterRestore = [\n    random.between(0, 1),\n    random.between(0, 1),\n    random.between(0, 1)\n]\n\nexpect(afterRestore).toEqual(afterSave)"
              },
              {
                "title": "setState returns this for chaining",
                "line": 148,
                "source": "const state = random.getState()\nexpect(random.setState(state)).toBe(random)"
              },
              {
                "title": "sequence reproduction with state",
                "line": 154,
                "source": "const initialState = random.getState()\n\nconst firstSequence = [\n    random.between(0, 100),\n    random.between(10, 50),\n    random.between(-10, 10)\n]\n\nrandom.setState(initialState)\n\nconst secondSequence = [\n    random.between(0, 100),\n    random.between(10, 50),\n    random.between(-10, 10)\n]\n\nexpect(secondSequence).toEqual(firstSequence)"
              }
            ],
            "describes": []
          },
          {
            "title": "fork",
            "line": 177,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates a new Random instance",
                "line": 179,
                "source": "const forkedRandom = random.fork()\nexpect(forkedRandom).toBeInstanceOf(Random)\nexpect(forkedRandom).not.toBe(random)"
              },
              {
                "title": "forked instance has same seed and state",
                "line": 186,
                "source": "random.between(0, 10)\n\nconst forkedRandom = random.fork()\nexpect(forkedRandom.getSeed()).toEqual(random.getSeed())\nexpect(forkedRandom.getState()).toEqual(random.getState())"
              },
              {
                "title": "forked instance produces same sequence",
                "line": 195,
                "source": "random.between(0, 10)\n\nconst forkedRandom = random.fork()\n\nconst originalSequence = [\n    random.between(0, 100),\n    random.between(0, 100),\n    random.between(0, 100)\n]\n\nrandom.setState(forkedRandom.getState())\n\nconst forkedSequence = [\n    forkedRandom.between(0, 100),\n    forkedRandom.between(0, 100),\n    forkedRandom.between(0, 100)\n]\n\nexpect(forkedSequence).toEqual(originalSequence)"
              },
              {
                "title": "forked instance diverges independently",
                "line": 218,
                "source": "random.between(0, 10)\n\nconst forkedRandom = random.fork()\n\nforkedRandom.between(0, 10)\nexpect(forkedRandom.getState()).not.toEqual(random.getState())"
              }
            ],
            "describes": []
          },
          {
            "title": "between",
            "line": 230,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns value in range",
                "line": 232,
                "source": "const value = random.between(0, 10)\nexpect(value).toBeGreaterThanOrEqual(0)\nexpect(value).toBeLessThan(10)"
              },
              {
                "title": "works with negative ranges",
                "line": 239,
                "source": "const negativeValue = random.between(-10, 0)\nexpect(negativeValue).toBeGreaterThanOrEqual(-10)\nexpect(negativeValue).toBeLessThan(0)"
              },
              {
                "title": "works with decimal ranges",
                "line": 246,
                "source": "const value = random.between(0.5, 1.5)\nexpect(value).toBeGreaterThanOrEqual(0.5)\nexpect(value).toBeLessThan(1.5)"
              }
            ],
            "describes": []
          },
          {
            "title": "intBetween",
            "line": 255,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns integer in range",
                "line": 257,
                "source": "const value = random.intBetween(0, 10)\nexpect(value).toBeGreaterThanOrEqual(0)\nexpect(value).toBeLessThan(10)\nexpect(Number.isInteger(value)).toBe(true)"
              },
              {
                "title": "returns integers for many iterations",
                "line": 265,
                "source": "for (let i = 0; i < 100; i++) {\n    const value = random.intBetween(0, 100)\n    expect(Number.isInteger(value)).toBe(true)\n}"
              }
            ],
            "describes": []
          },
          {
            "title": "pick",
            "line": 275,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns element from array",
                "line": 277,
                "source": "const array = [1, 2, 3, 4, 5]\nconst value = random.pick(array)\nexpect(array).toContain(value)"
              },
              {
                "title": "can pick all elements over many iterations",
                "line": 284,
                "source": "const array = ['a', 'b', 'c']\nconst picked = new Set()\n\nfor (let i = 0; i < 100; i++) {\n    picked.add(random.pick(array))\n}\n\nexpect(picked.size).toBe(3)"
              }
            ],
            "describes": []
          },
          {
            "title": "oneChanceIn",
            "line": 298,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns boolean",
                "line": 300,
                "source": "const result = random.oneChanceIn(2)\nexpect(typeof result).toBe('boolean')"
              },
              {
                "title": "higher chances produce fewer true results",
                "line": 306,
                "source": "const testRandom = new Random('oneChanceTest')\nlet trueCount2 = 0\nlet trueCount10 = 0\n\nfor (let i = 0; i < 1000; i++) {\n    if (testRandom.oneChanceIn(2)) {\n        trueCount2++\n    }\n    if (testRandom.oneChanceIn(10)) {\n        trueCount10++\n    }\n}\n\nexpect(trueCount2).toBeGreaterThan(trueCount10)"
              }
            ],
            "describes": []
          },
          {
            "title": "coinToss",
            "line": 326,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns boolean",
                "line": 328,
                "source": "const result = random.coinToss()\nexpect(typeof result).toBe('boolean')"
              },
              {
                "title": "produces roughly equal distribution",
                "line": 334,
                "source": "const testRandom = new Random('coinTossTest')\nlet trueCount = 0\n\nfor (let i = 0; i < 1000; i++) {\n    if (testRandom.coinToss()) {\n        trueCount++\n    }\n}\n\nexpect(trueCount).toBeGreaterThan(400)\nexpect(trueCount).toBeLessThan(600)"
              }
            ],
            "describes": []
          },
          {
            "title": "weightedChoice",
            "line": 351,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "respects weights distribution",
                "line": 353,
                "source": "const choices = [\n    {value: 'rare', weight: 1},\n    {value: 'common', weight: 99}\n]\n\nconst results = {rare: 0, common: 0}\nconst testRandom = new Random('weightedTestSeed')\n\nfor (let i = 0; i < 1000; i++) {\n    const result = testRandom.weightedChoice(choices)\n    results[result]++\n}\n\nexpect(results.common).toBeGreaterThan(results.rare)\nexpect(results.rare).toBeGreaterThan(0)"
              },
              {
                "title": "returns undefined for empty array",
                "line": 372,
                "source": "expect(random.weightedChoice([])).toBeUndefined()"
              },
              {
                "title": "returns undefined for undefined input",
                "line": 377,
                "source": "expect(random.weightedChoice()).toBeUndefined()"
              },
              {
                "title": "works with single choice",
                "line": 382,
                "source": "const choices = [{value: 'only', weight: 1}]\nexpect(random.weightedChoice(choices)).toBe('only')"
              }
            ],
            "describes": []
          },
          {
            "title": "generateSeed",
            "line": 390,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns string of default length 10",
                "line": 392,
                "source": "const seed = Random.generateSeed()\nexpect(typeof seed).toBe('string')\nexpect(seed.length).toBe(10)"
              },
              {
                "title": "respects custom length",
                "line": 399,
                "source": "const customLengthSeed = Random.generateSeed(15)\nexpect(customLengthSeed.length).toBe(15)"
              },
              {
                "title": "generates different seeds",
                "line": 405,
                "source": "const seed1 = Random.generateSeed()\nconst seed2 = Random.generateSeed()\nexpect(seed1).not.toEqual(seed2)"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/math/color.doc.js": {
    "file": "/math/color.test.js",
    "describes": [
      {
        "title": "Color",
        "line": 5,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "toString returns hex string",
            "line": 300,
            "source": "const color = new Color('#ff0000')\nexpect(color.toString()).toBe('#ff0000')"
          },
          {
            "title": "clone creates independent copy",
            "line": 306,
            "source": "const original = new Color('#ff0000')\noriginal.a = 0.5\nconst cloned = original.clone()\nexpect(cloned.r).toBe(original.r)\nexpect(cloned.g).toBe(original.g)\nexpect(cloned.b).toBe(original.b)\nexpect(cloned.a).toBe(original.a)\ncloned.r = 0\nexpect(original.r).toBeCloseTo(1, 5)"
          }
        ],
        "describes": [
          {
            "title": "constructor",
            "line": 7,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates color with default values",
                "line": 9,
                "source": "const color = new Color()\nexpect(color.r).toBe(0)\nexpect(color.g).toBe(0)\nexpect(color.b).toBe(0)\nexpect(color.a).toBe(1)"
              },
              {
                "title": "creates color from hex string",
                "line": 18,
                "source": "const color = new Color('#ff0000')\nexpect(color.r).toBeCloseTo(1, 5)\nexpect(color.g).toBe(0)\nexpect(color.b).toBe(0)"
              },
              {
                "title": "creates color from another Color instance",
                "line": 26,
                "source": "const original = new Color('#00ff00')\nconst copy = new Color(original)\nexpect(copy.r).toBe(original.r)\nexpect(copy.g).toBe(original.g)\nexpect(copy.b).toBe(original.b)\nexpect(copy.a).toBe(original.a)"
              }
            ],
            "describes": []
          },
          {
            "title": "set",
            "line": 38,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "sets from hex string with 6 characters",
                "line": 40,
                "source": "const color = new Color()\ncolor.set('#ff8800')\nexpect(color.r).toBeCloseTo(1, 5)\nexpect(color.g).toBeCloseTo(0.533, 2)\nexpect(color.b).toBe(0)"
              },
              {
                "title": "sets from hex string with 3 characters",
                "line": 49,
                "source": "const color = new Color()\ncolor.set('#f00')\nexpect(color.r).toBeCloseTo(1, 5)\nexpect(color.g).toBe(0)\nexpect(color.b).toBe(0)"
              },
              {
                "title": "sets from hex string with 8 characters (with alpha)",
                "line": 58,
                "source": "const color = new Color()\ncolor.set('#ff000080')\nexpect(color.r).toBeCloseTo(1, 5)\nexpect(color.a).toBeCloseTo(0.502, 2)"
              },
              {
                "title": "sets from hex string with 4 characters (with alpha)",
                "line": 66,
                "source": "const color = new Color()\ncolor.set('#f008')\nexpect(color.r).toBeCloseTo(1, 5)\nexpect(color.a).toBeCloseTo(0.533, 2)"
              },
              {
                "title": "sets from CSS color name",
                "line": 74,
                "source": "const color = new Color()\ncolor.set('red')\nexpect(color.r).toBeCloseTo(1, 5)\nexpect(color.g).toBe(0)\nexpect(color.b).toBe(0)"
              },
              {
                "title": "sets from rgb string",
                "line": 83,
                "source": "const color = new Color()\ncolor.set('rgb(255, 128, 0)')\nexpect(color.r).toBeCloseTo(1, 5)\nexpect(color.g).toBeCloseTo(0.502, 2)\nexpect(color.b).toBe(0)"
              },
              {
                "title": "sets from rgba string",
                "line": 92,
                "source": "const color = new Color()\ncolor.set('rgba(255, 0, 0, 0.5)')\nexpect(color.r).toBeCloseTo(1, 5)\nexpect(color.a).toBe(0.5)"
              },
              {
                "title": "sets from hsl string",
                "line": 100,
                "source": "const color = new Color()\ncolor.set('hsl(0, 100, 50)')\nexpect(color.r).toBeCloseTo(1, 5)\nexpect(color.g).toBeCloseTo(0, 1)\nexpect(color.b).toBeCloseTo(0, 1)"
              },
              {
                "title": "sets from hsla string",
                "line": 109,
                "source": "const color = new Color()\ncolor.set('hsla(0, 100, 50, 0.5)')\nexpect(color.r).toBeCloseTo(1, 5)\nexpect(color.a).toBe(0.5)"
              },
              {
                "title": "sets from number (RGB)",
                "line": 117,
                "source": "const color = new Color()\ncolor.set(0xff0000)\nexpect(color.r).toBeCloseTo(1, 5)\nexpect(color.g).toBe(0)\nexpect(color.b).toBe(0)\nexpect(color.a).toBe(1)"
              },
              {
                "title": "sets from number (RGBA)",
                "line": 127,
                "source": "const color = new Color()\ncolor.set(0xff000080)\nexpect(color.r).toBeCloseTo(1, 5)\nexpect(color.a).toBeCloseTo(0.502, 2)"
              },
              {
                "title": "sets from array",
                "line": 135,
                "source": "const color = new Color()\ncolor.set([1, 0.5, 0.25, 0.75])\nexpect(color.r).toBe(1)\nexpect(color.g).toBe(0.5)\nexpect(color.b).toBe(0.25)\nexpect(color.a).toBe(0.75)"
              },
              {
                "title": "sets from array with missing alpha",
                "line": 145,
                "source": "const color = new Color()\ncolor.set([1, 0.5, 0.25])\nexpect(color.a).toBe(1)"
              },
              {
                "title": "sets from RGB object",
                "line": 152,
                "source": "const color = new Color()\ncolor.set({r: 1, g: 0.5, b: 0.25})\nexpect(color.r).toBe(1)\nexpect(color.g).toBe(0.5)\nexpect(color.b).toBe(0.25)"
              },
              {
                "title": "sets from HSL object",
                "line": 161,
                "source": "const color = new Color()\ncolor.set({h: 0, s: 100, l: 50})\nexpect(color.r).toBeCloseTo(1, 5)\nexpect(color.g).toBeCloseTo(0, 1)\nexpect(color.b).toBeCloseTo(0, 1)"
              },
              {
                "title": "returns this for chaining",
                "line": 170,
                "source": "const color = new Color()\nconst result = color.set('#ff0000')\nexpect(result).toBe(color)"
              }
            ],
            "describes": []
          },
          {
            "title": "toHsl",
            "line": 179,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "converts red to HSL",
                "line": 181,
                "source": "const color = new Color('#ff0000')\nconst hsl = color.toHsl()\nexpect(hsl.h).toBe(0)\nexpect(hsl.s).toBe(100)\nexpect(hsl.l).toBe(50)"
              },
              {
                "title": "converts green to HSL",
                "line": 190,
                "source": "const color = new Color('#00ff00')\nconst hsl = color.toHsl()\nexpect(hsl.h).toBe(120)\nexpect(hsl.s).toBe(100)\nexpect(hsl.l).toBe(50)"
              },
              {
                "title": "converts blue to HSL",
                "line": 199,
                "source": "const color = new Color('#0000ff')\nconst hsl = color.toHsl()\nexpect(hsl.h).toBe(240)\nexpect(hsl.s).toBe(100)\nexpect(hsl.l).toBe(50)"
              },
              {
                "title": "converts gray to HSL",
                "line": 208,
                "source": "const color = new Color('#808080')\nconst hsl = color.toHsl()\nexpect(hsl.h).toBe(0)\nexpect(hsl.s).toBe(0)\nexpect(hsl.l).toBe(50)"
              },
              {
                "title": "includes alpha in HSL output",
                "line": 217,
                "source": "const color = new Color('#ff0000')\ncolor.a = 0.5\nconst hsl = color.toHsl()\nexpect(hsl.a).toBe(0.5)"
              }
            ],
            "describes": []
          },
          {
            "title": "toRgb",
            "line": 227,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns RGB values 0-255",
                "line": 229,
                "source": "const color = new Color('#ff8040')\nconst rgb = color.toRgb()\nexpect(rgb.r).toBe(255)\nexpect(rgb.g).toBe(128)\nexpect(rgb.b).toBe(64)"
              },
              {
                "title": "includes alpha",
                "line": 238,
                "source": "const color = new Color('#ff0000')\ncolor.a = 0.5\nconst rgb = color.toRgb()\nexpect(rgb.a).toBe(0.5)"
              }
            ],
            "describes": []
          },
          {
            "title": "toHex",
            "line": 248,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns hex string without alpha",
                "line": 250,
                "source": "const color = new Color([1, 0.5, 0])\nconst hex = color.toHex()\nexpect(hex).toBe('#ff8000')"
              },
              {
                "title": "returns hex string with alpha when requested",
                "line": 257,
                "source": "const color = new Color([1, 0, 0, 0.5])\nconst hex = color.toHex(true)\nexpect(hex).toBe('#ff000080')"
              }
            ],
            "describes": []
          },
          {
            "title": "toRgbString",
            "line": 266,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns rgb() format for opaque colors",
                "line": 268,
                "source": "const color = new Color('#ff8040')\nexpect(color.toRgbString()).toBe('rgb(255, 128, 64)')"
              },
              {
                "title": "returns rgba() format for transparent colors",
                "line": 274,
                "source": "const color = new Color('#ff8040')\ncolor.a = 0.5\nexpect(color.toRgbString()).toBe('rgba(255, 128, 64, 0.5)')"
              }
            ],
            "describes": []
          },
          {
            "title": "toHslString",
            "line": 283,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns hsl() format for opaque colors",
                "line": 285,
                "source": "const color = new Color('#ff0000')\nexpect(color.toHslString()).toBe('hsl(0, 100%, 50%)')"
              },
              {
                "title": "returns hsla() format for transparent colors",
                "line": 291,
                "source": "const color = new Color('#ff0000')\ncolor.a = 0.5\nexpect(color.toHslString()).toBe('hsla(0, 100%, 50%, 0.5)')"
              }
            ],
            "describes": []
          },
          {
            "title": "copy",
            "line": 319,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "copies values from another color",
                "line": 321,
                "source": "const source = new Color('#00ff00')\nsource.a = 0.5\nconst target = new Color('#ff0000')\ntarget.copy(source)\nexpect(target.r).toBe(source.r)\nexpect(target.g).toBe(source.g)\nexpect(target.b).toBe(source.b)\nexpect(target.a).toBe(source.a)"
              },
              {
                "title": "returns this for chaining",
                "line": 333,
                "source": "const source = new Color('#00ff00')\nconst target = new Color()\nexpect(target.copy(source)).toBe(target)"
              }
            ],
            "describes": []
          },
          {
            "title": "setAlpha",
            "line": 342,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "sets alpha value",
                "line": 344,
                "source": "const color = new Color('#ff0000')\ncolor.setAlpha(0.5)\nexpect(color.a).toBe(0.5)"
              },
              {
                "title": "returns this for chaining",
                "line": 351,
                "source": "const color = new Color()\nexpect(color.setAlpha(0.5)).toBe(color)"
              }
            ],
            "describes": []
          },
          {
            "title": "lighten",
            "line": 359,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "increases lightness",
                "line": 361,
                "source": "const color = new Color('#ff0000')\nconst originalL = color.toHsl().l\ncolor.lighten(20)\nexpect(color.toHsl().l).toBeGreaterThan(originalL)"
              },
              {
                "title": "caps at 100%",
                "line": 369,
                "source": "const color = new Color('#ffffff')\ncolor.lighten(50)\nexpect(color.toHsl().l).toBe(100)"
              },
              {
                "title": "returns this for chaining",
                "line": 376,
                "source": "const color = new Color('#ff0000')\nexpect(color.lighten(10)).toBe(color)"
              }
            ],
            "describes": []
          },
          {
            "title": "darken",
            "line": 384,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "decreases lightness",
                "line": 386,
                "source": "const color = new Color('#ff0000')\nconst originalL = color.toHsl().l\ncolor.darken(20)\nexpect(color.toHsl().l).toBeLessThan(originalL)"
              },
              {
                "title": "caps at 0%",
                "line": 394,
                "source": "const color = new Color('#000000')\ncolor.darken(50)\nexpect(color.toHsl().l).toBe(0)"
              },
              {
                "title": "returns this for chaining",
                "line": 401,
                "source": "const color = new Color('#ff0000')\nexpect(color.darken(10)).toBe(color)"
              }
            ],
            "describes": []
          },
          {
            "title": "saturate",
            "line": 409,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "increases saturation",
                "line": 411,
                "source": "const color = new Color({h: 0, s: 50, l: 50})\ncolor.saturate(20)\nexpect(color.toHsl().s).toBe(70)"
              },
              {
                "title": "caps at 100%",
                "line": 418,
                "source": "const color = new Color('#ff0000')\ncolor.saturate(50)\nexpect(color.toHsl().s).toBe(100)"
              },
              {
                "title": "returns this for chaining",
                "line": 425,
                "source": "const color = new Color('#ff0000')\nexpect(color.saturate(10)).toBe(color)"
              }
            ],
            "describes": []
          },
          {
            "title": "desaturate",
            "line": 433,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "decreases saturation",
                "line": 435,
                "source": "const color = new Color({h: 0, s: 50, l: 50})\ncolor.desaturate(20)\nexpect(color.toHsl().s).toBe(30)"
              },
              {
                "title": "caps at 0%",
                "line": 442,
                "source": "const color = new Color('#808080')\ncolor.desaturate(50)\nexpect(color.toHsl().s).toBe(0)"
              },
              {
                "title": "returns this for chaining",
                "line": 449,
                "source": "const color = new Color('#ff0000')\nexpect(color.desaturate(10)).toBe(color)"
              }
            ],
            "describes": []
          },
          {
            "title": "rotate",
            "line": 457,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "rotates hue by positive degrees",
                "line": 459,
                "source": "const color = new Color('#ff0000')\ncolor.rotate(120)\nexpect(color.toHsl().h).toBe(120)"
              },
              {
                "title": "rotates hue by negative degrees",
                "line": 466,
                "source": "const color = new Color('#ff0000')\ncolor.rotate(-60)\nexpect(color.toHsl().h).toBe(300)"
              },
              {
                "title": "wraps around 360",
                "line": 473,
                "source": "const color = new Color({h: 350, s: 100, l: 50})\ncolor.rotate(30)\nexpect(color.toHsl().h).toBe(20)"
              },
              {
                "title": "returns this for chaining",
                "line": 480,
                "source": "const color = new Color('#ff0000')\nexpect(color.rotate(90)).toBe(color)"
              }
            ],
            "describes": []
          },
          {
            "title": "mix",
            "line": 488,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "mixes two colors equally by default",
                "line": 490,
                "source": "const color = new Color('#ff0000')\ncolor.mix('#0000ff')\nexpect(color.r).toBeCloseTo(0.5, 1)\nexpect(color.b).toBeCloseTo(0.5, 1)"
              },
              {
                "title": "mixes with custom ratio",
                "line": 498,
                "source": "const color = new Color('#ff0000')\ncolor.mix('#0000ff', 0.25)\nexpect(color.r).toBeCloseTo(0.75, 1)\nexpect(color.b).toBeCloseTo(0.25, 1)"
              },
              {
                "title": "accepts Color instance",
                "line": 506,
                "source": "const color1 = new Color('#ff0000')\nconst color2 = new Color('#0000ff')\ncolor1.mix(color2, 0.5)\nexpect(color1.r).toBeCloseTo(0.5, 1)\nexpect(color1.b).toBeCloseTo(0.5, 1)"
              },
              {
                "title": "returns this for chaining",
                "line": 515,
                "source": "const color = new Color('#ff0000')\nexpect(color.mix('#0000ff')).toBe(color)"
              }
            ],
            "describes": []
          },
          {
            "title": "invert",
            "line": 523,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "inverts color",
                "line": 525,
                "source": "const color = new Color('#ff0000')\ncolor.invert()\nexpect(color.r).toBeCloseTo(0, 1)\nexpect(color.g).toBeCloseTo(1, 1)\nexpect(color.b).toBeCloseTo(1, 1)"
              },
              {
                "title": "returns this for chaining",
                "line": 534,
                "source": "const color = new Color('#ff0000')\nexpect(color.invert()).toBe(color)"
              }
            ],
            "describes": []
          },
          {
            "title": "grayscale",
            "line": 542,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "converts to grayscale using luminance weights",
                "line": 544,
                "source": "const color = new Color('#ff0000')\ncolor.grayscale()\nexpect(color.r).toBe(color.g)\nexpect(color.g).toBe(color.b)"
              },
              {
                "title": "returns this for chaining",
                "line": 552,
                "source": "const color = new Color('#ff0000')\nexpect(color.grayscale()).toBe(color)"
              }
            ],
            "describes": []
          },
          {
            "title": "equals",
            "line": 560,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns true for identical colors",
                "line": 562,
                "source": "const color1 = new Color('#ff0000')\nconst color2 = new Color('#ff0000')\nexpect(color1.equals(color2)).toBe(true)"
              },
              {
                "title": "returns false for different colors",
                "line": 569,
                "source": "const color1 = new Color('#ff0000')\nconst color2 = new Color('#00ff00')\nexpect(color1.equals(color2)).toBe(false)"
              },
              {
                "title": "compares with non-Color values",
                "line": 576,
                "source": "const color = new Color('#ff0000')\nexpect(color.equals('#ff0000')).toBe(true)\nexpect(color.equals('#00ff00')).toBe(false)"
              },
              {
                "title": "considers alpha in comparison",
                "line": 583,
                "source": "const color1 = new Color('#ff0000')\nconst color2 = new Color('#ff0000')\ncolor2.a = 0.5\nexpect(color1.equals(color2)).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "luminance",
            "line": 593,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns 0 for black",
                "line": 595,
                "source": "const color = new Color('#000000')\nexpect(color.luminance).toBe(0)"
              },
              {
                "title": "returns 1 for white",
                "line": 601,
                "source": "const color = new Color('#ffffff')\nexpect(color.luminance).toBeCloseTo(1, 2)"
              },
              {
                "title": "returns value between 0 and 1 for other colors",
                "line": 607,
                "source": "const color = new Color('#808080')\nexpect(color.luminance).toBeGreaterThan(0)\nexpect(color.luminance).toBeLessThan(1)"
              }
            ],
            "describes": []
          },
          {
            "title": "isDark",
            "line": 616,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns true for dark colors",
                "line": 618,
                "source": "const color = new Color('#000000')\nexpect(color.isDark).toBe(true)"
              },
              {
                "title": "returns false for light colors",
                "line": 624,
                "source": "const color = new Color('#ffffff')\nexpect(color.isDark).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "isLight",
            "line": 632,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns true for light colors",
                "line": 634,
                "source": "const color = new Color('#ffffff')\nexpect(color.isLight).toBe(true)"
              },
              {
                "title": "returns false for dark colors",
                "line": 640,
                "source": "const color = new Color('#000000')\nexpect(color.isLight).toBe(false)"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/math/easing.doc.js": {
    "file": "/math/easing.test.js",
    "describes": [
      {
        "title": "Easing",
        "line": 4,
        "beforeEach": null,
        "afterEach": null,
        "tests": [],
        "describes": [
          {
            "title": "linear",
            "line": 6,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns 0 at t=0",
                "line": 8,
                "source": "expect(Easing.linear(0)).toBe(0)"
              },
              {
                "title": "returns 1 at t=1",
                "line": 12,
                "source": "expect(Easing.linear(1)).toBe(1)"
              },
              {
                "title": "returns 0.5 at t=0.5",
                "line": 16,
                "source": "expect(Easing.linear(0.5)).toBe(0.5)"
              },
              {
                "title": "returns input unchanged",
                "line": 20,
                "source": "expect(Easing.linear(0.25)).toBe(0.25)\nexpect(Easing.linear(0.75)).toBe(0.75)"
              }
            ],
            "describes": []
          },
          {
            "title": "resolve",
            "line": 28,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns function as-is",
                "line": 30,
                "source": "const customFn = t => t * t\nexpect(Easing.resolve(customFn)).toBe(customFn)"
              },
              {
                "title": "returns easing function by name",
                "line": 35,
                "source": "expect(Easing.resolve('linear')).toBe(Easing.linear)\nexpect(Easing.resolve('easeInQuad')).toBe(Easing.easeInQuad)\nexpect(Easing.resolve('easeOutCubic')).toBe(Easing.easeOutCubic)"
              },
              {
                "title": "returns linear for unknown string",
                "line": 41,
                "source": "expect(Easing.resolve('unknownEasing')).toBe(Easing.linear)"
              },
              {
                "title": "returns linear for invalid input",
                "line": 45,
                "source": "expect(Easing.resolve(null)).toBe(Easing.linear)\nexpect(Easing.resolve(undefined)).toBe(Easing.linear)\nexpect(Easing.resolve(123)).toBe(Easing.linear)"
              }
            ],
            "describes": []
          },
          {
            "title": "lerp",
            "line": 54,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns start at t=0",
                "line": 56,
                "source": "expect(Easing.lerp(10, 20, 0)).toBe(10)"
              },
              {
                "title": "returns end at t=1",
                "line": 60,
                "source": "expect(Easing.lerp(10, 20, 1)).toBe(20)"
              },
              {
                "title": "returns midpoint at t=0.5 with linear",
                "line": 64,
                "source": "expect(Easing.lerp(0, 100, 0.5)).toBe(50)"
              },
              {
                "title": "interpolates correctly",
                "line": 68,
                "source": "expect(Easing.lerp(0, 100, 0.25)).toBe(25)\nexpect(Easing.lerp(0, 100, 0.75)).toBe(75)"
              },
              {
                "title": "works with negative values",
                "line": 73,
                "source": "expect(Easing.lerp(-100, 100, 0.5)).toBe(0)\nexpect(Easing.lerp(100, -100, 0.5)).toBe(0)"
              },
              {
                "title": "uses linear easing by default",
                "line": 78,
                "source": "expect(Easing.lerp(0, 100, 0.5)).toBe(50)"
              },
              {
                "title": "accepts easing function by name",
                "line": 82,
                "source": "const result = Easing.lerp(0, 100, 0.5, 'easeInQuad')\nexpect(result).toBe(25) // easeInQuad(0.5) = 0.25"
              },
              {
                "title": "accepts custom easing function",
                "line": 87,
                "source": "const customEase = t => t * t * t // cubic\nconst result = Easing.lerp(0, 100, 0.5, customEase)\nexpect(result).toBe(12.5) // 0.5^3 = 0.125"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/math/grid.doc.js": {
    "file": "/math/grid.test.js",
    "describes": [
      {
        "title": "Grid",
        "line": 4,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "constructor with dimensions",
            "line": 6,
            "source": "const grid = new Grid({width: 5, height: 3})\nexpect(grid.width).toBe(5)\nexpect(grid.height).toBe(3)"
          },
          {
            "title": "constructor without dimensions (infinite grid)",
            "line": 13,
            "source": "const grid = new Grid()\nexpect(grid.width).toBeNull()\nexpect(grid.height).toBeNull()"
          },
          {
            "title": "setCell and getCell",
            "line": 20,
            "source": "const grid = new Grid()\n\nexpect(grid.getCell({x: 0, y: 0})).toBeUndefined()\n\ngrid.setCell({x: 0, y: 0}, 'test')\nexpect(grid.getCell({x: 0, y: 0})).toBe('test')\n\ngrid.setCell({x: -5, y: 10}, 42)\nexpect(grid.getCell({x: -5, y: 10})).toBe(42)"
          },
          {
            "title": "setCell with undefined removes cell",
            "line": 33,
            "source": "const grid = new Grid()\n\ngrid.setCell({x: 0, y: 0}, 'test')\nexpect(grid.getCell({x: 0, y: 0})).toBe('test')\n\ngrid.setCell({x: 0, y: 0}, undefined)\nexpect(grid.getCell({x: 0, y: 0})).toBeUndefined()"
          },
          {
            "title": "isInside with finite grid",
            "line": 44,
            "source": "const grid = new Grid({width: 3, height: 3})\n\nexpect(grid.isInside({x: 0, y: 0})).toBe(true)\nexpect(grid.isInside({x: 2, y: 2})).toBe(true)\nexpect(grid.isInside({x: 1, y: 1})).toBe(true)\n\nexpect(grid.isInside({x: -1, y: 0})).toBe(false)\nexpect(grid.isInside({x: 0, y: -1})).toBe(false)\nexpect(grid.isInside({x: 3, y: 0})).toBe(false)\nexpect(grid.isInside({x: 0, y: 3})).toBe(false)"
          },
          {
            "title": "isInside with infinite grid",
            "line": 58,
            "source": "const grid = new Grid()\n\nexpect(grid.isInside({x: 0, y: 0})).toBe(true)\nexpect(grid.isInside({x: -1000, y: 1000})).toBe(true)\nexpect(grid.isInside({x: 999999, y: -999999})).toBe(true)"
          },
          {
            "title": "forEachCell with finite grid",
            "line": 67,
            "source": "const grid = new Grid({width: 2, height: 2})\ngrid.setCell({x: 0, y: 0}, 'a')\ngrid.setCell({x: 1, y: 1}, 'b')\n\nconst visited = []\ngrid.forEachCell((coords, value) => {\n    visited.push({coords, value})\n})\n\nexpect(visited).toHaveLength(4)\nexpect(visited[0]).toEqual({coords: {x: 0, y: 0}, value: 'a'})\nexpect(visited[1]).toEqual({coords: {x: 1, y: 0}, value: undefined})\nexpect(visited[2]).toEqual({coords: {x: 0, y: 1}, value: undefined})\nexpect(visited[3]).toEqual({coords: {x: 1, y: 1}, value: 'b'})"
          },
          {
            "title": "forEachCell with infinite grid throws error",
            "line": 85,
            "source": "const grid = new Grid()\nconst callback = () => {}\nexpect(() => {\n    grid.forEachCell(callback)\n}).toThrow('Cannot iterate over infinite grid')"
          },
          {
            "title": "forEachDefinedCell",
            "line": 94,
            "source": "const grid = new Grid()\ngrid.setCell({x: 0, y: 0}, 'a')\ngrid.setCell({x: 5, y: -3}, 'b')\ngrid.setCell({x: -1, y: 2}, 'c')\n\nconst visited = []\ngrid.forEachDefinedCell((coords, value) => {\n    visited.push({coords, value})\n})\n\nexpect(visited).toHaveLength(3)\nexpect(visited.find(v => v.value === 'a')).toBeDefined()\nexpect(visited.find(v => v.value === 'b')).toBeDefined()\nexpect(visited.find(v => v.value === 'c')).toBeDefined()"
          },
          {
            "title": "neighbourOf",
            "line": 112,
            "source": "const grid = new Grid()\ngrid.setCell({x: 6, y: 3}, 'test1')\ngrid.setCell({x: 4, y: 4}, 'test2')\n\nconst coords = {x: 5, y: 3}\n\nexpect(grid.neighbourOf(coords, {x: 1, y: 0})).toEqual({x: 6, y: 3, cell: 'test1'})\nexpect(grid.neighbourOf(coords, {x: -1, y: 1})).toEqual({x: 4, y: 4, cell: 'test2'})\nexpect(grid.neighbourOf(coords, {x: 0, y: -2})).toEqual({x: 5, y: 1, cell: undefined})"
          },
          {
            "title": "fourNeighboursOf",
            "line": 125,
            "source": "const grid = new Grid()\ngrid.setCell({x: 2, y: 4}, 'up')\ngrid.setCell({x: 3, y: 3}, 'right')\n\nconst neighbours = grid.fourNeighboursOf({x: 2, y: 3})\n\nexpect(neighbours).toHaveLength(4)\nexpect(neighbours).toContainEqual({x: 2, y: 4, cell: 'up'})\nexpect(neighbours).toContainEqual({x: 3, y: 3, cell: 'right'})\nexpect(neighbours).toContainEqual({x: 2, y: 2, cell: undefined})\nexpect(neighbours).toContainEqual({x: 1, y: 3, cell: undefined})"
          },
          {
            "title": "eightNeighboursOf",
            "line": 140,
            "source": "const grid = new Grid()\ngrid.setCell({x: 2, y: 4}, 'up')\ngrid.setCell({x: 3, y: 4}, 'upRight')\ngrid.setCell({x: 1, y: 2}, 'downLeft')\n\nconst neighbours = grid.eightNeighboursOf({x: 2, y: 3})\n\nexpect(neighbours).toHaveLength(8)\nexpect(neighbours).toContainEqual({x: 2, y: 4, cell: 'up'})\nexpect(neighbours).toContainEqual({x: 3, y: 4, cell: 'upRight'})\nexpect(neighbours).toContainEqual({x: 3, y: 3, cell: undefined})\nexpect(neighbours).toContainEqual({x: 3, y: 2, cell: undefined})\nexpect(neighbours).toContainEqual({x: 2, y: 2, cell: undefined})\nexpect(neighbours).toContainEqual({x: 1, y: 2, cell: 'downLeft'})\nexpect(neighbours).toContainEqual({x: 1, y: 3, cell: undefined})\nexpect(neighbours).toContainEqual({x: 1, y: 4, cell: undefined})"
          },
          {
            "title": "getCol with finite grid",
            "line": 160,
            "source": "const grid = new Grid({width: 3, height: 3})\ngrid.setCell({x: 1, y: 0}, 'a')\ngrid.setCell({x: 1, y: 1}, 'b')\ngrid.setCell({x: 1, y: 2}, 'c')\n\nconst col = grid.getCol(1)\nexpect(col).toEqual(['a', 'b', 'c'])\n\nconst emptyCol = grid.getCol(0)\nexpect(emptyCol).toEqual([undefined, undefined, undefined])"
          },
          {
            "title": "getCol with infinite grid throws error",
            "line": 174,
            "source": "const grid = new Grid()\n\nexpect(() => {\n    grid.getCol(0)\n}).toThrow('Cannot get column from infinite grid')"
          },
          {
            "title": "getRow with finite grid",
            "line": 183,
            "source": "const grid = new Grid({width: 3, height: 3})\ngrid.setCell({x: 0, y: 1}, 'a')\ngrid.setCell({x: 1, y: 1}, 'b')\ngrid.setCell({x: 2, y: 1}, 'c')\n\nconst row = grid.getRow(1)\nexpect(row).toEqual(['a', 'b', 'c'])\n\nconst emptyRow = grid.getRow(0)\nexpect(emptyRow).toEqual([undefined, undefined, undefined])"
          },
          {
            "title": "getRow with infinite grid throws error",
            "line": 197,
            "source": "const grid = new Grid()\n\nexpect(() => {\n    grid.getRow(0)\n}).toThrow('Cannot get row from infinite grid')"
          },
          {
            "title": "clear",
            "line": 206,
            "source": "const grid = new Grid()\ngrid.setCell({x: 0, y: 0}, 'a')\ngrid.setCell({x: 1, y: 1}, 'b')\n\nexpect(grid.getCell({x: 0, y: 0})).toBe('a')\n\ngrid.clear()\n\nexpect(grid.getCell({x: 0, y: 0})).toBeUndefined()\nexpect(grid.getCell({x: 1, y: 1})).toBeUndefined()"
          },
          {
            "title": "clone",
            "line": 220,
            "source": "const grid = new Grid({width: 3, height: 3})\ngrid.setCell({x: 0, y: 0}, 'a')\ngrid.setCell({x: 1, y: 1}, 'b')\n\nconst cloned = grid.clone()\n\nexpect(cloned).not.toBe(grid)\nexpect(cloned.width).toBe(3)\nexpect(cloned.height).toBe(3)\nexpect(cloned.getCell({x: 0, y: 0})).toBe('a')\nexpect(cloned.getCell({x: 1, y: 1})).toBe('b')\n\ncloned.setCell({x: 0, y: 0}, 'modified')\nexpect(grid.getCell({x: 0, y: 0})).toBe('a')"
          },
          {
            "title": "getBounds with empty grid",
            "line": 238,
            "source": "const grid = new Grid()\nexpect(grid.getBounds()).toBeNull()"
          },
          {
            "title": "getBounds with cells",
            "line": 244,
            "source": "const grid = new Grid()\ngrid.setCell({x: -2, y: 3}, 'a')\ngrid.setCell({x: 5, y: -1}, 'b')\ngrid.setCell({x: 0, y: 0}, 'c')\n\nconst bounds = grid.getBounds()\nexpect(bounds).toEqual({\n    minX: -2,\n    maxX: 5,\n    minY: -1,\n    maxY: 3,\n    width: 8,\n    height: 5\n})"
          },
          {
            "title": "fourDirections constant",
            "line": 262,
            "source": "expect(fourDirections.up).toEqual({x: 0, y: 1})\nexpect(fourDirections.right).toEqual({x: 1, y: 0})\nexpect(fourDirections.down).toEqual({x: 0, y: -1})\nexpect(fourDirections.left).toEqual({x: -1, y: 0})"
          },
          {
            "title": "eightDirections constant",
            "line": 270,
            "source": "expect(eightDirections.up).toEqual({x: 0, y: 1})\nexpect(eightDirections.upRight).toEqual({x: 1, y: 1})\nexpect(eightDirections.right).toEqual({x: 1, y: 0})\nexpect(eightDirections.downRight).toEqual({x: 1, y: -1})\nexpect(eightDirections.down).toEqual({x: 0, y: -1})\nexpect(eightDirections.downLeft).toEqual({x: -1, y: -1})\nexpect(eightDirections.left).toEqual({x: -1, y: 0})\nexpect(eightDirections.upLeft).toEqual({x: -1, y: 1})"
          },
          {
            "title": "export returns grid data",
            "line": 282,
            "source": "const grid = new Grid({width: 3, height: 2})\ngrid.setCell({x: 0, y: 0}, 'a')\ngrid.setCell({x: 2, y: 1}, {value: 42})\n\nconst exported = grid.export()\n\nexpect(exported.width).toBe(3)\nexpect(exported.height).toBe(2)\nexpect(exported.cells['0,0']).toBe('a')\nexpect(exported.cells['2,1']).toEqual({value: 42})"
          },
          {
            "title": "export with objects that have export method",
            "line": 296,
            "source": "const grid = new Grid({width: 2, height: 2})\ngrid.setCell({x: 0, y: 0}, {\n    value: 10,\n    export: () => ({exported: true, value: 10})\n})\n\nconst exported = grid.export()\n\nexpect(exported.cells['0,0']).toEqual({exported: true, value: 10})"
          }
        ],
        "describes": []
      }
    ]
  },
  "/math/noise.doc.js": {
    "file": "/math/noise.test.js",
    "describes": [
      {
        "title": "Noise",
        "line": 4,
        "beforeEach": {
          "line": 7,
          "source": "noise = new Noise(12345)"
        },
        "afterEach": null,
        "tests": [],
        "describes": [
          {
            "title": "constructor",
            "line": 12,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates instance with default seed",
                "line": 14,
                "source": "const defaultNoise = new Noise()\nexpect(defaultNoise).toBeInstanceOf(Noise)"
              },
              {
                "title": "creates instance with custom seed",
                "line": 20,
                "source": "const customNoise = new Noise(42)\nexpect(customNoise).toBeInstanceOf(Noise)"
              }
            ],
            "describes": []
          },
          {
            "title": "seed",
            "line": 28,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns this for chaining",
                "line": 30,
                "source": "expect(noise.seed(999)).toBe(noise)"
              },
              {
                "title": "resets generator with new seed",
                "line": 35,
                "source": "const value1 = noise.perlin(1, 2, 3)\nnoise.seed(12345)\nconst value2 = noise.perlin(1, 2, 3)\nexpect(value1).toBe(value2)"
              },
              {
                "title": "different seeds produce different values",
                "line": 43,
                "source": "const noise1 = new Noise(111)\nconst noise2 = new Noise(222)\nexpect(noise1.perlin(1.7, 2.3, 3.9)).not.toBe(noise2.perlin(1.7, 2.3, 3.9))"
              }
            ],
            "describes": []
          },
          {
            "title": "perlin",
            "line": 52,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns value between -1 and 1",
                "line": 54,
                "source": "for (let i = 0; i < 100; i++) {\n    const value = noise.perlin(i * 0.1, i * 0.2, i * 0.3)\n    expect(value).toBeGreaterThanOrEqual(-1)\n    expect(value).toBeLessThanOrEqual(1)\n}"
              },
              {
                "title": "deterministic for same inputs",
                "line": 63,
                "source": "const value1 = noise.perlin(1.5, 2.5, 3.5)\nconst value2 = noise.perlin(1.5, 2.5, 3.5)\nexpect(value1).toBe(value2)"
              },
              {
                "title": "varies smoothly between adjacent points",
                "line": 70,
                "source": "const value1 = noise.perlin(1.0, 1.0, 1.0)\nconst value2 = noise.perlin(1.01, 1.0, 1.0)\nexpect(Math.abs(value1 - value2)).toBeLessThan(0.1)"
              },
              {
                "title": "works with default y and z parameters",
                "line": 77,
                "source": "const value = noise.perlin(5)\nexpect(typeof value).toBe('number')\nexpect(value).not.toBeNaN()"
              }
            ],
            "describes": []
          },
          {
            "title": "perlin2d",
            "line": 86,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns same value as perlin with z=0",
                "line": 88,
                "source": "const value2d = noise.perlin2d(1.5, 2.5)\nconst value3d = noise.perlin(1.5, 2.5, 0)\nexpect(value2d).toBe(value3d)"
              },
              {
                "title": "returns value between -1 and 1",
                "line": 95,
                "source": "for (let i = 0; i < 100; i++) {\n    const value = noise.perlin2d(i * 0.1, i * 0.2)\n    expect(value).toBeGreaterThanOrEqual(-1)\n    expect(value).toBeLessThanOrEqual(1)\n}"
              }
            ],
            "describes": []
          },
          {
            "title": "fbm",
            "line": 106,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns value between -1 and 1",
                "line": 108,
                "source": "for (let i = 0; i < 50; i++) {\n    const value = noise.fbm(i * 0.1, i * 0.2)\n    expect(value).toBeGreaterThanOrEqual(-1)\n    expect(value).toBeLessThanOrEqual(1)\n}"
              },
              {
                "title": "uses default options",
                "line": 117,
                "source": "const value = noise.fbm(1, 2)\nexpect(typeof value).toBe('number')\nexpect(value).not.toBeNaN()"
              },
              {
                "title": "respects octaves parameter",
                "line": 124,
                "source": "const value1 = noise.fbm(1.5, 2.7, {octaves: 1})\nconst value2 = noise.fbm(1.5, 2.7, {octaves: 8})\nexpect(value1).not.toBe(value2)"
              },
              {
                "title": "respects lacunarity parameter",
                "line": 131,
                "source": "const value1 = noise.fbm(1, 2, {lacunarity: 1.5})\nconst value2 = noise.fbm(1, 2, {lacunarity: 3})\nexpect(value1).not.toBe(value2)"
              },
              {
                "title": "respects persistence parameter",
                "line": 138,
                "source": "const value1 = noise.fbm(1.5, 2.7, {persistence: 0.3})\nconst value2 = noise.fbm(1.5, 2.7, {persistence: 0.7})\nexpect(value1).not.toBe(value2)"
              },
              {
                "title": "deterministic for same inputs",
                "line": 145,
                "source": "const value1 = noise.fbm(5, 10, {octaves: 4, lacunarity: 2, persistence: 0.5})\nconst value2 = noise.fbm(5, 10, {octaves: 4, lacunarity: 2, persistence: 0.5})\nexpect(value1).toBe(value2)"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/math/pathfinder.doc.js": {
    "file": "/math/pathfinder.test.js",
    "describes": [
      {
        "title": "Pathfinder",
        "line": 5,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "constructor with default options",
            "line": 7,
            "source": "const pathfinder = new Pathfinder()\n\nexpect(pathfinder.heuristic).toBe(heuristics.manhattan)\nexpect(pathfinder.allowDiagonal).toBe(false)\nexpect(pathfinder.isWalkable()).toBe(true)"
          },
          {
            "title": "constructor with custom options",
            "line": 16,
            "source": "const customHeuristic = heuristics.euclidean\nconst customWalkable = (cell) => cell !== 'wall'\n\nconst pathfinder = new Pathfinder({\n    heuristic: customHeuristic,\n    allowDiagonal: true,\n    isWalkable: customWalkable\n})\n\nexpect(pathfinder.heuristic).toBe(customHeuristic)\nexpect(pathfinder.allowDiagonal).toBe(true)\nexpect(pathfinder.isWalkable).toBe(customWalkable)"
          },
          {
            "title": "findPath simple case",
            "line": 32,
            "source": "const grid = new Grid({width: 5, height: 5})\nconst pathfinder = new Pathfinder()\n\nconst path = pathfinder.findPath(grid, {x: 0, y: 0}, {x: 2, y: 0})\n\nexpect(path).toEqual([\n    {x: 0, y: 0},\n    {x: 1, y: 0},\n    {x: 2, y: 0}\n])"
          },
          {
            "title": "findPath with obstacles",
            "line": 46,
            "source": "const grid = new Grid({width: 5, height: 3})\ngrid.setCell({x: 1, y: 0}, 'wall')\ngrid.setCell({x: 1, y: 1}, 'wall')\n\nconst pathfinder = new Pathfinder({\n    isWalkable: (cell) => cell !== 'wall'\n})\n\nconst path = pathfinder.findPath(grid, {x: 0, y: 0}, {x: 2, y: 0})\n\nexpect(path).toEqual([\n    {x: 0, y: 0},\n    {x: 0, y: 1},\n    {x: 0, y: 2},\n    {x: 1, y: 2},\n    {x: 2, y: 2},\n    {x: 2, y: 1},\n    {x: 2, y: 0}\n])"
          },
          {
            "title": "findPath with diagonal movement",
            "line": 69,
            "source": "const grid = new Grid({width: 3, height: 3})\nconst pathfinder = new Pathfinder({allowDiagonal: true})\n\nconst path = pathfinder.findPath(grid, {x: 0, y: 0}, {x: 2, y: 2})\n\nexpect(path).toEqual([\n    {x: 0, y: 0},\n    {x: 1, y: 1},\n    {x: 2, y: 2}\n])"
          },
          {
            "title": "findPath no solution",
            "line": 83,
            "source": "const grid = new Grid({width: 3, height: 3})\ngrid.setCell({x: 1, y: 0}, 'wall')\ngrid.setCell({x: 1, y: 1}, 'wall')\ngrid.setCell({x: 1, y: 2}, 'wall')\n\nconst pathfinder = new Pathfinder({\n    isWalkable: (cell) => cell !== 'wall'\n})\n\nconst path = pathfinder.findPath(grid, {x: 0, y: 0}, {x: 2, y: 0})\n\nexpect(path).toBeNull()"
          },
          {
            "title": "findPath invalid start position",
            "line": 99,
            "source": "const grid = new Grid({width: 3, height: 3})\nconst pathfinder = new Pathfinder()\n\nconst path = pathfinder.findPath(grid, {x: -1, y: 0}, {x: 2, y: 0})\n\nexpect(path).toBeNull()"
          },
          {
            "title": "findPath invalid goal position",
            "line": 109,
            "source": "const grid = new Grid({width: 3, height: 3})\nconst pathfinder = new Pathfinder()\n\nconst path = pathfinder.findPath(grid, {x: 0, y: 0}, {x: 5, y: 0})\n\nexpect(path).toBeNull()"
          },
          {
            "title": "findPath start is not walkable",
            "line": 119,
            "source": "const grid = new Grid({width: 3, height: 3})\ngrid.setCell({x: 0, y: 0}, 'wall')\n\nconst pathfinder = new Pathfinder({\n    isWalkable: (cell) => cell !== 'wall'\n})\n\nconst path = pathfinder.findPath(grid, {x: 0, y: 0}, {x: 2, y: 0})\n\nexpect(path).toBeNull()"
          },
          {
            "title": "findPath goal is not walkable",
            "line": 133,
            "source": "const grid = new Grid({width: 3, height: 3})\ngrid.setCell({x: 2, y: 0}, 'wall')\n\nconst pathfinder = new Pathfinder({\n    isWalkable: (cell) => cell !== 'wall'\n})\n\nconst path = pathfinder.findPath(grid, {x: 0, y: 0}, {x: 2, y: 0})\n\nexpect(path).toBeNull()"
          },
          {
            "title": "findPath same start and goal",
            "line": 147,
            "source": "const grid = new Grid({width: 3, height: 3})\nconst pathfinder = new Pathfinder()\n\nconst path = pathfinder.findPath(grid, {x: 1, y: 1}, {x: 1, y: 1})\n\nexpect(path).toEqual([{x: 1, y: 1}])"
          },
          {
            "title": "setHeuristic",
            "line": 157,
            "source": "const pathfinder = new Pathfinder()\n\npathfinder.setHeuristic(heuristics.euclidean)\n\nexpect(pathfinder.heuristic).toBe(heuristics.euclidean)"
          },
          {
            "title": "setAllowDiagonal",
            "line": 166,
            "source": "const pathfinder = new Pathfinder()\n\npathfinder.setAllowDiagonal(true)\n\nexpect(pathfinder.allowDiagonal).toBe(true)"
          },
          {
            "title": "setWalkableFunction",
            "line": 175,
            "source": "const pathfinder = new Pathfinder()\nconst newWalkable = (cell) => cell === 'floor'\n\npathfinder.setWalkableFunction(newWalkable)\n\nexpect(pathfinder.isWalkable).toBe(newWalkable)"
          },
          {
            "title": "manhattan heuristic",
            "line": 185,
            "source": "const distance = heuristics.manhattan({x: 0, y: 0}, {x: 3, y: 4})\nexpect(distance).toBe(7)"
          },
          {
            "title": "euclidean heuristic",
            "line": 191,
            "source": "const distance = heuristics.euclidean({x: 0, y: 0}, {x: 3, y: 4})\nexpect(distance).toBe(5)"
          },
          {
            "title": "diagonal heuristic",
            "line": 197,
            "source": "const distance = heuristics.diagonal({x: 0, y: 0}, {x: 3, y: 4})\nexpect(distance).toBe(4)"
          },
          {
            "title": "complex maze pathfinding",
            "line": 203,
            "source": "const grid = new Grid({width: 5, height: 5})\n\n// Create a maze pattern\n// . # . . .\n// . # . # .\n// . . . # .\n// # # . # .\n// . . . . .\n\ngrid.setCell({x: 1, y: 0}, 'wall')\ngrid.setCell({x: 1, y: 1}, 'wall')\ngrid.setCell({x: 3, y: 1}, 'wall')\ngrid.setCell({x: 3, y: 2}, 'wall')\ngrid.setCell({x: 0, y: 3}, 'wall')\ngrid.setCell({x: 1, y: 3}, 'wall')\ngrid.setCell({x: 3, y: 3}, 'wall')\n\nconst pathfinder = new Pathfinder({\n    isWalkable: (cell) => cell !== 'wall'\n})\n\nconst path = pathfinder.findPath(grid, {x: 0, y: 0}, {x: 4, y: 0})\n\nexpect(path).not.toBeNull()\nexpect(path[0]).toEqual({x: 0, y: 0})\nexpect(path[path.length - 1]).toEqual({x: 4, y: 0})\nexpect(path.length).toBeGreaterThan(4)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/math/vec2.doc.js": {
    "file": "/math/vec2.test.js",
    "describes": [
      {
        "title": "Vec2",
        "line": 4,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "isVector2",
            "line": 571,
            "source": "const vec = new Vec2()\nexpect(vec.isVector2).toBe(true)"
          }
        ],
        "describes": [
          {
            "title": "constructor",
            "line": 6,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "with x and y",
                "line": 8,
                "source": "const vec = new Vec2(1, 2)\nexpect(vec.x).toBe(1)\nexpect(vec.y).toBe(2)"
              },
              {
                "title": "with object",
                "line": 14,
                "source": "const vec = new Vec2({x: 3, y: 4})\nexpect(vec.x).toBe(3)\nexpect(vec.y).toBe(4)"
              },
              {
                "title": "with array",
                "line": 20,
                "source": "const vec = new Vec2([7, 8])\nexpect(vec.x).toBe(7)\nexpect(vec.y).toBe(8)"
              },
              {
                "title": "with no parameters",
                "line": 26,
                "source": "const vec = new Vec2()\nexpect(vec.x).toBe(0)\nexpect(vec.y).toBe(0)"
              },
              {
                "title": "with only x",
                "line": 32,
                "source": "const vec = new Vec2(5)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(0)"
              }
            ],
            "describes": []
          },
          {
            "title": "setters",
            "line": 41,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "set",
                "line": 43,
                "source": "const vec = new Vec2()\nexpect(vec.set(3, 4)).toBe(vec)\nexpect(vec.x).toBe(3)\nexpect(vec.y).toBe(4)"
              },
              {
                "title": "setX",
                "line": 50,
                "source": "const vec = new Vec2(1, 2)\nexpect(vec.setX(5)).toBe(vec)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(2)"
              },
              {
                "title": "setY",
                "line": 57,
                "source": "const vec = new Vec2(1, 2)\nexpect(vec.setY(6)).toBe(vec)\nexpect(vec.x).toBe(1)\nexpect(vec.y).toBe(6)"
              },
              {
                "title": "setScalar",
                "line": 64,
                "source": "const vec = new Vec2()\nexpect(vec.setScalar(7)).toBe(vec)\nexpect(vec.x).toBe(7)\nexpect(vec.y).toBe(7)"
              },
              {
                "title": "setComponent",
                "line": 71,
                "source": "const vec = new Vec2(1, 2)\nexpect(vec.setComponent(0, 10)).toBe(vec)\nexpect(vec.x).toBe(10)\nexpect(vec.setComponent(1, 20)).toBe(vec)\nexpect(vec.y).toBe(20)"
              },
              {
                "title": "setComponent throws on invalid index",
                "line": 79,
                "source": "const vec = new Vec2()\nexpect(() => {\n    vec.setComponent(2, 5)\n}).toThrow('index out of range: 2')"
              }
            ],
            "describes": []
          },
          {
            "title": "copy and clone",
            "line": 89,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "copy",
                "line": 91,
                "source": "const vec1 = new Vec2(1, 2)\nconst vec2 = new Vec2(3, 4)\nexpect(vec1.copy(vec2)).toBe(vec1)\nexpect(vec1.x).toBe(3)\nexpect(vec1.y).toBe(4)"
              },
              {
                "title": "clone",
                "line": 99,
                "source": "const vec1 = new Vec2(5, 6)\nconst vec2 = vec1.clone()\nexpect(vec2).not.toBe(vec1)\nexpect(vec2.x).toBe(5)\nexpect(vec2.y).toBe(6)"
              }
            ],
            "describes": []
          },
          {
            "title": "addition",
            "line": 110,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "add",
                "line": 112,
                "source": "const vec = new Vec2(1, 2)\nexpect(vec.add(new Vec2(3, 4))).toBe(vec)\nexpect(vec.x).toBe(4)\nexpect(vec.y).toBe(6)"
              },
              {
                "title": "addScalar",
                "line": 119,
                "source": "const vec = new Vec2(1, 2)\nexpect(vec.addScalar(5)).toBe(vec)\nexpect(vec.x).toBe(6)\nexpect(vec.y).toBe(7)"
              },
              {
                "title": "addVectors",
                "line": 126,
                "source": "const vec = new Vec2()\nexpect(vec.addVectors(new Vec2(1, 2), new Vec2(3, 4))).toBe(vec)\nexpect(vec.x).toBe(4)\nexpect(vec.y).toBe(6)"
              },
              {
                "title": "addScaledVector",
                "line": 133,
                "source": "const vec = new Vec2(1, 2)\nexpect(vec.addScaledVector(new Vec2(2, 3), 2)).toBe(vec)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(8)"
              }
            ],
            "describes": []
          },
          {
            "title": "subtraction",
            "line": 143,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "sub",
                "line": 145,
                "source": "const vec = new Vec2(5, 7)\nexpect(vec.sub(new Vec2(2, 3))).toBe(vec)\nexpect(vec.x).toBe(3)\nexpect(vec.y).toBe(4)"
              },
              {
                "title": "subScalar",
                "line": 152,
                "source": "const vec = new Vec2(10, 20)\nexpect(vec.subScalar(5)).toBe(vec)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(15)"
              },
              {
                "title": "subVectors",
                "line": 159,
                "source": "const vec = new Vec2()\nexpect(vec.subVectors(new Vec2(8, 10), new Vec2(3, 4))).toBe(vec)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(6)"
              }
            ],
            "describes": []
          },
          {
            "title": "multiplication",
            "line": 169,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "multiply",
                "line": 171,
                "source": "const vec = new Vec2(2, 3)\nexpect(vec.multiply(new Vec2(4, 5))).toBe(vec)\nexpect(vec.x).toBe(8)\nexpect(vec.y).toBe(15)"
              },
              {
                "title": "multiplyScalar",
                "line": 178,
                "source": "const vec = new Vec2(3, 4)\nexpect(vec.multiplyScalar(2)).toBe(vec)\nexpect(vec.x).toBe(6)\nexpect(vec.y).toBe(8)"
              }
            ],
            "describes": []
          },
          {
            "title": "division",
            "line": 188,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "divide",
                "line": 190,
                "source": "const vec = new Vec2(12, 20)\nexpect(vec.divide(new Vec2(3, 4))).toBe(vec)\nexpect(vec.x).toBe(4)\nexpect(vec.y).toBe(5)"
              },
              {
                "title": "divideScalar",
                "line": 197,
                "source": "const vec = new Vec2(10, 20)\nexpect(vec.divideScalar(2)).toBe(vec)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(10)"
              }
            ],
            "describes": []
          },
          {
            "title": "vector operations",
            "line": 207,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "dot",
                "line": 209,
                "source": "const vec1 = new Vec2(2, 3)\nconst vec2 = new Vec2(4, 5)\nexpect(vec1.dot(vec2)).toBe(23)"
              },
              {
                "title": "cross",
                "line": 215,
                "source": "const vec1 = new Vec2(2, 3)\nconst vec2 = new Vec2(4, 5)\nexpect(vec1.cross(vec2)).toBe(-2)"
              },
              {
                "title": "lengthSq",
                "line": 221,
                "source": "const vec = new Vec2(3, 4)\nexpect(vec.lengthSq()).toBe(25)"
              },
              {
                "title": "length",
                "line": 226,
                "source": "const vec = new Vec2(3, 4)\nexpect(vec.length()).toBe(5)"
              },
              {
                "title": "manhattanLength",
                "line": 231,
                "source": "const vec = new Vec2(3, -4)\nexpect(vec.manhattanLength()).toBe(7)"
              },
              {
                "title": "normalize",
                "line": 236,
                "source": "const vec = new Vec2(3, 4)\nexpect(vec.normalize()).toBe(vec)\nexpect(vec.x).toBeCloseTo(0.6)\nexpect(vec.y).toBeCloseTo(0.8)\nexpect(vec.length()).toBeCloseTo(1)"
              },
              {
                "title": "normalize zero vector",
                "line": 244,
                "source": "const vec = new Vec2(0, 0)\nexpect(vec.normalize()).toBe(vec)\nexpect(vec.x).toBe(0)\nexpect(vec.y).toBe(0)"
              },
              {
                "title": "setLength",
                "line": 251,
                "source": "const vec = new Vec2(3, 4)\nexpect(vec.setLength(10)).toBe(vec)\nexpect(vec.length()).toBeCloseTo(10)\nexpect(vec.x).toBeCloseTo(6)\nexpect(vec.y).toBeCloseTo(8)"
              }
            ],
            "describes": []
          },
          {
            "title": "angles",
            "line": 262,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "angle",
                "line": 264,
                "source": "const vec = new Vec2(1, 0)\nexpect(vec.angle()).toBeCloseTo(0)\nconst vec2 = new Vec2(0, 1)\nexpect(vec2.angle()).toBeCloseTo(Math.PI / 2)"
              },
              {
                "title": "angleTo",
                "line": 271,
                "source": "const vec1 = new Vec2(1, 0)\nconst vec2 = new Vec2(0, 1)\nexpect(vec1.angleTo(vec2)).toBeCloseTo(Math.PI / 2)"
              },
              {
                "title": "angleTo parallel vectors",
                "line": 277,
                "source": "const vec1 = new Vec2(1, 0)\nconst vec2 = new Vec2(2, 0)\nexpect(vec1.angleTo(vec2)).toBeCloseTo(0)"
              }
            ],
            "describes": []
          },
          {
            "title": "distance",
            "line": 286,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "distanceTo",
                "line": 288,
                "source": "const vec1 = new Vec2(1, 2)\nconst vec2 = new Vec2(4, 6)\nexpect(vec1.distanceTo(vec2)).toBe(5)"
              },
              {
                "title": "distanceToSquared",
                "line": 294,
                "source": "const vec1 = new Vec2(1, 2)\nconst vec2 = new Vec2(4, 6)\nexpect(vec1.distanceToSquared(vec2)).toBe(25)"
              },
              {
                "title": "manhattanDistanceTo",
                "line": 300,
                "source": "const vec1 = new Vec2(1, 2)\nconst vec2 = new Vec2(4, 6)\nexpect(vec1.manhattanDistanceTo(vec2)).toBe(7)"
              }
            ],
            "describes": []
          },
          {
            "title": "interpolation",
            "line": 309,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "lerp",
                "line": 311,
                "source": "const vec = new Vec2(0, 0)\nexpect(vec.lerp(new Vec2(10, 20), 0.5)).toBe(vec)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(10)"
              },
              {
                "title": "lerp at 0",
                "line": 318,
                "source": "const vec = new Vec2(1, 2)\nvec.lerp(new Vec2(10, 20), 0)\nexpect(vec.x).toBe(1)\nexpect(vec.y).toBe(2)"
              },
              {
                "title": "lerp at 1",
                "line": 325,
                "source": "const vec = new Vec2(1, 2)\nvec.lerp(new Vec2(10, 20), 1)\nexpect(vec.x).toBe(10)\nexpect(vec.y).toBe(20)"
              },
              {
                "title": "lerpVectors",
                "line": 332,
                "source": "const vec = new Vec2()\nexpect(vec.lerpVectors(new Vec2(0, 0), new Vec2(10, 20), 0.5)).toBe(vec)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(10)"
              }
            ],
            "describes": []
          },
          {
            "title": "comparison",
            "line": 342,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "equals with Vec2",
                "line": 344,
                "source": "const vec1 = new Vec2(1, 2)\nconst vec2 = new Vec2(1, 2)\nconst vec3 = new Vec2(3, 4)\nexpect(vec1.equals(vec2)).toBe(true)\nexpect(vec1.equals(vec3)).toBe(false)"
              },
              {
                "title": "equals with object",
                "line": 352,
                "source": "const vec1 = new Vec2(1, 2)\nconst vec4 = {x: 1, y: 2, z: 0}\nexpect(vec1.equals(vec4)).toBe(true)"
              }
            ],
            "describes": []
          },
          {
            "title": "array conversion",
            "line": 361,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "fromArray",
                "line": 363,
                "source": "const vec = new Vec2()\nexpect(vec.fromArray([5, 6])).toBe(vec)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(6)"
              },
              {
                "title": "fromArray with offset",
                "line": 370,
                "source": "const vec = new Vec2()\nvec.fromArray([1, 2, 3, 4], 2)\nexpect(vec.x).toBe(3)\nexpect(vec.y).toBe(4)"
              },
              {
                "title": "toArray",
                "line": 377,
                "source": "const vec = new Vec2(7, 8)\nconst arr = vec.toArray()\nexpect(arr).toEqual([7, 8])"
              },
              {
                "title": "toArray with existing array",
                "line": 383,
                "source": "const vec = new Vec2(9, 10)\nconst arr = [1, 2, 3, 4]\nexpect(vec.toArray(arr, 2)).toBe(arr)\nexpect(arr).toEqual([1, 2, 9, 10])"
              }
            ],
            "describes": []
          },
          {
            "title": "negation and min/max",
            "line": 393,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "negate",
                "line": 395,
                "source": "const vec = new Vec2(3, -4)\nexpect(vec.negate()).toBe(vec)\nexpect(vec.x).toBe(-3)\nexpect(vec.y).toBe(4)"
              },
              {
                "title": "min",
                "line": 402,
                "source": "const vec = new Vec2(5, 2)\nexpect(vec.min(new Vec2(3, 4))).toBe(vec)\nexpect(vec.x).toBe(3)\nexpect(vec.y).toBe(2)"
              },
              {
                "title": "max",
                "line": 409,
                "source": "const vec = new Vec2(5, 2)\nexpect(vec.max(new Vec2(3, 4))).toBe(vec)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(4)"
              }
            ],
            "describes": []
          },
          {
            "title": "clamping",
            "line": 419,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "clamp",
                "line": 421,
                "source": "const vec = new Vec2(15, -5)\nexpect(vec.clamp(new Vec2(0, 0), new Vec2(10, 10))).toBe(vec)\nexpect(vec.x).toBe(10)\nexpect(vec.y).toBe(0)"
              },
              {
                "title": "clampScalar",
                "line": 428,
                "source": "const vec = new Vec2(15, -5)\nexpect(vec.clampScalar(0, 10)).toBe(vec)\nexpect(vec.x).toBe(10)\nexpect(vec.y).toBe(0)"
              },
              {
                "title": "clampLength min",
                "line": 435,
                "source": "const vec = new Vec2(1, 0)\nvec.clampLength(5, 10)\nexpect(vec.length()).toBeCloseTo(5)"
              },
              {
                "title": "clampLength max",
                "line": 441,
                "source": "const vec = new Vec2(20, 0)\nvec.clampLength(5, 10)\nexpect(vec.length()).toBeCloseTo(10)"
              },
              {
                "title": "clampLength in range",
                "line": 447,
                "source": "const vec = new Vec2(7, 0)\nvec.clampLength(5, 10)\nexpect(vec.length()).toBeCloseTo(7)"
              }
            ],
            "describes": []
          },
          {
            "title": "rounding",
            "line": 456,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "floor",
                "line": 458,
                "source": "const vec = new Vec2(1.7, 2.3)\nexpect(vec.floor()).toBe(vec)\nexpect(vec.x).toBe(1)\nexpect(vec.y).toBe(2)"
              },
              {
                "title": "ceil",
                "line": 465,
                "source": "const vec = new Vec2(1.3, 2.7)\nexpect(vec.ceil()).toBe(vec)\nexpect(vec.x).toBe(2)\nexpect(vec.y).toBe(3)"
              },
              {
                "title": "round",
                "line": 472,
                "source": "const vec = new Vec2(1.4, 2.6)\nexpect(vec.round()).toBe(vec)\nexpect(vec.x).toBe(1)\nexpect(vec.y).toBe(3)"
              },
              {
                "title": "roundToZero positive",
                "line": 479,
                "source": "const vec = new Vec2(1.9, 2.9)\nexpect(vec.roundToZero()).toBe(vec)\nexpect(vec.x).toBe(1)\nexpect(vec.y).toBe(2)"
              },
              {
                "title": "roundToZero negative",
                "line": 486,
                "source": "const vec = new Vec2(-1.9, -2.9)\nvec.roundToZero()\nexpect(vec.x).toBe(-1)\nexpect(vec.y).toBe(-2)"
              }
            ],
            "describes": []
          },
          {
            "title": "rotation",
            "line": 496,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "rotateAround",
                "line": 498,
                "source": "const vec = new Vec2(1, 0)\nconst center = new Vec2(0, 0)\nexpect(vec.rotateAround(center, Math.PI / 2)).toBe(vec)\nexpect(vec.x).toBeCloseTo(0)\nexpect(vec.y).toBeCloseTo(1)"
              },
              {
                "title": "rotateAround with offset center",
                "line": 506,
                "source": "const vec = new Vec2(2, 1)\nconst center = new Vec2(1, 1)\nvec.rotateAround(center, Math.PI / 2)\nexpect(vec.x).toBeCloseTo(1)\nexpect(vec.y).toBeCloseTo(2)"
              }
            ],
            "describes": []
          },
          {
            "title": "random and component access",
            "line": 517,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "random",
                "line": 519,
                "source": "const vec = new Vec2()\nexpect(vec.random()).toBe(vec)\nexpect(vec.x).toBeGreaterThanOrEqual(0)\nexpect(vec.x).toBeLessThan(1)\nexpect(vec.y).toBeGreaterThanOrEqual(0)\nexpect(vec.y).toBeLessThan(1)"
              },
              {
                "title": "getComponent",
                "line": 528,
                "source": "const vec = new Vec2(5, 7)\nexpect(vec.getComponent(0)).toBe(5)\nexpect(vec.getComponent(1)).toBe(7)"
              },
              {
                "title": "getComponent throws on invalid index",
                "line": 534,
                "source": "const vec = new Vec2()\nexpect(() => {\n    vec.getComponent(2)\n}).toThrow('index out of range: 2')"
              }
            ],
            "describes": []
          },
          {
            "title": "aliases",
            "line": 544,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "width getter",
                "line": 546,
                "source": "const vec = new Vec2(10, 20)\nexpect(vec.width).toBe(10)"
              },
              {
                "title": "width setter",
                "line": 551,
                "source": "const vec = new Vec2()\nvec.width = 15\nexpect(vec.x).toBe(15)"
              },
              {
                "title": "height getter",
                "line": 557,
                "source": "const vec = new Vec2(10, 20)\nexpect(vec.height).toBe(20)"
              },
              {
                "title": "height setter",
                "line": 562,
                "source": "const vec = new Vec2()\nvec.height = 25\nexpect(vec.y).toBe(25)"
              }
            ],
            "describes": []
          },
          {
            "title": "iteration",
            "line": 577,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "iterator",
                "line": 579,
                "source": "const vec = new Vec2(3, 4)\nconst [x, y] = vec\nexpect(x).toBe(3)\nexpect(y).toBe(4)"
              },
              {
                "title": "spread operator",
                "line": 586,
                "source": "const vec = new Vec2(5, 6)\nconst arr = [...vec]\nexpect(arr).toEqual([5, 6])"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/math/vec3.doc.js": {
    "file": "/math/vec3.test.js",
    "describes": [
      {
        "title": "Vec3",
        "line": 4,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "reflect",
            "line": 635,
            "source": "const vec = new Vec3(1, -1, 0)\nconst normal = new Vec3(0, 1, 0)\nexpect(vec.reflect(normal)).toBe(vec)\nexpect(vec.x).toBeCloseTo(1)\nexpect(vec.y).toBeCloseTo(1)\nexpect(vec.z).toBeCloseTo(0)"
          },
          {
            "title": "applyAxisAngle",
            "line": 645,
            "source": "const vec = new Vec3(1, 0, 0)\nconst axis = new Vec3(0, 0, 1)\nexpect(vec.applyAxisAngle(axis, Math.PI / 2)).toBe(vec)\nexpect(vec.x).toBeCloseTo(0)\nexpect(vec.y).toBeCloseTo(1)\nexpect(vec.z).toBeCloseTo(0)"
          },
          {
            "title": "isVector3",
            "line": 655,
            "source": "const vec = new Vec3()\nexpect(vec.isVector3).toBe(true)"
          }
        ],
        "describes": [
          {
            "title": "constructor",
            "line": 6,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "with x, y and z",
                "line": 8,
                "source": "const vec = new Vec3(1, 2, 3)\nexpect(vec.x).toBe(1)\nexpect(vec.y).toBe(2)\nexpect(vec.z).toBe(3)"
              },
              {
                "title": "with object",
                "line": 15,
                "source": "const vec = new Vec3({x: 3, y: 4, z: 5})\nexpect(vec.x).toBe(3)\nexpect(vec.y).toBe(4)\nexpect(vec.z).toBe(5)"
              },
              {
                "title": "with array",
                "line": 22,
                "source": "const vec = new Vec3([7, 8, 9])\nexpect(vec.x).toBe(7)\nexpect(vec.y).toBe(8)\nexpect(vec.z).toBe(9)"
              },
              {
                "title": "with no parameters",
                "line": 29,
                "source": "const vec = new Vec3()\nexpect(vec.x).toBe(0)\nexpect(vec.y).toBe(0)\nexpect(vec.z).toBe(0)"
              },
              {
                "title": "with only x",
                "line": 36,
                "source": "const vec = new Vec3(5)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(0)\nexpect(vec.z).toBe(0)"
              },
              {
                "title": "with x and y",
                "line": 43,
                "source": "const vec = new Vec3(5, 6)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(6)\nexpect(vec.z).toBe(0)"
              }
            ],
            "describes": []
          },
          {
            "title": "setters",
            "line": 53,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "set",
                "line": 55,
                "source": "const vec = new Vec3()\nexpect(vec.set(3, 4, 5)).toBe(vec)\nexpect(vec.x).toBe(3)\nexpect(vec.y).toBe(4)\nexpect(vec.z).toBe(5)"
              },
              {
                "title": "setX",
                "line": 63,
                "source": "const vec = new Vec3(1, 2, 3)\nexpect(vec.setX(5)).toBe(vec)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(2)\nexpect(vec.z).toBe(3)"
              },
              {
                "title": "setY",
                "line": 71,
                "source": "const vec = new Vec3(1, 2, 3)\nexpect(vec.setY(6)).toBe(vec)\nexpect(vec.x).toBe(1)\nexpect(vec.y).toBe(6)\nexpect(vec.z).toBe(3)"
              },
              {
                "title": "setZ",
                "line": 79,
                "source": "const vec = new Vec3(1, 2, 3)\nexpect(vec.setZ(7)).toBe(vec)\nexpect(vec.x).toBe(1)\nexpect(vec.y).toBe(2)\nexpect(vec.z).toBe(7)"
              },
              {
                "title": "setScalar",
                "line": 87,
                "source": "const vec = new Vec3()\nexpect(vec.setScalar(7)).toBe(vec)\nexpect(vec.x).toBe(7)\nexpect(vec.y).toBe(7)\nexpect(vec.z).toBe(7)"
              },
              {
                "title": "setComponent",
                "line": 95,
                "source": "const vec = new Vec3(1, 2, 3)\nexpect(vec.setComponent(0, 10)).toBe(vec)\nexpect(vec.x).toBe(10)\nexpect(vec.setComponent(1, 20)).toBe(vec)\nexpect(vec.y).toBe(20)\nexpect(vec.setComponent(2, 30)).toBe(vec)\nexpect(vec.z).toBe(30)"
              },
              {
                "title": "setComponent throws on invalid index",
                "line": 105,
                "source": "const vec = new Vec3()\nexpect(() => {\n    vec.setComponent(3, 5)\n}).toThrow('index out of range: 3')"
              }
            ],
            "describes": []
          },
          {
            "title": "copy and clone",
            "line": 115,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "copy",
                "line": 117,
                "source": "const vec1 = new Vec3(1, 2, 3)\nconst vec2 = new Vec3(4, 5, 6)\nexpect(vec1.copy(vec2)).toBe(vec1)\nexpect(vec1.x).toBe(4)\nexpect(vec1.y).toBe(5)\nexpect(vec1.z).toBe(6)"
              },
              {
                "title": "clone",
                "line": 126,
                "source": "const vec1 = new Vec3(5, 6, 7)\nconst vec2 = vec1.clone()\nexpect(vec2).not.toBe(vec1)\nexpect(vec2.x).toBe(5)\nexpect(vec2.y).toBe(6)\nexpect(vec2.z).toBe(7)"
              }
            ],
            "describes": []
          },
          {
            "title": "addition",
            "line": 138,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "add",
                "line": 140,
                "source": "const vec = new Vec3(1, 2, 3)\nexpect(vec.add(new Vec3(4, 5, 6))).toBe(vec)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(7)\nexpect(vec.z).toBe(9)"
              },
              {
                "title": "addScalar",
                "line": 148,
                "source": "const vec = new Vec3(1, 2, 3)\nexpect(vec.addScalar(5)).toBe(vec)\nexpect(vec.x).toBe(6)\nexpect(vec.y).toBe(7)\nexpect(vec.z).toBe(8)"
              },
              {
                "title": "addVectors",
                "line": 156,
                "source": "const vec = new Vec3()\nexpect(vec.addVectors(new Vec3(1, 2, 3), new Vec3(4, 5, 6))).toBe(vec)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(7)\nexpect(vec.z).toBe(9)"
              },
              {
                "title": "addScaledVector",
                "line": 164,
                "source": "const vec = new Vec3(1, 2, 3)\nexpect(vec.addScaledVector(new Vec3(2, 3, 4), 2)).toBe(vec)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(8)\nexpect(vec.z).toBe(11)"
              }
            ],
            "describes": []
          },
          {
            "title": "subtraction",
            "line": 175,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "sub",
                "line": 177,
                "source": "const vec = new Vec3(5, 7, 9)\nexpect(vec.sub(new Vec3(2, 3, 4))).toBe(vec)\nexpect(vec.x).toBe(3)\nexpect(vec.y).toBe(4)\nexpect(vec.z).toBe(5)"
              },
              {
                "title": "subScalar",
                "line": 185,
                "source": "const vec = new Vec3(10, 20, 30)\nexpect(vec.subScalar(5)).toBe(vec)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(15)\nexpect(vec.z).toBe(25)"
              },
              {
                "title": "subVectors",
                "line": 193,
                "source": "const vec = new Vec3()\nexpect(vec.subVectors(new Vec3(8, 10, 12), new Vec3(3, 4, 5))).toBe(vec)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(6)\nexpect(vec.z).toBe(7)"
              }
            ],
            "describes": []
          },
          {
            "title": "multiplication",
            "line": 204,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "multiply",
                "line": 206,
                "source": "const vec = new Vec3(2, 3, 4)\nexpect(vec.multiply(new Vec3(4, 5, 6))).toBe(vec)\nexpect(vec.x).toBe(8)\nexpect(vec.y).toBe(15)\nexpect(vec.z).toBe(24)"
              },
              {
                "title": "multiplyScalar",
                "line": 214,
                "source": "const vec = new Vec3(3, 4, 5)\nexpect(vec.multiplyScalar(2)).toBe(vec)\nexpect(vec.x).toBe(6)\nexpect(vec.y).toBe(8)\nexpect(vec.z).toBe(10)"
              },
              {
                "title": "multiplyVectors",
                "line": 222,
                "source": "const vec = new Vec3()\nexpect(vec.multiplyVectors(new Vec3(2, 3, 4), new Vec3(5, 6, 7))).toBe(vec)\nexpect(vec.x).toBe(10)\nexpect(vec.y).toBe(18)\nexpect(vec.z).toBe(28)"
              }
            ],
            "describes": []
          },
          {
            "title": "division",
            "line": 233,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "divide",
                "line": 235,
                "source": "const vec = new Vec3(12, 20, 30)\nexpect(vec.divide(new Vec3(3, 4, 5))).toBe(vec)\nexpect(vec.x).toBe(4)\nexpect(vec.y).toBe(5)\nexpect(vec.z).toBe(6)"
              },
              {
                "title": "divideScalar",
                "line": 243,
                "source": "const vec = new Vec3(10, 20, 30)\nexpect(vec.divideScalar(2)).toBe(vec)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(10)\nexpect(vec.z).toBe(15)"
              }
            ],
            "describes": []
          },
          {
            "title": "vector operations",
            "line": 254,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "dot",
                "line": 256,
                "source": "const vec1 = new Vec3(2, 3, 4)\nconst vec2 = new Vec3(5, 6, 7)\nexpect(vec1.dot(vec2)).toBe(56)"
              },
              {
                "title": "cross",
                "line": 262,
                "source": "const vec = new Vec3(1, 0, 0)\nexpect(vec.cross(new Vec3(0, 1, 0))).toBe(vec)\nexpect(vec.x).toBe(0)\nexpect(vec.y).toBe(0)\nexpect(vec.z).toBe(1)"
              },
              {
                "title": "crossVectors",
                "line": 270,
                "source": "const vec = new Vec3()\nexpect(vec.crossVectors(new Vec3(1, 0, 0), new Vec3(0, 1, 0))).toBe(vec)\nexpect(vec.x).toBe(0)\nexpect(vec.y).toBe(0)\nexpect(vec.z).toBe(1)"
              },
              {
                "title": "lengthSq",
                "line": 278,
                "source": "const vec = new Vec3(2, 3, 6)\nexpect(vec.lengthSq()).toBe(49)"
              },
              {
                "title": "length",
                "line": 283,
                "source": "const vec = new Vec3(2, 3, 6)\nexpect(vec.length()).toBe(7)"
              },
              {
                "title": "manhattanLength",
                "line": 288,
                "source": "const vec = new Vec3(3, -4, 5)\nexpect(vec.manhattanLength()).toBe(12)"
              },
              {
                "title": "normalize",
                "line": 293,
                "source": "const vec = new Vec3(0, 0, 5)\nexpect(vec.normalize()).toBe(vec)\nexpect(vec.x).toBeCloseTo(0)\nexpect(vec.y).toBeCloseTo(0)\nexpect(vec.z).toBeCloseTo(1)\nexpect(vec.length()).toBeCloseTo(1)"
              },
              {
                "title": "normalize zero vector",
                "line": 302,
                "source": "const vec = new Vec3(0, 0, 0)\nexpect(vec.normalize()).toBe(vec)\nexpect(vec.x).toBe(0)\nexpect(vec.y).toBe(0)\nexpect(vec.z).toBe(0)"
              },
              {
                "title": "setLength",
                "line": 310,
                "source": "const vec = new Vec3(0, 0, 5)\nexpect(vec.setLength(10)).toBe(vec)\nexpect(vec.length()).toBeCloseTo(10)\nexpect(vec.x).toBeCloseTo(0)\nexpect(vec.y).toBeCloseTo(0)\nexpect(vec.z).toBeCloseTo(10)"
              }
            ],
            "describes": []
          },
          {
            "title": "angles",
            "line": 322,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "angleTo",
                "line": 324,
                "source": "const vec1 = new Vec3(1, 0, 0)\nconst vec2 = new Vec3(0, 1, 0)\nexpect(vec1.angleTo(vec2)).toBeCloseTo(Math.PI / 2)"
              },
              {
                "title": "angleTo parallel vectors",
                "line": 330,
                "source": "const vec1 = new Vec3(1, 0, 0)\nconst vec2 = new Vec3(2, 0, 0)\nexpect(vec1.angleTo(vec2)).toBeCloseTo(0)"
              },
              {
                "title": "angleTo opposite vectors",
                "line": 336,
                "source": "const vec1 = new Vec3(1, 0, 0)\nconst vec2 = new Vec3(-1, 0, 0)\nexpect(vec1.angleTo(vec2)).toBeCloseTo(Math.PI)"
              }
            ],
            "describes": []
          },
          {
            "title": "distance",
            "line": 345,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "distanceTo",
                "line": 347,
                "source": "const vec1 = new Vec3(1, 2, 3)\nconst vec2 = new Vec3(4, 6, 3)\nexpect(vec1.distanceTo(vec2)).toBe(5)"
              },
              {
                "title": "distanceToSquared",
                "line": 353,
                "source": "const vec1 = new Vec3(1, 2, 3)\nconst vec2 = new Vec3(4, 6, 3)\nexpect(vec1.distanceToSquared(vec2)).toBe(25)"
              },
              {
                "title": "manhattanDistanceTo",
                "line": 359,
                "source": "const vec1 = new Vec3(1, 2, 3)\nconst vec2 = new Vec3(4, 6, 8)\nexpect(vec1.manhattanDistanceTo(vec2)).toBe(12)"
              }
            ],
            "describes": []
          },
          {
            "title": "interpolation",
            "line": 368,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "lerp",
                "line": 370,
                "source": "const vec = new Vec3(0, 0, 0)\nexpect(vec.lerp(new Vec3(10, 20, 30), 0.5)).toBe(vec)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(10)\nexpect(vec.z).toBe(15)"
              },
              {
                "title": "lerp at 0",
                "line": 378,
                "source": "const vec = new Vec3(1, 2, 3)\nvec.lerp(new Vec3(10, 20, 30), 0)\nexpect(vec.x).toBe(1)\nexpect(vec.y).toBe(2)\nexpect(vec.z).toBe(3)"
              },
              {
                "title": "lerp at 1",
                "line": 386,
                "source": "const vec = new Vec3(1, 2, 3)\nvec.lerp(new Vec3(10, 20, 30), 1)\nexpect(vec.x).toBe(10)\nexpect(vec.y).toBe(20)\nexpect(vec.z).toBe(30)"
              },
              {
                "title": "lerpVectors",
                "line": 394,
                "source": "const vec = new Vec3()\nexpect(vec.lerpVectors(new Vec3(0, 0, 0), new Vec3(10, 20, 30), 0.5)).toBe(vec)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(10)\nexpect(vec.z).toBe(15)"
              }
            ],
            "describes": []
          },
          {
            "title": "comparison",
            "line": 405,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "equals with Vec3",
                "line": 407,
                "source": "const vec1 = new Vec3(1, 2, 3)\nconst vec2 = new Vec3(1, 2, 3)\nconst vec3 = new Vec3(4, 5, 6)\nexpect(vec1.equals(vec2)).toBe(true)\nexpect(vec1.equals(vec3)).toBe(false)"
              },
              {
                "title": "equals with object",
                "line": 415,
                "source": "const vec1 = new Vec3(1, 2, 3)\nconst vec4 = {x: 1, y: 2, z: 3}\nexpect(vec1.equals(vec4)).toBe(true)"
              }
            ],
            "describes": []
          },
          {
            "title": "array conversion",
            "line": 424,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "fromArray",
                "line": 426,
                "source": "const vec = new Vec3()\nexpect(vec.fromArray([5, 6, 7])).toBe(vec)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(6)\nexpect(vec.z).toBe(7)"
              },
              {
                "title": "fromArray with offset",
                "line": 434,
                "source": "const vec = new Vec3()\nvec.fromArray([1, 2, 3, 4, 5], 2)\nexpect(vec.x).toBe(3)\nexpect(vec.y).toBe(4)\nexpect(vec.z).toBe(5)"
              },
              {
                "title": "toArray",
                "line": 442,
                "source": "const vec = new Vec3(7, 8, 9)\nconst arr = vec.toArray()\nexpect(arr).toEqual([7, 8, 9])"
              },
              {
                "title": "toArray with existing array",
                "line": 448,
                "source": "const vec = new Vec3(9, 10, 11)\nconst arr = [1, 2, 3, 4, 5]\nexpect(vec.toArray(arr, 2)).toBe(arr)\nexpect(arr).toEqual([1, 2, 9, 10, 11])"
              }
            ],
            "describes": []
          },
          {
            "title": "negation and min/max",
            "line": 458,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "negate",
                "line": 460,
                "source": "const vec = new Vec3(3, -4, 5)\nexpect(vec.negate()).toBe(vec)\nexpect(vec.x).toBe(-3)\nexpect(vec.y).toBe(4)\nexpect(vec.z).toBe(-5)"
              },
              {
                "title": "min",
                "line": 468,
                "source": "const vec = new Vec3(5, 2, 7)\nexpect(vec.min(new Vec3(3, 4, 6))).toBe(vec)\nexpect(vec.x).toBe(3)\nexpect(vec.y).toBe(2)\nexpect(vec.z).toBe(6)"
              },
              {
                "title": "max",
                "line": 476,
                "source": "const vec = new Vec3(5, 2, 7)\nexpect(vec.max(new Vec3(3, 4, 6))).toBe(vec)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(4)\nexpect(vec.z).toBe(7)"
              }
            ],
            "describes": []
          },
          {
            "title": "clamping",
            "line": 487,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "clamp",
                "line": 489,
                "source": "const vec = new Vec3(15, -5, 25)\nexpect(vec.clamp(new Vec3(0, 0, 0), new Vec3(10, 10, 10))).toBe(vec)\nexpect(vec.x).toBe(10)\nexpect(vec.y).toBe(0)\nexpect(vec.z).toBe(10)"
              },
              {
                "title": "clampScalar",
                "line": 497,
                "source": "const vec = new Vec3(15, -5, 7)\nexpect(vec.clampScalar(0, 10)).toBe(vec)\nexpect(vec.x).toBe(10)\nexpect(vec.y).toBe(0)\nexpect(vec.z).toBe(7)"
              },
              {
                "title": "clampLength min",
                "line": 505,
                "source": "const vec = new Vec3(1, 0, 0)\nvec.clampLength(5, 10)\nexpect(vec.length()).toBeCloseTo(5)"
              },
              {
                "title": "clampLength max",
                "line": 511,
                "source": "const vec = new Vec3(20, 0, 0)\nvec.clampLength(5, 10)\nexpect(vec.length()).toBeCloseTo(10)"
              },
              {
                "title": "clampLength in range",
                "line": 517,
                "source": "const vec = new Vec3(7, 0, 0)\nvec.clampLength(5, 10)\nexpect(vec.length()).toBeCloseTo(7)"
              }
            ],
            "describes": []
          },
          {
            "title": "rounding",
            "line": 526,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "floor",
                "line": 528,
                "source": "const vec = new Vec3(1.7, 2.3, 3.9)\nexpect(vec.floor()).toBe(vec)\nexpect(vec.x).toBe(1)\nexpect(vec.y).toBe(2)\nexpect(vec.z).toBe(3)"
              },
              {
                "title": "ceil",
                "line": 536,
                "source": "const vec = new Vec3(1.3, 2.7, 3.1)\nexpect(vec.ceil()).toBe(vec)\nexpect(vec.x).toBe(2)\nexpect(vec.y).toBe(3)\nexpect(vec.z).toBe(4)"
              },
              {
                "title": "round",
                "line": 544,
                "source": "const vec = new Vec3(1.4, 2.6, 3.5)\nexpect(vec.round()).toBe(vec)\nexpect(vec.x).toBe(1)\nexpect(vec.y).toBe(3)\nexpect(vec.z).toBe(4)"
              },
              {
                "title": "roundToZero positive",
                "line": 552,
                "source": "const vec = new Vec3(1.9, 2.9, 3.9)\nexpect(vec.roundToZero()).toBe(vec)\nexpect(vec.x).toBe(1)\nexpect(vec.y).toBe(2)\nexpect(vec.z).toBe(3)"
              },
              {
                "title": "roundToZero negative",
                "line": 560,
                "source": "const vec = new Vec3(-1.9, -2.9, -3.9)\nvec.roundToZero()\nexpect(vec.x).toBe(-1)\nexpect(vec.y).toBe(-2)\nexpect(vec.z).toBe(-3)"
              }
            ],
            "describes": []
          },
          {
            "title": "random",
            "line": 571,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "random",
                "line": 573,
                "source": "const vec = new Vec3()\nexpect(vec.random()).toBe(vec)\nexpect(vec.x).toBeGreaterThanOrEqual(0)\nexpect(vec.x).toBeLessThan(1)\nexpect(vec.y).toBeGreaterThanOrEqual(0)\nexpect(vec.y).toBeLessThan(1)\nexpect(vec.z).toBeGreaterThanOrEqual(0)\nexpect(vec.z).toBeLessThan(1)"
              },
              {
                "title": "randomDirection",
                "line": 584,
                "source": "const vec = new Vec3()\nexpect(vec.randomDirection()).toBe(vec)\nexpect(vec.length()).toBeCloseTo(1)"
              }
            ],
            "describes": []
          },
          {
            "title": "component access",
            "line": 593,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "getComponent",
                "line": 595,
                "source": "const vec = new Vec3(5, 7, 9)\nexpect(vec.getComponent(0)).toBe(5)\nexpect(vec.getComponent(1)).toBe(7)\nexpect(vec.getComponent(2)).toBe(9)"
              },
              {
                "title": "getComponent throws on invalid index",
                "line": 602,
                "source": "const vec = new Vec3()\nexpect(() => {\n    vec.getComponent(3)\n}).toThrow('index out of range: 3')"
              }
            ],
            "describes": []
          },
          {
            "title": "projection",
            "line": 612,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "projectOnVector",
                "line": 614,
                "source": "const vec = new Vec3(1, 1, 0)\nconst target = new Vec3(1, 0, 0)\nexpect(vec.projectOnVector(target)).toBe(vec)\nexpect(vec.x).toBeCloseTo(1)\nexpect(vec.y).toBeCloseTo(0)\nexpect(vec.z).toBeCloseTo(0)"
              },
              {
                "title": "projectOnPlane",
                "line": 623,
                "source": "const vec = new Vec3(1, 1, 1)\nconst normal = new Vec3(0, 1, 0)\nexpect(vec.projectOnPlane(normal)).toBe(vec)\nexpect(vec.x).toBeCloseTo(1)\nexpect(vec.y).toBeCloseTo(0)\nexpect(vec.z).toBeCloseTo(1)"
              }
            ],
            "describes": []
          },
          {
            "title": "iteration",
            "line": 661,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "iterator",
                "line": 663,
                "source": "const vec = new Vec3(3, 4, 5)\nconst [x, y, z] = vec\nexpect(x).toBe(3)\nexpect(y).toBe(4)\nexpect(z).toBe(5)"
              },
              {
                "title": "spread operator",
                "line": 671,
                "source": "const vec = new Vec3(5, 6, 7)\nconst arr = [...vec]\nexpect(arr).toEqual([5, 6, 7])"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/math/vec4.doc.js": {
    "file": "/math/vec4.test.js",
    "describes": [
      {
        "title": "Vec4",
        "line": 4,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "random",
            "line": 562,
            "source": "const vec = new Vec4()\nexpect(vec.random()).toBe(vec)\nexpect(vec.x).toBeGreaterThanOrEqual(0)\nexpect(vec.x).toBeLessThan(1)\nexpect(vec.y).toBeGreaterThanOrEqual(0)\nexpect(vec.y).toBeLessThan(1)\nexpect(vec.z).toBeGreaterThanOrEqual(0)\nexpect(vec.z).toBeLessThan(1)\nexpect(vec.w).toBeGreaterThanOrEqual(0)\nexpect(vec.w).toBeLessThan(1)"
          },
          {
            "title": "isVector4",
            "line": 623,
            "source": "const vec = new Vec4()\nexpect(vec.isVector4).toBe(true)"
          }
        ],
        "describes": [
          {
            "title": "constructor",
            "line": 6,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "with x, y, z and w",
                "line": 8,
                "source": "const vec = new Vec4(1, 2, 3, 4)\nexpect(vec.x).toBe(1)\nexpect(vec.y).toBe(2)\nexpect(vec.z).toBe(3)\nexpect(vec.w).toBe(4)"
              },
              {
                "title": "with object",
                "line": 16,
                "source": "const vec = new Vec4({x: 3, y: 4, z: 5, w: 6})\nexpect(vec.x).toBe(3)\nexpect(vec.y).toBe(4)\nexpect(vec.z).toBe(5)\nexpect(vec.w).toBe(6)"
              },
              {
                "title": "with array",
                "line": 24,
                "source": "const vec = new Vec4([7, 8, 9, 10])\nexpect(vec.x).toBe(7)\nexpect(vec.y).toBe(8)\nexpect(vec.z).toBe(9)\nexpect(vec.w).toBe(10)"
              },
              {
                "title": "with no parameters defaults w to 1",
                "line": 32,
                "source": "const vec = new Vec4()\nexpect(vec.x).toBe(0)\nexpect(vec.y).toBe(0)\nexpect(vec.z).toBe(0)\nexpect(vec.w).toBe(1)"
              },
              {
                "title": "with only x",
                "line": 40,
                "source": "const vec = new Vec4(5)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(0)\nexpect(vec.z).toBe(0)\nexpect(vec.w).toBe(1)"
              },
              {
                "title": "with x, y and z",
                "line": 48,
                "source": "const vec = new Vec4(5, 6, 7)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(6)\nexpect(vec.z).toBe(7)\nexpect(vec.w).toBe(1)"
              }
            ],
            "describes": []
          },
          {
            "title": "setters",
            "line": 59,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "set",
                "line": 61,
                "source": "const vec = new Vec4()\nexpect(vec.set(3, 4, 5, 6)).toBe(vec)\nexpect(vec.x).toBe(3)\nexpect(vec.y).toBe(4)\nexpect(vec.z).toBe(5)\nexpect(vec.w).toBe(6)"
              },
              {
                "title": "setX",
                "line": 70,
                "source": "const vec = new Vec4(1, 2, 3, 4)\nexpect(vec.setX(5)).toBe(vec)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(2)\nexpect(vec.z).toBe(3)\nexpect(vec.w).toBe(4)"
              },
              {
                "title": "setY",
                "line": 79,
                "source": "const vec = new Vec4(1, 2, 3, 4)\nexpect(vec.setY(6)).toBe(vec)\nexpect(vec.x).toBe(1)\nexpect(vec.y).toBe(6)\nexpect(vec.z).toBe(3)\nexpect(vec.w).toBe(4)"
              },
              {
                "title": "setZ",
                "line": 88,
                "source": "const vec = new Vec4(1, 2, 3, 4)\nexpect(vec.setZ(7)).toBe(vec)\nexpect(vec.x).toBe(1)\nexpect(vec.y).toBe(2)\nexpect(vec.z).toBe(7)\nexpect(vec.w).toBe(4)"
              },
              {
                "title": "setW",
                "line": 97,
                "source": "const vec = new Vec4(1, 2, 3, 4)\nexpect(vec.setW(8)).toBe(vec)\nexpect(vec.x).toBe(1)\nexpect(vec.y).toBe(2)\nexpect(vec.z).toBe(3)\nexpect(vec.w).toBe(8)"
              },
              {
                "title": "setScalar",
                "line": 106,
                "source": "const vec = new Vec4()\nexpect(vec.setScalar(7)).toBe(vec)\nexpect(vec.x).toBe(7)\nexpect(vec.y).toBe(7)\nexpect(vec.z).toBe(7)\nexpect(vec.w).toBe(7)"
              },
              {
                "title": "setComponent",
                "line": 115,
                "source": "const vec = new Vec4(1, 2, 3, 4)\nexpect(vec.setComponent(0, 10)).toBe(vec)\nexpect(vec.x).toBe(10)\nexpect(vec.setComponent(1, 20)).toBe(vec)\nexpect(vec.y).toBe(20)\nexpect(vec.setComponent(2, 30)).toBe(vec)\nexpect(vec.z).toBe(30)\nexpect(vec.setComponent(3, 40)).toBe(vec)\nexpect(vec.w).toBe(40)"
              },
              {
                "title": "setComponent throws on invalid index",
                "line": 127,
                "source": "const vec = new Vec4()\nexpect(() => {\n    vec.setComponent(4, 5)\n}).toThrow('index out of range: 4')"
              }
            ],
            "describes": []
          },
          {
            "title": "copy and clone",
            "line": 137,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "copy",
                "line": 139,
                "source": "const vec1 = new Vec4(1, 2, 3, 4)\nconst vec2 = new Vec4(5, 6, 7, 8)\nexpect(vec1.copy(vec2)).toBe(vec1)\nexpect(vec1.x).toBe(5)\nexpect(vec1.y).toBe(6)\nexpect(vec1.z).toBe(7)\nexpect(vec1.w).toBe(8)"
              },
              {
                "title": "copy from Vec3",
                "line": 149,
                "source": "const vec1 = new Vec4(1, 2, 3, 4)\nconst vec3 = {x: 5, y: 6, z: 7}\nexpect(vec1.copy(vec3)).toBe(vec1)\nexpect(vec1.x).toBe(5)\nexpect(vec1.y).toBe(6)\nexpect(vec1.z).toBe(7)\nexpect(vec1.w).toBe(1)"
              },
              {
                "title": "clone",
                "line": 159,
                "source": "const vec1 = new Vec4(5, 6, 7, 8)\nconst vec2 = vec1.clone()\nexpect(vec2).not.toBe(vec1)\nexpect(vec2.x).toBe(5)\nexpect(vec2.y).toBe(6)\nexpect(vec2.z).toBe(7)\nexpect(vec2.w).toBe(8)"
              }
            ],
            "describes": []
          },
          {
            "title": "addition",
            "line": 172,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "add",
                "line": 174,
                "source": "const vec = new Vec4(1, 2, 3, 4)\nexpect(vec.add(new Vec4(5, 6, 7, 8))).toBe(vec)\nexpect(vec.x).toBe(6)\nexpect(vec.y).toBe(8)\nexpect(vec.z).toBe(10)\nexpect(vec.w).toBe(12)"
              },
              {
                "title": "addScalar",
                "line": 183,
                "source": "const vec = new Vec4(1, 2, 3, 4)\nexpect(vec.addScalar(5)).toBe(vec)\nexpect(vec.x).toBe(6)\nexpect(vec.y).toBe(7)\nexpect(vec.z).toBe(8)\nexpect(vec.w).toBe(9)"
              },
              {
                "title": "addVectors",
                "line": 192,
                "source": "const vec = new Vec4()\nexpect(vec.addVectors(new Vec4(1, 2, 3, 4), new Vec4(5, 6, 7, 8))).toBe(vec)\nexpect(vec.x).toBe(6)\nexpect(vec.y).toBe(8)\nexpect(vec.z).toBe(10)\nexpect(vec.w).toBe(12)"
              },
              {
                "title": "addScaledVector",
                "line": 201,
                "source": "const vec = new Vec4(1, 2, 3, 4)\nexpect(vec.addScaledVector(new Vec4(2, 3, 4, 5), 2)).toBe(vec)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(8)\nexpect(vec.z).toBe(11)\nexpect(vec.w).toBe(14)"
              }
            ],
            "describes": []
          },
          {
            "title": "subtraction",
            "line": 213,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "sub",
                "line": 215,
                "source": "const vec = new Vec4(10, 12, 14, 16)\nexpect(vec.sub(new Vec4(2, 3, 4, 5))).toBe(vec)\nexpect(vec.x).toBe(8)\nexpect(vec.y).toBe(9)\nexpect(vec.z).toBe(10)\nexpect(vec.w).toBe(11)"
              },
              {
                "title": "subScalar",
                "line": 224,
                "source": "const vec = new Vec4(10, 20, 30, 40)\nexpect(vec.subScalar(5)).toBe(vec)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(15)\nexpect(vec.z).toBe(25)\nexpect(vec.w).toBe(35)"
              },
              {
                "title": "subVectors",
                "line": 233,
                "source": "const vec = new Vec4()\nexpect(vec.subVectors(new Vec4(10, 12, 14, 16), new Vec4(3, 4, 5, 6))).toBe(vec)\nexpect(vec.x).toBe(7)\nexpect(vec.y).toBe(8)\nexpect(vec.z).toBe(9)\nexpect(vec.w).toBe(10)"
              }
            ],
            "describes": []
          },
          {
            "title": "multiplication",
            "line": 245,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "multiply",
                "line": 247,
                "source": "const vec = new Vec4(2, 3, 4, 5)\nexpect(vec.multiply(new Vec4(4, 5, 6, 7))).toBe(vec)\nexpect(vec.x).toBe(8)\nexpect(vec.y).toBe(15)\nexpect(vec.z).toBe(24)\nexpect(vec.w).toBe(35)"
              },
              {
                "title": "multiplyScalar",
                "line": 256,
                "source": "const vec = new Vec4(3, 4, 5, 6)\nexpect(vec.multiplyScalar(2)).toBe(vec)\nexpect(vec.x).toBe(6)\nexpect(vec.y).toBe(8)\nexpect(vec.z).toBe(10)\nexpect(vec.w).toBe(12)"
              }
            ],
            "describes": []
          },
          {
            "title": "division",
            "line": 268,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "divide",
                "line": 270,
                "source": "const vec = new Vec4(12, 20, 30, 42)\nexpect(vec.divide(new Vec4(3, 4, 5, 6))).toBe(vec)\nexpect(vec.x).toBe(4)\nexpect(vec.y).toBe(5)\nexpect(vec.z).toBe(6)\nexpect(vec.w).toBe(7)"
              },
              {
                "title": "divideScalar",
                "line": 279,
                "source": "const vec = new Vec4(10, 20, 30, 40)\nexpect(vec.divideScalar(2)).toBe(vec)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(10)\nexpect(vec.z).toBe(15)\nexpect(vec.w).toBe(20)"
              }
            ],
            "describes": []
          },
          {
            "title": "vector operations",
            "line": 291,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "dot",
                "line": 293,
                "source": "const vec1 = new Vec4(1, 2, 3, 4)\nconst vec2 = new Vec4(5, 6, 7, 8)\nexpect(vec1.dot(vec2)).toBe(70)"
              },
              {
                "title": "lengthSq",
                "line": 299,
                "source": "const vec = new Vec4(1, 2, 2, 4)\nexpect(vec.lengthSq()).toBe(25)"
              },
              {
                "title": "length",
                "line": 304,
                "source": "const vec = new Vec4(1, 2, 2, 4)\nexpect(vec.length()).toBe(5)"
              },
              {
                "title": "manhattanLength",
                "line": 309,
                "source": "const vec = new Vec4(3, -4, 5, -6)\nexpect(vec.manhattanLength()).toBe(18)"
              },
              {
                "title": "normalize",
                "line": 314,
                "source": "const vec = new Vec4(0, 0, 0, 5)\nexpect(vec.normalize()).toBe(vec)\nexpect(vec.x).toBeCloseTo(0)\nexpect(vec.y).toBeCloseTo(0)\nexpect(vec.z).toBeCloseTo(0)\nexpect(vec.w).toBeCloseTo(1)\nexpect(vec.length()).toBeCloseTo(1)"
              },
              {
                "title": "normalize zero vector",
                "line": 324,
                "source": "const vec = new Vec4(0, 0, 0, 0)\nexpect(vec.normalize()).toBe(vec)\nexpect(vec.x).toBe(0)\nexpect(vec.y).toBe(0)\nexpect(vec.z).toBe(0)\nexpect(vec.w).toBe(0)"
              },
              {
                "title": "setLength",
                "line": 333,
                "source": "const vec = new Vec4(0, 0, 0, 5)\nexpect(vec.setLength(10)).toBe(vec)\nexpect(vec.length()).toBeCloseTo(10)\nexpect(vec.w).toBeCloseTo(10)"
              }
            ],
            "describes": []
          },
          {
            "title": "interpolation",
            "line": 343,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "lerp",
                "line": 345,
                "source": "const vec = new Vec4(0, 0, 0, 0)\nexpect(vec.lerp(new Vec4(10, 20, 30, 40), 0.5)).toBe(vec)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(10)\nexpect(vec.z).toBe(15)\nexpect(vec.w).toBe(20)"
              },
              {
                "title": "lerp at 0",
                "line": 354,
                "source": "const vec = new Vec4(1, 2, 3, 4)\nvec.lerp(new Vec4(10, 20, 30, 40), 0)\nexpect(vec.x).toBe(1)\nexpect(vec.y).toBe(2)\nexpect(vec.z).toBe(3)\nexpect(vec.w).toBe(4)"
              },
              {
                "title": "lerp at 1",
                "line": 363,
                "source": "const vec = new Vec4(1, 2, 3, 4)\nvec.lerp(new Vec4(10, 20, 30, 40), 1)\nexpect(vec.x).toBe(10)\nexpect(vec.y).toBe(20)\nexpect(vec.z).toBe(30)\nexpect(vec.w).toBe(40)"
              },
              {
                "title": "lerpVectors",
                "line": 372,
                "source": "const vec = new Vec4()\nexpect(vec.lerpVectors(new Vec4(0, 0, 0, 0), new Vec4(10, 20, 30, 40), 0.5)).toBe(vec)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(10)\nexpect(vec.z).toBe(15)\nexpect(vec.w).toBe(20)"
              }
            ],
            "describes": []
          },
          {
            "title": "comparison",
            "line": 384,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "equals with Vec4",
                "line": 386,
                "source": "const vec1 = new Vec4(1, 2, 3, 4)\nconst vec2 = new Vec4(1, 2, 3, 4)\nconst vec3 = new Vec4(5, 6, 7, 8)\nexpect(vec1.equals(vec2)).toBe(true)\nexpect(vec1.equals(vec3)).toBe(false)"
              },
              {
                "title": "equals with object",
                "line": 394,
                "source": "const vec1 = new Vec4(1, 2, 3, 4)\nconst obj = {x: 1, y: 2, z: 3, w: 4}\nexpect(vec1.equals(obj)).toBe(true)"
              }
            ],
            "describes": []
          },
          {
            "title": "array conversion",
            "line": 403,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "fromArray",
                "line": 405,
                "source": "const vec = new Vec4()\nexpect(vec.fromArray([5, 6, 7, 8])).toBe(vec)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(6)\nexpect(vec.z).toBe(7)\nexpect(vec.w).toBe(8)"
              },
              {
                "title": "fromArray with offset",
                "line": 414,
                "source": "const vec = new Vec4()\nvec.fromArray([1, 2, 3, 4, 5, 6], 2)\nexpect(vec.x).toBe(3)\nexpect(vec.y).toBe(4)\nexpect(vec.z).toBe(5)\nexpect(vec.w).toBe(6)"
              },
              {
                "title": "toArray",
                "line": 423,
                "source": "const vec = new Vec4(7, 8, 9, 10)\nconst arr = vec.toArray()\nexpect(arr).toEqual([7, 8, 9, 10])"
              },
              {
                "title": "toArray with existing array",
                "line": 429,
                "source": "const vec = new Vec4(9, 10, 11, 12)\nconst arr = [1, 2, 3, 4, 5, 6]\nexpect(vec.toArray(arr, 2)).toBe(arr)\nexpect(arr).toEqual([1, 2, 9, 10, 11, 12])"
              }
            ],
            "describes": []
          },
          {
            "title": "negation and min/max",
            "line": 439,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "negate",
                "line": 441,
                "source": "const vec = new Vec4(3, -4, 5, -6)\nexpect(vec.negate()).toBe(vec)\nexpect(vec.x).toBe(-3)\nexpect(vec.y).toBe(4)\nexpect(vec.z).toBe(-5)\nexpect(vec.w).toBe(6)"
              },
              {
                "title": "min",
                "line": 450,
                "source": "const vec = new Vec4(5, 2, 7, 3)\nexpect(vec.min(new Vec4(3, 4, 6, 5))).toBe(vec)\nexpect(vec.x).toBe(3)\nexpect(vec.y).toBe(2)\nexpect(vec.z).toBe(6)\nexpect(vec.w).toBe(3)"
              },
              {
                "title": "max",
                "line": 459,
                "source": "const vec = new Vec4(5, 2, 7, 3)\nexpect(vec.max(new Vec4(3, 4, 6, 5))).toBe(vec)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(4)\nexpect(vec.z).toBe(7)\nexpect(vec.w).toBe(5)"
              }
            ],
            "describes": []
          },
          {
            "title": "clamping",
            "line": 471,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "clamp",
                "line": 473,
                "source": "const vec = new Vec4(15, -5, 25, -10)\nexpect(vec.clamp(new Vec4(0, 0, 0, 0), new Vec4(10, 10, 10, 10))).toBe(vec)\nexpect(vec.x).toBe(10)\nexpect(vec.y).toBe(0)\nexpect(vec.z).toBe(10)\nexpect(vec.w).toBe(0)"
              },
              {
                "title": "clampScalar",
                "line": 482,
                "source": "const vec = new Vec4(15, -5, 7, 12)\nexpect(vec.clampScalar(0, 10)).toBe(vec)\nexpect(vec.x).toBe(10)\nexpect(vec.y).toBe(0)\nexpect(vec.z).toBe(7)\nexpect(vec.w).toBe(10)"
              },
              {
                "title": "clampLength min",
                "line": 491,
                "source": "const vec = new Vec4(1, 0, 0, 0)\nvec.clampLength(5, 10)\nexpect(vec.length()).toBeCloseTo(5)"
              },
              {
                "title": "clampLength max",
                "line": 497,
                "source": "const vec = new Vec4(20, 0, 0, 0)\nvec.clampLength(5, 10)\nexpect(vec.length()).toBeCloseTo(10)"
              },
              {
                "title": "clampLength in range",
                "line": 503,
                "source": "const vec = new Vec4(7, 0, 0, 0)\nvec.clampLength(5, 10)\nexpect(vec.length()).toBeCloseTo(7)"
              }
            ],
            "describes": []
          },
          {
            "title": "rounding",
            "line": 512,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "floor",
                "line": 514,
                "source": "const vec = new Vec4(1.7, 2.3, 3.9, 4.1)\nexpect(vec.floor()).toBe(vec)\nexpect(vec.x).toBe(1)\nexpect(vec.y).toBe(2)\nexpect(vec.z).toBe(3)\nexpect(vec.w).toBe(4)"
              },
              {
                "title": "ceil",
                "line": 523,
                "source": "const vec = new Vec4(1.3, 2.7, 3.1, 4.9)\nexpect(vec.ceil()).toBe(vec)\nexpect(vec.x).toBe(2)\nexpect(vec.y).toBe(3)\nexpect(vec.z).toBe(4)\nexpect(vec.w).toBe(5)"
              },
              {
                "title": "round",
                "line": 532,
                "source": "const vec = new Vec4(1.4, 2.6, 3.5, 4.4)\nexpect(vec.round()).toBe(vec)\nexpect(vec.x).toBe(1)\nexpect(vec.y).toBe(3)\nexpect(vec.z).toBe(4)\nexpect(vec.w).toBe(4)"
              },
              {
                "title": "roundToZero positive",
                "line": 541,
                "source": "const vec = new Vec4(1.9, 2.9, 3.9, 4.9)\nexpect(vec.roundToZero()).toBe(vec)\nexpect(vec.x).toBe(1)\nexpect(vec.y).toBe(2)\nexpect(vec.z).toBe(3)\nexpect(vec.w).toBe(4)"
              },
              {
                "title": "roundToZero negative",
                "line": 550,
                "source": "const vec = new Vec4(-1.9, -2.9, -3.9, -4.9)\nvec.roundToZero()\nexpect(vec.x).toBe(-1)\nexpect(vec.y).toBe(-2)\nexpect(vec.z).toBe(-3)\nexpect(vec.w).toBe(-4)"
              }
            ],
            "describes": []
          },
          {
            "title": "component access",
            "line": 576,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "getComponent",
                "line": 578,
                "source": "const vec = new Vec4(5, 7, 9, 11)\nexpect(vec.getComponent(0)).toBe(5)\nexpect(vec.getComponent(1)).toBe(7)\nexpect(vec.getComponent(2)).toBe(9)\nexpect(vec.getComponent(3)).toBe(11)"
              },
              {
                "title": "getComponent throws on invalid index",
                "line": 586,
                "source": "const vec = new Vec4()\nexpect(() => {\n    vec.getComponent(4)\n}).toThrow('index out of range: 4')"
              }
            ],
            "describes": []
          },
          {
            "title": "aliases",
            "line": 596,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "width getter",
                "line": 598,
                "source": "const vec = new Vec4(10, 20, 30, 40)\nexpect(vec.width).toBe(30)"
              },
              {
                "title": "width setter",
                "line": 603,
                "source": "const vec = new Vec4()\nvec.width = 15\nexpect(vec.z).toBe(15)"
              },
              {
                "title": "height getter",
                "line": 609,
                "source": "const vec = new Vec4(10, 20, 30, 40)\nexpect(vec.height).toBe(40)"
              },
              {
                "title": "height setter",
                "line": 614,
                "source": "const vec = new Vec4()\nvec.height = 25\nexpect(vec.w).toBe(25)"
              }
            ],
            "describes": []
          },
          {
            "title": "iteration",
            "line": 629,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "iterator",
                "line": 631,
                "source": "const vec = new Vec4(3, 4, 5, 6)\nconst [x, y, z, w] = vec\nexpect(x).toBe(3)\nexpect(y).toBe(4)\nexpect(z).toBe(5)\nexpect(w).toBe(6)"
              },
              {
                "title": "spread operator",
                "line": 640,
                "source": "const vec = new Vec4(5, 6, 7, 8)\nconst arr = [...vec]\nexpect(arr).toEqual([5, 6, 7, 8])"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/math/services/pathfinding_service.doc.js": {
    "file": "/math/services/pathfinding_service.test.js",
    "describes": [
      {
        "title": "PathfindingService",
        "line": 7,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "constructor with config",
            "line": 9,
            "source": "const service = new PathfindingService({\n    allowDiagonal: false,\n    heuristic: 'euclidean',\n    maxCacheSize: 400\n})\n\nexpect(service.pathfinder.allowDiagonal).toBe(false)\nexpect(service.pathfinder.heuristic).toBe(heuristics.euclidean)\nexpect(service.maxCacheSize).toBe(400)"
          },
          {
            "title": "constructor with defaults",
            "line": 22,
            "source": "const service = new PathfindingService()\n\nexpect(service.pathfinder.allowDiagonal).toBe(true)\nexpect(service.pathfinder.heuristic).toBe(heuristics.manhattan)\nexpect(service.maxCacheSize).toBe(500)"
          },
          {
            "title": "constructor with invalid heuristic falls back to manhattan",
            "line": 31,
            "source": "const service = new PathfindingService({\n    heuristic: 'invalid-heuristic'\n})\n\nexpect(service.pathfinder.heuristic).toBe(heuristics.manhattan)"
          },
          {
            "title": "setGrid and findPath",
            "line": 40,
            "source": "const service = new PathfindingService()\n\nconst grid = new Grid({width: 5, height: 5})\ngrid.setCell({x: 1, y: 1}, 'wall')\nconst gridData = grid.export()\n\nconst setGridReq = {params: {gridData}}\nconst setGridRes = {send: vi.fn(), error: vi.fn()}\n\nservice.setGrid(setGridReq, setGridRes)\n\nexpect(setGridRes.send).toHaveBeenCalledWith(\n    expect.objectContaining({\n        success: true,\n        gridSize: '5x5',\n        cellCount: 1\n    })\n)\n\nconst findPathReq = {\n    params: {\n        start: {x: 0, y: 0},\n        goal: {x: 2, y: 2}\n    }\n}\nconst findPathRes = {send: vi.fn(), error: vi.fn()}\n\nservice.findPath(findPathReq, findPathRes)\n\nexpect(findPathRes.send).toHaveBeenCalledWith(\n    expect.objectContaining({\n        found: true,\n        length: expect.any(Number),\n        path: expect.arrayContaining([\n            {x: 0, y: 0},\n            {x: 2, y: 2}\n        ]),\n        calculationTime: expect.any(Number),\n        cached: false\n    })\n)"
          },
          {
            "title": "path caching",
            "line": 85,
            "source": "const service = new PathfindingService()\n\nconst grid = new Grid({width: 3, height: 3})\nconst gridData = grid.export()\n\nconst setGridReq = {params: {gridData}}\nconst setGridRes = {send: vi.fn(), error: vi.fn()}\nservice.setGrid(setGridReq, setGridRes)\n\nconst pathReq = {\n    params: {\n        start: {x: 0, y: 0},\n        goal: {x: 2, y: 2}\n    }\n}\nconst pathRes1 = {send: vi.fn(), error: vi.fn()}\nconst pathRes2 = {send: vi.fn(), error: vi.fn()}\n\nservice.findPath(pathReq, pathRes1)\nservice.findPath(pathReq, pathRes2)\n\nexpect(pathRes1.send).toHaveBeenCalledWith(\n    expect.objectContaining({cached: false})\n)\n\nexpect(pathRes2.send).toHaveBeenCalledWith(\n    expect.objectContaining({cached: true})\n)"
          },
          {
            "title": "error handling - missing grid",
            "line": 117,
            "source": "const service = new PathfindingService()\n\nconst req = {\n    params: {\n        start: {x: 0, y: 0},\n        goal: {x: 2, y: 2}\n    }\n}\nconst res = {send: vi.fn(), error: vi.fn()}\n\nservice.findPath(req, res)\n\nexpect(res.error).toHaveBeenCalledWith('No grid set. Call setGrid first.')"
          },
          {
            "title": "error handling - missing parameters",
            "line": 134,
            "source": "const service = new PathfindingService()\n\nconst setGridReq = {params: {}}\nconst setGridRes = {send: vi.fn(), error: vi.fn()}\n\nservice.setGrid(setGridReq, setGridRes)\n\nexpect(setGridRes.error).toHaveBeenCalledWith('Missing gridData parameter')\n\nconst grid = new Grid({width: 3, height: 3})\nconst gridData = grid.export()\n\nconst validSetReq = {params: {gridData}}\nconst validSetRes = {send: vi.fn(), error: vi.fn()}\nservice.setGrid(validSetReq, validSetRes)\n\nconst findPathReq = {params: {start: {x: 0, y: 0}}}\nconst findPathRes = {send: vi.fn(), error: vi.fn()}\n\nservice.findPath(findPathReq, findPathRes)\n\nexpect(findPathRes.error).toHaveBeenCalledWith('Missing start or goal coordinates')"
          },
          {
            "title": "pathfinder options",
            "line": 160,
            "source": "const service = new PathfindingService()\n\nconst grid = new Grid({width: 3, height: 3})\nconst gridData = grid.export()\n\nconst setGridReq = {params: {gridData}}\nconst setGridRes = {send: vi.fn(), error: vi.fn()}\nservice.setGrid(setGridReq, setGridRes)\n\nconst findPathReq = {\n    params: {\n        start: {x: 0, y: 0},\n        goal: {x: 2, y: 2},\n        options: {\n            heuristic: 'euclidean',\n            allowDiagonal: false\n        }\n    }\n}\nconst findPathRes = {send: vi.fn(), error: vi.fn()}\n\nservice.findPath(findPathReq, findPathRes)\n\nexpect(findPathRes.send).toHaveBeenCalledWith(\n    expect.objectContaining({\n        found: true,\n        cached: false\n    })\n)\n\nexpect(service.pathfinder.allowDiagonal).toBe(false)"
          },
          {
            "title": "setCell clears cache",
            "line": 195,
            "source": "const service = new PathfindingService()\n\nconst grid = new Grid({width: 3, height: 3})\nconst gridData = grid.export()\n\nconst setGridReq = {params: {gridData}}\nconst setGridRes = {send: vi.fn(), error: vi.fn()}\nservice.setGrid(setGridReq, setGridRes)\n\nconst pathReq = {\n    params: {\n        start: {x: 0, y: 0},\n        goal: {x: 2, y: 2}\n    }\n}\nconst pathRes = {send: vi.fn(), error: vi.fn()}\nservice.findPath(pathReq, pathRes)\n\nexpect(service.pathCache.size).toBe(1)\n\nconst setCellReq = {\n    params: {\n        coords: {x: 1, y: 1},\n        value: 'wall'\n    }\n}\nconst setCellRes = {send: vi.fn(), error: vi.fn()}\n\nservice.setCell(setCellReq, setCellRes)\n\nexpect(setCellRes.send).toHaveBeenCalledWith({\n    success: true,\n    coords: {x: 1, y: 1},\n    value: 'wall',\n    cacheCleared: true\n})\n\nexpect(service.pathCache.size).toBe(0)"
          },
          {
            "title": "setCell error handling",
            "line": 237,
            "source": "const service = new PathfindingService()\n\nconst setCellReq1 = {\n    params: {\n        coords: {x: 1, y: 1},\n        value: 'wall'\n    }\n}\nconst setCellRes1 = {send: vi.fn(), error: vi.fn()}\n\nservice.setCell(setCellReq1, setCellRes1)\n\nexpect(setCellRes1.error).toHaveBeenCalledWith('No grid set. Call setGrid first.')\n\nconst grid = new Grid({width: 3, height: 3})\nconst gridData = grid.export()\n\nconst setGridReq = {params: {gridData}}\nconst setGridRes = {send: vi.fn(), error: vi.fn()}\nservice.setGrid(setGridReq, setGridRes)\n\nconst setCellReq2 = {params: {value: 'wall'}}\nconst setCellRes2 = {send: vi.fn(), error: vi.fn()}\n\nservice.setCell(setCellReq2, setCellRes2)\n\nexpect(setCellRes2.error).toHaveBeenCalledWith('Missing or invalid coords parameter')\n\nconst setCellReq3 = {\n    params: {\n        coords: {x: 1},\n        value: 'wall'\n    }\n}\nconst setCellRes3 = {send: vi.fn(), error: vi.fn()}\n\nservice.setCell(setCellReq3, setCellRes3)\n\nexpect(setCellRes3.error).toHaveBeenCalledWith('Missing or invalid coords parameter')"
          },
          {
            "title": "cacheResult evicts oldest entry when cache is full",
            "line": 280,
            "source": "const service = new PathfindingService({maxCacheSize: 2})\n\nservice.cacheResult('key1', {path: [], found: false, length: 0, calculationTime: 1})\nservice.cacheResult('key2', {path: [], found: false, length: 0, calculationTime: 2})\n\nexpect(service.pathCache.size).toBe(2)\nexpect(service.pathCache.has('key1')).toBe(true)\nexpect(service.pathCache.has('key2')).toBe(true)\n\nservice.cacheResult('key3', {path: [], found: true, length: 5, calculationTime: 3})\n\nexpect(service.pathCache.size).toBe(2)\nexpect(service.pathCache.has('key1')).toBe(false)\nexpect(service.pathCache.has('key2')).toBe(true)\nexpect(service.pathCache.has('key3')).toBe(true)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/render/canvas_renderer.doc.js": {
    "file": "/render/canvas_renderer.test.js",
    "describes": [
      {
        "title": "CanvasRenderer",
        "line": 9,
        "beforeEach": {
          "line": 14,
          "source": "canvas = document.createElement('canvas')\ncanvas.width = 800\ncanvas.height = 600\nrenderer = new CanvasRenderer({canvas})"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor with canvas",
            "line": 22,
            "source": "expect(renderer.canvas).toBe(canvas)\nexpect(renderer.ctx).toBe(canvas.getContext('2d'))\nexpect(renderer.camera).toBeInstanceOf(Camera)\nexpect(renderer.backgroundColor).toBe(null)"
          },
          {
            "title": "constructor with container",
            "line": 30,
            "source": "const container = document.createElement('div')\nconst r = new CanvasRenderer({container, width: 400, height: 300})\n\nexpect(r.canvas).toBeInstanceOf(HTMLCanvasElement)\nexpect(r.container).toBe(container)\nexpect(container.contains(r.canvas)).toBe(true)"
          },
          {
            "title": "constructor with options",
            "line": 40,
            "source": "const camera = new Camera()\nconst r = new CanvasRenderer({\n    canvas,\n    camera,\n    backgroundColor: '#ffffff'\n})\n\nexpect(r.camera).toBe(camera)\nexpect(r.backgroundColor).toBe('#ffffff')"
          },
          {
            "title": "autoFit observes container resize",
            "line": 53,
            "source": "const container = document.createElement('div')\n\nObject.defineProperty(container, 'clientWidth', {value: 400, writable: true})\nObject.defineProperty(container, 'clientHeight', {value: 300, writable: true})\n\nconst r = new CanvasRenderer({container, autoFit: true})\n\nexpect(r.displayWidth).toBe(400)\nexpect(r.displayHeight).toBe(300)\n\nr.dispose()"
          },
          {
            "title": "dispose cleans up autoFit observer",
            "line": 68,
            "source": "const container = document.createElement('div')\nObject.defineProperty(container, 'clientWidth', {value: 400, writable: true})\nObject.defineProperty(container, 'clientHeight', {value: 300, writable: true})\n\nconst r = new CanvasRenderer({container, autoFit: true})\n\nexpect(r.canvas).toBeInstanceOf(HTMLCanvasElement)\nexpect(r.ctx).toBeDefined()\n\nr.dispose()\n\nexpect(r.canvas).toBe(null)\nexpect(r.ctx).toBe(null)"
          },
          {
            "title": "autoFitEnabled can be toggled dynamically",
            "line": 85,
            "source": "const container = document.createElement('div')\nObject.defineProperty(container, 'clientWidth', {value: 400, writable: true})\nObject.defineProperty(container, 'clientHeight', {value: 300, writable: true})\n\nconst r = new CanvasRenderer({container, autoFit: true})\n\nexpect(r.autoFitEnabled).toBe(true)\nexpect(r.displayWidth).toBe(400)\nexpect(r.displayHeight).toBe(300)\n\n// Disable autoFit\nr.autoFitEnabled = false\nexpect(r.autoFitEnabled).toBe(false)\n\n// Re-enable autoFit\nr.autoFitEnabled = true\nexpect(r.autoFitEnabled).toBe(true)\n\nr.dispose()"
          },
          {
            "title": "changing container with autoFit updates observer",
            "line": 108,
            "source": "const container1 = document.createElement('div')\nconst container2 = document.createElement('div')\n\nObject.defineProperty(container1, 'clientWidth', {value: 400, writable: true})\nObject.defineProperty(container1, 'clientHeight', {value: 300, writable: true})\nObject.defineProperty(container2, 'clientWidth', {value: 800, writable: true})\nObject.defineProperty(container2, 'clientHeight', {value: 600, writable: true})\n\nconst r = new CanvasRenderer({container: container1, autoFit: true})\n\nexpect(r.displayWidth).toBe(400)\nexpect(r.displayHeight).toBe(300)\nexpect(r.container).toBe(container1)\n\n// Change container - should trigger resize\nr.container = container2\n\nexpect(r.container).toBe(container2)\nexpect(r.displayWidth).toBe(800)\nexpect(r.displayHeight).toBe(600)\n\nr.dispose()"
          },
          {
            "title": "changing container without autoFit does not resize",
            "line": 134,
            "source": "const container1 = document.createElement('div')\nconst container2 = document.createElement('div')\n\nObject.defineProperty(container1, 'clientWidth', {value: 400, writable: true})\nObject.defineProperty(container1, 'clientHeight', {value: 300, writable: true})\nObject.defineProperty(container2, 'clientWidth', {value: 800, writable: true})\nObject.defineProperty(container2, 'clientHeight', {value: 600, writable: true})\n\nconst r = new CanvasRenderer({container: container1, width: 400, height: 300})\n\nexpect(r.displayWidth).toBe(400)\nexpect(r.displayHeight).toBe(300)\n\n// Change container - should NOT auto-resize\nr.container = container2\n\nexpect(r.container).toBe(container2)\nexpect(r.displayWidth).toBe(400) // Should remain same\nexpect(r.displayHeight).toBe(300) // Should remain same\n\nr.dispose()"
          },
          {
            "title": "render clears canvas",
            "line": 159,
            "source": "const scene = new Group2D()\nconst ctx = canvas.getContext('2d')\n\nvi.spyOn(ctx, 'clearRect')\n\nrenderer.render(scene)\n\nexpect(ctx.clearRect).toHaveBeenCalledWith(0, 0, 800, 600)"
          },
          {
            "title": "render with background color",
            "line": 171,
            "source": "const scene = new Group2D()\nconst ctx = canvas.getContext('2d')\n\nrenderer.backgroundColor = '#ff0000'\nvi.spyOn(ctx, 'fillRect')\n\nrenderer.render(scene)\n\nexpect(ctx.fillRect).toHaveBeenCalledWith(0, 0, 800, 600)"
          },
          {
            "title": "render updates world matrix",
            "line": 184,
            "source": "const scene = new Group2D()\nvi.spyOn(scene, 'updateWorldMatrix')\n\nrenderer.render(scene)\n\nexpect(scene.updateWorldMatrix).toHaveBeenCalledWith(false)"
          },
          {
            "title": "render with visible object",
            "line": 194,
            "source": "const scene = new Group2D()\nconst circle = new Circle({radius: 10, color: '#ff0000'})\nscene.addChild(circle)\n\nexpect(() => renderer.render(scene)).not.toThrow()"
          },
          {
            "title": "render with invisible object",
            "line": 203,
            "source": "const scene = new Group2D()\nconst circle = new Circle({radius: 10, color: '#ff0000', visible: false})\nscene.addChild(circle)\n\nvi.spyOn(circle, 'render')\n\nrenderer.render(scene)\n\nexpect(circle.render).not.toHaveBeenCalled()"
          },
          {
            "title": "render with nested groups",
            "line": 216,
            "source": "const scene = new Group2D()\nconst group1 = new Group2D({x: 10, y: 20})\nconst group2 = new Group2D({x: 5, y: 5})\nconst circle = new Circle({radius: 10, color: '#ff0000'})\n\nscene.addChild(group1)\ngroup1.addChild(group2)\ngroup2.addChild(circle)\n\nexpect(() => renderer.render(scene)).not.toThrow()"
          },
          {
            "title": "render with opacity",
            "line": 230,
            "source": "const scene = new Group2D()\nconst circle = new Circle({radius: 10, color: '#ff0000', opacity: 0.5})\nscene.addChild(circle)\n\nexpect(() => renderer.render(scene)).not.toThrow()"
          },
          {
            "title": "render respects camera transformations",
            "line": 239,
            "source": "const scene = new Group2D()\nconst circle = new Circle({x: 0, y: 0, radius: 10, color: '#ff0000'})\nscene.addChild(circle)\n\nrenderer.camera.setPosition(5, 5)\nrenderer.camera.setZoom(2)\n\nexpect(() => renderer.render(scene)).not.toThrow()"
          },
          {
            "title": "render multiple objects",
            "line": 251,
            "source": "const scene = new Group2D()\nscene.addChild(\n    new Circle({x: 0, y: 0, radius: 10, color: '#ff0000'}),\n    new Rectangle({x: 50, y: 50, width: 20, height: 20, color: '#00ff00'}),\n    new Circle({x: -50, y: -50, radius: 15, color: '#0000ff'})\n)\n\nexpect(() => renderer.render(scene)).not.toThrow()"
          },
          {
            "title": "render with rotation",
            "line": 263,
            "source": "const scene = new Group2D()\nconst rect = new Rectangle({\n    x: 0,\n    y: 0,\n    width: 50,\n    height: 30,\n    rotation: Math.PI / 4,\n    color: '#ff0000'\n})\nscene.addChild(rect)\n\nexpect(() => renderer.render(scene)).not.toThrow()"
          },
          {
            "title": "render with scale",
            "line": 279,
            "source": "const scene = new Group2D()\nconst circle = new Circle({\n    x: 0,\n    y: 0,\n    radius: 10,\n    scaleX: 2,\n    scaleY: 3,\n    color: '#ff0000'\n})\nscene.addChild(circle)\n\nexpect(() => renderer.render(scene)).not.toThrow()"
          },
          {
            "title": "registerRenderer adds renderer for object types",
            "line": 295,
            "source": "class CustomObject {}\nconst customRenderer = {\n    constructor: {handles: [CustomObject]},\n    init: vi.fn(),\n    reset: vi.fn(),\n    flush: vi.fn(),\n    dispose: vi.fn()\n}\n\nconst result = renderer.registerRenderer(customRenderer)\n\nexpect(result).toBe(renderer)\nexpect(customRenderer.init).toHaveBeenCalled()"
          },
          {
            "title": "unregisterRenderer removes renderer",
            "line": 312,
            "source": "class CustomObject {}\nconst customRenderer = {\n    constructor: {handles: [CustomObject]},\n    init: vi.fn(),\n    reset: vi.fn(),\n    flush: vi.fn(),\n    dispose: vi.fn()\n}\n\nrenderer.registerRenderer(customRenderer)\nconst result = renderer.unregisterRenderer(customRenderer)\n\nexpect(result).toBe(renderer)\nexpect(customRenderer.dispose).toHaveBeenCalled()"
          }
        ],
        "describes": []
      }
    ]
  },
  "/render/webgl_renderer.doc.js": {
    "file": "/render/webgl_renderer.test.js",
    "describes": [
      {
        "title": "WebGLRenderer",
        "line": 34,
        "beforeEach": {
          "line": 39,
          "source": "canvas = document.createElement('canvas')\ncanvas.width = 800\ncanvas.height = 600\nrenderer = new WebGLRenderer({canvas})"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "setPixelRatio updates viewport on pixel ratio change",
            "line": 285,
            "source": "expect(() => renderer.setPixelRatio(2)).not.toThrow()"
          },
          {
            "title": "dispose cleans up resources",
            "line": 290,
            "source": "renderer.dispose()\n\nexpect(renderer.gl).toBe(null)\nexpect(renderer.canvas).toBe(null)"
          }
        ],
        "describes": [
          {
            "title": "constructor",
            "line": 47,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "uses provided canvas",
                "line": 49,
                "source": "expect(renderer.canvas).toBe(canvas)"
              },
              {
                "title": "gets WebGL context",
                "line": 54,
                "source": "expect(renderer.gl).toBeDefined()"
              },
              {
                "title": "initializes camera",
                "line": 59,
                "source": "expect(renderer.camera).toBeInstanceOf(Camera)"
              },
              {
                "title": "has static $name",
                "line": 64,
                "source": "expect(WebGLRenderer.$name).toBe('webGLRenderer')"
              },
              {
                "title": "with provided camera",
                "line": 69,
                "source": "const camera = new Camera({x: 10, y: 20})\nconst r = new WebGLRenderer({canvas, camera})\nexpect(r.camera).toBe(camera)"
              },
              {
                "title": "with backgroundColor",
                "line": 76,
                "source": "const r = new WebGLRenderer({canvas, backgroundColor: '#FF0000'})\nexpect(r.backgroundColor).toBe('#FF0000')"
              },
              {
                "title": "with enableCulling",
                "line": 82,
                "source": "const r = new WebGLRenderer({canvas, enableCulling: true})\nexpect(r.enableCulling).toBe(true)"
              },
              {
                "title": "initializes stats",
                "line": 88,
                "source": "expect(renderer.stats).toBeDefined()\nexpect(renderer.stats.totalObjects).toBe(0)\nexpect(renderer.stats.renderedObjects).toBe(0)\nexpect(renderer.stats.culledObjects).toBe(0)"
              }
            ],
            "describes": []
          },
          {
            "title": "shaderRegistry",
            "line": 98,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "has shaderRegistry accessor",
                "line": 100,
                "source": "expect(renderer.shaderRegistry).toBeDefined()"
              },
              {
                "title": "can register custom shaders",
                "line": 105,
                "source": "const definition = {\n    vertex: 'void main() {}',\n    fragment: 'void main() {}',\n    uniforms: [],\n    attributes: []\n}\n\nconst program = renderer.registerShader('custom', definition)\nexpect(program).toBeDefined()"
              },
              {
                "title": "can get registered shader",
                "line": 118,
                "source": "const definition = {\n    vertex: 'void main() {}',\n    fragment: 'void main() {}',\n    uniforms: [],\n    attributes: []\n}\n\nrenderer.registerShader('test', definition)\nconst shader = renderer.getShader('test')\nexpect(shader).toBeDefined()"
              }
            ],
            "describes": []
          },
          {
            "title": "shaderEffectRegistry",
            "line": 134,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "has shaderEffectRegistry accessor",
                "line": 136,
                "source": "expect(renderer.shaderEffectRegistry).toBeDefined()"
              },
              {
                "title": "registerShaderEffect registers an effect class",
                "line": 141,
                "source": "class TestEffect {\n    static shader = {\n        params: [],\n        uniforms: [],\n        fragment: ''\n    }\n}\n\nexpect(() => renderer.registerShaderEffect(TestEffect)).not.toThrow()\nexpect(renderer.shaderEffectRegistry.has('TestEffect')).toBe(true)"
              },
              {
                "title": "setUniform stores uniform value",
                "line": 155,
                "source": "renderer.setUniform('uTime', 1.5)\nexpect(renderer.getUniform('uTime')).toBe(1.5)"
              },
              {
                "title": "setUniform with type stores uniform value and type",
                "line": 161,
                "source": "renderer.setUniform('uResolution', [800, 600], 'vec2')\nexpect(renderer.getUniform('uResolution')).toEqual([800, 600])"
              },
              {
                "title": "setUniform returns this for chaining",
                "line": 167,
                "source": "const result = renderer.setUniform('uTime', 1.0)\nexpect(result).toBe(renderer)"
              },
              {
                "title": "getUniform returns undefined for unknown uniform",
                "line": 173,
                "source": "expect(renderer.getUniform('uUnknown')).toBeUndefined()"
              }
            ],
            "describes": []
          },
          {
            "title": "postProcessor",
            "line": 180,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "has postProcessor accessor",
                "line": 182,
                "source": "expect(renderer.postProcessor).toBeDefined()"
              },
              {
                "title": "can add post pass",
                "line": 187,
                "source": "const pass = renderer.addPostPass(MockPass)\nexpect(renderer.postProcessor.passes.length).toBe(1)\nexpect(pass).toBeInstanceOf(MockPass)"
              },
              {
                "title": "can get post pass by name",
                "line": 194,
                "source": "renderer.addPostPass(MockPass)\nexpect(renderer.getPass('mockPass')).toBeInstanceOf(MockPass)"
              },
              {
                "title": "can remove post pass",
                "line": 200,
                "source": "const pass = renderer.addPostPass(MockPass)\nrenderer.removePostPass(pass)\nexpect(renderer.postProcessor.passes.length).toBe(0)"
              },
              {
                "title": "postPasses returns all render passes",
                "line": 207,
                "source": "renderer.addPostPass(MockPass)\nexpect(renderer.postPasses.length).toBe(1)"
              }
            ],
            "describes": []
          },
          {
            "title": "render",
            "line": 215,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "renders empty scene without error",
                "line": 217,
                "source": "const scene = new Group2D()\nexpect(() => renderer.render(scene)).not.toThrow()"
              },
              {
                "title": "clears the canvas",
                "line": 223,
                "source": "const scene = new Group2D()\nexpect(() => renderer.render(scene)).not.toThrow()"
              },
              {
                "title": "updates world matrix",
                "line": 229,
                "source": "const scene = new Group2D()\nvi.spyOn(scene, 'updateWorldMatrix')\n\nrenderer.render(scene)\n\nexpect(scene.updateWorldMatrix).toHaveBeenCalledWith(false)"
              },
              {
                "title": "renders circle",
                "line": 239,
                "source": "const scene = new Group2D()\nconst circle = new Circle({radius: 1, color: '#FF0000'})\nscene.addChild(circle)\n\nexpect(() => renderer.render(scene)).not.toThrow()"
              },
              {
                "title": "renders rectangle",
                "line": 248,
                "source": "const scene = new Group2D()\nconst rect = new Rectangle({width: 2, height: 1, color: '#00FF00'})\nscene.addChild(rect)\n\nexpect(() => renderer.render(scene)).not.toThrow()"
              },
              {
                "title": "skips invisible objects",
                "line": 257,
                "source": "const scene = new Group2D()\nconst circle = new Circle({radius: 1, color: '#FF0000', visible: false})\nscene.addChild(circle)\n\nrenderer.render(scene)\nexpect(renderer.stats.totalObjects).toBe(1)"
              },
              {
                "title": "applies opacity inheritance",
                "line": 267,
                "source": "const scene = new Group2D({opacity: 0.5})\nconst circle = new Circle({radius: 1, color: '#FF0000', opacity: 0.5})\nscene.addChild(circle)\n\nexpect(() => renderer.render(scene)).not.toThrow()"
              },
              {
                "title": "renders with background color",
                "line": 276,
                "source": "renderer.backgroundColor = '#0000FF'\nconst scene = new Group2D()\nexpect(() => renderer.render(scene)).not.toThrow()"
              }
            ],
            "describes": []
          },
          {
            "title": "registerRenderer and unregisterRenderer",
            "line": 298,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "registerRenderer adds custom renderer",
                "line": 300,
                "source": "class CustomObject {}\nclass CustomRenderer {\n    static get handles () {\n        return [CustomObject]\n    }\n\n    init = vi.fn()\n    reset = vi.fn()\n    flush = vi.fn()\n    dispose = vi.fn()\n}\n\nconst customRenderer = new CustomRenderer()\nconst result = renderer.registerRenderer(customRenderer)\n\nexpect(result).toBe(renderer)\nexpect(customRenderer.init).toHaveBeenCalled()"
              },
              {
                "title": "unregisterRenderer removes renderer",
                "line": 321,
                "source": "class CustomObject {}\nclass CustomRenderer {\n    static get handles () {\n        return [CustomObject]\n    }\n\n    init = vi.fn()\n    reset = vi.fn()\n    flush = vi.fn()\n    dispose = vi.fn()\n}\n\nconst customRenderer = new CustomRenderer()\nrenderer.registerRenderer(customRenderer)\n\nconst result = renderer.unregisterRenderer(customRenderer)\n\nexpect(result).toBe(renderer)\nexpect(customRenderer.dispose).toHaveBeenCalled()"
              }
            ],
            "describes": []
          },
          {
            "title": "applyPixelRatio",
            "line": 346,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "applyPixelRatio updates viewport",
                "line": 348,
                "source": "renderer.pixelRatio = 2\nexpect(() => renderer.applyPixelRatio()).not.toThrow()"
              },
              {
                "title": "applyPixelRatio resizes post processor",
                "line": 354,
                "source": "const originalWidth = canvas.width\nconst originalHeight = canvas.height\n\nrenderer.applyPixelRatio()\n\nexpect(renderer.gl).toBeDefined()\nexpect(canvas.width).toBe(originalWidth)\nexpect(canvas.height).toBe(originalHeight)"
              }
            ],
            "describes": []
          },
          {
            "title": "setRenderGroups and clearRenderGroups",
            "line": 368,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "setRenderGroups creates render groups",
                "line": 370,
                "source": "const scene = new Group2D()\n\nrenderer.setRenderGroups([\n    {$id: 'background', content: scene},\n    {$id: 'foreground', content: scene}\n])\n\nexpect(renderer.renderGroups.length).toBe(2)"
              },
              {
                "title": "setRenderGroups returns this for chaining",
                "line": 382,
                "source": "const scene = new Group2D()\n\nconst result = renderer.setRenderGroups([\n    {$id: 'test', content: scene}\n])\n\nexpect(result).toBe(renderer)"
              },
              {
                "title": "clearRenderGroups removes all render groups",
                "line": 393,
                "source": "const scene = new Group2D()\n\nrenderer.setRenderGroups([\n    {$id: 'group1', content: scene},\n    {$id: 'group2', content: scene}\n])\n\nexpect(renderer.renderGroups.length).toBe(2)\n\nconst result = renderer.clearRenderGroups()\n\nexpect(result).toBe(renderer)\nexpect(renderer.renderGroups.length).toBe(0)"
              },
              {
                "title": "setRenderGroups clears previous groups",
                "line": 410,
                "source": "const scene = new Group2D()\n\nrenderer.setRenderGroups([\n    {$id: 'oldGroup', content: scene}\n])\n\nrenderer.setRenderGroups([\n    {$id: 'newGroup', content: scene}\n])\n\nexpect(renderer.renderGroups.length).toBe(1)\nexpect(renderer.renderGroups[0].$id).toBe('newGroup')"
              }
            ],
            "describes": []
          },
          {
            "title": "prependRenderGroup",
            "line": 428,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "adds group at the beginning",
                "line": 430,
                "source": "const scene1 = new Group2D()\nconst scene2 = new Group2D()\n\nrenderer.appendRenderGroup({$id: 'existing', content: scene1})\nrenderer.prependRenderGroup({$id: 'first', content: scene2})\n\nexpect(renderer.renderGroups.length).toBe(2)\nexpect(renderer.renderGroups[0].$id).toBe('first')\nexpect(renderer.renderGroups[1].$id).toBe('existing')"
              },
              {
                "title": "returns the created group",
                "line": 443,
                "source": "const scene = new Group2D()\n\nconst group = renderer.prependRenderGroup({$id: 'test', content: scene})\n\nexpect(group).toBeDefined()\nexpect(group.$id).toBe('test')"
              },
              {
                "title": "creates group with content",
                "line": 453,
                "source": "const scene = new Group2D()\n\nconst group = renderer.prependRenderGroup({$id: 'test', content: scene})\n\nexpect(group.content).toBe(scene)"
              }
            ],
            "describes": []
          },
          {
            "title": "appendRenderGroup",
            "line": 464,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "adds group at the end",
                "line": 466,
                "source": "const scene1 = new Group2D()\nconst scene2 = new Group2D()\n\nrenderer.appendRenderGroup({$id: 'first', content: scene1})\nrenderer.appendRenderGroup({$id: 'second', content: scene2})\n\nexpect(renderer.renderGroups.length).toBe(2)\nexpect(renderer.renderGroups[0].$id).toBe('first')\nexpect(renderer.renderGroups[1].$id).toBe('second')"
              },
              {
                "title": "returns the created group",
                "line": 479,
                "source": "const scene = new Group2D()\n\nconst group = renderer.appendRenderGroup({$id: 'test', content: scene})\n\nexpect(group).toBeDefined()\nexpect(group.$id).toBe('test')"
              },
              {
                "title": "creates group with content",
                "line": 489,
                "source": "const scene = new Group2D()\n\nconst group = renderer.appendRenderGroup({$id: 'test', content: scene})\n\nexpect(group.content).toBe(scene)"
              }
            ],
            "describes": []
          },
          {
            "title": "removeRenderGroup",
            "line": 500,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "removes group by id string",
                "line": 502,
                "source": "const scene = new Group2D()\n\nrenderer.appendRenderGroup({$id: 'group1', content: scene})\nrenderer.appendRenderGroup({$id: 'group2', content: scene})\n\nexpect(renderer.renderGroups.length).toBe(2)\n\nconst result = renderer.removeRenderGroup('group1')\n\nexpect(result).toBe(renderer)\nexpect(renderer.renderGroups.length).toBe(1)\nexpect(renderer.renderGroups[0].$id).toBe('group2')"
              },
              {
                "title": "removes group by group object",
                "line": 518,
                "source": "const scene = new Group2D()\n\nconst group1 = renderer.appendRenderGroup({$id: 'group1', content: scene})\nrenderer.appendRenderGroup({$id: 'group2', content: scene})\n\nconst result = renderer.removeRenderGroup(group1)\n\nexpect(result).toBe(renderer)\nexpect(renderer.renderGroups.length).toBe(1)\nexpect(renderer.renderGroups[0].$id).toBe('group2')"
              },
              {
                "title": "does nothing for non-existent group",
                "line": 532,
                "source": "const scene = new Group2D()\n\nrenderer.appendRenderGroup({$id: 'existing', content: scene})\n\nconst result = renderer.removeRenderGroup('nonexistent')\n\nexpect(result).toBe(renderer)\nexpect(renderer.renderGroups.length).toBe(1)"
              },
              {
                "title": "removes correct group when multiple exist",
                "line": 544,
                "source": "const scene = new Group2D()\n\nrenderer.appendRenderGroup({$id: 'first', content: scene})\nrenderer.appendRenderGroup({$id: 'middle', content: scene})\nrenderer.appendRenderGroup({$id: 'last', content: scene})\n\nrenderer.removeRenderGroup('middle')\n\nexpect(renderer.renderGroups.length).toBe(2)\nexpect(renderer.renderGroups[0].$id).toBe('first')\nexpect(renderer.renderGroups[1].$id).toBe('last')"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/render/base_renderer.doc.js": {
    "file": "/render/base_renderer.test.js",
    "describes": [
      {
        "title": "BaseRenderer",
        "line": 5,
        "beforeEach": {
          "line": 10,
          "source": "container = document.createElement('div')\ndocument.body.appendChild(container)\nrenderer = new BaseRenderer({container})"
        },
        "afterEach": null,
        "tests": [],
        "describes": [
          {
            "title": "constructor",
            "line": 17,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates BaseRenderer instance",
                "line": 19,
                "source": "expect(renderer).toBeInstanceOf(BaseRenderer)"
              },
              {
                "title": "creates canvas element",
                "line": 24,
                "source": "expect(renderer.canvas).toBeInstanceOf(HTMLCanvasElement)"
              },
              {
                "title": "uses provided canvas",
                "line": 29,
                "source": "const customCanvas = document.createElement('canvas')\nconst r = new BaseRenderer({canvas: customCanvas})\nexpect(r.canvas).toBe(customCanvas)"
              },
              {
                "title": "sets default dimensions",
                "line": 36,
                "source": "expect(renderer.displayWidth).toBeDefined()\nexpect(renderer.displayHeight).toBeDefined()"
              },
              {
                "title": "sets custom dimensions",
                "line": 42,
                "source": "const r = new BaseRenderer({width: 1024, height: 768})\nexpect(r.displayWidth).toBe(1024)\nexpect(r.displayHeight).toBe(768)"
              },
              {
                "title": "has category renderer",
                "line": 49,
                "source": "expect(renderer.$category).toBe('renderer')"
              },
              {
                "title": "creates default camera",
                "line": 54,
                "source": "expect(renderer.camera).toBeDefined()"
              }
            ],
            "describes": []
          },
          {
            "title": "container",
            "line": 61,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "gets container from canvas parent",
                "line": 63,
                "source": "expect(renderer.container).toBe(container)"
              },
              {
                "title": "sets container and appends canvas",
                "line": 68,
                "source": "const newContainer = document.createElement('div')\nrenderer.container = newContainer\nexpect(renderer.canvas.parentElement).toBe(newContainer)"
              }
            ],
            "describes": []
          },
          {
            "title": "autoFitEnabled",
            "line": 77,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "disabled by default",
                "line": 79,
                "source": "expect(renderer.autoFitEnabled).toBe(false)"
              },
              {
                "title": "enables autoFit",
                "line": 84,
                "source": "renderer.autoFitEnabled = true\nexpect(renderer.autoFitEnabled).toBe(true)"
              },
              {
                "title": "disables autoFit",
                "line": 90,
                "source": "renderer.autoFitEnabled = true\nrenderer.autoFitEnabled = false\nexpect(renderer.autoFitEnabled).toBe(false)"
              },
              {
                "title": "enabled via option",
                "line": 97,
                "source": "const r = new BaseRenderer({autoFit: true, container})\nexpect(r.autoFitEnabled).toBe(true)"
              }
            ],
            "describes": []
          },
          {
            "title": "pixelRatio",
            "line": 105,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "defaults to 1",
                "line": 107,
                "source": "expect(renderer.pixelRatio).toBe(1)"
              },
              {
                "title": "sets custom pixelRatio",
                "line": 112,
                "source": "const r = new BaseRenderer({pixelRatio: 2})\nexpect(r.pixelRatio).toBe(2)"
              },
              {
                "title": "applyPixelRatio scales canvas dimensions",
                "line": 118,
                "source": "renderer.displayWidth = 100\nrenderer.displayHeight = 100\nrenderer.pixelRatio = 2\nrenderer.applyPixelRatio()\n\nexpect(renderer.canvas.width).toBe(200)\nexpect(renderer.canvas.height).toBe(200)"
              },
              {
                "title": "setPixelRatio updates pixelRatio",
                "line": 129,
                "source": "renderer.setPixelRatio(3)\nexpect(renderer.pixelRatio).toBe(3)"
              },
              {
                "title": "setPixelRatio returns this",
                "line": 135,
                "source": "expect(renderer.setPixelRatio(2)).toBe(renderer)"
              }
            ],
            "describes": []
          },
          {
            "title": "resize",
            "line": 142,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "updates display dimensions",
                "line": 144,
                "source": "renderer.resize(500, 400)\nexpect(renderer.displayWidth).toBe(500)\nexpect(renderer.displayHeight).toBe(400)"
              },
              {
                "title": "updates canvas style",
                "line": 151,
                "source": "renderer.resize(500, 400)\nexpect(renderer.canvas.style.width).toBe('500px')\nexpect(renderer.canvas.style.height).toBe('400px')"
              },
              {
                "title": "returns this",
                "line": 158,
                "source": "expect(renderer.resize(100, 100)).toBe(renderer)"
              }
            ],
            "describes": []
          },
          {
            "title": "resizeToContainer",
            "line": 165,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns this",
                "line": 167,
                "source": "expect(renderer.resizeToContainer()).toBe(renderer)"
              },
              {
                "title": "does not throw without container",
                "line": 172,
                "source": "const r = new BaseRenderer({})\nexpect(() => r.resizeToContainer()).not.toThrow()"
              }
            ],
            "describes": []
          },
          {
            "title": "dispose",
            "line": 180,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "sets canvas to null",
                "line": 182,
                "source": "renderer.dispose()\nexpect(renderer.canvas).toBeNull()"
              },
              {
                "title": "sets camera to null",
                "line": 188,
                "source": "renderer.dispose()\nexpect(renderer.camera).toBeNull()"
              },
              {
                "title": "removes canvas from DOM",
                "line": 194,
                "source": "renderer.dispose()\nexpect(container.children.length).toBe(0)"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/render/camera.doc.js": {
    "file": "/render/camera.test.js",
    "describes": [
      {
        "title": "Camera",
        "line": 6,
        "beforeEach": {
          "line": 10,
          "source": "camera = new Camera()"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "extends PerkyModule",
            "line": 15,
            "source": "expect(camera).toBeInstanceOf(PerkyModule)"
          },
          {
            "title": "$category",
            "line": 20,
            "source": "expect(Camera.$category).toBe('camera')\nexpect(camera.$category).toBe('camera')"
          },
          {
            "title": "constructor defaults",
            "line": 26,
            "source": "expect(camera.x).toBe(0)\nexpect(camera.y).toBe(0)\nexpect(camera.zoom).toBe(1)\nexpect(camera.unitsInView).toEqual({height: 10})\nexpect(camera.viewportWidth).toBe(800)\nexpect(camera.viewportHeight).toBe(600)\nexpect(camera.followTarget).toBe(null)\nexpect(camera.followSpeed).toBe(0.1)"
          },
          {
            "title": "constructor with options",
            "line": 38,
            "source": "const cam = new Camera({\n    x: 10,\n    y: 20,\n    zoom: 2,\n    unitsInView: 5,\n    viewportWidth: 1024,\n    viewportHeight: 768\n})\n\nexpect(cam.x).toBe(10)\nexpect(cam.y).toBe(20)\nexpect(cam.zoom).toBe(2)\nexpect(cam.unitsInView).toEqual({height: 5})\nexpect(cam.viewportWidth).toBe(1024)\nexpect(cam.viewportHeight).toBe(768)"
          },
          {
            "title": "pixelsPerUnit",
            "line": 57,
            "source": "camera.unitsInView = {height: 10}\ncamera.viewportHeight = 600\ncamera.zoom = 1\n\nexpect(camera.pixelsPerUnit).toBe(60)\n\ncamera.zoom = 2\nexpect(camera.pixelsPerUnit).toBe(120)"
          },
          {
            "title": "setUnitsInView",
            "line": 69,
            "source": "const result = camera.setUnitsInView(5)\n\nexpect(camera.unitsInView).toEqual({height: 5})\nexpect(result).toBe(camera)"
          },
          {
            "title": "setZoom",
            "line": 77,
            "source": "const result = camera.setZoom(2)\n\nexpect(camera.zoom).toBe(2)\nexpect(result).toBe(camera)"
          },
          {
            "title": "setPosition",
            "line": 85,
            "source": "const result = camera.setPosition(10, 20)\n\nexpect(camera.x).toBe(10)\nexpect(camera.y).toBe(20)\nexpect(result).toBe(camera)"
          },
          {
            "title": "follow",
            "line": 94,
            "source": "const target = {x: 100, y: 200}\nconst result = camera.follow(target, 0.2)\n\nexpect(camera.followTarget).toBe(target)\nexpect(camera.followSpeed).toBe(0.2)\nexpect(result).toBe(camera)"
          },
          {
            "title": "update without follow",
            "line": 104,
            "source": "camera.x = 10\ncamera.y = 20\n\ncamera.update()\n\nexpect(camera.x).toBe(10)\nexpect(camera.y).toBe(20)"
          },
          {
            "title": "update with follow",
            "line": 115,
            "source": "const target = {x: 100, y: 200}\ncamera.follow(target, 0.1)\ncamera.x = 0\ncamera.y = 0\n\ncamera.update()\n\nexpect(camera.x).toBeCloseTo(10)\nexpect(camera.y).toBeCloseTo(20)"
          },
          {
            "title": "worldToScreen",
            "line": 128,
            "source": "camera.x = 0\ncamera.y = 0\ncamera.unitsInView = {height: 10}\ncamera.viewportWidth = 800\ncamera.viewportHeight = 600\ncamera.zoom = 1\n\nconst result = camera.worldToScreen(0, 0)\nexpect(result.x).toBe(400)\nexpect(result.y).toBe(300)\n\nconst result2 = camera.worldToScreen(5, 5)\nexpect(result2.x).toBeCloseTo(700)\nexpect(result2.y).toBeCloseTo(0)"
          },
          {
            "title": "screenToWorld",
            "line": 146,
            "source": "camera.x = 0\ncamera.y = 0\ncamera.unitsInView = {height: 10}\ncamera.viewportWidth = 800\ncamera.viewportHeight = 600\ncamera.zoom = 1\n\nconst result = camera.screenToWorld(400, 300)\nexpect(result.x).toBeCloseTo(0)\nexpect(result.y).toBeCloseTo(0)\n\nconst result2 = camera.screenToWorld(700, 0)\nexpect(result2.x).toBeCloseTo(5)\nexpect(result2.y).toBeCloseTo(5)"
          },
          {
            "title": "applyToContext",
            "line": 164,
            "source": "const ctx = {\n    translate: vi.fn(),\n    scale: vi.fn()\n}\n\ncamera.viewportWidth = 800\ncamera.viewportHeight = 600\ncamera.unitsInView = {height: 10}\ncamera.zoom = 1\ncamera.x = 5\ncamera.y = 10\n\ncamera.applyToContext(ctx)\n\nexpect(ctx.translate).toHaveBeenCalledTimes(2)\nexpect(ctx.translate).toHaveBeenNthCalledWith(1, 400, 300)\nexpect(ctx.translate).toHaveBeenNthCalledWith(2, -5, -10)\nexpect(ctx.scale).toHaveBeenCalledWith(60, -60)"
          },
          {
            "title": "isVisible with visible bounds",
            "line": 186,
            "source": "camera.x = 0\ncamera.y = 0\ncamera.viewportWidth = 800\ncamera.viewportHeight = 600\ncamera.unitsInView = {height: 10}\ncamera.zoom = 1\n\nconst bounds = {minX: -1, minY: -1, maxX: 1, maxY: 1, width: 2, height: 2}\nexpect(camera.isVisible(bounds)).toBe(true)"
          },
          {
            "title": "isVisible with bounds outside camera",
            "line": 199,
            "source": "camera.x = 0\ncamera.y = 0\ncamera.viewportWidth = 800\ncamera.viewportHeight = 600\ncamera.unitsInView = {height: 10}\ncamera.zoom = 1\n\nconst bounds = {minX: 100, minY: 100, maxX: 110, maxY: 110, width: 10, height: 10}\nexpect(camera.isVisible(bounds)).toBe(false)"
          },
          {
            "title": "isVisible with partially visible bounds",
            "line": 212,
            "source": "camera.x = 0\ncamera.y = 0\ncamera.viewportWidth = 800\ncamera.viewportHeight = 600\ncamera.unitsInView = {height: 10}\ncamera.zoom = 1\n\nconst bounds = {minX: 5, minY: -1, maxX: 10, maxY: 1, width: 5, height: 2}\nexpect(camera.isVisible(bounds)).toBe(true)"
          },
          {
            "title": "isVisible with empty bounds",
            "line": 225,
            "source": "camera.x = 0\ncamera.y = 0\ncamera.viewportWidth = 800\ncamera.viewportHeight = 600\ncamera.unitsInView = {height: 10}\ncamera.zoom = 1\n\nconst bounds = {minX: 0, minY: 0, maxX: 0, maxY: 0, width: 0, height: 0}\nexpect(camera.isVisible(bounds)).toBe(false)"
          },
          {
            "title": "rotation defaults to 0",
            "line": 238,
            "source": "expect(camera.rotation).toBe(0)"
          },
          {
            "title": "rotation can be set",
            "line": 243,
            "source": "camera.rotation = Math.PI / 4\nexpect(camera.rotation).toBeCloseTo(Math.PI / 4)"
          },
          {
            "title": "worldToScreen with rotation",
            "line": 249,
            "source": "camera.x = 0\ncamera.y = 0\ncamera.rotation = Math.PI / 2\ncamera.viewportWidth = 800\ncamera.viewportHeight = 600\ncamera.unitsInView = {height: 10}\ncamera.zoom = 1\n\nconst result = camera.worldToScreen(1, 0)\n\nexpect(result.x).toBeCloseTo(400)\nexpect(result.y).toBeCloseTo(360)"
          },
          {
            "title": "screenToWorld with rotation",
            "line": 265,
            "source": "camera.x = 0\ncamera.y = 0\ncamera.rotation = Math.PI / 2\ncamera.viewportWidth = 800\ncamera.viewportHeight = 600\ncamera.unitsInView = {height: 10}\ncamera.zoom = 1\n\nconst result = camera.screenToWorld(400, 240)\n\nexpect(result.x).toBeCloseTo(-1, 0.01)\nexpect(result.y).toBeCloseTo(0, 0.01)"
          },
          {
            "title": "worldToScreen and screenToWorld are inverse operations with rotation",
            "line": 281,
            "source": "camera.x = 5\ncamera.y = 3\ncamera.rotation = Math.PI / 3\ncamera.viewportWidth = 800\ncamera.viewportHeight = 600\ncamera.unitsInView = {height: 10}\ncamera.zoom = 1.5\n\nconst worldPoint = {x: 10, y: 7}\nconst screen = camera.worldToScreen(worldPoint.x, worldPoint.y)\nconst backToWorld = camera.screenToWorld(screen.x, screen.y)\n\nexpect(backToWorld.x).toBeCloseTo(worldPoint.x, 0.01)\nexpect(backToWorld.y).toBeCloseTo(worldPoint.y, 0.01)"
          },
          {
            "title": "stopFollow clears followTarget",
            "line": 417,
            "source": "const target = {x: 100, y: 200}\ncamera.follow(target)\n\nexpect(camera.followTarget).toBe(target)\n\nconst result = camera.stopFollow()\n\nexpect(camera.followTarget).toBeNull()\nexpect(result).toBe(camera)"
          },
          {
            "title": "animateTo sets up transition",
            "line": 430,
            "source": "camera.x = 0\ncamera.y = 0\ncamera.zoom = 1\ncamera.rotation = 0\n\nconst result = camera.animateTo({\n    x: 10,\n    y: 20,\n    zoom: 2,\n    rotation: Math.PI\n}, {duration: 2, easing: 'linear'})\n\nexpect(camera.transition).not.toBeNull()\nexpect(camera.transition.startX).toBe(0)\nexpect(camera.transition.startY).toBe(0)\nexpect(camera.transition.targetX).toBe(10)\nexpect(camera.transition.targetY).toBe(20)\nexpect(camera.transition.targetZoom).toBe(2)\nexpect(camera.transition.duration).toBe(2)\nexpect(result).toBe(camera)"
          },
          {
            "title": "transitionTo animates to another camera state",
            "line": 454,
            "source": "const otherCamera = new Camera({x: 50, y: 100, zoom: 3, rotation: Math.PI / 2})\n\ncamera.transitionTo(otherCamera, {duration: 1})\n\nexpect(camera.transition.targetX).toBe(50)\nexpect(camera.transition.targetY).toBe(100)\nexpect(camera.transition.targetZoom).toBe(3)\nexpect(camera.transition.targetRotation).toBe(Math.PI / 2)"
          },
          {
            "title": "cancelTransition clears transition",
            "line": 466,
            "source": "camera.animateTo({x: 10, y: 20}, {duration: 1})\n\nexpect(camera.transition).not.toBeNull()\n\nconst result = camera.cancelTransition()\n\nexpect(camera.transition).toBeNull()\nexpect(result).toBe(camera)"
          },
          {
            "title": "animate adds effect to effects array",
            "line": 478,
            "source": "const handler = vi.fn()\n\nconst result = camera.animate(handler, {duration: 2})\n\nexpect(camera.effects).toHaveLength(1)\nexpect(camera.effects[0].handler).toBe(handler)\nexpect(camera.effects[0].duration).toBe(2)\nexpect(result).toBe(camera)"
          },
          {
            "title": "shake adds shake effect",
            "line": 490,
            "source": "const result = camera.shake({intensity: 0.5, duration: 0.3})\n\nexpect(camera.effects).toHaveLength(1)\nexpect(camera.effects[0].duration).toBe(0.3)\nexpect(result).toBe(camera)"
          },
          {
            "title": "clearEffects removes all effects and resets offsets",
            "line": 499,
            "source": "camera.animate(() => {})\ncamera.offsetX = 5\ncamera.offsetY = 3\ncamera.offsetZoom = 0.5\ncamera.offsetRotation = 0.1\n\nconst result = camera.clearEffects()\n\nexpect(camera.effects).toHaveLength(0)\nexpect(camera.offsetX).toBe(0)\nexpect(camera.offsetY).toBe(0)\nexpect(camera.offsetZoom).toBe(0)\nexpect(camera.offsetRotation).toBe(0)\nexpect(result).toBe(camera)"
          },
          {
            "title": "worldToScreenCSS returns same as worldToScreen",
            "line": 517,
            "source": "camera.x = 5\ncamera.y = 10\ncamera.viewportWidth = 800\ncamera.viewportHeight = 600\ncamera.unitsInView = {height: 10}\n\nconst worldX = 7\nconst worldY = 12\n\nconst screenResult = camera.worldToScreen(worldX, worldY)\nconst cssResult = camera.worldToScreenCSS(worldX, worldY)\n\nexpect(cssResult.x).toBe(screenResult.x)\nexpect(cssResult.y).toBe(screenResult.y)"
          }
        ],
        "describes": [
          {
            "title": "unitsInView modes",
            "line": 299,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "height-based mode with explicit object",
                "line": 301,
                "source": "const cam = new Camera({\n    unitsInView: {height: 10},\n    viewportWidth: 800,\n    viewportHeight: 600\n})\n\nexpect(cam.unitsInView).toEqual({height: 10})\nexpect(cam.pixelsPerUnit).toBe(60) // 600 / 10"
              },
              {
                "title": "width-based mode",
                "line": 313,
                "source": "const cam = new Camera({\n    unitsInView: {width: 20},\n    viewportWidth: 800,\n    viewportHeight: 600\n})\n\nexpect(cam.unitsInView).toEqual({width: 20})\nexpect(cam.pixelsPerUnit).toBe(40) // 800 / 20"
              },
              {
                "title": "cover mode shows at least both dimensions",
                "line": 325,
                "source": "// Landscape viewport (800x600, ratio 4:3)\nconst cam = new Camera({\n    unitsInView: {width: 14, height: 5},\n    viewportWidth: 800,\n    viewportHeight: 600\n})\n\nexpect(cam.unitsInView).toEqual({width: 14, height: 5})\n\n// Should use height as constraint (smaller ppu to show both)\n// ppuForWidth = 800 / 14  57.14\n// ppuForHeight = 600 / 5 = 120\n// min(57.14, 120) = 57.14\nexpect(cam.pixelsPerUnit).toBeCloseTo(57.14, 1)"
              },
              {
                "title": "cover mode on portrait viewport",
                "line": 343,
                "source": "// Portrait viewport (600x800, ratio 3:4)\nconst cam = new Camera({\n    unitsInView: {width: 14, height: 5},\n    viewportWidth: 600,\n    viewportHeight: 800\n})\n\n// ppuForWidth = 600 / 14  42.86\n// ppuForHeight = 800 / 5 = 160\n// min(42.86, 160) = 42.86\nexpect(cam.pixelsPerUnit).toBeCloseTo(42.86, 1)"
              },
              {
                "title": "cover mode on square viewport",
                "line": 358,
                "source": "// Square viewport (800x800)\nconst cam = new Camera({\n    unitsInView: {width: 10, height: 10},\n    viewportWidth: 800,\n    viewportHeight: 800\n})\n\n// ppuForWidth = 800 / 10 = 80\n// ppuForHeight = 800 / 10 = 80\n// min(80, 80) = 80\nexpect(cam.pixelsPerUnit).toBe(80)"
              },
              {
                "title": "setUnitsInView with width object",
                "line": 373,
                "source": "const result = camera.setUnitsInView({width: 15})\n\nexpect(camera.unitsInView).toEqual({width: 15})\nexpect(result).toBe(camera)"
              },
              {
                "title": "setUnitsInView with cover mode object",
                "line": 381,
                "source": "const result = camera.setUnitsInView({width: 14, height: 5})\n\nexpect(camera.unitsInView).toEqual({width: 14, height: 5})\nexpect(result).toBe(camera)"
              },
              {
                "title": "width-based mode with zoom",
                "line": 389,
                "source": "const cam = new Camera({\n    unitsInView: {width: 20},\n    viewportWidth: 800,\n    viewportHeight: 600,\n    zoom: 2\n})\n\n// (800 / 20) * 2 = 80\nexpect(cam.pixelsPerUnit).toBe(80)"
              },
              {
                "title": "cover mode with zoom",
                "line": 402,
                "source": "const cam = new Camera({\n    unitsInView: {width: 14, height: 5},\n    viewportWidth: 800,\n    viewportHeight: 600,\n    zoom: 1.5\n})\n\n// min(800/14, 600/5) * 1.5  57.14 * 1.5  85.71\nexpect(cam.pixelsPerUnit).toBeCloseTo(85.71, 1)"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/render/canvas_layer.doc.js": {
    "file": "/render/canvas_layer.test.js",
    "describes": [
      {
        "title": "CanvasLayer",
        "line": 8,
        "beforeEach": {
          "line": 12,
          "source": "layer = new CanvasLayer({$id: 'test-canvas'})"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor creates canvas element",
            "line": 17,
            "source": "expect(layer.canvas).toBeInstanceOf(HTMLCanvasElement)\nexpect(layer.element).toBe(layer.canvas)\nexpect(layer.canvas.style.position).toBe('absolute')"
          },
          {
            "title": "constructor creates renderer",
            "line": 24,
            "source": "expect(layer.renderer).toBeDefined()\nexpect(layer.renderer.canvas).toBe(layer.canvas)"
          },
          {
            "title": "constructor creates default camera if not provided",
            "line": 30,
            "source": "expect(layer.renderer.camera).toBeInstanceOf(Camera)"
          },
          {
            "title": "constructor with provided camera",
            "line": 35,
            "source": "const camera = new Camera({x: 10, y: 20})\nconst l = new CanvasLayer({$id: 'test', camera})\n\nexpect(l.renderer.camera).toBe(camera)"
          },
          {
            "title": "constructor with custom dimensions",
            "line": 43,
            "source": "const l = new CanvasLayer({\n    $id: 'test',\n    width: 1024,\n    height: 768\n})\n\nexpect(l.canvas.width).toBe(1024)\nexpect(l.canvas.height).toBe(768)"
          },
          {
            "title": "constructor with pixelRatio",
            "line": 55,
            "source": "const l = new CanvasLayer({\n    $id: 'test',\n    width: 800,\n    height: 600,\n    pixelRatio: 2\n})\n\nexpect(l.canvas.width).toBe(1600)\nexpect(l.canvas.height).toBe(1200)\n\nexpect(l.canvas.style.width).toBe('800px')\nexpect(l.canvas.style.height).toBe('600px')"
          },
          {
            "title": "constructor with backgroundColor option",
            "line": 71,
            "source": "const l = new CanvasLayer({$id: 'test', backgroundColor: '#FF0000'})\nexpect(l.renderer.backgroundColor).toBe('#FF0000')"
          },
          {
            "title": "constructor with enableCulling option",
            "line": 77,
            "source": "const l = new CanvasLayer({$id: 'test', enableCulling: true})\nexpect(l.renderer.enableCulling).toBe(true)"
          },
          {
            "title": "setContent stores content",
            "line": 83,
            "source": "const scene = new Group2D()\nlayer.setContent(scene)\n\nexpect(layer.content).toBe(scene)"
          },
          {
            "title": "render calls renderer.render",
            "line": 91,
            "source": "const scene = new Group2D()\nlayer.setContent(scene)\n\nexpect(() => layer.render()).not.toThrow()"
          },
          {
            "title": "render does nothing when no content",
            "line": 99,
            "source": "layer.content = null\nexpect(() => layer.render()).not.toThrow()"
          },
          {
            "title": "resize updates canvas dimensions",
            "line": 105,
            "source": "layer.resize(1024, 768)\n\nexpect(layer.canvas.width).toBe(1024)\nexpect(layer.canvas.height).toBe(768)"
          },
          {
            "title": "resize with pixelRatio scales internal canvas",
            "line": 113,
            "source": "const l = new CanvasLayer({$id: 'test', pixelRatio: 2})\n\nl.resize(800, 600)\n\nexpect(l.canvas.width).toBe(1600)\nexpect(l.canvas.height).toBe(1200)\nexpect(l.canvas.style.width).toBe('800px')\nexpect(l.canvas.style.height).toBe('600px')"
          },
          {
            "title": "resize updates camera viewport dimensions",
            "line": 125,
            "source": "const camera = new Camera()\nconst l = new CanvasLayer({$id: 'test', camera, pixelRatio: 1})\n\nl.resize(1024, 768)\n\nexpect(camera.viewportWidth).toBe(1024)\nexpect(camera.viewportHeight).toBe(768)"
          },
          {
            "title": "resize with viewport",
            "line": 136,
            "source": "const l = new CanvasLayer({\n    $id: 'test',\n    viewport: {\n        x: 0,\n        y: 0,\n        width: '50%',\n        height: '50%',\n        anchor: 'top-left'\n    }\n})\n\nl.resize(1000, 800)\n\nexpect(l.canvas.width).toBe(500)\nexpect(l.canvas.height).toBe(400)"
          },
          {
            "title": "autoRender defaults to true",
            "line": 155,
            "source": "expect(layer.autoRender).toBe(true)"
          },
          {
            "title": "autoRender can be set to false",
            "line": 160,
            "source": "const l = new CanvasLayer({$id: 'test', autoRender: false})\nexpect(l.autoRender).toBe(false)"
          },
          {
            "title": "dispose cleans up",
            "line": 166,
            "source": "const container = document.createElement('div')\nlayer.mount(container)\n\nlayer.dispose()\n\nexpect(layer.element).toBe(null)\nexpect(container.contains(layer.canvas)).toBe(false)"
          },
          {
            "title": "integration: full render cycle",
            "line": 177,
            "source": "const scene = new Group2D()\nconst circle = new Circle({x: 0, y: 0, radius: 1, color: '#FF0000'})\nscene.addChild(circle)\n\nlayer.setContent(scene)\n\nexpect(() => layer.render()).not.toThrow()"
          },
          {
            "title": "provided camera gets viewport updated",
            "line": 188,
            "source": "const camera = new Camera({\n    viewportWidth: 100,\n    viewportHeight: 100,\n    pixelRatio: 1\n})\n\nnew CanvasLayer({\n    $id: 'test',\n    width: 800,\n    height: 600,\n    pixelRatio: 2,\n    camera\n})\n\nexpect(camera.viewportWidth).toBe(800)\nexpect(camera.viewportHeight).toBe(600)\nexpect(camera.pixelRatio).toBe(1)"
          },
          {
            "title": "viewport with anchor top-right",
            "line": 209,
            "source": "const l = new CanvasLayer({\n    $id: 'test',\n    width: 1000,\n    height: 800,\n    viewport: {\n        x: 10,\n        y: 10,\n        width: 200,\n        height: 150,\n        anchor: 'top-right'\n    }\n})\n\n// Canvas should be 200x150\nexpect(l.canvas.width).toBe(200)\nexpect(l.canvas.height).toBe(150)\n\n// Positioned at top-right: 1000 - 200 - 10 = 790\nexpect(l.canvas.style.left).toBe('790px')\nexpect(l.canvas.style.top).toBe('10px')"
          },
          {
            "title": "applyStyles sets canvas styles correctly",
            "line": 280,
            "source": "const l = new CanvasLayer({\n    $id: 'styled',\n    zIndex: 5,\n    opacity: 0.8,\n    pointerEvents: 'none',\n    visible: false\n})\n\nexpect(l.canvas.style.position).toBe('absolute')\nexpect(l.canvas.style.top).toBe('0px')\nexpect(l.canvas.style.left).toBe('0px')\nexpect(l.canvas.style.zIndex).toBe('5')\nexpect(l.canvas.style.opacity).toBe('0.8')\nexpect(l.canvas.style.pointerEvents).toBe('none')\nexpect(l.canvas.style.display).toBe('none')"
          }
        ],
        "describes": [
          {
            "title": "rendererType option",
            "line": 233,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "defaults to canvas",
                "line": 235,
                "source": "expect(layer.rendererType).toBe('canvas')"
              },
              {
                "title": "can be set to webgl",
                "line": 240,
                "source": "const l = new CanvasLayer({$id: 'webgl-test', rendererType: 'webgl'})\nexpect(l.rendererType).toBe('webgl')"
              },
              {
                "title": "creates WebGLRenderer renderer when rendererType is webgl",
                "line": 246,
                "source": "const l = new CanvasLayer({$id: 'webgl-test', rendererType: 'webgl'})\nexpect(l.renderer.constructor.name).toBe('WebGLRenderer')"
              },
              {
                "title": "creates CanvasRenderer renderer when rendererType is canvas",
                "line": 252,
                "source": "const l = new CanvasLayer({$id: 'canvas-test', rendererType: 'canvas'})\nexpect(l.renderer.constructor.name).toBe('CanvasRenderer')"
              },
              {
                "title": "webgl layer works with same API as canvas",
                "line": 258,
                "source": "const l = new CanvasLayer({$id: 'webgl-api', rendererType: 'webgl'})\nconst scene = new Group2D()\n\nl.setContent(scene)\nexpect(l.content).toBe(scene)\n\nexpect(() => l.render()).not.toThrow()"
              },
              {
                "title": "webgl layer resize works",
                "line": 269,
                "source": "const l = new CanvasLayer({$id: 'webgl-resize', rendererType: 'webgl'})\nl.resize(1024, 768)\n\nexpect(l.canvas.width).toBe(1024)\nexpect(l.canvas.height).toBe(768)"
              }
            ],
            "describes": []
          },
          {
            "title": "WebGLRenderer delegation via onInstall",
            "line": 299,
            "beforeEach": {
              "line": 303,
              "source": "webglLayer = new CanvasLayer({$id: 'webgl-delegation', rendererType: 'webgl'})"
            },
            "afterEach": null,
            "tests": [
              {
                "title": "setRenderGroups is delegated to layer",
                "line": 308,
                "source": "const group = new Group2D()\nconst configs = [{$name: 'test', content: group}]\n\nwebglLayer.setRenderGroups(configs)\n\nexpect(webglLayer.renderer.renderGroups).toHaveLength(1)"
              },
              {
                "title": "clearRenderGroups is delegated to layer",
                "line": 318,
                "source": "const group = new Group2D()\nwebglLayer.setRenderGroups([{$name: 'test', content: group}])\n\nwebglLayer.clearRenderGroups()\n\nexpect(webglLayer.renderer.renderGroups).toHaveLength(0)"
              },
              {
                "title": "setUniform is delegated to layer",
                "line": 328,
                "source": "webglLayer.setUniform('uTime', 1.5)\n\nexpect(webglLayer.getUniform('uTime')).toBe(1.5)"
              },
              {
                "title": "getUniform is delegated to layer",
                "line": 335,
                "source": "webglLayer.setUniform('uTest', 42)\n\nexpect(webglLayer.getUniform('uTest')).toBe(42)"
              },
              {
                "title": "getPass is delegated to layer",
                "line": 342,
                "source": "expect(webglLayer.getPass('nonexistent')).toBeNull()"
              },
              {
                "title": "registerShaderEffect is delegated to layer",
                "line": 347,
                "source": "const MockEffect = {\n    name: 'mockEffect',\n    uniforms: {},\n    vertexShader: '',\n    fragmentShader: ''\n}\n\nwebglLayer.registerShaderEffect(MockEffect)\n\nexpect(webglLayer.renderer.shaderEffectRegistry.get('mockEffect')).toBe(MockEffect)"
              },
              {
                "title": "canvas renderer does not have WebGL methods",
                "line": 361,
                "source": "const canvasLayer = new CanvasLayer({$id: 'canvas-test', rendererType: 'canvas'})\n\nexpect(canvasLayer.setRenderGroups).toBeUndefined()\nexpect(canvasLayer.setUniform).toBeUndefined()\nexpect(canvasLayer.registerShaderEffect).toBeUndefined()"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/render/circle.doc.js": {
    "file": "/render/circle.test.js",
    "describes": [
      {
        "title": "Circle",
        "line": 6,
        "beforeEach": {
          "line": 10,
          "source": "circle = new Circle()"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor defaults",
            "line": 15,
            "source": "expect(circle.radius).toBe(10)\nexpect(circle.color).toBe('#000000')\nexpect(circle.strokeColor).toBe('#000000')\nexpect(circle.strokeWidth).toBe(0)"
          },
          {
            "title": "constructor with options",
            "line": 23,
            "source": "const c = new Circle({\n    x: 10,\n    y: 20,\n    radius: 50,\n    color: '#ff0000',\n    strokeColor: '#00ff00',\n    strokeWidth: 2,\n    opacity: 0.5\n})\n\nexpect(c.x).toBe(10)\nexpect(c.y).toBe(20)\nexpect(c.radius).toBe(50)\nexpect(c.color).toBe('#ff0000')\nexpect(c.strokeColor).toBe('#00ff00')\nexpect(c.strokeWidth).toBe(2)\nexpect(c.opacity).toBe(0.5)"
          },
          {
            "title": "setRadius",
            "line": 44,
            "source": "const result = circle.setRadius(25)\n\nexpect(circle.radius).toBe(25)\nexpect(result).toBe(circle)"
          },
          {
            "title": "getBounds",
            "line": 52,
            "source": "circle.radius = 20\ncircle.anchorX = 0.5\ncircle.anchorY = 0.5\n\nconst bounds = circle.getBounds()\n\nexpect(bounds.minX).toBeCloseTo(-20)\nexpect(bounds.minY).toBeCloseTo(-20)\nexpect(bounds.maxX).toBeCloseTo(20)\nexpect(bounds.maxY).toBeCloseTo(20)\nexpect(bounds.width).toBe(40)\nexpect(bounds.height).toBe(40)"
          },
          {
            "title": "getBounds with custom anchor",
            "line": 68,
            "source": "circle.radius = 10\ncircle.anchorX = 0\ncircle.anchorY = 0\n\nconst bounds = circle.getBounds()\n\nexpect(bounds.minX).toBeCloseTo(0)\nexpect(bounds.minY).toBeCloseTo(0)\nexpect(bounds.maxX).toBeCloseTo(20)\nexpect(bounds.maxY).toBeCloseTo(20)\nexpect(bounds.width).toBe(20)\nexpect(bounds.height).toBe(20)"
          }
        ],
        "describes": []
      },
      {
        "title": "CanvasCircleRenderer",
        "line": 86,
        "beforeEach": {
          "line": 91,
          "source": "renderer = new CanvasCircleRenderer()\nctx = {\n    beginPath: vi.fn(),\n    arc: vi.fn(),\n    fill: vi.fn(),\n    stroke: vi.fn()\n}"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "handles Circle class",
            "line": 102,
            "source": "expect(CanvasCircleRenderer.handles).toContain(Circle)"
          },
          {
            "title": "render without stroke",
            "line": 107,
            "source": "const circle = new Circle({\n    radius: 20,\n    color: '#ff0000',\n    anchorX: 0.5,\n    anchorY: 0.5,\n    strokeWidth: 0\n})\n\nrenderer.render(circle, ctx)\n\nexpect(ctx.beginPath).toHaveBeenCalled()\nexpect(ctx.arc).toHaveBeenCalledWith(0, 0, 20, 0, Math.PI * 2)\nexpect(ctx.fill).toHaveBeenCalled()\nexpect(ctx.stroke).not.toHaveBeenCalled()"
          },
          {
            "title": "render with stroke",
            "line": 125,
            "source": "const circle = new Circle({\n    radius: 20,\n    color: '#ff0000',\n    strokeColor: '#0000ff',\n    strokeWidth: 2,\n    anchorX: 0.5,\n    anchorY: 0.5\n})\n\nrenderer.render(circle, ctx)\n\nexpect(ctx.beginPath).toHaveBeenCalled()\nexpect(ctx.arc).toHaveBeenCalledWith(0, 0, 20, 0, Math.PI * 2)\nexpect(ctx.fill).toHaveBeenCalled()\nexpect(ctx.stroke).toHaveBeenCalled()"
          },
          {
            "title": "render with custom anchor",
            "line": 144,
            "source": "const circle = new Circle({\n    radius: 20,\n    anchorX: 0,\n    anchorY: 0\n})\n\nrenderer.render(circle, ctx)\n\nexpect(ctx.arc).toHaveBeenCalledWith(20, 20, 20, 0, Math.PI * 2)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/render/group_2d.doc.js": {
    "file": "/render/group_2d.test.js",
    "describes": [
      {
        "title": "Group2D",
        "line": 6,
        "beforeEach": {
          "line": 10,
          "source": "group = new Group2D()"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor",
            "line": 15,
            "source": "expect(group).toBeInstanceOf(Object2D)\nexpect(group.children).toEqual([])"
          },
          {
            "title": "constructor with options",
            "line": 21,
            "source": "const g = new Group2D({\n    x: 10,\n    y: 20,\n    rotation: Math.PI,\n    scaleX: 2,\n    scaleY: 3,\n    opacity: 0.5,\n    visible: false\n})\n\nexpect(g.x).toBe(10)\nexpect(g.y).toBe(20)\nexpect(g.rotation).toBe(Math.PI)\nexpect(g.scaleX).toBe(2)\nexpect(g.scaleY).toBe(3)\nexpect(g.opacity).toBe(0.5)\nexpect(g.visible).toBe(false)"
          },
          {
            "title": "addChild",
            "line": 42,
            "source": "const child1 = new Object2D()\nconst child2 = new Object2D()\n\nconst result = group.addChild(child1, child2)\n\nexpect(group.children).toEqual([child1, child2])\nexpect(child1.parent).toBe(group)\nexpect(child2.parent).toBe(group)\nexpect(result).toBe(group)"
          },
          {
            "title": "addChild with single child",
            "line": 55,
            "source": "const child = new Object2D()\n\ngroup.addChild(child)\n\nexpect(group.children).toEqual([child])\nexpect(child.parent).toBe(group)"
          },
          {
            "title": "addChild is fluent",
            "line": 65,
            "source": "const child = new Object2D()\n\nconst result = group.addChild(child).setPosition(10, 20)\n\nexpect(result).toBe(group)\nexpect(group.x).toBe(10)\nexpect(group.y).toBe(20)"
          },
          {
            "title": "nested groups",
            "line": 76,
            "source": "const parent = new Group2D()\nconst child = new Group2D()\nconst grandchild = new Object2D()\n\nparent.addChild(child)\nchild.addChild(grandchild)\n\nexpect(parent.children).toEqual([child])\nexpect(child.children).toEqual([grandchild])\nexpect(child.parent).toBe(parent)\nexpect(grandchild.parent).toBe(child)"
          },
          {
            "title": "world matrix propagation",
            "line": 91,
            "source": "const parent = new Group2D()\nparent.x = 10\nparent.y = 20\n\nconst child = new Group2D()\nchild.x = 5\nchild.y = 5\n\nparent.addChild(child)\nparent.updateWorldMatrix()\n\nconst m = child.worldMatrix\nexpect(m[4]).toBeCloseTo(15)\nexpect(m[5]).toBeCloseTo(25)"
          },
          {
            "title": "getBounds returns zero bounds for empty group",
            "line": 109,
            "source": "const bounds = group.getBounds()\n\nexpect(bounds).toEqual({\n    minX: 0,\n    minY: 0,\n    maxX: 0,\n    maxY: 0,\n    width: 0,\n    height: 0\n})"
          },
          {
            "title": "getBounds calculates bounds from children",
            "line": 123,
            "source": "const child1 = new Object2D({x: 0, y: 0})\nchild1.getBounds = () => ({minX: -5, minY: -5, maxX: 5, maxY: 5, width: 10, height: 10})\n\nconst child2 = new Object2D({x: 10, y: 10})\nchild2.getBounds = () => ({minX: -2, minY: -2, maxX: 2, maxY: 2, width: 4, height: 4})\n\ngroup.addChild(child1, child2)\ngroup.updateWorldMatrix()\n\nconst bounds = group.getBounds()\n\nexpect(bounds.minX).toBe(-5)\nexpect(bounds.minY).toBe(-5)\nexpect(bounds.maxX).toBe(12)\nexpect(bounds.maxY).toBe(12)\nexpect(bounds.width).toBe(17)\nexpect(bounds.height).toBe(17)"
          },
          {
            "title": "getBounds ignores zero-size children",
            "line": 144,
            "source": "const child1 = new Object2D({x: 5, y: 5})\nchild1.getBounds = () => ({minX: -2, minY: -2, maxX: 2, maxY: 2, width: 4, height: 4})\n\nconst emptyChild = new Object2D({x: 100, y: 100})\nemptyChild.getBounds = () => ({minX: 0, minY: 0, maxX: 0, maxY: 0, width: 0, height: 0})\n\ngroup.addChild(child1, emptyChild)\ngroup.updateWorldMatrix()\n\nconst bounds = group.getBounds()\n\nexpect(bounds.minX).toBe(3)\nexpect(bounds.minY).toBe(3)\nexpect(bounds.maxX).toBe(7)\nexpect(bounds.maxY).toBe(7)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/render/html_layer.doc.js": {
    "file": "/render/html_layer.test.js",
    "describes": [
      {
        "title": "HTMLLayer",
        "line": 6,
        "beforeEach": {
          "line": 10,
          "source": "layer = new HTMLLayer({$id: 'test-html'})"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor creates div element",
            "line": 15,
            "source": "expect(layer.div).toBeInstanceOf(HTMLDivElement)\nexpect(layer.element).toBe(layer.div)\nexpect(layer.div.style.position).toBe('absolute')"
          },
          {
            "title": "constructor with content option",
            "line": 22,
            "source": "const l = new HTMLLayer({\n    $id: 'test',\n    content: '<p>Hello World</p>'\n})\n\nexpect(l.div.innerHTML).toBe('<p>Hello World</p>')"
          },
          {
            "title": "constructor with className option",
            "line": 32,
            "source": "const l = new HTMLLayer({\n    $id: 'test',\n    className: 'my-custom-class'\n})\n\nexpect(l.div.className).toBe('my-custom-class')"
          },
          {
            "title": "constructor with camera option",
            "line": 42,
            "source": "const camera = new Camera()\nconst l = new HTMLLayer({$id: 'test', camera})\n\nexpect(l.camera).toBe(camera)"
          },
          {
            "title": "setContent with string",
            "line": 50,
            "source": "layer.setContent('<h1>Title</h1>')\nexpect(layer.div.innerHTML).toBe('<h1>Title</h1>')"
          },
          {
            "title": "setContent with HTMLElement",
            "line": 56,
            "source": "const p = document.createElement('p')\np.textContent = 'Paragraph'\n\nlayer.setContent(p)\n\nexpect(layer.div.contains(p)).toBe(true)\nexpect(layer.div.children.length).toBe(1)"
          },
          {
            "title": "addClass and removeClass",
            "line": 67,
            "source": "layer.addClass('foo')\nexpect(layer.div.classList.contains('foo')).toBe(true)\n\nlayer.addClass('bar')\nexpect(layer.div.classList.contains('bar')).toBe(true)\n\nlayer.removeClass('foo')\nexpect(layer.div.classList.contains('foo')).toBe(false)\nexpect(layer.div.classList.contains('bar')).toBe(true)"
          },
          {
            "title": "setStyle",
            "line": 80,
            "source": "layer.setStyle('backgroundColor', 'red')\nexpect(layer.div.style.backgroundColor).toBe('red')"
          },
          {
            "title": "setCamera",
            "line": 86,
            "source": "const camera = new Camera()\n\nlayer.setCamera(camera)\n\nexpect(layer.camera).toBe(camera)"
          },
          {
            "title": "createWorldElement creates element",
            "line": 95,
            "source": "layer.camera = new Camera()\n\nconst el = layer.createWorldElement('<div>Test</div>', 10, 20)\n\nexpect(el).toBeInstanceOf(HTMLDivElement)\nexpect(el.innerHTML).toBe('<div>Test</div>')\nexpect(layer.div.contains(el)).toBe(true)\nexpect(layer.worldElements.length).toBe(1)"
          },
          {
            "title": "createWorldElement with options",
            "line": 107,
            "source": "layer.camera = new Camera()\n\nconst el = layer.createWorldElement(\n    '<span>Label</span>',\n    5,\n    10,\n    {\n        offsetX: 10,\n        offsetY: 20,\n        worldOffsetX: 0.5,\n        worldOffsetY: 1,\n        pointerEvents: 'none'\n    }\n)\n\nexpect(el.style.pointerEvents).toBe('none')\n\nconst worldEl = layer.worldElements[0]\nexpect(worldEl.worldX).toBe(5)\nexpect(worldEl.worldY).toBe(10)\nexpect(worldEl.offsetX).toBe(10)\nexpect(worldEl.offsetY).toBe(20)\nexpect(worldEl.worldOffsetX).toBe(0.5)\nexpect(worldEl.worldOffsetY).toBe(1)"
          },
          {
            "title": "createWorldElement with targetObject",
            "line": 135,
            "source": "layer.camera = new Camera()\nconst target = {x: 5, y: 10}\n\nlayer.createWorldElement('<div>Target</div>', 0, 0, {\n    targetObject: target\n})\n\nconst worldEl = layer.worldElements[0]\nexpect(worldEl.targetObject).toBe(target)"
          },
          {
            "title": "removeWorldElement",
            "line": 148,
            "source": "layer.camera = new Camera()\nconst el = layer.createWorldElement('<div>Remove me</div>', 0, 0)\n\nexpect(layer.worldElements.length).toBe(1)\nexpect(layer.div.contains(el)).toBe(true)\n\nlayer.removeWorldElement(el)\n\nexpect(layer.worldElements.length).toBe(0)\nexpect(layer.div.contains(el)).toBe(false)"
          },
          {
            "title": "updateElementWorldPosition",
            "line": 162,
            "source": "layer.camera = new Camera()\nconst el = layer.createWorldElement('<div>Move me</div>', 0, 0)\n\nlayer.updateElementWorldPosition(el, 15, 25)\n\nconst worldEl = layer.worldElements[0]\nexpect(worldEl.worldX).toBe(15)\nexpect(worldEl.worldY).toBe(25)"
          },
          {
            "title": "setElementTarget",
            "line": 174,
            "source": "layer.camera = new Camera()\nconst el = layer.createWorldElement('<div>Target me</div>', 0, 0)\nconst target = {x: 10, y: 20}\n\nlayer.setElementTarget(el, target)\n\nconst worldEl = layer.worldElements[0]\nexpect(worldEl.targetObject).toBe(target)"
          },
          {
            "title": "updateWorldElements without camera does nothing",
            "line": 186,
            "source": "layer.camera = null\nlayer.createWorldElement('<div>No camera</div>', 10, 10)\n\nexpect(() => layer.updateWorldElements()).not.toThrow()"
          },
          {
            "title": "updateWorldElements positions element",
            "line": 194,
            "source": "const camera = new Camera({\n    x: 0,\n    y: 0,\n    zoom: 1,\n    unitsInView: 10,\n    viewportWidth: 800,\n    viewportHeight: 600,\n    pixelRatio: 1\n})\nlayer.camera = camera\n\nconst el = layer.createWorldElement('<div>Position me</div>', 0, 0)\n\nlayer.updateWorldElements(true)\n\nexpect(el.style.transform).toContain('translate')"
          },
          {
            "title": "updateWorldElements syncs targetObject position",
            "line": 214,
            "source": "const camera = new Camera()\nlayer.camera = camera\n\nconst target = {x: 5, y: 10}\nlayer.createWorldElement('<div>Follow</div>', 0, 0, {\n    targetObject: target\n})\n\nlayer.updateWorldElements(true)\n\nconst worldEl = layer.worldElements[0]\nexpect(worldEl.worldX).toBe(5)\nexpect(worldEl.worldY).toBe(10)"
          },
          {
            "title": "updateWorldElements with inheritTransform",
            "line": 231,
            "source": "const camera = new Camera()\nlayer.camera = camera\n\nconst target = {\n    x: 0,\n    y: 0,\n    rotation: Math.PI / 4,\n    scaleX: 2,\n    scaleY: 2\n}\n\nconst el = layer.createWorldElement('<div>Inherit</div>', 0, 0, {\n    targetObject: target,\n    inheritTransform: true\n})\n\nlayer.updateWorldElements(true)\n\nexpect(el.style.transform).toContain('rotate')\nexpect(el.style.transform).toContain('scale')"
          },
          {
            "title": "updateWorldElements culls offscreen elements",
            "line": 255,
            "source": "const camera = new Camera({\n    x: 0,\n    y: 0,\n    zoom: 1,\n    unitsInView: 10,\n    viewportWidth: 800,\n    viewportHeight: 600,\n    pixelRatio: 1\n})\nlayer.camera = camera\n\nconst el = layer.createWorldElement('<div>Offscreen</div>', 1000, 1000)\n\nlayer.updateWorldElements(true)\n\nconst worldEl = layer.worldElements[0]\nexpect(worldEl.visible).toBe(false)\nexpect(el.style.display).toBe('none')"
          },
          {
            "title": "cssToWorldUnits",
            "line": 277,
            "source": "const camera = new Camera({\n    unitsInView: 10,\n    viewportHeight: 600,\n    zoom: 1,\n    pixelRatio: 1\n})\nlayer.camera = camera\n\nconst units = layer.cssToWorldUnits(120)\n\nexpect(units).toBe(2)"
          },
          {
            "title": "worldUnitsToCss",
            "line": 292,
            "source": "const camera = new Camera({\n    unitsInView: 10,\n    viewportHeight: 600,\n    zoom: 1,\n    pixelRatio: 1\n})\nlayer.camera = camera\n\nconst pixels = layer.worldUnitsToCss(3)\n\nexpect(pixels).toBe(180)"
          },
          {
            "title": "resize updates viewport",
            "line": 307,
            "source": "layer.viewport = {x: 0, y: 0, width: '50%', height: '50%', anchor: 'top-left'}\n\nlayer.resize(1000, 800)\n\nexpect(layer.div.style.width).toBe('500px')\nexpect(layer.div.style.height).toBe('400px')"
          },
          {
            "title": "applyStyles sets div styles correctly",
            "line": 317,
            "source": "const l = new HTMLLayer({\n    $id: 'styled-html',\n    zIndex: 10,\n    opacity: 0.7,\n    pointerEvents: 'none',\n    visible: false\n})\n\nexpect(l.div.style.position).toBe('absolute')\nexpect(l.div.style.zIndex).toBe('10')\nexpect(l.div.style.opacity).toBe('0.7')\nexpect(l.div.style.pointerEvents).toBe('none')\nexpect(l.div.style.display).toBe('none')"
          }
        ],
        "describes": []
      }
    ]
  },
  "/render/layer.doc.js": {
    "file": "/render/layer.test.js",
    "describes": [
      {
        "title": "Layer",
        "line": 5,
        "beforeEach": {
          "line": 9,
          "source": "layer = new Layer({$id: 'test-layer'})"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor defaults",
            "line": 14,
            "source": "expect(layer.$id).toBe('test-layer')\nexpect(layer.zIndex).toBe(0)\nexpect(layer.visible).toBe(true)\nexpect(layer.opacity).toBe(1)\nexpect(layer.pointerEvents).toBe('auto')\nexpect(layer.element).toBe(null)\nexpect(layer.container).toBe(null)"
          },
          {
            "title": "constructor with options",
            "line": 25,
            "source": "const l = new Layer({\n    $id: 'custom',\n    zIndex: 10,\n    visible: false,\n    opacity: 0.5,\n    pointerEvents: 'none'\n})\n\nexpect(l.$id).toBe('custom')\nexpect(l.zIndex).toBe(10)\nexpect(l.visible).toBe(false)\nexpect(l.opacity).toBe(0.5)\nexpect(l.pointerEvents).toBe('none')"
          },
          {
            "title": "viewport defaults",
            "line": 42,
            "source": "expect(layer.viewport.x).toBe(0)\nexpect(layer.viewport.y).toBe(0)\nexpect(layer.viewport.width).toBe('100%')\nexpect(layer.viewport.height).toBe('100%')\nexpect(layer.viewport.anchor).toBe('top-left')"
          },
          {
            "title": "viewport with custom options",
            "line": 51,
            "source": "const l = new Layer({\n    $id: 'test',\n    viewport: {\n        x: 10,\n        y: 20,\n        width: 200,\n        height: 150,\n        anchor: 'top-right'\n    }\n})\n\nexpect(l.viewport.x).toBe(10)\nexpect(l.viewport.y).toBe(20)\nexpect(l.viewport.width).toBe(200)\nexpect(l.viewport.height).toBe(150)\nexpect(l.viewport.anchor).toBe('top-right')"
          },
          {
            "title": "calculateViewport with percentage width/height",
            "line": 71,
            "source": "layer.viewport = {x: 0, y: 0, width: '50%', height: '75%', anchor: 'top-left'}\n\nconst vp = layer.calculateViewport(800, 600)\n\nexpect(vp.x).toBe(0)\nexpect(vp.y).toBe(0)\nexpect(vp.width).toBe(400) // 50% of 800\nexpect(vp.height).toBe(450) // 75% of 600"
          },
          {
            "title": "calculateViewport with pixel values",
            "line": 83,
            "source": "layer.viewport = {x: 10, y: 20, width: 200, height: 150, anchor: 'top-left'}\n\nconst vp = layer.calculateViewport(800, 600)\n\nexpect(vp.x).toBe(10)\nexpect(vp.y).toBe(20)\nexpect(vp.width).toBe(200)\nexpect(vp.height).toBe(150)"
          },
          {
            "title": "calculateViewport with top-right anchor",
            "line": 95,
            "source": "layer.viewport = {x: 10, y: 20, width: 200, height: 150, anchor: 'top-right'}\n\nconst vp = layer.calculateViewport(800, 600)\n\nexpect(vp.x).toBe(590) // 800 - 200 - 10\nexpect(vp.y).toBe(20)\nexpect(vp.width).toBe(200)\nexpect(vp.height).toBe(150)"
          },
          {
            "title": "calculateViewport with bottom-left anchor",
            "line": 107,
            "source": "layer.viewport = {x: 10, y: 20, width: 200, height: 150, anchor: 'bottom-left'}\n\nconst vp = layer.calculateViewport(800, 600)\n\nexpect(vp.x).toBe(10)\nexpect(vp.y).toBe(430) // 600 - 150 - 20\nexpect(vp.width).toBe(200)\nexpect(vp.height).toBe(150)"
          },
          {
            "title": "calculateViewport with bottom-right anchor",
            "line": 119,
            "source": "layer.viewport = {x: 10, y: 20, width: 200, height: 150, anchor: 'bottom-right'}\n\nconst vp = layer.calculateViewport(800, 600)\n\nexpect(vp.x).toBe(590) // 800 - 200 - 10\nexpect(vp.y).toBe(430) // 600 - 150 - 20\nexpect(vp.width).toBe(200)\nexpect(vp.height).toBe(150)"
          },
          {
            "title": "setZIndex",
            "line": 131,
            "source": "const element = document.createElement('div')\nlayer.element = element\n\nlayer.setZIndex(42)\n\nexpect(layer.zIndex).toBe(42)\nexpect(element.style.zIndex).toBe('42')"
          },
          {
            "title": "setVisible",
            "line": 142,
            "source": "const element = document.createElement('div')\nlayer.element = element\n\nlayer.setVisible(false)\nexpect(layer.visible).toBe(false)\nexpect(element.style.display).toBe('none')\n\nlayer.setVisible(true)\nexpect(layer.visible).toBe(true)\nexpect(element.style.display).toBe('block')"
          },
          {
            "title": "setOpacity",
            "line": 156,
            "source": "const element = document.createElement('div')\nlayer.element = element\n\nlayer.setOpacity(0.7)\n\nexpect(layer.opacity).toBe(0.7)\nexpect(element.style.opacity).toBe('0.7')"
          },
          {
            "title": "setPointerEvents",
            "line": 167,
            "source": "const element = document.createElement('div')\nlayer.element = element\n\nlayer.setPointerEvents('none')\n\nexpect(layer.pointerEvents).toBe('none')\nexpect(element.style.pointerEvents).toBe('none')"
          },
          {
            "title": "mount and unmount",
            "line": 178,
            "source": "const container = document.createElement('div')\nconst element = document.createElement('div')\nlayer.element = element\n\nlayer.mount(container)\n\nexpect(layer.container).toBe(container)\nexpect(container.contains(element)).toBe(true)\n\nlayer.unmount()\n\nexpect(layer.container).toBe(null)\nexpect(container.contains(element)).toBe(false)"
          },
          {
            "title": "resize updates viewport",
            "line": 195,
            "source": "layer.viewport = {x: 0, y: 0, width: '50%', height: '50%', anchor: 'top-left'}\n\nlayer.resize(1000, 800)\n\nexpect(layer.resolvedViewport.width).toBe(500)\nexpect(layer.resolvedViewport.height).toBe(400)"
          },
          {
            "title": "applyViewport updates element styles",
            "line": 205,
            "source": "const element = document.createElement('div')\nlayer.element = element\nlayer.calculateViewport(800, 600)\n\nlayer.applyViewport()\n\nexpect(element.style.left).toBe('0px')\nexpect(element.style.top).toBe('0px')\nexpect(element.style.width).toBe('800px')\nexpect(element.style.height).toBe('600px')"
          },
          {
            "title": "destroy unmounts and clears element",
            "line": 219,
            "source": "const container = document.createElement('div')\nconst element = document.createElement('div')\nlayer.element = element\nlayer.mount(container)\n\nlayer.dispose()\n\nexpect(layer.element).toBe(null)\nexpect(container.contains(element)).toBe(false)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/render/object_2d.doc.js": {
    "file": "/render/object_2d.test.js",
    "describes": [
      {
        "title": "Object2D",
        "line": 5,
        "beforeEach": {
          "line": 9,
          "source": "object = new Object2D()"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor defaults",
            "line": 14,
            "source": "expect(object.visible).toBe(true)\nexpect(object.opacity).toBe(1)\nexpect(object.depth).toBe(0)\nexpect(object.anchorX).toBe(0.5)\nexpect(object.anchorY).toBe(0.5)\nexpect(object.x).toBe(0)\nexpect(object.y).toBe(0)\nexpect(object.rotation).toBe(0)\nexpect(object.scaleX).toBe(1)\nexpect(object.scaleY).toBe(1)"
          },
          {
            "title": "constructor with options",
            "line": 28,
            "source": "const obj = new Object2D({\n    x: 10,\n    y: 20,\n    rotation: Math.PI,\n    scaleX: 2,\n    scaleY: 3,\n    opacity: 0.5,\n    depth: 5,\n    visible: false,\n    anchorX: 0.25,\n    anchorY: 0.75,\n    pivotX: 5,\n    pivotY: 10\n})\n\nexpect(obj.x).toBe(10)\nexpect(obj.y).toBe(20)\nexpect(obj.rotation).toBe(Math.PI)\nexpect(obj.scaleX).toBe(2)\nexpect(obj.scaleY).toBe(3)\nexpect(obj.opacity).toBe(0.5)\nexpect(obj.depth).toBe(5)\nexpect(obj.visible).toBe(false)\nexpect(obj.anchorX).toBe(0.25)\nexpect(obj.anchorY).toBe(0.75)\nexpect(obj.pivotX).toBe(5)\nexpect(obj.pivotY).toBe(10)"
          },
          {
            "title": "setPosition",
            "line": 59,
            "source": "const result = object.setPosition(10, 20)\n\nexpect(object.x).toBe(10)\nexpect(object.y).toBe(20)\nexpect(result).toBe(object)"
          },
          {
            "title": "setRotation",
            "line": 68,
            "source": "const result = object.setRotation(Math.PI / 2)\n\nexpect(object.rotation).toBeCloseTo(Math.PI / 2)\nexpect(result).toBe(object)"
          },
          {
            "title": "setScale with two values",
            "line": 76,
            "source": "const result = object.setScale(2, 3)\n\nexpect(object.scaleX).toBe(2)\nexpect(object.scaleY).toBe(3)\nexpect(result).toBe(object)"
          },
          {
            "title": "setScale with one value",
            "line": 85,
            "source": "const result = object.setScale(2)\n\nexpect(object.scaleX).toBe(2)\nexpect(object.scaleY).toBe(2)\nexpect(result).toBe(object)"
          },
          {
            "title": "setOpacity",
            "line": 94,
            "source": "const result = object.setOpacity(0.5)\n\nexpect(object.opacity).toBe(0.5)\nexpect(result).toBe(object)"
          },
          {
            "title": "setDepth",
            "line": 102,
            "source": "const result = object.setDepth(10)\n\nexpect(object.depth).toBe(10)\nexpect(result).toBe(object)"
          },
          {
            "title": "setAnchor with two values",
            "line": 110,
            "source": "const result = object.setAnchor(0.25, 0.75)\n\nexpect(object.anchorX).toBe(0.25)\nexpect(object.anchorY).toBe(0.75)\nexpect(result).toBe(object)"
          },
          {
            "title": "setAnchor with one value",
            "line": 119,
            "source": "const result = object.setAnchor(0.25)\n\nexpect(object.anchorX).toBe(0.25)\nexpect(object.anchorY).toBe(0.25)\nexpect(result).toBe(object)"
          },
          {
            "title": "setPivot",
            "line": 128,
            "source": "const result = object.setPivot(5, 10)\n\nexpect(object.pivotX).toBe(5)\nexpect(object.pivotY).toBe(10)\nexpect(result).toBe(object)"
          },
          {
            "title": "render does nothing by default",
            "line": 137,
            "source": "expect(() => object.render({})).not.toThrow()"
          },
          {
            "title": "fluent interface",
            "line": 142,
            "source": "const result = object\n    .setPosition(10, 20)\n    .setRotation(Math.PI)\n    .setScale(2, 3)\n    .setOpacity(0.5)\n    .setDepth(7)\n    .setAnchor(0.25, 0.75)\n    .setPivot(5, 10)\n\nexpect(result).toBe(object)\nexpect(object.x).toBe(10)\nexpect(object.y).toBe(20)\nexpect(object.rotation).toBeCloseTo(Math.PI)\nexpect(object.scaleX).toBe(2)\nexpect(object.scaleY).toBe(3)\nexpect(object.opacity).toBe(0.5)\nexpect(object.depth).toBe(7)\nexpect(object.anchorX).toBe(0.25)\nexpect(object.anchorY).toBe(0.75)\nexpect(object.pivotX).toBe(5)\nexpect(object.pivotY).toBe(10)"
          },
          {
            "title": "getBounds default",
            "line": 167,
            "source": "const bounds = object.getBounds()\n\nexpect(bounds.minX).toBe(0)\nexpect(bounds.minY).toBe(0)\nexpect(bounds.maxX).toBe(0)\nexpect(bounds.maxY).toBe(0)\nexpect(bounds.width).toBe(0)\nexpect(bounds.height).toBe(0)"
          },
          {
            "title": "getWorldBounds with translation",
            "line": 179,
            "source": "object.x = 10\nobject.y = 20\nobject.getBounds = () => ({minX: 0, minY: 0, maxX: 10, maxY: 10, width: 10, height: 10})\nobject.updateWorldMatrix()\n\nconst bounds = object.getWorldBounds()\n\nexpect(bounds.minX).toBeCloseTo(10)\nexpect(bounds.minY).toBeCloseTo(20)\nexpect(bounds.maxX).toBeCloseTo(20)\nexpect(bounds.maxY).toBeCloseTo(30)"
          },
          {
            "title": "getWorldBounds with scale",
            "line": 194,
            "source": "object.scaleX = 2\nobject.scaleY = 2\nobject.getBounds = () => ({minX: 0, minY: 0, maxX: 10, maxY: 10, width: 10, height: 10})\nobject.updateWorldMatrix()\n\nconst bounds = object.getWorldBounds()\n\nexpect(bounds.width).toBeCloseTo(20)\nexpect(bounds.height).toBeCloseTo(20)"
          },
          {
            "title": "showDebugGizmos enables debug gizmos with defaults",
            "line": 207,
            "source": "const result = object.showDebugGizmos()\n\nexpect(object.debugGizmos).toEqual({\n    bounds: true,\n    anchor: true,\n    pivot: true,\n    origin: true\n})\nexpect(result).toBe(object)"
          },
          {
            "title": "showDebugGizmos with custom options",
            "line": 220,
            "source": "object.showDebugGizmos({\n    bounds: true,\n    anchor: false,\n    pivot: false,\n    origin: true\n})\n\nexpect(object.debugGizmos).toEqual({\n    bounds: true,\n    anchor: false,\n    pivot: false,\n    origin: true\n})"
          },
          {
            "title": "hideDebugGizmos disables debug gizmos",
            "line": 237,
            "source": "object.showDebugGizmos()\n\nexpect(object.debugGizmos).not.toBeNull()\n\nconst result = object.hideDebugGizmos()\n\nexpect(object.debugGizmos).toBeNull()\nexpect(result).toBe(object)"
          },
          {
            "title": "setVisible changes visible property",
            "line": 249,
            "source": "expect(object.visible).toBe(true)\n\nconst result = object.setVisible(false)\n\nexpect(object.visible).toBe(false)\nexpect(result).toBe(object)\n\nobject.setVisible(true)\n\nexpect(object.visible).toBe(true)"
          },
          {
            "title": "depth setter triggers markChildrenNeedSort on parent",
            "line": 263,
            "source": "const parent = new Object2D()\nconst child1 = new Object2D({depth: 0})\nconst child2 = new Object2D({depth: 1})\n\nparent.add(child1, child2)\n\n// Get initial sorted children\nconst sorted1 = parent.getSortedChildren()\nexpect(sorted1[0]).toBe(child1)\nexpect(sorted1[1]).toBe(child2)\n\n// Change depth using setter\nchild1.depth = 10\n\n// Should trigger re-sort\nconst sorted2 = parent.getSortedChildren()\nexpect(sorted2[0]).toBe(child2)\nexpect(sorted2[1]).toBe(child1)"
          },
          {
            "title": "depth setter does not trigger if value unchanged",
            "line": 285,
            "source": "const parent = new Object2D()\nconst child = new Object2D({depth: 5})\n\nparent.add(child)\nparent.getSortedChildren()\n\n// Set same value\nchild.depth = 5\n\n// Cache should still be valid (same reference)\nconst sorted1 = parent.getSortedChildren()\nconst sorted2 = parent.getSortedChildren()\nexpect(sorted1).toBe(sorted2)"
          },
          {
            "title": "depth setter works without parent",
            "line": 302,
            "source": "const obj = new Object2D()\n\n// Should not throw when no parent\nexpect(() => {\n    obj.depth = 10\n}).not.toThrow()\n\nexpect(obj.depth).toBe(10)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/render/rectangle.doc.js": {
    "file": "/render/rectangle.test.js",
    "describes": [
      {
        "title": "Rectangle",
        "line": 6,
        "beforeEach": {
          "line": 10,
          "source": "rectangle = new Rectangle()"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor defaults",
            "line": 15,
            "source": "expect(rectangle.width).toBe(10)\nexpect(rectangle.height).toBe(10)\nexpect(rectangle.color).toBe('#000000')\nexpect(rectangle.strokeColor).toBe('#000000')\nexpect(rectangle.strokeWidth).toBe(0)"
          },
          {
            "title": "constructor with options",
            "line": 24,
            "source": "const r = new Rectangle({\n    x: 10,\n    y: 20,\n    width: 100,\n    height: 50,\n    color: '#ff0000',\n    strokeColor: '#00ff00',\n    strokeWidth: 2,\n    opacity: 0.5,\n    rotation: Math.PI / 4\n})\n\nexpect(r.x).toBe(10)\nexpect(r.y).toBe(20)\nexpect(r.width).toBe(100)\nexpect(r.height).toBe(50)\nexpect(r.color).toBe('#ff0000')\nexpect(r.strokeColor).toBe('#00ff00')\nexpect(r.strokeWidth).toBe(2)\nexpect(r.opacity).toBe(0.5)\nexpect(r.rotation).toBeCloseTo(Math.PI / 4)"
          },
          {
            "title": "getBounds",
            "line": 49,
            "source": "rectangle.width = 100\nrectangle.height = 50\nrectangle.anchorX = 0.5\nrectangle.anchorY = 0.5\n\nconst bounds = rectangle.getBounds()\n\nexpect(bounds.minX).toBe(-50)\nexpect(bounds.minY).toBe(-25)\nexpect(bounds.maxX).toBe(50)\nexpect(bounds.maxY).toBe(25)\nexpect(bounds.width).toBe(100)\nexpect(bounds.height).toBe(50)"
          }
        ],
        "describes": []
      },
      {
        "title": "CanvasRectangleRenderer",
        "line": 68,
        "beforeEach": {
          "line": 73,
          "source": "renderer = new CanvasRectangleRenderer()\nctx = {\n    fillRect: vi.fn(),\n    strokeRect: vi.fn()\n}"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "handles Rectangle class",
            "line": 82,
            "source": "expect(CanvasRectangleRenderer.handles).toContain(Rectangle)"
          },
          {
            "title": "render without stroke",
            "line": 87,
            "source": "const rect = new Rectangle({\n    width: 100,\n    height: 50,\n    color: '#ff0000',\n    anchorX: 0.5,\n    anchorY: 0.5,\n    strokeWidth: 0\n})\n\nrenderer.render(rect, ctx)\n\nexpect(ctx.fillRect).toHaveBeenCalledWith(-50, -25, 100, 50)\nexpect(ctx.strokeRect).not.toHaveBeenCalled()"
          },
          {
            "title": "render with stroke",
            "line": 104,
            "source": "const rect = new Rectangle({\n    width: 100,\n    height: 50,\n    color: '#ff0000',\n    strokeColor: '#0000ff',\n    strokeWidth: 2,\n    anchorX: 0.5,\n    anchorY: 0.5\n})\n\nrenderer.render(rect, ctx)\n\nexpect(ctx.fillRect).toHaveBeenCalledWith(-50, -25, 100, 50)\nexpect(ctx.strokeRect).toHaveBeenCalledWith(-50, -25, 100, 50)"
          },
          {
            "title": "render with custom anchor",
            "line": 122,
            "source": "const rect = new Rectangle({\n    width: 100,\n    height: 50,\n    anchorX: 0,\n    anchorY: 0\n})\n\nrenderer.render(rect, ctx)\n\nexpect(ctx.fillRect).toHaveBeenCalledWith(-0, -0, 100, 50)"
          },
          {
            "title": "render with top-left anchor",
            "line": 136,
            "source": "const rect = new Rectangle({\n    width: 100,\n    height: 50,\n    anchorX: 1,\n    anchorY: 1\n})\n\nrenderer.render(rect, ctx)\n\nexpect(ctx.fillRect).toHaveBeenCalledWith(-100, -50, 100, 50)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/render/render_group.doc.js": {
    "file": "/render/render_group.test.js",
    "describes": [
      {
        "title": "RenderGroup",
        "line": 40,
        "beforeEach": {
          "line": 44,
          "source": "renderGroup = new RenderGroup()"
        },
        "afterEach": null,
        "tests": [],
        "describes": [
          {
            "title": "BLEND_MODES",
            "line": 49,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "exports normal blend mode",
                "line": 51,
                "source": "expect(BLEND_MODES.normal).toBe('normal')"
              },
              {
                "title": "exports additive blend mode",
                "line": 56,
                "source": "expect(BLEND_MODES.additive).toBe('additive')"
              },
              {
                "title": "exports multiply blend mode",
                "line": 61,
                "source": "expect(BLEND_MODES.multiply).toBe('multiply')"
              }
            ],
            "describes": []
          },
          {
            "title": "static properties",
            "line": 68,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "has $category of renderGroup",
                "line": 70,
                "source": "expect(RenderGroup.$category).toBe('renderGroup')"
              },
              {
                "title": "has $name of renderGroup",
                "line": 75,
                "source": "expect(RenderGroup.$name).toBe('renderGroup')"
              }
            ],
            "describes": []
          },
          {
            "title": "constructor",
            "line": 82,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "content defaults to null",
                "line": 84,
                "source": "expect(renderGroup.content).toBeNull()"
              },
              {
                "title": "postPasses defaults to empty array",
                "line": 89,
                "source": "expect(renderGroup.postPasses).toEqual([])"
              },
              {
                "title": "blendMode defaults to normal",
                "line": 94,
                "source": "expect(renderGroup.blendMode).toBe(BLEND_MODES.normal)"
              },
              {
                "title": "visible defaults to true",
                "line": 99,
                "source": "expect(renderGroup.visible).toBe(true)"
              },
              {
                "title": "opacity defaults to 1",
                "line": 104,
                "source": "expect(renderGroup.opacity).toBe(1)"
              },
              {
                "title": "accepts custom content",
                "line": 109,
                "source": "const content = {name: 'test-content'}\nconst group = new RenderGroup({content})\n\nexpect(group.content).toBe(content)"
              },
              {
                "title": "accepts custom postPasses",
                "line": 117,
                "source": "const pass = new MockRenderPass()\nconst group = new RenderGroup({postPasses: [pass]})\n\nexpect(group.postPasses).toContain(pass)"
              },
              {
                "title": "accepts custom blendMode",
                "line": 125,
                "source": "const group = new RenderGroup({blendMode: BLEND_MODES.additive})\n\nexpect(group.blendMode).toBe(BLEND_MODES.additive)"
              },
              {
                "title": "accepts custom visibility",
                "line": 132,
                "source": "const group = new RenderGroup({visible: false})\n\nexpect(group.visible).toBe(false)"
              },
              {
                "title": "accepts custom opacity",
                "line": 139,
                "source": "const group = new RenderGroup({opacity: 0.5})\n\nexpect(group.opacity).toBe(0.5)"
              }
            ],
            "describes": []
          },
          {
            "title": "onInstall",
            "line": 148,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "does nothing without valid renderer",
                "line": 150,
                "source": "expect(() => renderGroup.onInstall()).not.toThrow()"
              },
              {
                "title": "initializes passes when renderer has gl and shaderRegistry",
                "line": 155,
                "source": "const pass = new MockRenderPass()\nconst renderer = new MockRenderer()\n\nrenderer.create(RenderGroup, {$id: 'test', postPasses: [pass]})\n\nconst installedGroup = renderer.getChild('test')\nexpect(installedGroup.postPasses[0].initCalled).toBe(true)"
              },
              {
                "title": "creates framebuffer for the group",
                "line": 166,
                "source": "const renderer = new MockRenderer()\n\nrenderer.create(RenderGroup, {$id: 'test'})\n\nexpect(renderer.postProcessor.framebufferManager.getOrCreateBuffer)\n    .toHaveBeenCalledWith('test')"
              },
              {
                "title": "handles missing postProcessor gracefully",
                "line": 176,
                "source": "class MinimalRenderer extends PerkyModule {\n    constructor () {\n        super()\n        this.gl = {}\n        this.shaderRegistry = {}\n    }\n}\n\nconst renderer = new MinimalRenderer()\nexpect(() => renderer.create(RenderGroup, {$id: 'test'})).not.toThrow()"
              }
            ],
            "describes": []
          },
          {
            "title": "hasActivePasses",
            "line": 192,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns false when no passes",
                "line": 194,
                "source": "expect(renderGroup.hasActivePasses()).toBe(false)"
              },
              {
                "title": "returns true when at least one pass is enabled",
                "line": 199,
                "source": "const pass = new MockRenderPass()\npass.enabled = true\nrenderGroup.postPasses = [pass]\n\nexpect(renderGroup.hasActivePasses()).toBe(true)"
              },
              {
                "title": "returns false when all passes are disabled",
                "line": 208,
                "source": "const pass1 = new MockRenderPass()\nconst pass2 = new MockRenderPass()\npass1.enabled = false\npass2.enabled = false\nrenderGroup.postPasses = [pass1, pass2]\n\nexpect(renderGroup.hasActivePasses()).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "addPostPass",
            "line": 221,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "adds pass to postPasses array",
                "line": 223,
                "source": "const pass = new MockRenderPass()\nrenderGroup.addPostPass(pass)\n\nexpect(renderGroup.postPasses).toContain(pass)"
              },
              {
                "title": "returns this for chaining",
                "line": 231,
                "source": "const pass = new MockRenderPass()\nconst result = renderGroup.addPostPass(pass)\n\nexpect(result).toBe(renderGroup)"
              },
              {
                "title": "emits postPass:added event",
                "line": 239,
                "source": "const handler = vi.fn()\nrenderGroup.on('postPass:added', handler)\n\nconst pass = new MockRenderPass()\nrenderGroup.addPostPass(pass)\n\nexpect(handler).toHaveBeenCalledWith(pass)"
              },
              {
                "title": "initializes pass if already installed in renderer",
                "line": 250,
                "source": "const renderer = new MockRenderer()\nconst group = renderer.create(RenderGroup, {$id: 'test-group'})\n\nconst pass = new MockRenderPass()\ngroup.addPostPass(pass)\n\nexpect(pass.initCalled).toBe(true)"
              }
            ],
            "describes": []
          },
          {
            "title": "removePostPass",
            "line": 263,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "removes pass from postPasses array",
                "line": 265,
                "source": "const pass = new MockRenderPass()\nrenderGroup.postPasses = [pass]\n\nrenderGroup.removePostPass(pass)\n\nexpect(renderGroup.postPasses).not.toContain(pass)"
              },
              {
                "title": "disposes the removed pass",
                "line": 275,
                "source": "const pass = new MockRenderPass()\nrenderGroup.postPasses = [pass]\n\nrenderGroup.removePostPass(pass)\n\nexpect(pass.disposed).toBe(true)"
              },
              {
                "title": "returns this for chaining",
                "line": 285,
                "source": "const pass = new MockRenderPass()\nrenderGroup.postPasses = [pass]\n\nconst result = renderGroup.removePostPass(pass)\n\nexpect(result).toBe(renderGroup)"
              },
              {
                "title": "emits postPass:removed event",
                "line": 295,
                "source": "const handler = vi.fn()\nrenderGroup.on('postPass:removed', handler)\n\nconst pass = new MockRenderPass()\nrenderGroup.postPasses = [pass]\nrenderGroup.removePostPass(pass)\n\nexpect(handler).toHaveBeenCalledWith(pass)"
              },
              {
                "title": "does nothing for unknown pass",
                "line": 307,
                "source": "const pass1 = new MockRenderPass()\nconst pass2 = new MockRenderPass()\nrenderGroup.postPasses = [pass1]\n\nrenderGroup.removePostPass(pass2)\n\nexpect(renderGroup.postPasses).toContain(pass1)\nexpect(pass2.disposed).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "onDispose",
            "line": 321,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "disposes all passes",
                "line": 323,
                "source": "const pass1 = new MockRenderPass()\nconst pass2 = new MockRenderPass()\nrenderGroup.postPasses = [pass1, pass2]\n\nrenderGroup.onDispose()\n\nexpect(pass1.disposed).toBe(true)\nexpect(pass2.disposed).toBe(true)"
              },
              {
                "title": "clears postPasses array",
                "line": 335,
                "source": "const pass = new MockRenderPass()\nrenderGroup.postPasses = [pass]\n\nrenderGroup.onDispose()\n\nexpect(renderGroup.postPasses).toEqual([])"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/render/render_system.doc.js": {
    "file": "/render/render_system.test.js",
    "describes": [
      {
        "title": "RenderSystem",
        "line": 6,
        "beforeEach": {
          "line": 11,
          "source": "container = document.createElement('div')\ndocument.body.appendChild(container)\nrenderSystem = new RenderSystem({container})"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "dispose does not crash when called twice",
            "line": 202,
            "source": "renderSystem.dispose()\n\nexpect(() => {\n    renderSystem.dispose()\n}).not.toThrow()"
          },
          {
            "title": "install delegates methods to host",
            "line": 211,
            "source": "const host = {\n    on: vi.fn()\n}\n\nrenderSystem.install(host)\n\nexpect(host.createLayer).toBeDefined()\nexpect(host.getLayer).toBeDefined()\nexpect(host.renderLayer).toBeDefined()"
          },
          {
            "title": "childrenByCategory returns only layers",
            "line": 224,
            "source": "renderSystem.createLayer('layer1', 'canvas')\nrenderSystem.createLayer('layer2', 'canvas')\n\nconst layers = renderSystem.childrenByCategory('layer')\n\nexpect(layers).toHaveLength(2)\nexpect(layers.every(l => l.$category === 'layer')).toBe(true)"
          },
          {
            "title": "mount mounts view to container",
            "line": 235,
            "source": "const newContainer = document.createElement('div')\n\nrenderSystem.mount(newContainer)\n\nexpect(renderSystem.mounted).toBe(true)\nexpect(renderSystem.container).toBe(newContainer)"
          },
          {
            "title": "dismount unmounts view from container",
            "line": 245,
            "source": "renderSystem.dismount()\n\nexpect(renderSystem.mounted).toBe(false)"
          },
          {
            "title": "setupCameras creates main camera by default",
            "line": 252,
            "source": "const rs = new RenderSystem()\n\nconst camera = rs.getCamera('main')\n\nexpect(camera).toBeDefined()\nexpect(camera.$category).toBe('camera')"
          },
          {
            "title": "setupCameras with config creates additional cameras",
            "line": 262,
            "source": "const rs = new RenderSystem({\n    cameras: {\n        main: {unitsInView: 5},\n        secondary: {unitsInView: 10}\n    }\n})\n\nexpect(rs.getCamera('main').unitsInView).toEqual({height: 5})\nexpect(rs.getCamera('secondary').unitsInView).toEqual({height: 10})"
          },
          {
            "title": "resolveCamera with string returns camera",
            "line": 275,
            "source": "const camera = renderSystem.resolveCamera('main')\n\nexpect(camera).toBe(renderSystem.getCamera('main'))"
          },
          {
            "title": "resolveCamera with Camera returns same camera",
            "line": 282,
            "source": "const existing = renderSystem.getCamera('main')\n\nconst resolved = renderSystem.resolveCamera(existing)\n\nexpect(resolved).toBe(existing)"
          },
          {
            "title": "resolveCamera with null returns null",
            "line": 291,
            "source": "const resolved = renderSystem.resolveCamera(null)\n\nexpect(resolved).toBeNull()"
          },
          {
            "title": "getHTML returns element from any layer",
            "line": 298,
            "source": "renderSystem.createLayer('canvasLayer', 'canvas')\nrenderSystem.createLayer('htmlLayer', 'html')\n\nconst canvasElement = renderSystem.getHTML('canvasLayer')\nconst htmlElement = renderSystem.getHTML('htmlLayer')\n\nexpect(canvasElement).toBeInstanceOf(HTMLCanvasElement)\nexpect(htmlElement).toBeInstanceOf(HTMLDivElement)"
          },
          {
            "title": "sortLayers reorders layers by zIndex in DOM",
            "line": 310,
            "source": "renderSystem.createLayer('low', 'canvas', {zIndex: 1})\nrenderSystem.createLayer('high', 'canvas', {zIndex: 10})\nrenderSystem.createLayer('mid', 'canvas', {zIndex: 5})\n\nconst result = renderSystem.sortLayers()\n\nexpect(result).toBe(renderSystem)\n\nconst elements = Array.from(renderSystem.element.children)\nconst zIndexes = elements.map(el => {\n    const layer = renderSystem.childrenByCategory('layer').find(l => l.element === el)\n    return layer?.zIndex\n}).filter(z => z !== undefined)\n\nexpect(zIndexes).toEqual([1, 5, 10])"
          },
          {
            "title": "resize updates layer dimensions and cameras",
            "line": 329,
            "source": "renderSystem.createLayer('game', 'canvas')\nconst camera = renderSystem.getCamera('main')\n\nrenderSystem.resize(1920, 1080)\n\nexpect(renderSystem.layerWidth).toBe(1920)\nexpect(renderSystem.layerHeight).toBe(1080)\nexpect(camera.viewportWidth).toBe(1920)\nexpect(camera.viewportHeight).toBe(1080)"
          },
          {
            "title": "resizeToContainer uses element dimensions",
            "line": 342,
            "source": "Object.defineProperty(renderSystem.element, 'clientWidth', {value: 1024, writable: true})\nObject.defineProperty(renderSystem.element, 'clientHeight', {value: 768, writable: true})\n\nrenderSystem.resizeToContainer()\n\nexpect(renderSystem.layerWidth).toBe(1024)\nexpect(renderSystem.layerHeight).toBe(768)"
          },
          {
            "title": "enableAutoResize enables auto resize",
            "line": 353,
            "source": "renderSystem.autoResizeEnabled = false\n\nconst result = renderSystem.enableAutoResize()\n\nexpect(renderSystem.autoResizeEnabled).toBe(true)\nexpect(result).toBe(renderSystem)"
          },
          {
            "title": "disableAutoResize disables auto resize",
            "line": 363,
            "source": "renderSystem.autoResizeEnabled = true\n\nconst result = renderSystem.disableAutoResize()\n\nexpect(renderSystem.autoResizeEnabled).toBe(false)\nexpect(result).toBe(renderSystem)"
          }
        ],
        "describes": [
          {
            "title": "constructor",
            "line": 18,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates RenderSystem instance with PerkyView",
                "line": 20,
                "source": "expect(renderSystem).toBeInstanceOf(RenderSystem)\nexpect(renderSystem.view).toBeInstanceOf(PerkyView)"
              },
              {
                "title": "sets layer dimensions from options",
                "line": 26,
                "source": "const customRenderSystem = new RenderSystem({\n    container,\n    width: 1024,\n    height: 768\n})\n\nexpect(customRenderSystem.layerWidth).toBe(1024)\nexpect(customRenderSystem.layerHeight).toBe(768)"
              },
              {
                "title": "has category renderSystem",
                "line": 38,
                "source": "expect(renderSystem.$category).toBe('renderSystem')"
              }
            ],
            "describes": []
          },
          {
            "title": "layer management",
            "line": 45,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "createLayer creates and returns canvas layer",
                "line": 47,
                "source": "const layer = renderSystem.createLayer('test', 'canvas')\n\nexpect(layer).toBeDefined()\nexpect(renderSystem.getLayer('test')).toBe(layer)"
              },
              {
                "title": "getLayer retrieves layer by name",
                "line": 55,
                "source": "renderSystem.createLayer('game', 'canvas')\nconst layer = renderSystem.getLayer('game')\n\nexpect(layer).toBeDefined()\nexpect(layer.$id).toBe('game')"
              },
              {
                "title": "removeLayer removes layer",
                "line": 64,
                "source": "renderSystem.createLayer('temp', 'canvas')\nexpect(renderSystem.getLayer('temp')).toBeDefined()\n\nrenderSystem.removeLayer('temp')\nexpect(renderSystem.getLayer('temp')).toBeNull()"
              },
              {
                "title": "getRenderer retrieves renderer from layer",
                "line": 73,
                "source": "renderSystem.createLayer('game', 'canvas')\nconst renderer = renderSystem.getRenderer('game')\n\nexpect(renderer).toBeDefined()\nexpect(renderer.constructor.name).toBe('CanvasRenderer')"
              },
              {
                "title": "getRenderer retrieves WebGLRenderer for webgl layer",
                "line": 82,
                "source": "renderSystem.createLayer('game', 'webgl')\nconst renderer = renderSystem.getRenderer('game')\n\nexpect(renderer).toBeDefined()\nexpect(renderer.constructor.name).toBe('WebGLRenderer')"
              }
            ],
            "describes": []
          },
          {
            "title": "rendering",
            "line": 93,
            "beforeEach": {
              "line": 95,
              "source": "renderSystem.createLayer('game', 'canvas')"
            },
            "afterEach": null,
            "tests": [
              {
                "title": "render does not throw",
                "line": 100,
                "source": "expect(() => renderSystem.render()).not.toThrow()"
              },
              {
                "title": "renderLayer renders specific layer",
                "line": 105,
                "source": "expect(() => renderSystem.renderLayer('game')).not.toThrow()"
              }
            ],
            "describes": []
          },
          {
            "title": "layer visibility",
            "line": 112,
            "beforeEach": {
              "line": 114,
              "source": "renderSystem.createLayer('ui', 'canvas')"
            },
            "afterEach": null,
            "tests": [
              {
                "title": "showLayer calls setVisible with true",
                "line": 119,
                "source": "const layer = renderSystem.getLayer('ui')\nconst spy = vi.spyOn(layer, 'setVisible')\n\nrenderSystem.showLayer('ui')\n\nexpect(spy).toHaveBeenCalledWith(true)"
              },
              {
                "title": "hideLayer calls setVisible with false",
                "line": 129,
                "source": "const layer = renderSystem.getLayer('ui')\nconst spy = vi.spyOn(layer, 'setVisible')\n\nrenderSystem.hideLayer('ui')\n\nexpect(spy).toHaveBeenCalledWith(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "camera management",
            "line": 141,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "getCamera returns main camera by default",
                "line": 143,
                "source": "const camera = renderSystem.getCamera()\n\nexpect(camera).toBeDefined()"
              },
              {
                "title": "getCamera retrieves camera by id",
                "line": 150,
                "source": "const camera = renderSystem.getCamera('main')\n\nexpect(camera).toBeDefined()"
              },
              {
                "title": "setCamera creates camera with options",
                "line": 157,
                "source": "const camera = renderSystem.setCamera('test', {unitsInView: 5})\n\nexpect(renderSystem.getCamera('test')).toBe(camera)\nexpect(camera.unitsInView).toEqual({height: 5})"
              },
              {
                "title": "createCamera creates camera with full options",
                "line": 165,
                "source": "const camera = renderSystem.createCamera('secondary', {\n    unitsInView: {width: 20},\n    zoom: 2\n})\n\nexpect(camera.$id).toBe('secondary')\nexpect(camera.$category).toBe('camera')\nexpect(camera.unitsInView).toEqual({width: 20})\nexpect(camera.zoom).toBe(2)\nexpect(renderSystem.getCamera('secondary')).toBe(camera)"
              },
              {
                "title": "setCamera replaces existing camera",
                "line": 179,
                "source": "const first = renderSystem.setCamera('test', {zoom: 1})\nconst second = renderSystem.setCamera('test', {zoom: 2})\n\nexpect(renderSystem.getCamera('test')).toBe(second)\nexpect(second.zoom).toBe(2)\nexpect(first.disposed).toBe(true)"
              },
              {
                "title": "childrenByCategory lists all cameras",
                "line": 189,
                "source": "renderSystem.createCamera('secondary', {})\n\nconst cameras = renderSystem.childrenByCategory('camera')\n\nexpect(cameras.length).toBe(2)\nexpect(cameras.map(c => c.$id)).toContain('main')\nexpect(cameras.map(c => c.$id)).toContain('secondary')"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/render/render_transform.doc.js": {
    "file": "/render/render_transform.test.js",
    "describes": [
      {
        "title": "RenderTransform",
        "line": 5,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "constructor defaults enabled to true",
            "line": 7,
            "source": "const transform = new RenderTransform()\nexpect(transform.enabled).toBe(true)"
          },
          {
            "title": "constructor accepts enabled option",
            "line": 13,
            "source": "const transform = new RenderTransform({enabled: false})\nexpect(transform.enabled).toBe(false)"
          },
          {
            "title": "init",
            "line": 19,
            "source": "const transform = new RenderTransform()\nexpect(() => transform.init()).not.toThrow()"
          },
          {
            "title": "apply returns matrices unchanged",
            "line": 25,
            "source": "const transform = new RenderTransform()\nconst matrices = {projection: [1, 0, 0], view: [0, 1, 0]}\nconst result = transform.apply({}, matrices)\nexpect(result).toBe(matrices)"
          },
          {
            "title": "getProgram returns null",
            "line": 33,
            "source": "const transform = new RenderTransform()\nexpect(transform.getProgram()).toBeNull()"
          },
          {
            "title": "applyUniforms",
            "line": 39,
            "source": "const transform = new RenderTransform()\nexpect(() => transform.applyUniforms()).not.toThrow()"
          },
          {
            "title": "dispose",
            "line": 45,
            "source": "const transform = new RenderTransform()\nexpect(() => transform.dispose()).not.toThrow()"
          }
        ],
        "describes": []
      }
    ]
  },
  "/render/sprite.doc.js": {
    "file": "/render/sprite.test.js",
    "describes": [
      {
        "title": "Sprite",
        "line": 7,
        "beforeEach": {
          "line": 13,
          "source": "mockImage = {\n    width: 100,\n    height: 100,\n    naturalWidth: 100,\n    naturalHeight: 100,\n    complete: true\n}\nmockFrame = {\n    filename: 'frame1',\n    frame: {x: 0, y: 0, w: 10, h: 10},\n    image: mockImage\n}\nsprite = new Sprite({\n    frame: mockFrame,\n    width: 5\n})"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "initializes with frame and converts to region",
            "line": 33,
            "source": "expect(sprite.region).toBeInstanceOf(TextureRegion)\nexpect(sprite.region.width).toBe(10)\nexpect(sprite.region.height).toBe(10)\nexpect(sprite.width).toBe(5)\nexpect(sprite.height).toBeNull()"
          },
          {
            "title": "initializes with image",
            "line": 42,
            "source": "const s = new Sprite({image: mockImage})\n\nexpect(s.region).toBeInstanceOf(TextureRegion)\nexpect(s.image).toBe(mockImage)"
          },
          {
            "title": "initializes with region",
            "line": 50,
            "source": "const region = new TextureRegion({image: mockImage, x: 0, y: 0, width: 50, height: 50})\nconst s = new Sprite({region})\n\nexpect(s.region).toBe(region)"
          },
          {
            "title": "getBounds calculates bounds from region and width",
            "line": 58,
            "source": "const bounds = sprite.getBounds()\n\nexpect(bounds.width).toBe(5)\nexpect(bounds.height).toBe(5)"
          },
          {
            "title": "getBounds calculates bounds from region and height",
            "line": 66,
            "source": "sprite = new Sprite({\n    frame: mockFrame,\n    height: 10\n})\nconst bounds = sprite.getBounds()\n\nexpect(bounds.width).toBe(10)\nexpect(bounds.height).toBe(10)"
          },
          {
            "title": "addAnimation stores animation",
            "line": 78,
            "source": "const mockAnim = {\n    play: vi.fn(),\n    stop: vi.fn()\n}\n\nsprite.addAnimation('walk', mockAnim)\nexpect(sprite.animations.get('walk')).toBe(mockAnim)"
          },
          {
            "title": "play starts animation",
            "line": 89,
            "source": "const mockAnim = {\n    play: vi.fn(),\n    stop: vi.fn()\n}\n\nsprite.addAnimation('walk', mockAnim)\nsprite.play('walk')\n\nexpect(sprite.currentAnimation).toBe(mockAnim)\nexpect(mockAnim.play).toHaveBeenCalled()"
          },
          {
            "title": "stop stops current animation",
            "line": 103,
            "source": "const mockAnim = {\n    play: vi.fn(),\n    stop: vi.fn()\n}\n\nsprite.addAnimation('walk', mockAnim)\nsprite.play('walk')\nsprite.stop()\n\nexpect(sprite.currentAnimation).toBeNull()\nexpect(mockAnim.stop).toHaveBeenCalled()"
          },
          {
            "title": "setFrame updates region from legacy frame format",
            "line": 118,
            "source": "const newFrame = {\n    filename: 'frame2',\n    frame: {x: 10, y: 0, w: 20, h: 20},\n    image: mockImage\n}\n\nsprite.setFrame(newFrame)\n\nexpect(sprite.region).toBeInstanceOf(TextureRegion)\nexpect(sprite.region.x).toBe(10)\nexpect(sprite.region.width).toBe(20)"
          },
          {
            "title": "setFrame accepts TextureRegion directly",
            "line": 133,
            "source": "const region = new TextureRegion({image: mockImage, x: 32, y: 64, width: 16, height: 16})\n\nsprite.setFrame(region)\n\nexpect(sprite.region).toBe(region)"
          },
          {
            "title": "image setter updates region",
            "line": 142,
            "source": "const newImage = {width: 200, height: 200}\nsprite.image = newImage\n\nexpect(sprite.image).toBe(newImage)\nexpect(sprite.region).toBeInstanceOf(TextureRegion)\nexpect(sprite.region.width).toBe(200)"
          },
          {
            "title": "image setter with null clears region",
            "line": 152,
            "source": "sprite.image = null\n\nexpect(sprite.image).toBeNull()\nexpect(sprite.region).toBeNull()"
          }
        ],
        "describes": []
      },
      {
        "title": "CanvasSpriteRenderer",
        "line": 162,
        "beforeEach": {
          "line": 169,
          "source": "renderer = new CanvasSpriteRenderer()\nctx = {\n    save: vi.fn(),\n    restore: vi.fn(),\n    scale: vi.fn(),\n    drawImage: vi.fn(),\n    translate: vi.fn(),\n    rotate: vi.fn()\n}\nmockImage = {\n    width: 100,\n    height: 100,\n    naturalWidth: 100,\n    naturalHeight: 100,\n    complete: true\n}\nmockFrame = {\n    filename: 'frame1',\n    frame: {x: 0, y: 0, w: 10, h: 10},\n    image: mockImage\n}"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "handles Sprite class",
            "line": 194,
            "source": "expect(CanvasSpriteRenderer.handles).toContain(Sprite)"
          },
          {
            "title": "render draws frame using region data",
            "line": 199,
            "source": "const sprite = new Sprite({\n    frame: mockFrame,\n    width: 5\n})\n\nrenderer.render(sprite, ctx)\n\nexpect(ctx.drawImage).toHaveBeenCalledWith(\n    mockImage,\n    0, 0, 10, 10,\n    expect.any(Number), expect.any(Number),\n    5, 5\n)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/render/sprite_animation.doc.js": {
    "file": "/render/sprite_animation.test.js",
    "describes": [
      {
        "title": "SpriteAnimation",
        "line": 4,
        "beforeEach": {
          "line": 9,
          "source": "vi.useFakeTimers({\n    toFake: ['setTimeout', 'clearTimeout', 'performance', 'Date']\n})\n\nvi.stubGlobal('requestAnimationFrame', (cb) => setTimeout(cb, 16))\nvi.stubGlobal('cancelAnimationFrame', (id) => clearTimeout(id))\n\nvi.stubGlobal('performance', {\n    now: () => Date.now()\n})\n\nsprite = {\n    region: null\n}\n\nframes = [\n    {region: 'region1'},\n    {region: 'region2'},\n    {region: 'region3'}\n]\n\nanimation = new SpriteAnimation({\n    sprite,\n    frames,\n    fps: 10,\n    loop: true,\n    autoStart: false\n})"
        },
        "afterEach": {
          "line": 40,
          "source": "animation.dispose()"
        },
        "tests": [
          {
            "title": "initializes with correct values",
            "line": 44,
            "source": "expect(animation.totalFrames).toBe(3)\nexpect(animation.fps).toBe(10)\nexpect(animation.loop).toBe(true)\nexpect(animation.playing).toBe(false)"
          },
          {
            "title": "play starts animation",
            "line": 51,
            "source": "const playSpy = vi.fn()\nanimation.on('play', playSpy)\n\nvi.stubGlobal('requestAnimationFrame', vi.fn())\n\nanimation.play()\n\nexpect(animation.playing).toBe(true)\nexpect(playSpy).toHaveBeenCalled()\n\nvi.unstubAllGlobals()"
          },
          {
            "title": "update advances frames",
            "line": 65,
            "source": "expect(animation.currentIndex).toBe(0)\n\nvi.stubGlobal('performance', {now: () => 1000})\nanimation.play()\n\nanimation.update(0.1)\nexpect(animation.currentIndex).toBe(1)\nexpect(sprite.region).toBe('region2')\n\nanimation.update(0.1)\nexpect(animation.currentIndex).toBe(2)\nexpect(sprite.region).toBe('region3')\n\nvi.unstubAllGlobals()"
          },
          {
            "title": "loops when enabled",
            "line": 82,
            "source": "vi.stubGlobal('performance', {now: () => 1000})\nanimation.play()\n\nanimation.update(0.1)\nanimation.update(0.1)\nexpect(animation.currentIndex).toBe(2)\n\nconst loopSpy = vi.fn()\nanimation.on('loop', loopSpy)\n\nanimation.update(0.1)\nexpect(animation.currentIndex).toBe(0)\nexpect(loopSpy).toHaveBeenCalled()\n\nvi.unstubAllGlobals()"
          },
          {
            "title": "stops at end when loop disabled",
            "line": 100,
            "source": "animation.setLoop(false)\n\nvi.stubGlobal('performance', {now: () => 1000})\nanimation.play()\n\nconst completeSpy = vi.fn()\nanimation.on('complete', completeSpy)\n\nanimation.update(0.1)\nanimation.update(0.1)\nanimation.update(0.1)\n\nexpect(animation.playing).toBe(false)\nexpect(animation.completed).toBe(true)\nexpect(completeSpy).toHaveBeenCalled()\n\nvi.unstubAllGlobals()"
          },
          {
            "title": "setFrame sets frame by index",
            "line": 120,
            "source": "animation.setFrame(2)\nexpect(animation.currentIndex).toBe(2)\nexpect(sprite.region).toBe('region3')"
          },
          {
            "title": "setFrameByName sets frame by name",
            "line": 126,
            "source": "const namedFrames = [\n    {name: 'frame1', region: 'region1'},\n    {name: 'frame2', region: 'region2'},\n    {name: 'frame3', region: 'region3'}\n]\nconst namedAnimation = new SpriteAnimation({\n    sprite,\n    frames: namedFrames,\n    fps: 10\n})\nnamedAnimation.setFrameByName(namedFrames[1])\nexpect(namedAnimation.currentIndex).toBe(1)\nexpect(sprite.region).toBe('region2')\nnamedAnimation.dispose()"
          },
          {
            "title": "pause stops playing",
            "line": 144,
            "source": "vi.stubGlobal('requestAnimationFrame', vi.fn())\nconst pauseSpy = vi.fn()\nanimation.on('pause', pauseSpy)\n\nanimation.play()\nexpect(animation.playing).toBe(true)\n\nanimation.pause()\n\nexpect(animation.playing).toBe(false)\nexpect(pauseSpy).toHaveBeenCalled()\n\nvi.unstubAllGlobals()"
          },
          {
            "title": "stop resets animation to start",
            "line": 161,
            "source": "vi.stubGlobal('performance', {now: () => 1000})\nconst stopSpy = vi.fn()\nanimation.on('stop', stopSpy)\n\nanimation.play()\nanimation.update(0.1)\nexpect(animation.currentIndex).toBe(1)\n\nanimation.stop()\n\nexpect(animation.currentIndex).toBe(0)\nexpect(animation.playing).toBe(false)\nexpect(animation.completed).toBe(false)\nexpect(stopSpy).toHaveBeenCalled()\n\nvi.unstubAllGlobals()"
          },
          {
            "title": "restart stops and plays animation",
            "line": 181,
            "source": "vi.stubGlobal('requestAnimationFrame', vi.fn())\nvi.stubGlobal('performance', {now: () => 1000})\n\nanimation.play()\nanimation.update(0.1)\nexpect(animation.currentIndex).toBe(1)\n\nanimation.restart()\n\nexpect(animation.currentIndex).toBe(0)\nexpect(animation.playing).toBe(true)\n\nvi.unstubAllGlobals()"
          },
          {
            "title": "nextFrame advances to next frame",
            "line": 198,
            "source": "animation.setFrame(0)\n\nanimation.nextFrame()\nexpect(animation.currentIndex).toBe(1)\n\nanimation.nextFrame()\nexpect(animation.currentIndex).toBe(2)\n\nanimation.nextFrame()\nexpect(animation.currentIndex).toBe(0)"
          },
          {
            "title": "previousFrame goes to previous frame",
            "line": 212,
            "source": "animation.setFrame(2)\n\nanimation.previousFrame()\nexpect(animation.currentIndex).toBe(1)\n\nanimation.previousFrame()\nexpect(animation.currentIndex).toBe(0)\n\nanimation.previousFrame()\nexpect(animation.currentIndex).toBe(2)"
          },
          {
            "title": "setFps updates fps",
            "line": 226,
            "source": "const fpsSpy = vi.fn()\nanimation.on('fpsChanged', fpsSpy)\n\nanimation.setFps(30)\n\nexpect(animation.fps).toBe(30)\nexpect(fpsSpy).toHaveBeenCalledWith(30)"
          },
          {
            "title": "playback modes work with string values",
            "line": 237,
            "source": "expect(animation.playbackMode).toBe('forward')\nanimation.setPlaybackMode('reverse')\nexpect(animation.playbackMode).toBe('reverse')\nanimation.setPlaybackMode('pingpong')\nexpect(animation.playbackMode).toBe('pingpong')"
          },
          {
            "title": "getFrameDuration returns base duration for frames without custom duration",
            "line": 246,
            "source": "const duration = animation.getFrameDuration(0)\nexpect(duration).toBe(0.1)"
          },
          {
            "title": "getFrameDuration returns scaled duration for frames with custom duration",
            "line": 252,
            "source": "const customFrames = [\n    {region: 'region1', duration: 2},\n    {region: 'region2'},\n    {region: 'region3', duration: 0.5}\n]\nconst customAnimation = new SpriteAnimation({\n    sprite,\n    frames: customFrames,\n    fps: 10\n})\n\nexpect(customAnimation.getFrameDuration(0)).toBe(0.2)\nexpect(customAnimation.getFrameDuration(1)).toBe(0.1)\nexpect(customAnimation.getFrameDuration(2)).toBe(0.05)\n\ncustomAnimation.dispose()"
          },
          {
            "title": "setSpeed updates speed",
            "line": 272,
            "source": "animation.setSpeed(2)\nexpect(animation.speed).toBe(2)\n\nanimation.setSpeed(0.5)\nexpect(animation.speed).toBe(0.5)"
          },
          {
            "title": "setPlaybackMode updates playback mode",
            "line": 281,
            "source": "animation.setPlaybackMode('reverse')\nexpect(animation.playbackMode).toBe('reverse')\n\nanimation.setPlaybackMode('pingpong')\nexpect(animation.playbackMode).toBe('pingpong')\n\nanimation.setPlaybackMode('forward')\nexpect(animation.playbackMode).toBe('forward')"
          }
        ],
        "describes": [
          {
            "title": "events",
            "line": 293,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "addEvent adds event to frame",
                "line": 295,
                "source": "animation.addEvent(1, 'footstep')\nexpect(animation.getEvents(1)).toEqual(['footstep'])"
              },
              {
                "title": "addEvent adds multiple events to same frame",
                "line": 301,
                "source": "animation.addEvent(1, 'footstep')\nanimation.addEvent(1, 'sound')\nexpect(animation.getEvents(1)).toEqual(['footstep', 'sound'])"
              },
              {
                "title": "removeEvent removes specific event from frame",
                "line": 308,
                "source": "animation.addEvent(1, 'footstep')\nanimation.addEvent(1, 'sound')\n\nanimation.removeEvent(1, 'footstep')\n\nexpect(animation.getEvents(1)).toEqual(['sound'])"
              },
              {
                "title": "removeEvent does nothing for non-existent frame",
                "line": 318,
                "source": "animation.removeEvent(99, 'footstep')\nexpect(animation.getEvents(99)).toEqual([])"
              },
              {
                "title": "removeEvent removes frame entry when no events remain",
                "line": 324,
                "source": "animation.addEvent(1, 'footstep')\nanimation.removeEvent(1, 'footstep')\n\nexpect(animation.getEvents(1)).toEqual([])"
              },
              {
                "title": "clearEvents removes all events",
                "line": 332,
                "source": "animation.addEvent(0, 'start')\nanimation.addEvent(1, 'footstep')\nanimation.addEvent(2, 'end')\n\nanimation.clearEvents()\n\nexpect(animation.getEvents(0)).toEqual([])\nexpect(animation.getEvents(1)).toEqual([])\nexpect(animation.getEvents(2)).toEqual([])"
              },
              {
                "title": "getEvents returns empty array for frame without events",
                "line": 345,
                "source": "expect(animation.getEvents(0)).toEqual([])"
              },
              {
                "title": "getFramesByEvent returns frames for event",
                "line": 350,
                "source": "animation.addEvent(0, 'hop')\nanimation.addEvent(2, 'hop')\nanimation.addEvent(1, 'sound')\n\nexpect(animation.getFramesByEvent('hop')).toEqual([0, 2])\nexpect(animation.getFramesByEvent('sound')).toEqual([1])\nexpect(animation.getFramesByEvent('unknown')).toEqual([])"
              },
              {
                "title": "getFramesByEvent updates when events are removed",
                "line": 361,
                "source": "animation.addEvent(0, 'hop')\nanimation.addEvent(2, 'hop')\n\nanimation.removeEvent(0, 'hop')\n\nexpect(animation.getFramesByEvent('hop')).toEqual([2])"
              },
              {
                "title": "getFramesByEvent is cleared when clearEvents is called",
                "line": 371,
                "source": "animation.addEvent(0, 'hop')\nanimation.addEvent(2, 'hop')\n\nanimation.clearEvents()\n\nexpect(animation.getFramesByEvent('hop')).toEqual([])"
              }
            ],
            "describes": []
          },
          {
            "title": "getSegmentProgress",
            "line": 383,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns 0 when event has less than 2 keyframes",
                "line": 385,
                "source": "animation.addEvent(0, 'single')\n\nexpect(animation.getSegmentProgress('single')).toBe(0)\nexpect(animation.getSegmentProgress('unknown')).toBe(0)"
              },
              {
                "title": "returns progress within segment",
                "line": 393,
                "source": "animation.addEvent(0, 'hop')\nanimation.addEvent(2, 'hop')\n\nanimation.setFrame(0)\nexpect(animation.getSegmentProgress('hop')).toBe(0)\n\nanimation.setFrame(1)\nexpect(animation.getSegmentProgress('hop')).toBe(0.5)"
              },
              {
                "title": "handles wrap-around segment",
                "line": 405,
                "source": "animation.addEvent(0, 'hop')\nanimation.addEvent(2, 'hop')\n\nanimation.setFrame(2)\nexpect(animation.getSegmentProgress('hop')).toBe(0)"
              },
              {
                "title": "works with multiple segments",
                "line": 414,
                "source": "const sixFrames = [\n    {region: 'r1'}, {region: 'r2'}, {region: 'r3'},\n    {region: 'r4'}, {region: 'r5'}, {region: 'r6'}\n]\nconst multiAnimation = new SpriteAnimation({sprite, frames: sixFrames, fps: 10})\n\nmultiAnimation.addEvent(0, 'hop')\nmultiAnimation.addEvent(3, 'hop')\n\nmultiAnimation.setFrame(0)\nexpect(multiAnimation.getSegmentProgress('hop')).toBe(0)\n\nmultiAnimation.setFrame(1)\nexpect(multiAnimation.getSegmentProgress('hop')).toBeCloseTo(1 / 3)\n\nmultiAnimation.setFrame(2)\nexpect(multiAnimation.getSegmentProgress('hop')).toBeCloseTo(2 / 3)\n\nmultiAnimation.setFrame(3)\nexpect(multiAnimation.getSegmentProgress('hop')).toBe(0)\n\nmultiAnimation.setFrame(4)\nexpect(multiAnimation.getSegmentProgress('hop')).toBeCloseTo(1 / 3)\n\nmultiAnimation.setFrame(5)\nexpect(multiAnimation.getSegmentProgress('hop')).toBeCloseTo(2 / 3)\n\nmultiAnimation.dispose()"
              }
            ],
            "describes": []
          },
          {
            "title": "seek methods",
            "line": 448,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "seekToFrame sets frame and resets elapsed time",
                "line": 450,
                "source": "animation.seekToFrame(2)\nexpect(animation.currentIndex).toBe(2)\nexpect(sprite.region).toBe('region3')"
              },
              {
                "title": "seekToFrame does nothing for invalid index",
                "line": 457,
                "source": "animation.seekToFrame(0)\nanimation.seekToFrame(-1)\nexpect(animation.currentIndex).toBe(0)\n\nanimation.seekToFrame(99)\nexpect(animation.currentIndex).toBe(0)"
              },
              {
                "title": "seekToProgress seeks to frame based on progress",
                "line": 467,
                "source": "animation.seekToProgress(0)\nexpect(animation.currentIndex).toBe(0)\n\nanimation.seekToProgress(0.5)\nexpect(animation.currentIndex).toBe(1)\n\nanimation.seekToProgress(1)\nexpect(animation.currentIndex).toBe(2)"
              },
              {
                "title": "seekToProgress clamps progress to valid range",
                "line": 479,
                "source": "animation.seekToProgress(-0.5)\nexpect(animation.currentIndex).toBe(0)\n\nanimation.seekToProgress(1.5)\nexpect(animation.currentIndex).toBe(2)"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/render/sprite_animator.doc.js": {
    "file": "/render/sprite_animator.test.js",
    "describes": [
      {
        "title": "SpriteAnimator",
        "line": 5,
        "beforeEach": {
          "line": 10,
          "source": "sprite = {region: null}\n\ntextureSystem = {\n    getSpritesheet: (name) => {\n        if (name === 'testSheet') {\n            return {\n                getAnimation: (animName) => {\n                    if (animName === 'walk') {\n                        return ['walk/1', 'walk/2', 'walk/3']\n                    }\n                    return null\n                },\n                getAnimationRegions: (animName) => {\n                    if (animName === 'walk') {\n                        return ['region:walk/1', 'region:walk/2', 'region:walk/3']\n                    }\n                    return []\n                },\n                getRegion: (frameName) => `region:${frameName}`\n            }\n        }\n        return null\n    },\n    getRegion: (id) => `direct:${id}`\n}"
        },
        "afterEach": {
          "line": 38,
          "source": "if (animator) {\n    animator.dispose()\n}"
        },
        "tests": [],
        "describes": [
          {
            "title": "constructor",
            "line": 45,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates animator with sprite and textureSystem",
                "line": 47,
                "source": "animator = new SpriteAnimator({\n    sprite,\n    textureSystem\n})\n\nexpect(animator.sprite).toBe(sprite)\nexpect(animator.textureSystem).toBe(textureSystem)\nexpect(animator.current).toBeNull()"
              },
              {
                "title": "loads config if provided",
                "line": 59,
                "source": "const config = {\n    animations: {\n        idle: {\n            source: 'testSheet:walk',\n            fps: 10\n        }\n    }\n}\n\nanimator = new SpriteAnimator({\n    sprite,\n    textureSystem,\n    config\n})\n\nexpect(animator.get('idle')).not.toBeNull()"
              }
            ],
            "describes": []
          },
          {
            "title": "loadConfig",
            "line": 81,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates animation from source shorthand",
                "line": 83,
                "source": "animator = new SpriteAnimator({sprite, textureSystem})\n\nanimator.loadConfig({\n    walk: {\n        source: 'testSheet:walk',\n        fps: 12,\n        loop: true\n    }\n})\n\nconst anim = animator.get('walk')\nexpect(anim).not.toBeNull()\nexpect(anim.fps).toBe(12)\nexpect(anim.loop).toBe(true)\nexpect(anim.totalFrames).toBe(3)"
              },
              {
                "title": "creates animation from explicit frames",
                "line": 102,
                "source": "animator = new SpriteAnimator({sprite, textureSystem})\n\nanimator.loadConfig({\n    custom: {\n        fps: 16,\n        loop: false,\n        frames: [\n            {source: 'testSheet:frame1'},\n            {source: 'testSheet:frame2', duration: 2.0},\n            {source: 'testSheet:frame3'}\n        ]\n    }\n})\n\nconst anim = animator.get('custom')\nexpect(anim).not.toBeNull()\nexpect(anim.fps).toBe(16)\nexpect(anim.loop).toBe(false)\nexpect(anim.totalFrames).toBe(3)"
              },
              {
                "title": "supports region format for direct texture lookup",
                "line": 125,
                "source": "animator = new SpriteAnimator({sprite, textureSystem})\n\nanimator.loadConfig({\n    mixed: {\n        fps: 10,\n        frames: [\n            {source: 'testSheet:frame1'},\n            {region: 'directTexture'}\n        ]\n    }\n})\n\nconst anim = animator.get('mixed')\nexpect(anim.totalFrames).toBe(2)"
              },
              {
                "title": "registers frame events from config",
                "line": 143,
                "source": "animator = new SpriteAnimator({sprite, textureSystem})\n\nanimator.loadConfig({\n    attack: {\n        fps: 10,\n        frames: [\n            {source: 'testSheet:frame1'},\n            {source: 'testSheet:frame2', events: ['windup']},\n            {source: 'testSheet:frame3', events: ['hit', 'sound']}\n        ]\n    }\n})\n\nconst anim = animator.get('attack')\nexpect(anim.getEvents(1)).toEqual(['windup'])\nexpect(anim.getEvents(2)).toEqual(['hit', 'sound'])"
              },
              {
                "title": "uses default values when not specified",
                "line": 163,
                "source": "animator = new SpriteAnimator({sprite, textureSystem})\n\nanimator.loadConfig({\n    minimal: {\n        source: 'testSheet:walk'\n    }\n})\n\nconst anim = animator.get('minimal')\nexpect(anim.fps).toBe(12)\nexpect(anim.loop).toBe(true)\nexpect(anim.playbackMode).toBe('forward')"
              }
            ],
            "describes": []
          },
          {
            "title": "play",
            "line": 181,
            "beforeEach": {
              "line": 183,
              "source": "animator = new SpriteAnimator({\n    sprite,\n    textureSystem,\n    config: {\n        animations: {\n            idle: {source: 'testSheet:walk', fps: 10},\n            run: {source: 'testSheet:walk', fps: 20}\n        }\n    }\n})"
            },
            "afterEach": null,
            "tests": [
              {
                "title": "plays animation by name",
                "line": 197,
                "source": "const anim = animator.play('idle')\n\nexpect(animator.current).toBe(anim)\nexpect(anim.playing).toBe(true)"
              },
              {
                "title": "stops previous animation when playing new one",
                "line": 205,
                "source": "animator.play('idle')\nconst idleAnim = animator.current\n\nanimator.play('run')\n\nexpect(idleAnim.playing).toBe(false)\nexpect(animator.current).toBe(animator.get('run'))"
              },
              {
                "title": "returns undefined for non-existent animation",
                "line": 216,
                "source": "const result = animator.play('nonexistent')\n\nexpect(result).toBeNull()\nexpect(animator.current).toBeNull()"
              }
            ],
            "describes": []
          },
          {
            "title": "get",
            "line": 226,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns animation by name",
                "line": 228,
                "source": "animator = new SpriteAnimator({\n    sprite,\n    textureSystem,\n    config: {\n        animations: {\n            walk: {source: 'testSheet:walk'}\n        }\n    }\n})\n\nconst anim = animator.get('walk')\nexpect(anim).not.toBeNull()\nexpect(anim.$id).toBe('walk')"
              },
              {
                "title": "returns null for non-existent animation",
                "line": 245,
                "source": "animator = new SpriteAnimator({sprite, textureSystem})\n\nexpect(animator.get('nonexistent')).toBeNull()"
              }
            ],
            "describes": []
          },
          {
            "title": "update",
            "line": 254,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "updates current animation",
                "line": 256,
                "source": "animator = new SpriteAnimator({\n    sprite,\n    textureSystem,\n    config: {\n        animations: {\n            walk: {source: 'testSheet:walk', fps: 10}\n        }\n    }\n})\n\nanimator.play('walk')\nconst initialIndex = animator.current.currentIndex\n\nanimator.update(0.15)\n\nexpect(animator.current.currentIndex).toBeGreaterThan(initialIndex)"
              },
              {
                "title": "does nothing when no animation is playing",
                "line": 276,
                "source": "animator = new SpriteAnimator({sprite, textureSystem})\n\nexpect(() => animator.update(0.1)).not.toThrow()"
              }
            ],
            "describes": []
          },
          {
            "title": "resolveFrames",
            "line": 285,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns empty array when spritesheet not found",
                "line": 287,
                "source": "animator = new SpriteAnimator({sprite, textureSystem})\n\nanimator.loadConfig({\n    missing: {\n        source: 'unknownSheet:walk'\n    }\n})\n\nconst anim = animator.get('missing')\nexpect(anim.totalFrames).toBe(0)"
              },
              {
                "title": "returns empty array when no frames or source",
                "line": 301,
                "source": "animator = new SpriteAnimator({sprite, textureSystem})\n\nanimator.loadConfig({\n    empty: {\n        fps: 10\n    }\n})\n\nconst anim = animator.get('empty')\nexpect(anim.totalFrames).toBe(0)"
              }
            ],
            "describes": []
          },
          {
            "title": "resolveSourceFrames",
            "line": 317,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns frames from spritesheet animation",
                "line": 319,
                "source": "animator = new SpriteAnimator({sprite, textureSystem})\n\nconst frames = animator.resolveSourceFrames('testSheet:walk')\n\nexpect(frames).toHaveLength(3)\nexpect(frames[0].name).toBe('walk/1')\nexpect(frames[0].region).toBe('region:walk/1')\nexpect(frames[1].name).toBe('walk/2')\nexpect(frames[2].name).toBe('walk/3')"
              },
              {
                "title": "returns empty array when spritesheet not found",
                "line": 332,
                "source": "animator = new SpriteAnimator({sprite, textureSystem})\n\nconst frames = animator.resolveSourceFrames('unknownSheet:walk')\n\nexpect(frames).toEqual([])"
              },
              {
                "title": "returns empty array when animation not found",
                "line": 341,
                "source": "animator = new SpriteAnimator({sprite, textureSystem})\n\nconst frames = animator.resolveSourceFrames('testSheet:unknownAnim')\n\nexpect(frames).toEqual([])"
              }
            ],
            "describes": []
          },
          {
            "title": "resolveFrame",
            "line": 352,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "resolves frame with region format",
                "line": 354,
                "source": "animator = new SpriteAnimator({sprite, textureSystem})\n\nconst frame = animator.resolveFrame({\n    region: 'myTexture',\n    duration: 2,\n    events: ['hit']\n})\n\nexpect(frame.region).toBe('direct:myTexture')\nexpect(frame.duration).toBe(2)\nexpect(frame.events).toEqual(['hit'])"
              },
              {
                "title": "resolves frame with source format",
                "line": 369,
                "source": "animator = new SpriteAnimator({sprite, textureSystem})\n\nconst frame = animator.resolveFrame({\n    source: 'testSheet:frame1',\n    duration: 1.5,\n    events: ['sound']\n})\n\nexpect(frame.region).toBe('region:frame1')\nexpect(frame.name).toBe('frame1')\nexpect(frame.duration).toBe(1.5)\nexpect(frame.events).toEqual(['sound'])"
              },
              {
                "title": "returns null region when spritesheet not found",
                "line": 385,
                "source": "animator = new SpriteAnimator({sprite, textureSystem})\n\nconst frame = animator.resolveFrame({\n    source: 'unknownSheet:frame1'\n})\n\nexpect(frame.region).toBeNull()"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/render/spritesheet.doc.js": {
    "file": "/render/spritesheet.test.js",
    "describes": [
      {
        "title": "Spritesheet",
        "line": 4,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "initializes with image and data",
            "line": 20,
            "source": "const sheet = new Spritesheet({image: mockImage, data: mockData})\nexpect(sheet.images[0]).toBe(mockImage)\nexpect(sheet.data).toBe(mockData)"
          },
          {
            "title": "getFrame retrieves frame by name",
            "line": 26,
            "source": "const sheet = new Spritesheet({image: mockImage, data: mockData})\nconst frame = sheet.getFrame('frame1')\nexpect(frame).toBeDefined()\nexpect(frame.filename).toBe('frame1')\nexpect(frame.image).toBe(mockImage)"
          },
          {
            "title": "getFrame returns null for non-existent frame",
            "line": 34,
            "source": "const sheet = new Spritesheet({image: mockImage, data: mockData})\nconst frame = sheet.getFrame('non-existent')\nexpect(frame).toBeNull()"
          },
          {
            "title": "getFrames retrieves multiple frames by names",
            "line": 40,
            "source": "const sheet = new Spritesheet({image: mockImage, data: mockData})\nconst frames = sheet.getFrames(['frame1', 'frame2'])\nexpect(frames).toHaveLength(2)\nexpect(frames[0].filename).toBe('frame1')\nexpect(frames[1].filename).toBe('frame2')"
          },
          {
            "title": "getFrames returns all frames without arguments",
            "line": 48,
            "source": "const sheet = new Spritesheet({image: mockImage, data: mockData})\nconst frames = sheet.getFrames()\nexpect(frames).toHaveLength(2)"
          },
          {
            "title": "listFrames returns all frame names",
            "line": 54,
            "source": "const sheet = new Spritesheet({image: mockImage, data: mockData})\nconst names = sheet.listFrames()\nexpect(names).toEqual(['frame1', 'frame2'])"
          },
          {
            "title": "getRegion retrieves region by name",
            "line": 61,
            "source": "const sheet = new Spritesheet({image: mockImage, data: mockData})\nconst region = sheet.getRegion('frame1')\nexpect(region).not.toBeNull()\nexpect(region.x).toBe(0)\nexpect(region.y).toBe(0)\nexpect(region.width).toBe(10)\nexpect(region.height).toBe(10)"
          },
          {
            "title": "getRegion returns null for non-existent frame",
            "line": 72,
            "source": "const sheet = new Spritesheet({image: mockImage, data: mockData})\nconst region = sheet.getRegion('non-existent')\nexpect(region).toBeNull()"
          },
          {
            "title": "getRegions retrieves multiple regions by names",
            "line": 79,
            "source": "const sheet = new Spritesheet({image: mockImage, data: mockData})\nconst regions = sheet.getRegions(['frame1', 'frame2'])\nexpect(regions).toHaveLength(2)\nexpect(regions[0].x).toBe(0)\nexpect(regions[1].x).toBe(10)"
          }
        ],
        "describes": [
          {
            "title": "animations",
            "line": 88,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "getAnimation returns animation frame names",
                "line": 103,
                "source": "const sheet = new Spritesheet({image: mockImage, data: mockDataWithAnimations})\nconst anim = sheet.getAnimation('walk')\nexpect(anim).toEqual(['walk_0', 'walk_1'])"
              },
              {
                "title": "getAnimation returns null for non-existent animation",
                "line": 110,
                "source": "const sheet = new Spritesheet({image: mockImage, data: mockDataWithAnimations})\nconst anim = sheet.getAnimation('non-existent')\nexpect(anim).toBeNull()"
              },
              {
                "title": "getAnimationRegions returns regions for animation",
                "line": 117,
                "source": "const sheet = new Spritesheet({image: mockImage, data: mockDataWithAnimations})\nconst regions = sheet.getAnimationRegions('walk')\nexpect(regions).toHaveLength(2)\nexpect(regions[0].x).toBe(0)\nexpect(regions[1].x).toBe(10)"
              },
              {
                "title": "getAnimationRegions returns empty array for non-existent animation",
                "line": 126,
                "source": "const sheet = new Spritesheet({image: mockImage, data: mockDataWithAnimations})\nconst regions = sheet.getAnimationRegions('non-existent')\nexpect(regions).toEqual([])"
              },
              {
                "title": "listAnimations returns all animation names",
                "line": 133,
                "source": "const sheet = new Spritesheet({image: mockImage, data: mockDataWithAnimations})\nconst names = sheet.listAnimations()\nexpect(names).toContain('walk')\nexpect(names).toContain('idle')\nexpect(names).toHaveLength(2)"
              },
              {
                "title": "listAnimations returns empty array when no animations",
                "line": 142,
                "source": "const sheet = new Spritesheet({image: mockImage, data: mockData})\nconst names = sheet.listAnimations()\nexpect(names).toEqual([])"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/render/transform.doc.js": {
    "file": "/render/transform.test.js",
    "describes": [
      {
        "title": "Transform",
        "line": 5,
        "beforeEach": {
          "line": 9,
          "source": "transform = new Transform()"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor",
            "line": 14,
            "source": "expect(transform.x).toBe(0)\nexpect(transform.y).toBe(0)\nexpect(transform.rotation).toBe(0)\nexpect(transform.scaleX).toBe(1)\nexpect(transform.scaleY).toBe(1)\nexpect(transform.pivotX).toBe(0)\nexpect(transform.pivotY).toBe(0)\nexpect(transform.parent).toBe(null)\nexpect(transform.children).toEqual([])"
          },
          {
            "title": "add child",
            "line": 27,
            "source": "const child1 = new Transform()\nconst child2 = new Transform()\n\ntransform.add(child1, child2)\n\nexpect(transform.children).toEqual([child1, child2])\nexpect(child1.parent).toBe(transform)\nexpect(child2.parent).toBe(transform)"
          },
          {
            "title": "add child removes from previous parent",
            "line": 39,
            "source": "const parent1 = new Transform()\nconst parent2 = new Transform()\nconst child = new Transform()\n\nparent1.add(child)\nexpect(parent1.children).toEqual([child])\nexpect(child.parent).toBe(parent1)\n\nparent2.add(child)\nexpect(parent1.children).toEqual([])\nexpect(parent2.children).toEqual([child])\nexpect(child.parent).toBe(parent2)"
          },
          {
            "title": "remove child",
            "line": 55,
            "source": "const child = new Transform()\n\ntransform.add(child)\nexpect(transform.children).toEqual([child])\n\ntransform.remove(child)\nexpect(transform.children).toEqual([])\nexpect(child.parent).toBe(null)"
          },
          {
            "title": "updateLocalMatrix identity",
            "line": 67,
            "source": "transform.updateLocalMatrix()\nconst m = transform.worldMatrix\n\nexpect(m[0]).toBeCloseTo(1)\nexpect(m[1]).toBeCloseTo(0)\nexpect(m[2]).toBeCloseTo(0)\nexpect(m[3]).toBeCloseTo(1)\nexpect(m[4]).toBeCloseTo(0)\nexpect(m[5]).toBeCloseTo(0)"
          },
          {
            "title": "updateLocalMatrix with translation",
            "line": 80,
            "source": "transform.x = 10\ntransform.y = 20\ntransform.updateWorldMatrix()\nconst m = transform.worldMatrix\n\nexpect(m[0]).toBeCloseTo(1)\nexpect(m[1]).toBeCloseTo(0)\nexpect(m[2]).toBeCloseTo(0)\nexpect(m[3]).toBeCloseTo(1)\nexpect(m[4]).toBeCloseTo(10)\nexpect(m[5]).toBeCloseTo(20)"
          },
          {
            "title": "updateLocalMatrix with rotation",
            "line": 95,
            "source": "transform.rotation = Math.PI / 2\ntransform.updateWorldMatrix()\nconst m = transform.worldMatrix\n\nexpect(m[0]).toBeCloseTo(0)\nexpect(m[1]).toBeCloseTo(1)\nexpect(m[2]).toBeCloseTo(-1)\nexpect(m[3]).toBeCloseTo(0)\nexpect(m[4]).toBeCloseTo(0)\nexpect(m[5]).toBeCloseTo(0)"
          },
          {
            "title": "updateLocalMatrix with scale",
            "line": 109,
            "source": "transform.scaleX = 2\ntransform.scaleY = 3\ntransform.updateWorldMatrix()\nconst m = transform.worldMatrix\n\nexpect(m[0]).toBeCloseTo(2)\nexpect(m[1]).toBeCloseTo(0)\nexpect(m[2]).toBeCloseTo(0)\nexpect(m[3]).toBeCloseTo(3)\nexpect(m[4]).toBeCloseTo(0)\nexpect(m[5]).toBeCloseTo(0)"
          },
          {
            "title": "updateWorldMatrix without parent",
            "line": 124,
            "source": "transform.x = 5\ntransform.y = 10\ntransform.updateWorldMatrix()\nconst m = transform.worldMatrix\n\nexpect(m[4]).toBeCloseTo(5)\nexpect(m[5]).toBeCloseTo(10)"
          },
          {
            "title": "updateWorldMatrix with parent",
            "line": 135,
            "source": "const parent = new Transform()\nparent.x = 10\nparent.y = 20\n\nconst child = new Transform()\nchild.x = 5\nchild.y = 5\n\nparent.add(child)\nparent.updateWorldMatrix()\n\nconst m = child.worldMatrix\nexpect(m[4]).toBeCloseTo(15)\nexpect(m[5]).toBeCloseTo(25)"
          },
          {
            "title": "markDirty propagates to children",
            "line": 153,
            "source": "const child1 = new Transform()\nconst child2 = new Transform()\n\ntransform.add(child1)\nchild1.add(child2)\n\ntransform.updateWorldMatrix()\nchild1.updateWorldMatrix()\nchild2.updateWorldMatrix()\n\ntransform.markDirty()\n\ntransform.x = 100\ntransform.updateWorldMatrix()\n\nconst m = child2.worldMatrix\nexpect(m[4]).toBeCloseTo(100)"
          },
          {
            "title": "getSortedChildren returns children sorted by depth",
            "line": 174,
            "source": "const child1 = new Transform()\nchild1.depth = 2\nconst child2 = new Transform()\nchild2.depth = 0\nconst child3 = new Transform()\nchild3.depth = 1\n\ntransform.add(child1, child2, child3)\n\nconst sorted = transform.getSortedChildren()\n\nexpect(sorted[0]).toBe(child2)\nexpect(sorted[1]).toBe(child3)\nexpect(sorted[2]).toBe(child1)"
          },
          {
            "title": "getSortedChildren caches result",
            "line": 192,
            "source": "const child1 = new Transform()\nchild1.depth = 1\nconst child2 = new Transform()\nchild2.depth = 0\n\ntransform.add(child1, child2)\n\nconst sorted1 = transform.getSortedChildren()\nconst sorted2 = transform.getSortedChildren()\n\nexpect(sorted1).toBe(sorted2)"
          },
          {
            "title": "markChildrenNeedSort invalidates cache",
            "line": 207,
            "source": "const child1 = new Transform()\nchild1.depth = 1\nconst child2 = new Transform()\nchild2.depth = 0\n\ntransform.add(child1, child2)\n\nconst sorted1 = transform.getSortedChildren()\ntransform.markChildrenNeedSort()\nconst sorted2 = transform.getSortedChildren()\n\nexpect(sorted1).not.toBe(sorted2)"
          },
          {
            "title": "add triggers re-sort on next getSortedChildren call",
            "line": 223,
            "source": "const child1 = new Transform()\nchild1.depth = 1\n\ntransform.add(child1)\ntransform.getSortedChildren()\n\nconst child2 = new Transform()\nchild2.depth = 0\ntransform.add(child2)\n\nconst sorted2 = transform.getSortedChildren()\nexpect(sorted2[0]).toBe(child2)\nexpect(sorted2[1]).toBe(child1)"
          },
          {
            "title": "remove triggers re-sort on next getSortedChildren call",
            "line": 240,
            "source": "const child1 = new Transform()\nchild1.depth = 0\nconst child2 = new Transform()\nchild2.depth = 1\n\ntransform.add(child1, child2)\nconst sorted1 = transform.getSortedChildren()\nexpect(sorted1.length).toBe(2)\n\ntransform.remove(child1)\nconst sorted2 = transform.getSortedChildren()\nexpect(sorted2.length).toBe(1)\nexpect(sorted2[0]).toBe(child2)"
          },
          {
            "title": "transformPoint with identity matrix",
            "line": 257,
            "source": "transform.updateWorldMatrix()\n\nconst result = transform.transformPoint({x: 10, y: 20})\n\nexpect(result.x).toBeCloseTo(10)\nexpect(result.y).toBeCloseTo(20)"
          },
          {
            "title": "transformPoint with translation",
            "line": 267,
            "source": "transform.x = 5\ntransform.y = 10\ntransform.updateWorldMatrix()\n\nconst result = transform.transformPoint({x: 10, y: 20})\n\nexpect(result.x).toBeCloseTo(15)\nexpect(result.y).toBeCloseTo(30)"
          },
          {
            "title": "transformPoint with scale",
            "line": 279,
            "source": "transform.scaleX = 2\ntransform.scaleY = 3\ntransform.updateWorldMatrix()\n\nconst result = transform.transformPoint({x: 10, y: 20})\n\nexpect(result.x).toBeCloseTo(20)\nexpect(result.y).toBeCloseTo(60)"
          },
          {
            "title": "transformPoint with rotation",
            "line": 291,
            "source": "transform.rotation = Math.PI / 2\ntransform.updateWorldMatrix()\n\nconst result = transform.transformPoint({x: 10, y: 0})\n\nexpect(result.x).toBeCloseTo(0)\nexpect(result.y).toBeCloseTo(10)"
          },
          {
            "title": "markDirty skips already dirty children",
            "line": 302,
            "source": "const child1 = new Transform()\nconst child2 = new Transform()\nconst grandchild = new Transform()\n\ntransform.add(child1)\nchild1.add(grandchild)\ntransform.add(child2)\n\n// All start dirty, so clear them\ntransform.updateWorldMatrix()\n\n// Mark only child1 dirty\nchild1.markDirty()\n\n// Now mark parent dirty - should not re-traverse child1's subtree\n// since child1 is already dirty\nlet markDirtyCallCount = 0\nconst originalMarkDirty = grandchild.markDirty.bind(grandchild)\ngrandchild.markDirty = () => {\n    markDirtyCallCount++\n    originalMarkDirty()\n}\n\ntransform.markDirty()\n\n// grandchild.markDirty should only be called once (from child1, not from transform)\n// because child1 was already dirty and should short-circuit\nexpect(markDirtyCallCount).toBe(0)"
          },
          {
            "title": "markDirty propagates when not already dirty",
            "line": 334,
            "source": "const child = new Transform()\nconst grandchild = new Transform()\n\ntransform.add(child)\nchild.add(grandchild)\n\n// Clear dirty flags\ntransform.updateWorldMatrix()\n\n// Track if grandchild gets marked\nlet grandchildMarked = false\nconst originalMarkDirty = grandchild.markDirty.bind(grandchild)\ngrandchild.markDirty = () => {\n    grandchildMarked = true\n    originalMarkDirty()\n}\n\ntransform.markDirty()\n\nexpect(grandchildMarked).toBe(true)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/render/traverse.doc.js": {
    "file": "/render/traverse.test.js",
    "describes": [
      {
        "title": "traverseAndCollect",
        "line": 65,
        "beforeEach": {
          "line": 70,
          "source": "mockRenderer = new MockRenderer()\nrendererRegistry = new Map()\nrendererRegistry.set(MockObject, mockRenderer)"
        },
        "afterEach": null,
        "tests": [],
        "describes": [
          {
            "title": "basic traversal",
            "line": 77,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "collects visible root object",
                "line": 79,
                "source": "const root = new MockObject()\n\ntraverseAndCollect(root, rendererRegistry)\n\nexpect(mockRenderer.collected.length).toBe(1)\nexpect(mockRenderer.collected[0].object).toBe(root)"
              },
              {
                "title": "skips invisible objects",
                "line": 89,
                "source": "const root = new MockObject({visible: false})\n\ntraverseAndCollect(root, rendererRegistry)\n\nexpect(mockRenderer.collected.length).toBe(0)"
              },
              {
                "title": "traverses children recursively",
                "line": 98,
                "source": "const child1 = new MockObject()\nconst child2 = new MockObject()\nconst root = new MockObject({children: [child1, child2]})\n\ntraverseAndCollect(root, rendererRegistry)\n\nexpect(mockRenderer.collected.length).toBe(3)"
              },
              {
                "title": "traverses nested children",
                "line": 109,
                "source": "const grandchild = new MockObject()\nconst child = new MockObject({children: [grandchild]})\nconst root = new MockObject({children: [child]})\n\ntraverseAndCollect(root, rendererRegistry)\n\nexpect(mockRenderer.collected.length).toBe(3)"
              },
              {
                "title": "stops traversal at invisible parent",
                "line": 120,
                "source": "const child = new MockObject()\nconst root = new MockObject({visible: false, children: [child]})\n\ntraverseAndCollect(root, rendererRegistry)\n\nexpect(mockRenderer.collected.length).toBe(0)"
              }
            ],
            "describes": []
          },
          {
            "title": "opacity handling",
            "line": 132,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "passes full opacity for opaque root",
                "line": 134,
                "source": "const root = new MockObject({opacity: 1})\n\ntraverseAndCollect(root, rendererRegistry)\n\nexpect(mockRenderer.collected[0].opacity).toBe(1)"
              },
              {
                "title": "passes root opacity to children",
                "line": 143,
                "source": "const child = new MockObject()\nconst root = new MockObject({opacity: 0.5, children: [child]})\n\ntraverseAndCollect(root, rendererRegistry)\n\nexpect(mockRenderer.collected[1].opacity).toBe(0.5)"
              },
              {
                "title": "multiplies opacity through hierarchy",
                "line": 153,
                "source": "const grandchild = new MockObject({opacity: 0.5})\nconst child = new MockObject({opacity: 0.5, children: [grandchild]})\nconst root = new MockObject({opacity: 0.5, children: [child]})\n\ntraverseAndCollect(root, rendererRegistry)\n\nexpect(mockRenderer.collected[0].opacity).toBe(0.5)\nexpect(mockRenderer.collected[1].opacity).toBe(0.25)\nexpect(mockRenderer.collected[2].opacity).toBe(0.125)"
              }
            ],
            "describes": []
          },
          {
            "title": "render hints",
            "line": 168,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "passes renderHints to renderer",
                "line": 170,
                "source": "const hints = {filter: 'blur(5px)'}\nconst root = new MockObject({renderHints: hints})\n\ntraverseAndCollect(root, rendererRegistry)\n\nexpect(mockRenderer.collected[0].hints).toBe(hints)"
              },
              {
                "title": "passes null hints when not set",
                "line": 180,
                "source": "const root = new MockObject()\n\ntraverseAndCollect(root, rendererRegistry)\n\nexpect(mockRenderer.collected[0].hints).toBeNull()"
              }
            ],
            "describes": []
          },
          {
            "title": "frustum culling",
            "line": 191,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "culling disabled by default",
                "line": 193,
                "source": "const camera = new MockCamera({minX: 100, maxX: 200, minY: 100, maxY: 200})\nconst root = new MockObject({worldBounds: {x: 0, y: 0}})\n\ntraverseAndCollect(root, rendererRegistry, {camera})\n\nexpect(mockRenderer.collected.length).toBe(1)"
              },
              {
                "title": "culls objects outside camera when enabled",
                "line": 203,
                "source": "const camera = new MockCamera({minX: 100, maxX: 200, minY: 100, maxY: 200})\nconst root = new MockObject({worldBounds: {x: 0, y: 0}})\n\ntraverseAndCollect(root, rendererRegistry, {\n    camera,\n    enableCulling: true\n})\n\nexpect(mockRenderer.collected.length).toBe(0)"
              },
              {
                "title": "keeps objects inside camera bounds",
                "line": 216,
                "source": "const camera = new MockCamera({minX: 0, maxX: 200, minY: 0, maxY: 200})\nconst root = new MockObject({worldBounds: {x: 100, y: 100}})\n\ntraverseAndCollect(root, rendererRegistry, {\n    camera,\n    enableCulling: true\n})\n\nexpect(mockRenderer.collected.length).toBe(1)"
              },
              {
                "title": "culled parent skips children",
                "line": 229,
                "source": "const camera = new MockCamera({minX: 100, maxX: 200, minY: 100, maxY: 200})\nconst child = new MockObject({worldBounds: {x: 150, y: 150}})\nconst root = new MockObject({\n    worldBounds: {x: 0, y: 0},\n    children: [child]\n})\n\ntraverseAndCollect(root, rendererRegistry, {\n    camera,\n    enableCulling: true\n})\n\nexpect(mockRenderer.collected.length).toBe(0)"
              }
            ],
            "describes": []
          },
          {
            "title": "stats tracking",
            "line": 248,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "tracks total objects",
                "line": 250,
                "source": "const stats = {totalObjects: 0, culledObjects: 0, renderedObjects: 0}\nconst child = new MockObject()\nconst root = new MockObject({children: [child]})\n\ntraverseAndCollect(root, rendererRegistry, {stats})\n\nexpect(stats.totalObjects).toBe(2)"
              },
              {
                "title": "tracks rendered objects",
                "line": 261,
                "source": "const stats = {totalObjects: 0, culledObjects: 0, renderedObjects: 0}\nconst root = new MockObject()\n\ntraverseAndCollect(root, rendererRegistry, {stats})\n\nexpect(stats.renderedObjects).toBe(1)"
              },
              {
                "title": "tracks culled objects",
                "line": 271,
                "source": "const stats = {totalObjects: 0, culledObjects: 0, renderedObjects: 0}\nconst camera = new MockCamera({minX: 100, maxX: 200, minY: 100, maxY: 200})\nconst root = new MockObject({worldBounds: {x: 0, y: 0}})\n\ntraverseAndCollect(root, rendererRegistry, {\n    camera,\n    enableCulling: true,\n    stats\n})\n\nexpect(stats.culledObjects).toBe(1)\nexpect(stats.renderedObjects).toBe(0)"
              },
              {
                "title": "does not count invisible objects",
                "line": 287,
                "source": "const stats = {totalObjects: 0, culledObjects: 0, renderedObjects: 0}\nconst root = new MockObject({visible: false})\n\ntraverseAndCollect(root, rendererRegistry, {stats})\n\nexpect(stats.totalObjects).toBe(0)"
              }
            ],
            "describes": []
          },
          {
            "title": "depth sorting",
            "line": 299,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "renders children sorted by depth",
                "line": 301,
                "source": "const child1 = new MockObject({depth: 2})\nconst child2 = new MockObject({depth: 0})\nconst child3 = new MockObject({depth: 1})\nconst root = new MockObject({children: [child1, child2, child3]})\n\ntraverseAndCollect(root, rendererRegistry)\n\nexpect(mockRenderer.collected[1].object).toBe(child2) // depth 0\nexpect(mockRenderer.collected[2].object).toBe(child3) // depth 1\nexpect(mockRenderer.collected[3].object).toBe(child1) // depth 2"
              },
              {
                "title": "preserves insertion order for same depth",
                "line": 315,
                "source": "const child1 = new MockObject({depth: 0})\nconst child2 = new MockObject({depth: 0})\nconst child3 = new MockObject({depth: 0})\nconst root = new MockObject({children: [child1, child2, child3]})\n\ntraverseAndCollect(root, rendererRegistry)\n\nexpect(mockRenderer.collected[1].object).toBe(child1)\nexpect(mockRenderer.collected[2].object).toBe(child2)\nexpect(mockRenderer.collected[3].object).toBe(child3)"
              },
              {
                "title": "handles negative depth values",
                "line": 329,
                "source": "const child1 = new MockObject({depth: 0})\nconst child2 = new MockObject({depth: -1})\nconst child3 = new MockObject({depth: 1})\nconst root = new MockObject({children: [child1, child2, child3]})\n\ntraverseAndCollect(root, rendererRegistry)\n\nexpect(mockRenderer.collected[1].object).toBe(child2) // depth -1\nexpect(mockRenderer.collected[2].object).toBe(child1) // depth 0\nexpect(mockRenderer.collected[3].object).toBe(child3) // depth 1"
              },
              {
                "title": "treats undefined depth as 0",
                "line": 343,
                "source": "const child1 = new MockObject({depth: 1})\nconst child2 = new MockObject() // no depth, should be 0\nconst root = new MockObject({children: [child1, child2]})\n\ntraverseAndCollect(root, rendererRegistry)\n\nexpect(mockRenderer.collected[1].object).toBe(child2) // depth 0\nexpect(mockRenderer.collected[2].object).toBe(child1) // depth 1"
              },
              {
                "title": "does not mutate original children array",
                "line": 355,
                "source": "const child1 = new MockObject({depth: 2})\nconst child2 = new MockObject({depth: 0})\nconst root = new MockObject({children: [child1, child2]})\n\ntraverseAndCollect(root, rendererRegistry)\n\nexpect(root.children[0]).toBe(child1)\nexpect(root.children[1]).toBe(child2)"
              }
            ],
            "describes": []
          },
          {
            "title": "registry lookup",
            "line": 369,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "only collects objects with registered renderer",
                "line": 371,
                "source": "class UnregisteredObject extends MockObject {}\nconst unregistered = new UnregisteredObject()\nconst root = new MockObject({children: [unregistered]})\n\ntraverseAndCollect(root, rendererRegistry)\n\nexpect(mockRenderer.collected.length).toBe(1)\nexpect(mockRenderer.collected[0].object).toBe(root)"
              },
              {
                "title": "still traverses children of unregistered objects",
                "line": 383,
                "source": "class UnregisteredObject extends MockObject {}\nconst registered = new MockObject()\nconst unregistered = new UnregisteredObject({children: [registered]})\nconst root = new MockObject({children: [unregistered]})\n\ntraverseAndCollect(root, rendererRegistry)\n\nexpect(mockRenderer.collected.length).toBe(2)"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/render/webgl_texture_manager.doc.js": {
    "file": "/render/webgl_texture_manager.test.js",
    "describes": [
      {
        "title": "WebGLTextureManager",
        "line": 7,
        "beforeEach": {
          "line": 12,
          "source": "gl = createMockGLWithSpies()\nmanager = new WebGLTextureManager({gl, autoFlush: false})"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "extends PerkyModule",
            "line": 18,
            "source": "expect(manager).toBeInstanceOf(PerkyModule)"
          },
          {
            "title": "$category",
            "line": 23,
            "source": "expect(WebGLTextureManager.$category).toBe('textureManager')"
          },
          {
            "title": "flushIfFull flushes oldest zombies when over limit",
            "line": 192,
            "source": "const smallManager = new WebGLTextureManager({\n    gl,\n    maxZombieSize: 1000,\n    autoFlush: false\n})\n\nconst images = []\nfor (let i = 0; i < 5; i++) {\n    const image = createMockImage(100, 100)\n    images.push(image)\n    smallManager.acquire(image)\n    smallManager.release(image)\n}\n\nexpect(gl.deleteTexture).toHaveBeenCalled()"
          },
          {
            "title": "stats returns correct stats",
            "line": 276,
            "source": "const image1 = createMockImage(100, 100)\nconst image2 = createMockImage(200, 200)\n\nmanager.acquire(image1)\nmanager.acquire(image2)\nmanager.release(image2)\n\nconst stats = manager.stats\n\nexpect(stats.activeCount).toBe(1)\nexpect(stats.zombieCount).toBe(1)\nexpect(stats.totalCount).toBe(2)"
          },
          {
            "title": "dispose deletes all textures",
            "line": 339,
            "source": "const image1 = createMockImage()\nconst image2 = createMockImage()\n\nmanager.acquire(image1)\nmanager.acquire(image2)\nmanager.release(image2)\n\nmanager.dispose()\n\nexpect(gl.deleteTexture).toHaveBeenCalledTimes(2)"
          }
        ],
        "describes": [
          {
            "title": "acquire",
            "line": 28,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates texture on first acquire",
                "line": 30,
                "source": "const image = createMockImage()\n\nconst texture = manager.acquire(image)\n\nexpect(texture).toBeDefined()\nexpect(gl.createTexture).toHaveBeenCalledTimes(1)"
              },
              {
                "title": "returns same texture on subsequent acquires",
                "line": 40,
                "source": "const image = createMockImage()\n\nconst texture1 = manager.acquire(image)\nconst texture2 = manager.acquire(image)\n\nexpect(texture1).toBe(texture2)\nexpect(gl.createTexture).toHaveBeenCalledTimes(1)"
              },
              {
                "title": "increments ref count",
                "line": 51,
                "source": "const image = createMockImage()\n\nmanager.acquire(image)\nmanager.acquire(image)\nmanager.acquire(image)\n\nexpect(manager.stats.activeCount).toBe(1)"
              },
              {
                "title": "returns null for null image",
                "line": 62,
                "source": "expect(manager.acquire(null)).toBeNull()"
              }
            ],
            "describes": []
          },
          {
            "title": "release",
            "line": 69,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "decrements ref count",
                "line": 71,
                "source": "const image = createMockImage()\n\nmanager.acquire(image)\nmanager.acquire(image)\nmanager.release(image)\n\nexpect(manager.stats.activeCount).toBe(1)"
              },
              {
                "title": "moves to zombies when refs reach zero",
                "line": 82,
                "source": "const image = createMockImage()\n\nmanager.acquire(image)\nmanager.release(image)\n\nexpect(manager.stats.activeCount).toBe(0)\nexpect(manager.stats.zombieCount).toBe(1)"
              },
              {
                "title": "does not delete texture immediately",
                "line": 93,
                "source": "const image = createMockImage()\n\nmanager.acquire(image)\nmanager.release(image)\n\nexpect(gl.deleteTexture).not.toHaveBeenCalled()"
              },
              {
                "title": "emits zombie event",
                "line": 103,
                "source": "const image = createMockImage()\nconst handler = vi.fn()\nmanager.on('zombie', handler)\n\nmanager.acquire(image)\nmanager.release(image)\n\nexpect(handler).toHaveBeenCalled()"
              }
            ],
            "describes": []
          },
          {
            "title": "resurrect",
            "line": 117,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "resurrects zombie on acquire",
                "line": 119,
                "source": "const image = createMockImage()\n\nconst texture1 = manager.acquire(image)\nmanager.release(image)\nconst texture2 = manager.acquire(image)\n\nexpect(texture1).toBe(texture2)\nexpect(gl.createTexture).toHaveBeenCalledTimes(1)\nexpect(manager.stats.zombieCount).toBe(0)\nexpect(manager.stats.activeCount).toBe(1)"
              },
              {
                "title": "emits resurrect event",
                "line": 133,
                "source": "const image = createMockImage()\nconst handler = vi.fn()\nmanager.on('resurrect', handler)\n\nmanager.acquire(image)\nmanager.release(image)\nmanager.acquire(image)\n\nexpect(handler).toHaveBeenCalled()"
              }
            ],
            "describes": []
          },
          {
            "title": "flush",
            "line": 148,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "deletes all zombie textures",
                "line": 150,
                "source": "const image1 = createMockImage()\nconst image2 = createMockImage()\n\nmanager.acquire(image1)\nmanager.acquire(image2)\nmanager.release(image1)\nmanager.release(image2)\n\nmanager.flush()\n\nexpect(gl.deleteTexture).toHaveBeenCalledTimes(2)\nexpect(manager.stats.zombieCount).toBe(0)"
              },
              {
                "title": "does not delete active textures",
                "line": 166,
                "source": "const image = createMockImage()\n\nmanager.acquire(image)\nmanager.flush()\n\nexpect(gl.deleteTexture).not.toHaveBeenCalled()\nexpect(manager.stats.activeCount).toBe(1)"
              },
              {
                "title": "emits flush event",
                "line": 177,
                "source": "const image = createMockImage()\nconst handler = vi.fn()\nmanager.on('flush', handler)\n\nmanager.acquire(image)\nmanager.release(image)\nmanager.flush()\n\nexpect(handler).toHaveBeenCalledWith(1, expect.any(Number))"
              }
            ],
            "describes": []
          },
          {
            "title": "flushStale",
            "line": 211,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "flushes textures older than maxAge",
                "line": 213,
                "source": "vi.useFakeTimers()\n\nconst image = createMockImage()\nmanager.acquire(image)\nmanager.release(image)\n\nvi.advanceTimersByTime(20 * 60 * 1000)\n\nmanager.flushStale()\n\nexpect(gl.deleteTexture).toHaveBeenCalled()\nexpect(manager.stats.zombieCount).toBe(0)\n\nvi.useRealTimers()"
              },
              {
                "title": "does not flush recent zombies",
                "line": 231,
                "source": "const image = createMockImage()\nmanager.acquire(image)\nmanager.release(image)\n\nmanager.flushStale()\n\nexpect(gl.deleteTexture).not.toHaveBeenCalled()\nexpect(manager.stats.zombieCount).toBe(1)"
              }
            ],
            "describes": []
          },
          {
            "title": "getTexture",
            "line": 245,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns texture for active image",
                "line": 247,
                "source": "const image = createMockImage()\nconst texture = manager.acquire(image)\n\nexpect(manager.getTexture(image)).toBe(texture)"
              },
              {
                "title": "returns texture for zombie image",
                "line": 255,
                "source": "const image = createMockImage()\nconst texture = manager.acquire(image)\nmanager.release(image)\n\nexpect(manager.getTexture(image)).toBe(texture)"
              },
              {
                "title": "creates texture if not exists (legacy mode)",
                "line": 264,
                "source": "const image = createMockImage()\n\nconst texture = manager.getTexture(image)\n\nexpect(texture).toBeDefined()\nexpect(manager.stats.activeCount).toBe(1)"
              }
            ],
            "describes": []
          },
          {
            "title": "autoFlush",
            "line": 292,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "starts interval on start when enabled",
                "line": 294,
                "source": "vi.useFakeTimers()\n\nconst autoManager = new WebGLTextureManager({\n    gl,\n    autoFlush: true,\n    autoFlushInterval: 1000\n})\n\nconst flushStaleSpy = vi.spyOn(autoManager, 'flushStale')\nautoManager.start()\n\nvi.advanceTimersByTime(3000)\n\nexpect(flushStaleSpy).toHaveBeenCalledTimes(3)\n\nautoManager.stop()\nvi.useRealTimers()"
              },
              {
                "title": "stops interval on stop",
                "line": 315,
                "source": "vi.useFakeTimers()\n\nconst autoManager = new WebGLTextureManager({\n    gl,\n    autoFlush: true,\n    autoFlushInterval: 1000\n})\n\nautoManager.start()\nautoManager.stop()\n\nconst flushStaleSpy = vi.spyOn(autoManager, 'flushStale')\n\nvi.advanceTimersByTime(3000)\n\nexpect(flushStaleSpy).not.toHaveBeenCalled()\n\nvi.useRealTimers()"
              }
            ],
            "describes": []
          },
          {
            "title": "hasTexture",
            "line": 353,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns true for active texture",
                "line": 355,
                "source": "const image = createMockImage()\nmanager.acquire(image)\n\nexpect(manager.hasTexture(image)).toBe(true)"
              },
              {
                "title": "returns true for zombie texture",
                "line": 363,
                "source": "const image = createMockImage()\nmanager.acquire(image)\nmanager.release(image)\n\nexpect(manager.hasTexture(image)).toBe(true)"
              },
              {
                "title": "returns false for unknown image",
                "line": 372,
                "source": "const image = createMockImage()\n\nexpect(manager.hasTexture(image)).toBe(false)"
              },
              {
                "title": "returns false after dispose",
                "line": 379,
                "source": "const image = createMockImage()\nmanager.acquire(image)\nmanager.dispose()\n\nconst newGl = createMockGLWithSpies()\nconst newManager = new WebGLTextureManager({gl: newGl, autoFlush: false})\n\nexpect(newManager.hasTexture(image)).toBe(false)"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/render/canvas/canvas_circle_renderer.doc.js": {
    "file": "/render/canvas/canvas_circle_renderer.test.js",
    "describes": [
      {
        "title": "CanvasCircleRenderer",
        "line": 7,
        "beforeEach": {
          "line": 13,
          "source": "renderer = new CanvasCircleRenderer()\nctx = {\n    beginPath: () => {},\n    arc: () => {},\n    fill: () => {},\n    stroke: () => {},\n    fillStyle: null,\n    strokeStyle: null,\n    lineWidth: 0\n}"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "extends CanvasObjectRenderer",
            "line": 27,
            "source": "expect(renderer).toBeInstanceOf(CanvasObjectRenderer)"
          },
          {
            "title": "handles returns Circle",
            "line": 32,
            "source": "expect(CanvasCircleRenderer.handles).toEqual([Circle])"
          }
        ],
        "describes": [
          {
            "title": "render",
            "line": 37,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "draws circle with correct offset for default anchor",
                "line": 39,
                "source": "let arcArgs = null\nctx.arc = (...args) => {\n    arcArgs = args\n}\n\nconst circle = {\n    radius: 50,\n    anchorX: 0.5,\n    anchorY: 0.5,\n    color: '#ff0000',\n    strokeWidth: 0\n}\n\nrenderer.render(circle, ctx)\n\nexpect(arcArgs[0]).toBe(0)\nexpect(arcArgs[1]).toBe(0)\nexpect(arcArgs[2]).toBe(50)\nexpect(arcArgs[3]).toBe(0)\nexpect(arcArgs[4]).toBe(Math.PI * 2)"
              },
              {
                "title": "draws circle with correct offset for top-left anchor",
                "line": 63,
                "source": "let arcArgs = null\nctx.arc = (...args) => {\n    arcArgs = args\n}\n\nconst circle = {\n    radius: 50,\n    anchorX: 0,\n    anchorY: 0,\n    color: '#ff0000',\n    strokeWidth: 0\n}\n\nrenderer.render(circle, ctx)\n\nexpect(arcArgs[0]).toBe(50)\nexpect(arcArgs[1]).toBe(50)"
              },
              {
                "title": "sets fill color",
                "line": 84,
                "source": "const circle = {\n    radius: 30,\n    anchorX: 0.5,\n    anchorY: 0.5,\n    color: '#00ff00',\n    strokeWidth: 0\n}\n\nrenderer.render(circle, ctx)\n\nexpect(ctx.fillStyle).toBe('#00ff00')"
              },
              {
                "title": "draws stroke when strokeWidth > 0",
                "line": 99,
                "source": "let stroked = false\nctx.stroke = () => {\n    stroked = true\n}\n\nconst circle = {\n    radius: 40,\n    anchorX: 0.5,\n    anchorY: 0.5,\n    color: '#ff0000',\n    strokeWidth: 2,\n    strokeColor: '#000000'\n}\n\nrenderer.render(circle, ctx)\n\nexpect(stroked).toBe(true)\nexpect(ctx.strokeStyle).toBe('#000000')\nexpect(ctx.lineWidth).toBe(2)"
              },
              {
                "title": "does not draw stroke when strokeWidth is 0",
                "line": 122,
                "source": "let stroked = false\nctx.stroke = () => {\n    stroked = true\n}\n\nconst circle = {\n    radius: 40,\n    anchorX: 0.5,\n    anchorY: 0.5,\n    color: '#ff0000',\n    strokeWidth: 0\n}\n\nrenderer.render(circle, ctx)\n\nexpect(stroked).toBe(false)"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/render/canvas/canvas_debug_gizmo_renderer.doc.js": {
    "file": "/render/canvas/canvas_debug_gizmo_renderer.test.js",
    "describes": [
      {
        "title": "CanvasDebugGizmoRenderer",
        "line": 5,
        "beforeEach": {
          "line": 12,
          "source": "renderer = new CanvasDebugGizmoRenderer()\nctx = {\n    save: () => {},\n    restore: () => {},\n    transform: () => {},\n    globalAlpha: 1,\n    strokeStyle: '',\n    fillStyle: '',\n    lineWidth: 0,\n    setLineDash: () => {},\n    strokeRect: () => {},\n    beginPath: () => {},\n    moveTo: () => {},\n    lineTo: () => {},\n    stroke: () => {},\n    fill: () => {},\n    arc: () => {}\n}\nmockContext = {ctx}\nrenderer.init(mockContext)\nrenderer.reset()"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "handles returns empty array",
            "line": 37,
            "source": "expect(CanvasDebugGizmoRenderer.handles).toEqual([])"
          },
          {
            "title": "collected returns empty array initially",
            "line": 42,
            "source": "expect(renderer.collected).toEqual([])"
          },
          {
            "title": "collectGizmo adds object to collected",
            "line": 47,
            "source": "const obj = {name: 'test'}\nrenderer.collectGizmo(obj, 0.8)\nexpect(renderer.collected).toEqual([{object: obj, opacity: 0.8, hints: null}])"
          },
          {
            "title": "collect adds object with hints",
            "line": 54,
            "source": "const obj = {name: 'test'}\nconst hints = {key: 'value'}\nrenderer.collect(obj, 0.5, hints)\nexpect(renderer.collected).toEqual([{object: obj, opacity: 0.5, hints}])"
          },
          {
            "title": "reset clears collected",
            "line": 62,
            "source": "renderer.collect({}, 1, null)\nrenderer.reset()\nexpect(renderer.collected).toEqual([])"
          },
          {
            "title": "renderPivot sets stroke style to magenta",
            "line": 266,
            "source": "const obj = {pivotX: 5, pivotY: 5}\nrenderer.renderPivot(ctx, obj)\nexpect(ctx.strokeStyle).toBe('rgba(255, 0, 255, 1)')"
          }
        ],
        "describes": [
          {
            "title": "flush",
            "line": 69,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "applies world matrix transform",
                "line": 71,
                "source": "let transformArgs = null\nctx.transform = (...args) => {\n    transformArgs = args\n}\n\nconst obj = {\n    worldMatrix: [1, 2, 3, 4, 5, 6],\n    debugGizmos: null\n}\nrenderer.collectGizmo(obj, 1)\nrenderer.flush()\n\nexpect(transformArgs).toEqual([1, 2, 3, 4, 5, 6])"
              },
              {
                "title": "sets global alpha from opacity",
                "line": 88,
                "source": "const obj = {\n    worldMatrix: [1, 0, 0, 1, 0, 0],\n    debugGizmos: null\n}\nrenderer.collectGizmo(obj, 0.7)\nrenderer.flush()\n\nexpect(ctx.globalAlpha).toBe(0.7)"
              },
              {
                "title": "saves and restores context for each object",
                "line": 100,
                "source": "let saveCount = 0\nlet restoreCount = 0\nctx.save = () => saveCount++\nctx.restore = () => restoreCount++\n\nconst obj1 = {worldMatrix: [1, 0, 0, 1, 0, 0], debugGizmos: null}\nconst obj2 = {worldMatrix: [1, 0, 0, 1, 0, 0], debugGizmos: null}\nrenderer.collectGizmo(obj1, 1)\nrenderer.collectGizmo(obj2, 1)\nrenderer.flush()\n\nexpect(saveCount).toBe(2)\nexpect(restoreCount).toBe(2)"
              }
            ],
            "describes": []
          },
          {
            "title": "renderGizmos",
            "line": 119,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns early if debugGizmos is null",
                "line": 121,
                "source": "const obj = {debugGizmos: null, getBounds: () => ({})}\nexpect(() => renderer.renderGizmos(obj, ctx)).not.toThrow()"
              },
              {
                "title": "does not render bounds when size is zero",
                "line": 127,
                "source": "let strokeRectCalled = false\nctx.strokeRect = () => {\n    strokeRectCalled = true\n}\n\nconst obj = {\n    debugGizmos: {bounds: true},\n    getBounds: () => ({minX: 0, minY: 0, width: 0, height: 0})\n}\nrenderer.renderGizmos(obj, ctx)\n\nexpect(strokeRectCalled).toBe(false)"
              },
              {
                "title": "renders bounds when size is non-zero",
                "line": 143,
                "source": "let strokeRectCalled = false\nctx.strokeRect = () => {\n    strokeRectCalled = true\n}\n\nconst obj = {\n    debugGizmos: {bounds: true},\n    getBounds: () => ({minX: 0, minY: 0, width: 10, height: 10})\n}\nrenderer.renderGizmos(obj, ctx)\n\nexpect(strokeRectCalled).toBe(true)"
              },
              {
                "title": "renders anchor when enabled",
                "line": 159,
                "source": "let arcCalled = false\nctx.arc = () => {\n    arcCalled = true\n}\n\nconst obj = {\n    debugGizmos: {anchor: true},\n    anchorX: 0.5,\n    anchorY: 0.5,\n    getBounds: () => ({minX: 0, minY: 0, width: 10, height: 10})\n}\nrenderer.renderGizmos(obj, ctx)\n\nexpect(arcCalled).toBe(true)"
              },
              {
                "title": "renders pivot when enabled",
                "line": 177,
                "source": "let arcCalled = false\nctx.arc = () => {\n    arcCalled = true\n}\n\nconst obj = {\n    debugGizmos: {pivot: true},\n    pivotX: 5,\n    pivotY: 5,\n    getBounds: () => ({minX: 0, minY: 0, width: 10, height: 10})\n}\nrenderer.renderGizmos(obj, ctx)\n\nexpect(arcCalled).toBe(true)"
              },
              {
                "title": "renders origin when enabled",
                "line": 195,
                "source": "let arcCalled = false\nctx.arc = () => {\n    arcCalled = true\n}\n\nconst obj = {\n    debugGizmos: {origin: true},\n    getBounds: () => ({minX: 0, minY: 0, width: 10, height: 10})\n}\nrenderer.renderGizmos(obj, ctx)\n\nexpect(arcCalled).toBe(true)"
              }
            ],
            "describes": []
          },
          {
            "title": "renderBounds",
            "line": 213,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "sets stroke style to green",
                "line": 215,
                "source": "const bounds = {minX: 0, minY: 0, width: 10, height: 10}\nrenderer.renderBounds(ctx, bounds)\nexpect(ctx.strokeStyle).toBe('rgba(0, 255, 0, 0.8)')"
              },
              {
                "title": "sets line dash pattern",
                "line": 222,
                "source": "let dashPattern = null\nctx.setLineDash = (pattern) => {\n    dashPattern = pattern\n}\nconst bounds = {minX: 0, minY: 0, width: 10, height: 10}\nrenderer.renderBounds(ctx, bounds)\nexpect(dashPattern).toEqual([])"
              },
              {
                "title": "calls strokeRect with bounds",
                "line": 233,
                "source": "let rectArgs = null\nctx.strokeRect = (...args) => {\n    rectArgs = args\n}\nconst bounds = {minX: 5, minY: 10, width: 20, height: 30}\nrenderer.renderBounds(ctx, bounds)\nexpect(rectArgs).toEqual([5, 10, 20, 30])"
              }
            ],
            "describes": []
          },
          {
            "title": "renderAnchor",
            "line": 246,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "sets stroke style to yellow",
                "line": 248,
                "source": "const obj = {anchorX: 0.5, anchorY: 0.5}\nconst bounds = {minX: 0, minY: 0, width: 10, height: 10}\nrenderer.renderAnchor(ctx, obj, bounds)\nexpect(ctx.strokeStyle).toBe('rgba(255, 255, 0, 1)')"
              },
              {
                "title": "sets fill style to semi-transparent yellow",
                "line": 256,
                "source": "const obj = {anchorX: 0.5, anchorY: 0.5}\nconst bounds = {minX: 0, minY: 0, width: 10, height: 10}\nrenderer.renderAnchor(ctx, obj, bounds)\nexpect(ctx.fillStyle).toBe('rgba(255, 255, 0, 0.5)')"
              }
            ],
            "describes": []
          },
          {
            "title": "renderOrigin",
            "line": 273,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "draws red x-axis",
                "line": 275,
                "source": "const strokes = []\nctx.beginPath = () => strokes.push('begin')\nctx.stroke = () => strokes.push(ctx.strokeStyle)\n\nrenderer.renderOrigin(ctx)\n\nexpect(strokes).toContain('rgba(255, 0, 0, 1)')"
              },
              {
                "title": "draws green y-axis",
                "line": 286,
                "source": "const strokes = []\nctx.stroke = () => strokes.push(ctx.strokeStyle)\n\nrenderer.renderOrigin(ctx)\n\nexpect(strokes).toContain('rgba(0, 255, 0, 1)')"
              },
              {
                "title": "draws white center dot",
                "line": 296,
                "source": "renderer.renderOrigin(ctx)\nexpect(ctx.fillStyle).toBe('rgba(255, 255, 255, 1)')"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/render/canvas/canvas_object_renderer.doc.js": {
    "file": "/render/canvas/canvas_object_renderer.test.js",
    "describes": [
      {
        "title": "CanvasObjectRenderer",
        "line": 5,
        "beforeEach": {
          "line": 12,
          "source": "renderer = new CanvasObjectRenderer()\nctx = {\n    save: () => {},\n    restore: () => {},\n    transform: () => {},\n    globalAlpha: 1,\n    filter: 'none'\n}\nmockContext = {ctx}"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "handles returns empty array",
            "line": 25,
            "source": "expect(CanvasObjectRenderer.handles).toEqual([])"
          },
          {
            "title": "ctx returns null before init",
            "line": 30,
            "source": "expect(renderer.ctx).toBeNull()"
          },
          {
            "title": "context returns null before init",
            "line": 35,
            "source": "expect(renderer.context).toBeNull()"
          },
          {
            "title": "reset clears collected objects",
            "line": 76,
            "source": "renderer.init(mockContext)\nconst obj = {worldMatrix: [1, 0, 0, 1, 0, 0]}\nrenderer.collect(obj, 1)\nrenderer.reset()\n\nlet transformCalled = false\nctx.transform = () => {\n    transformCalled = true\n}\nrenderer.flush()\n\nexpect(transformCalled).toBe(false)"
          },
          {
            "title": "render is a no-op by default",
            "line": 157,
            "source": "expect(() => renderer.render()).not.toThrow()"
          }
        ],
        "describes": [
          {
            "title": "init",
            "line": 40,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "stores context",
                "line": 42,
                "source": "renderer.init(mockContext)\nexpect(renderer.context).toBe(mockContext)"
              },
              {
                "title": "ctx returns context.ctx",
                "line": 48,
                "source": "renderer.init(mockContext)\nexpect(renderer.ctx).toBe(ctx)"
              }
            ],
            "describes": []
          },
          {
            "title": "collect",
            "line": 56,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "collects objects for later rendering",
                "line": 58,
                "source": "renderer.init(mockContext)\nconst obj = {worldMatrix: [1, 0, 0, 1, 0, 0]}\nrenderer.collect(obj, 1)\nexpect(() => renderer.flush()).not.toThrow()"
              },
              {
                "title": "collects with hints",
                "line": 66,
                "source": "renderer.init(mockContext)\nconst obj = {worldMatrix: [1, 0, 0, 1, 0, 0]}\nrenderer.collect(obj, 0.5, {filter: 'blur(5px)'})\nexpect(() => renderer.flush()).not.toThrow()"
              }
            ],
            "describes": []
          },
          {
            "title": "flush",
            "line": 92,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "applies world matrix transform",
                "line": 94,
                "source": "renderer.init(mockContext)\n\nlet transformArgs = null\nctx.transform = (...args) => {\n    transformArgs = args\n}\n\nconst obj = {worldMatrix: [1, 2, 3, 4, 5, 6]}\nrenderer.collect(obj, 1)\nrenderer.flush()\n\nexpect(transformArgs).toEqual([1, 2, 3, 4, 5, 6])"
              },
              {
                "title": "sets global alpha from opacity",
                "line": 110,
                "source": "renderer.init(mockContext)\n\nconst obj = {worldMatrix: [1, 0, 0, 1, 0, 0]}\nrenderer.collect(obj, 0.7)\nrenderer.flush()\n\nexpect(ctx.globalAlpha).toBe(0.7)"
              },
              {
                "title": "applies filter from hints",
                "line": 121,
                "source": "renderer.init(mockContext)\n\nconst obj = {worldMatrix: [1, 0, 0, 1, 0, 0]}\nrenderer.collect(obj, 1, {filter: 'blur(10px)'})\nrenderer.flush()\n\nexpect(ctx.filter).toBe('blur(10px)')"
              },
              {
                "title": "saves and restores context for each object",
                "line": 132,
                "source": "renderer.init(mockContext)\n\nlet saveCount = 0\nlet restoreCount = 0\nctx.save = () => {\n    saveCount++\n}\nctx.restore = () => {\n    restoreCount++\n}\n\nconst obj1 = {worldMatrix: [1, 0, 0, 1, 0, 0]}\nconst obj2 = {worldMatrix: [1, 0, 0, 1, 0, 0]}\nrenderer.collect(obj1, 1)\nrenderer.collect(obj2, 1)\nrenderer.flush()\n\nexpect(saveCount).toBe(2)\nexpect(restoreCount).toBe(2)"
              }
            ],
            "describes": []
          },
          {
            "title": "dispose",
            "line": 162,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "clears context reference",
                "line": 164,
                "source": "renderer.init(mockContext)\nrenderer.dispose()\nexpect(renderer.context).toBeNull()"
              },
              {
                "title": "clears collected objects",
                "line": 171,
                "source": "renderer.init(mockContext)\nconst obj = {worldMatrix: [1, 0, 0, 1, 0, 0]}\nrenderer.collect(obj, 1)\nrenderer.dispose()\n\nrenderer.init(mockContext)\nlet transformCalled = false\nctx.transform = () => {\n    transformCalled = true\n}\nrenderer.flush()\n\nexpect(transformCalled).toBe(false)"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/render/canvas/canvas_post_processor.doc.js": {
    "file": "/render/canvas/canvas_post_processor.test.js",
    "describes": [
      {
        "title": "CanvasPostProcessor",
        "line": 5,
        "beforeEach": {
          "line": 11,
          "source": "ctx = {\n    filter: 'none',\n    canvas: {width: 800, height: 600},\n    save: () => {},\n    restore: () => {},\n    fillRect: () => {},\n    fillStyle: null,\n    createRadialGradient: () => ({\n        addColorStop: () => {}\n    })\n}\nprocessor = new CanvasPostProcessor(ctx)"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "filters starts empty",
            "line": 27,
            "source": "expect(processor.filters).toEqual([])"
          },
          {
            "title": "addManualEffect returns this for chaining",
            "line": 94,
            "source": "const effect = {apply: () => {}}\nconst result = processor.addManualEffect(effect)\nexpect(result).toBe(processor)"
          },
          {
            "title": "dispose clears filters",
            "line": 334,
            "source": "processor.addFilter('blur', 5)\nprocessor.dispose()\n\nexpect(processor.filters).toEqual([])"
          }
        ],
        "describes": [
          {
            "title": "addFilter",
            "line": 32,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "adds filter to list",
                "line": 34,
                "source": "processor.addFilter('blur', 5)\nexpect(processor.filters).toEqual([{type: 'blur', value: 5}])"
              },
              {
                "title": "returns this for chaining",
                "line": 40,
                "source": "const result = processor.addFilter('blur', 5)\nexpect(result).toBe(processor)"
              },
              {
                "title": "allows multiple filters",
                "line": 46,
                "source": "processor.addFilter('blur', 5)\nprocessor.addFilter('brightness', 1.2)\n\nexpect(processor.filters).toHaveLength(2)"
              }
            ],
            "describes": []
          },
          {
            "title": "removeFilter",
            "line": 56,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "removes filter by type",
                "line": 58,
                "source": "processor.addFilter('blur', 5)\nprocessor.addFilter('brightness', 1.2)\nprocessor.removeFilter('blur')\n\nexpect(processor.filters).toEqual([{type: 'brightness', value: 1.2}])"
              },
              {
                "title": "returns this for chaining",
                "line": 67,
                "source": "const result = processor.removeFilter('blur')\nexpect(result).toBe(processor)"
              }
            ],
            "describes": []
          },
          {
            "title": "clearFilters",
            "line": 75,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "removes all filters",
                "line": 77,
                "source": "processor.addFilter('blur', 5)\nprocessor.addFilter('brightness', 1.2)\nprocessor.clearFilters()\n\nexpect(processor.filters).toEqual([])"
              },
              {
                "title": "returns this for chaining",
                "line": 86,
                "source": "const result = processor.clearFilters()\nexpect(result).toBe(processor)"
              }
            ],
            "describes": []
          },
          {
            "title": "removeManualEffect",
            "line": 101,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "removes specific effect",
                "line": 103,
                "source": "const effect1 = {apply: () => {}}\nconst effect2 = {apply: () => {}}\nprocessor.addManualEffect(effect1)\nprocessor.addManualEffect(effect2)\nprocessor.removeManualEffect(effect1)\n\nlet appliedCount = 0\neffect1.apply = () => {\n    appliedCount++\n}\neffect2.apply = () => {\n    appliedCount++\n}\n\nprocessor.finish(800, 600)\n\nexpect(appliedCount).toBe(1)"
              },
              {
                "title": "returns this for chaining",
                "line": 124,
                "source": "const result = processor.removeManualEffect({})\nexpect(result).toBe(processor)"
              }
            ],
            "describes": []
          },
          {
            "title": "clearManualEffects",
            "line": 132,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "removes all manual effects",
                "line": 134,
                "source": "processor.addManualEffect({apply: () => {}})\nprocessor.addManualEffect({apply: () => {}})\nprocessor.clearManualEffects()\n\nlet appliedCount = 0\nprocessor.finish(800, 600)\n\nexpect(appliedCount).toBe(0)"
              },
              {
                "title": "returns this for chaining",
                "line": 146,
                "source": "const result = processor.clearManualEffects()\nexpect(result).toBe(processor)"
              }
            ],
            "describes": []
          },
          {
            "title": "begin",
            "line": 154,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "sets filter string on context",
                "line": 156,
                "source": "processor.addFilter('blur', 5)\nprocessor.begin()\n\nexpect(ctx.filter).toBe('blur(5px)')"
              },
              {
                "title": "combines multiple filters",
                "line": 164,
                "source": "processor.addFilter('blur', 5)\nprocessor.addFilter('brightness', 1.2)\nprocessor.begin()\n\nexpect(ctx.filter).toBe('blur(5px) brightness(1.2)')"
              },
              {
                "title": "does not set filter when no filters",
                "line": 173,
                "source": "ctx.filter = 'existing'\nprocessor.begin()\n\nexpect(ctx.filter).toBe('existing')"
              },
              {
                "title": "formats contrast filter",
                "line": 181,
                "source": "processor.addFilter('contrast', 1.5)\nprocessor.begin()\nexpect(ctx.filter).toBe('contrast(1.5)')"
              },
              {
                "title": "formats grayscale filter",
                "line": 188,
                "source": "processor.addFilter('grayscale', 0.5)\nprocessor.begin()\nexpect(ctx.filter).toBe('grayscale(0.5)')"
              },
              {
                "title": "formats saturate filter",
                "line": 195,
                "source": "processor.addFilter('saturate', 2)\nprocessor.begin()\nexpect(ctx.filter).toBe('saturate(2)')"
              },
              {
                "title": "formats sepia filter",
                "line": 202,
                "source": "processor.addFilter('sepia', 0.8)\nprocessor.begin()\nexpect(ctx.filter).toBe('sepia(0.8)')"
              },
              {
                "title": "formats hueRotate filter",
                "line": 209,
                "source": "processor.addFilter('hueRotate', 90)\nprocessor.begin()\nexpect(ctx.filter).toBe('hue-rotate(90deg)')"
              },
              {
                "title": "formats invert filter",
                "line": 216,
                "source": "processor.addFilter('invert', 1)\nprocessor.begin()\nexpect(ctx.filter).toBe('invert(1)')"
              },
              {
                "title": "formats opacity filter",
                "line": 223,
                "source": "processor.addFilter('opacity', 0.5)\nprocessor.begin()\nexpect(ctx.filter).toBe('opacity(0.5)')"
              },
              {
                "title": "formats dropShadow filter",
                "line": 230,
                "source": "processor.addFilter('dropShadow', '4px 4px 10px black')\nprocessor.begin()\nexpect(ctx.filter).toBe('drop-shadow(4px 4px 10px black)')"
              }
            ],
            "describes": []
          },
          {
            "title": "finish",
            "line": 239,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "resets filter to none",
                "line": 241,
                "source": "processor.addFilter('blur', 5)\nprocessor.begin()\nprocessor.finish(800, 600)\n\nexpect(ctx.filter).toBe('none')"
              },
              {
                "title": "applies manual effects",
                "line": 250,
                "source": "let applied = false\nlet appliedWidth = null\nlet appliedHeight = null\n\nprocessor.addManualEffect({\n    apply: (c, w, h) => {\n        applied = true\n        appliedWidth = w\n        appliedHeight = h\n    }\n})\n\nprocessor.finish(800, 600)\n\nexpect(applied).toBe(true)\nexpect(appliedWidth).toBe(800)\nexpect(appliedHeight).toBe(600)"
              }
            ],
            "describes": []
          },
          {
            "title": "applyVignette",
            "line": 273,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates radial gradient",
                "line": 275,
                "source": "let gradientCreated = false\nctx.createRadialGradient = () => {\n    gradientCreated = true\n    return {addColorStop: () => {}}\n}\n\nprocessor.applyVignette()\n\nexpect(gradientCreated).toBe(true)"
              },
              {
                "title": "saves and restores context",
                "line": 288,
                "source": "let saved = false\nlet restored = false\nctx.save = () => {\n    saved = true\n}\nctx.restore = () => {\n    restored = true\n}\n\nprocessor.applyVignette()\n\nexpect(saved).toBe(true)\nexpect(restored).toBe(true)"
              },
              {
                "title": "fills rect with gradient",
                "line": 305,
                "source": "let fillRectArgs = null\nctx.fillRect = (...args) => {\n    fillRectArgs = args\n}\n\nprocessor.applyVignette()\n\nexpect(fillRectArgs).toEqual([0, 0, 800, 600])"
              },
              {
                "title": "uses default intensity and softness",
                "line": 317,
                "source": "let colorStops = []\nctx.createRadialGradient = () => ({\n    addColorStop: (pos, color) => {\n        colorStops.push({pos, color})\n    }\n})\n\nprocessor.applyVignette()\n\nexpect(colorStops[0].color).toBe('rgba(0, 0, 0, 0)')\nexpect(colorStops[1].color).toContain('rgba(0, 0, 0,')"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/render/canvas/canvas_rectangle_renderer.doc.js": {
    "file": "/render/canvas/canvas_rectangle_renderer.test.js",
    "describes": [
      {
        "title": "CanvasRectangleRenderer",
        "line": 7,
        "beforeEach": {
          "line": 13,
          "source": "renderer = new CanvasRectangleRenderer()\nctx = {\n    fillRect: () => {},\n    strokeRect: () => {},\n    fillStyle: null,\n    strokeStyle: null,\n    lineWidth: 0\n}"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "extends CanvasObjectRenderer",
            "line": 25,
            "source": "expect(renderer).toBeInstanceOf(CanvasObjectRenderer)"
          },
          {
            "title": "handles returns Rectangle",
            "line": 30,
            "source": "expect(CanvasRectangleRenderer.handles).toEqual([Rectangle])"
          }
        ],
        "describes": [
          {
            "title": "render",
            "line": 35,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "fills rectangle with color",
                "line": 37,
                "source": "let fillRectArgs = null\nctx.fillRect = (...args) => {\n    fillRectArgs = args\n}\n\nconst rect = {\n    width: 100,\n    height: 50,\n    anchorX: 0,\n    anchorY: 0,\n    color: '#ff0000',\n    strokeWidth: 0\n}\n\nrenderer.render(rect, ctx)\n\nexpect(ctx.fillStyle).toBe('#ff0000')\nexpect(fillRectArgs[0]).toBe(-0)\nexpect(fillRectArgs[1]).toBe(-0)\nexpect(fillRectArgs[2]).toBe(100)\nexpect(fillRectArgs[3]).toBe(50)"
              },
              {
                "title": "applies anchor offset",
                "line": 62,
                "source": "let fillRectArgs = null\nctx.fillRect = (...args) => {\n    fillRectArgs = args\n}\n\nconst rect = {\n    width: 100,\n    height: 100,\n    anchorX: 0.5,\n    anchorY: 0.5,\n    color: '#ff0000',\n    strokeWidth: 0\n}\n\nrenderer.render(rect, ctx)\n\nexpect(fillRectArgs[0]).toBe(-50)\nexpect(fillRectArgs[1]).toBe(-50)"
              },
              {
                "title": "does not fill when color is transparent",
                "line": 84,
                "source": "let filled = false\nctx.fillRect = () => {\n    filled = true\n}\n\nconst rect = {\n    width: 100,\n    height: 50,\n    anchorX: 0,\n    anchorY: 0,\n    color: 'transparent',\n    strokeWidth: 0\n}\n\nrenderer.render(rect, ctx)\n\nexpect(filled).toBe(false)"
              },
              {
                "title": "does not fill when color is null",
                "line": 105,
                "source": "let filled = false\nctx.fillRect = () => {\n    filled = true\n}\n\nconst rect = {\n    width: 100,\n    height: 50,\n    anchorX: 0,\n    anchorY: 0,\n    color: null,\n    strokeWidth: 0\n}\n\nrenderer.render(rect, ctx)\n\nexpect(filled).toBe(false)"
              },
              {
                "title": "draws stroke when strokeWidth > 0",
                "line": 126,
                "source": "let strokeRectArgs = null\nctx.strokeRect = (...args) => {\n    strokeRectArgs = args\n}\n\nconst rect = {\n    width: 100,\n    height: 50,\n    anchorX: 0,\n    anchorY: 0,\n    color: '#ff0000',\n    strokeWidth: 2,\n    strokeColor: '#000000'\n}\n\nrenderer.render(rect, ctx)\n\nexpect(ctx.strokeStyle).toBe('#000000')\nexpect(ctx.lineWidth).toBe(2)\nexpect(strokeRectArgs[0]).toBe(-0)\nexpect(strokeRectArgs[1]).toBe(-0)\nexpect(strokeRectArgs[2]).toBe(100)\nexpect(strokeRectArgs[3]).toBe(50)"
              },
              {
                "title": "does not stroke when strokeWidth is 0",
                "line": 153,
                "source": "let stroked = false\nctx.strokeRect = () => {\n    stroked = true\n}\n\nconst rect = {\n    width: 100,\n    height: 50,\n    anchorX: 0,\n    anchorY: 0,\n    color: '#ff0000',\n    strokeWidth: 0\n}\n\nrenderer.render(rect, ctx)\n\nexpect(stroked).toBe(false)"
              },
              {
                "title": "can draw stroke-only rectangle",
                "line": 174,
                "source": "let filled = false\nlet stroked = false\nctx.fillRect = () => {\n    filled = true\n}\nctx.strokeRect = () => {\n    stroked = true\n}\n\nconst rect = {\n    width: 100,\n    height: 50,\n    anchorX: 0,\n    anchorY: 0,\n    color: 'transparent',\n    strokeWidth: 3,\n    strokeColor: '#0000ff'\n}\n\nrenderer.render(rect, ctx)\n\nexpect(filled).toBe(false)\nexpect(stroked).toBe(true)"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/render/canvas/canvas_sprite_renderer.doc.js": {
    "file": "/render/canvas/canvas_sprite_renderer.test.js",
    "describes": [
      {
        "title": "CanvasSpriteRenderer",
        "line": 26,
        "beforeEach": {
          "line": 32,
          "source": "renderer = new CanvasSpriteRenderer()\nctx = {\n    save: () => {},\n    restore: () => {},\n    scale: () => {},\n    drawImage: () => {}\n}"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "extends CanvasObjectRenderer",
            "line": 43,
            "source": "expect(renderer).toBeInstanceOf(CanvasObjectRenderer)"
          },
          {
            "title": "handles returns Sprite",
            "line": 48,
            "source": "expect(CanvasSpriteRenderer.handles).toEqual([Sprite])"
          }
        ],
        "describes": [
          {
            "title": "render",
            "line": 53,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "does not draw without region",
                "line": 55,
                "source": "let drawn = false\nctx.drawImage = () => {\n    drawn = true\n}\n\nconst sprite = new Sprite()\n\nrenderer.render(sprite, ctx)\n\nexpect(drawn).toBe(false)"
              },
              {
                "title": "does not draw when image is not complete",
                "line": 69,
                "source": "let drawn = false\nctx.drawImage = () => {\n    drawn = true\n}\n\nconst img = {complete: false, naturalWidth: 100, width: 100, height: 100}\nconst sprite = new Sprite({frame: createMockFrame({x: 0, y: 0, w: 32, h: 32, image: img})})\n\nrenderer.render(sprite, ctx)\n\nexpect(drawn).toBe(false)"
              },
              {
                "title": "does not draw when naturalWidth is 0",
                "line": 84,
                "source": "let drawn = false\nctx.drawImage = () => {\n    drawn = true\n}\n\nconst img = {complete: true, naturalWidth: 0, width: 100, height: 100}\nconst sprite = new Sprite({frame: createMockFrame({x: 0, y: 0, w: 32, h: 32, image: img})})\n\nrenderer.render(sprite, ctx)\n\nexpect(drawn).toBe(false)"
              },
              {
                "title": "draws sprite from region",
                "line": 99,
                "source": "let drawArgs = null\nctx.drawImage = (...args) => {\n    drawArgs = args\n}\n\nconst img = createMockImage()\nconst sprite = new Sprite({frame: createMockFrame({x: 32, y: 64, w: 32, h: 32, image: img})})\n\nrenderer.render(sprite, ctx)\n\nexpect(drawArgs[0]).toBe(img)\nexpect(drawArgs[1]).toBe(32)\nexpect(drawArgs[2]).toBe(64)\nexpect(drawArgs[3]).toBe(32)\nexpect(drawArgs[4]).toBe(32)"
              },
              {
                "title": "scales by width when width is set",
                "line": 118,
                "source": "let drawArgs = null\nctx.drawImage = (...args) => {\n    drawArgs = args\n}\n\nconst img = createMockImage()\nconst sprite = new Sprite({\n    frame: createMockFrame({x: 0, y: 0, w: 32, h: 64, image: img}),\n    width: 64\n})\n\nrenderer.render(sprite, ctx)\n\nexpect(drawArgs[7]).toBe(64)\nexpect(drawArgs[8]).toBe(128)"
              },
              {
                "title": "scales by height when height is set",
                "line": 137,
                "source": "let drawArgs = null\nctx.drawImage = (...args) => {\n    drawArgs = args\n}\n\nconst img = createMockImage()\nconst sprite = new Sprite({\n    frame: createMockFrame({x: 0, y: 0, w: 64, h: 32, image: img}),\n    height: 64\n})\n\nrenderer.render(sprite, ctx)\n\nexpect(drawArgs[7]).toBe(128)\nexpect(drawArgs[8]).toBe(64)"
              },
              {
                "title": "applies anchor offset",
                "line": 156,
                "source": "let drawArgs = null\nctx.drawImage = (...args) => {\n    drawArgs = args\n}\n\nconst img = createMockImage()\nconst sprite = new Sprite({\n    frame: createMockFrame({x: 0, y: 0, w: 100, h: 100, image: img}),\n    anchorX: 0.5,\n    anchorY: 0.5\n})\n\nrenderer.render(sprite, ctx)\n\nexpect(drawArgs[5]).toBe(-50)"
              },
              {
                "title": "saves and restores context",
                "line": 175,
                "source": "let saved = false\nlet restored = false\nctx.save = () => {\n    saved = true\n}\nctx.restore = () => {\n    restored = true\n}\n\nconst img = createMockImage()\nconst sprite = new Sprite({frame: createMockFrame({x: 0, y: 0, w: 32, h: 32, image: img})})\n\nrenderer.render(sprite, ctx)\n\nexpect(saved).toBe(true)\nexpect(restored).toBe(true)"
              },
              {
                "title": "flips Y axis with scale",
                "line": 195,
                "source": "let scaleArgs = null\nctx.scale = (...args) => {\n    scaleArgs = args\n}\n\nconst img = createMockImage()\nconst sprite = new Sprite({frame: createMockFrame({x: 0, y: 0, w: 32, h: 32, image: img})})\n\nrenderer.render(sprite, ctx)\n\nexpect(scaleArgs).toEqual([1, -1])"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/render/postprocessing/framebuffer_manager.doc.js": {
    "file": "/render/postprocessing/framebuffer_manager.test.js",
    "describes": [
      {
        "title": "FramebufferManager",
        "line": 90,
        "beforeEach": {
          "line": 95,
          "source": "gl = createMockGL()\nmanager = new FramebufferManager(gl, 800, 600, 4)"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor",
            "line": 101,
            "source": "expect(manager.width).toBe(800)\nexpect(manager.height).toBe(600)\nexpect(manager.samples).toBe(4)"
          },
          {
            "title": "constructor clamps samples to MAX_SAMPLES",
            "line": 108,
            "source": "gl.getParameter = vi.fn(() => 2)\nconst m = new FramebufferManager(gl, 100, 100, 8)\nexpect(m.samples).toBe(2)"
          },
          {
            "title": "resize",
            "line": 115,
            "source": "manager.resize(1024, 768)\nexpect(manager.width).toBe(1024)\nexpect(manager.height).toBe(768)"
          },
          {
            "title": "resize with same dimensions does nothing",
            "line": 122,
            "source": "const deleteCount = gl.deleteFramebuffer.mock.calls.length\nmanager.resize(800, 600)\nexpect(gl.deleteFramebuffer.mock.calls.length).toBe(deleteCount)"
          },
          {
            "title": "bindSceneBuffer",
            "line": 129,
            "source": "manager.bindSceneBuffer()\nexpect(gl.bindFramebuffer).toHaveBeenCalled()\nexpect(gl.viewport).toHaveBeenCalledWith(0, 0, 800, 600)"
          },
          {
            "title": "resolveSceneBuffer",
            "line": 136,
            "source": "manager.resolveSceneBuffer()\nexpect(gl.bindFramebuffer).toHaveBeenCalledWith(gl.READ_FRAMEBUFFER, expect.anything())\nexpect(gl.bindFramebuffer).toHaveBeenCalledWith(gl.DRAW_FRAMEBUFFER, expect.anything())\nexpect(gl.blitFramebuffer).toHaveBeenCalled()"
          },
          {
            "title": "getSceneTexture",
            "line": 144,
            "source": "const texture = manager.getSceneTexture()\nexpect(texture).toBeDefined()\nexpect(texture).not.toBeNull()"
          },
          {
            "title": "resetPingPong",
            "line": 151,
            "source": "manager.swapAndGetTexture()\nmanager.resetPingPong()\nconst tex1 = manager.swapAndGetTexture()\nmanager.resetPingPong()\nconst tex2 = manager.swapAndGetTexture()\nexpect(tex1).toBe(tex2)"
          },
          {
            "title": "bindPingPong",
            "line": 161,
            "source": "manager.bindPingPong()\nexpect(gl.bindFramebuffer).toHaveBeenCalled()\nexpect(gl.viewport).toHaveBeenCalledWith(0, 0, 800, 600)"
          },
          {
            "title": "swapAndGetTexture alternates buffers",
            "line": 168,
            "source": "manager.resetPingPong()\nconst tex1 = manager.swapAndGetTexture()\nconst tex2 = manager.swapAndGetTexture()\nconst tex3 = manager.swapAndGetTexture()\nexpect(tex1).not.toBe(tex2)\nexpect(tex1).toBe(tex3)"
          },
          {
            "title": "getOrCreateBuffer creates new buffer",
            "line": 178,
            "source": "const buffer = manager.getOrCreateBuffer('test')\nexpect(buffer).toBeDefined()\nexpect(buffer.framebuffer).toBeDefined()\nexpect(buffer.texture).toBeDefined()"
          },
          {
            "title": "getOrCreateBuffer returns existing buffer",
            "line": 186,
            "source": "const buffer1 = manager.getOrCreateBuffer('test')\nconst buffer2 = manager.getOrCreateBuffer('test')\nexpect(buffer1).toBe(buffer2)"
          },
          {
            "title": "bindBuffer",
            "line": 193,
            "source": "manager.getOrCreateBuffer('test')\nconst result = manager.bindBuffer('test')\nexpect(result).toBe(true)\nexpect(gl.bindFramebuffer).toHaveBeenCalled()\nexpect(gl.viewport).toHaveBeenCalledWith(0, 0, 800, 600)"
          },
          {
            "title": "bindBuffer returns false for non-existent buffer",
            "line": 202,
            "source": "const result = manager.bindBuffer('nonexistent')\nexpect(result).toBe(false)"
          },
          {
            "title": "getBufferTexture",
            "line": 208,
            "source": "manager.getOrCreateBuffer('test')\nconst texture = manager.getBufferTexture('test')\nexpect(texture).toBeDefined()\nexpect(texture).not.toBeNull()"
          },
          {
            "title": "getBufferTexture returns null for non-existent buffer",
            "line": 216,
            "source": "const texture = manager.getBufferTexture('nonexistent')\nexpect(texture).toBeNull()"
          },
          {
            "title": "resolveToBuffer",
            "line": 222,
            "source": "manager.getOrCreateBuffer('test')\nconst result = manager.resolveToBuffer('test')\nexpect(result).toBe(true)\nexpect(gl.blitFramebuffer).toHaveBeenCalled()"
          },
          {
            "title": "resolveToBuffer returns false for non-existent buffer",
            "line": 230,
            "source": "const result = manager.resolveToBuffer('nonexistent')\nexpect(result).toBe(false)"
          },
          {
            "title": "disposeBuffer",
            "line": 236,
            "source": "manager.getOrCreateBuffer('test')\nconst result = manager.disposeBuffer('test')\nexpect(result).toBe(true)\nexpect(gl.deleteFramebuffer).toHaveBeenCalled()\nexpect(gl.deleteTexture).toHaveBeenCalled()"
          },
          {
            "title": "disposeBuffer returns false for non-existent buffer",
            "line": 245,
            "source": "const result = manager.disposeBuffer('nonexistent')\nexpect(result).toBe(false)"
          },
          {
            "title": "disposeNamedBuffers",
            "line": 251,
            "source": "manager.getOrCreateBuffer('test1')\nmanager.getOrCreateBuffer('test2')\nmanager.disposeNamedBuffers()\nexpect(manager.getBufferTexture('test1')).toBeNull()\nexpect(manager.getBufferTexture('test2')).toBeNull()"
          },
          {
            "title": "bindScreen",
            "line": 260,
            "source": "manager.bindScreen()\nexpect(gl.bindFramebuffer).toHaveBeenCalledWith(gl.FRAMEBUFFER, null)\nexpect(gl.viewport).toHaveBeenCalledWith(0, 0, 800, 600)"
          },
          {
            "title": "dispose",
            "line": 267,
            "source": "manager.getOrCreateBuffer('test')\nmanager.dispose()\nexpect(gl.deleteFramebuffer).toHaveBeenCalled()\nexpect(gl.deleteRenderbuffer).toHaveBeenCalled()\nexpect(gl.deleteTexture).toHaveBeenCalled()"
          }
        ],
        "describes": []
      }
    ]
  },
  "/render/postprocessing/fullscreen_quad.doc.js": {
    "file": "/render/postprocessing/fullscreen_quad.test.js",
    "describes": [
      {
        "title": "FullscreenQuad",
        "line": 6,
        "beforeEach": {
          "line": 11,
          "source": "gl = createMockGLWithSpies()\nquad = new FullscreenQuad(gl)"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor creates buffers",
            "line": 17,
            "source": "expect(gl.createBuffer).toHaveBeenCalledTimes(2)\nexpect(gl.bindBuffer).toHaveBeenCalled()\nexpect(gl.bufferData).toHaveBeenCalledTimes(2)"
          },
          {
            "title": "draw",
            "line": 24,
            "source": "const program = createMockProgram()\nquad.draw(gl, program)\n\nexpect(gl.bindBuffer).toHaveBeenCalled()\nexpect(gl.enableVertexAttribArray).toHaveBeenCalledWith(0)\nexpect(gl.enableVertexAttribArray).toHaveBeenCalledWith(1)\nexpect(gl.vertexAttribPointer).toHaveBeenCalledTimes(2)\nexpect(gl.drawArrays).toHaveBeenCalledWith(gl.TRIANGLE_STRIP, 0, 4)"
          },
          {
            "title": "draw without aTexCoord attribute",
            "line": 36,
            "source": "const program = createMockProgram({hasTexCoord: false})\nquad.draw(gl, program)\n\nexpect(gl.enableVertexAttribArray).toHaveBeenCalledWith(0)\nexpect(gl.enableVertexAttribArray).toHaveBeenCalledTimes(1)\nexpect(gl.drawArrays).toHaveBeenCalledWith(gl.TRIANGLE_STRIP, 0, 4)"
          },
          {
            "title": "draw with missing aPosition warns",
            "line": 46,
            "source": "const program = {attributes: {aPosition: undefined}}\nconst warnSpy = vi.spyOn(console, 'warn').mockImplementation(() => {})\n\nquad.draw(gl, program)\n\nexpect(warnSpy).toHaveBeenCalledWith('FullscreenQuad: aPosition attribute not found')\nexpect(gl.drawArrays).not.toHaveBeenCalled()\n\nwarnSpy.mockRestore()"
          },
          {
            "title": "draw with aPosition = -1 warns",
            "line": 59,
            "source": "const program = {attributes: {aPosition: -1}}\nconst warnSpy = vi.spyOn(console, 'warn').mockImplementation(() => {})\n\nquad.draw(gl, program)\n\nexpect(warnSpy).toHaveBeenCalledWith('FullscreenQuad: aPosition attribute not found')\nexpect(gl.drawArrays).not.toHaveBeenCalled()\n\nwarnSpy.mockRestore()"
          },
          {
            "title": "draw with aTexCoord = -1 skips texcoord setup",
            "line": 72,
            "source": "const program = {attributes: {aPosition: 0, aTexCoord: -1}}\nquad.draw(gl, program)\n\nexpect(gl.enableVertexAttribArray).toHaveBeenCalledTimes(1)\nexpect(gl.enableVertexAttribArray).toHaveBeenCalledWith(0)\nexpect(gl.drawArrays).toHaveBeenCalled()"
          },
          {
            "title": "dispose",
            "line": 82,
            "source": "quad.dispose(gl)\n\nexpect(gl.deleteBuffer).toHaveBeenCalledTimes(2)"
          },
          {
            "title": "dispose can be called multiple times",
            "line": 89,
            "source": "quad.dispose(gl)\nquad.dispose(gl)\n\nexpect(gl.deleteBuffer).toHaveBeenCalledTimes(2)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/render/postprocessing/post_processor.doc.js": {
    "file": "/render/postprocessing/post_processor.test.js",
    "describes": [
      {
        "title": "PostProcessor",
        "line": 33,
        "beforeEach": {
          "line": 39,
          "source": "gl = createMockGLWithSpies()\nshaderRegistry = createMockShaderRegistry()\nprocessor = createProcessor(gl, shaderRegistry)"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "is a PerkyModule",
            "line": 46,
            "source": "expect(processor).toBeInstanceOf(PerkyModule)"
          },
          {
            "title": "static properties",
            "line": 51,
            "source": "expect(PostProcessor.$category).toBe('postProcessor')\nexpect(PostProcessor.$bind).toBe('postProcessor')"
          },
          {
            "title": "constructor",
            "line": 57,
            "source": "expect(processor.enabled).toBe(true)\nexpect(processor.passes).toEqual([])\nexpect(processor.framebufferManager).toBeDefined()"
          },
          {
            "title": "enabled getter and setter",
            "line": 64,
            "source": "processor.enabled = false\nexpect(processor.enabled).toBe(false)\nprocessor.enabled = true\nexpect(processor.enabled).toBe(true)"
          },
          {
            "title": "addPass",
            "line": 72,
            "source": "const pass = new MockPass()\nconst result = processor.addPass(pass)\n\nexpect(result).toBe(processor)\nexpect(processor.passes).toContain(pass)\nexpect(shaderRegistry.register).toHaveBeenCalled()"
          },
          {
            "title": "removePass",
            "line": 82,
            "source": "const pass = new MockPass()\nprocessor.addPass(pass)\nvi.spyOn(pass, 'dispose')\n\nconst result = processor.removePass(pass)\n\nexpect(result).toBe(processor)\nexpect(processor.passes).not.toContain(pass)\nexpect(pass.dispose).toHaveBeenCalled()"
          },
          {
            "title": "removePass with non-existent pass",
            "line": 95,
            "source": "const pass = new MockPass()\nconst result = processor.removePass(pass)\n\nexpect(result).toBe(processor)"
          },
          {
            "title": "clearPasses",
            "line": 103,
            "source": "const pass1 = new MockPass()\nconst pass2 = new MockPass()\nprocessor.addPass(pass1)\nprocessor.addPass(pass2)\nvi.spyOn(pass1, 'dispose')\nvi.spyOn(pass2, 'dispose')\n\nconst result = processor.clearPasses()\n\nexpect(result).toBe(processor)\nexpect(processor.passes).toEqual([])\nexpect(pass1.dispose).toHaveBeenCalled()\nexpect(pass2.dispose).toHaveBeenCalled()"
          },
          {
            "title": "resize",
            "line": 120,
            "source": "const fbManager = processor.framebufferManager\nvi.spyOn(fbManager, 'resize')\n\nprocessor.resize(1024, 768)\n\nexpect(fbManager.resize).toHaveBeenCalledWith(1024, 768)"
          },
          {
            "title": "hasActivePasses returns false when no passes",
            "line": 130,
            "source": "expect(processor.hasActivePasses()).toBe(false)"
          },
          {
            "title": "hasActivePasses returns false when disabled",
            "line": 135,
            "source": "const pass = new MockPass()\nprocessor.addPass(pass)\nprocessor.enabled = false\n\nexpect(processor.hasActivePasses()).toBe(false)"
          },
          {
            "title": "hasActivePasses returns false when all passes disabled",
            "line": 144,
            "source": "const pass = new MockPass()\npass.enabled = false\nprocessor.addPass(pass)\n\nexpect(processor.hasActivePasses()).toBe(false)"
          },
          {
            "title": "hasActivePasses returns true with active pass",
            "line": 153,
            "source": "const pass = new MockPass()\nprocessor.addPass(pass)\n\nexpect(processor.hasActivePasses()).toBe(true)"
          },
          {
            "title": "begin returns false when no active passes",
            "line": 161,
            "source": "expect(processor.begin()).toBe(false)"
          },
          {
            "title": "begin returns true and binds scene buffer when active",
            "line": 166,
            "source": "const pass = new MockPass()\nprocessor.addPass(pass)\nconst fbManager = processor.framebufferManager\nvi.spyOn(fbManager, 'resetPingPong')\nvi.spyOn(fbManager, 'bindSceneBuffer')\n\nconst result = processor.begin()\n\nexpect(result).toBe(true)\nexpect(fbManager.resetPingPong).toHaveBeenCalled()\nexpect(fbManager.bindSceneBuffer).toHaveBeenCalled()"
          },
          {
            "title": "finish does nothing when no active passes",
            "line": 181,
            "source": "processor.finish()\nexpect(gl.disable).not.toHaveBeenCalled()"
          },
          {
            "title": "finish processes active passes",
            "line": 187,
            "source": "const pass = new MockPass()\nprocessor.addPass(pass)\nvi.spyOn(pass, 'render')\nconst fbManager = processor.framebufferManager\nvi.spyOn(fbManager, 'resolveSceneBuffer')\nvi.spyOn(fbManager, 'bindScreen')\n\nprocessor.finish()\n\nexpect(fbManager.resolveSceneBuffer).toHaveBeenCalled()\nexpect(gl.disable).toHaveBeenCalledWith(gl.BLEND)\nexpect(fbManager.bindScreen).toHaveBeenCalled()\nexpect(pass.render).toHaveBeenCalled()\nexpect(gl.enable).toHaveBeenCalledWith(gl.BLEND)"
          },
          {
            "title": "finish with multiple passes uses ping-pong buffers",
            "line": 205,
            "source": "const pass1 = new MockPass()\nconst pass2 = new MockPass()\nprocessor.addPass(pass1)\nprocessor.addPass(pass2)\nconst fbManager = processor.framebufferManager\nvi.spyOn(fbManager, 'bindPingPong')\nvi.spyOn(fbManager, 'swapAndGetTexture')\nvi.spyOn(fbManager, 'bindScreen')\n\nprocessor.finish()\n\nexpect(fbManager.bindPingPong).toHaveBeenCalled()\nexpect(fbManager.swapAndGetTexture).toHaveBeenCalled()\nexpect(fbManager.bindScreen).toHaveBeenCalled()"
          },
          {
            "title": "finish skips disabled passes",
            "line": 223,
            "source": "const pass1 = new MockPass()\nconst pass2 = new MockPass()\npass1.enabled = false\nprocessor.addPass(pass1)\nprocessor.addPass(pass2)\nvi.spyOn(pass1, 'render')\nvi.spyOn(pass2, 'render')\n\nprocessor.finish()\n\nexpect(pass1.render).not.toHaveBeenCalled()\nexpect(pass2.render).toHaveBeenCalled()"
          },
          {
            "title": "dispose",
            "line": 239,
            "source": "const pass = new MockPass()\nprocessor.addPass(pass)\nvi.spyOn(pass, 'dispose')\nconst fbManager = processor.framebufferManager\nvi.spyOn(fbManager, 'dispose')\n\nprocessor.dispose()\n\nexpect(pass.dispose).toHaveBeenCalled()\nexpect(fbManager.dispose).toHaveBeenCalled()"
          }
        ],
        "describes": []
      }
    ]
  },
  "/render/postprocessing/render_pass.doc.js": {
    "file": "/render/postprocessing/render_pass.test.js",
    "describes": [
      {
        "title": "RenderPass",
        "line": 23,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "static shaderDefinition is null by default",
            "line": 25,
            "source": "expect(RenderPass.shaderDefinition).toBeNull()"
          },
          {
            "title": "static defaultUniforms is empty by default",
            "line": 30,
            "source": "expect(RenderPass.defaultUniforms).toEqual({})"
          },
          {
            "title": "static uniformConfig is empty by default",
            "line": 35,
            "source": "expect(RenderPass.uniformConfig).toEqual({})"
          },
          {
            "title": "constructor copies defaultUniforms",
            "line": 40,
            "source": "const pass = new TestPass()\nexpect(pass.uniforms.uValue).toBe(1.0)"
          },
          {
            "title": "enabled getter and setter",
            "line": 46,
            "source": "const pass = new TestPass()\nexpect(pass.enabled).toBe(true)\npass.enabled = false\nexpect(pass.enabled).toBe(false)"
          },
          {
            "title": "program getter",
            "line": 54,
            "source": "const pass = new TestPass()\nexpect(pass.program).toBeNull()"
          },
          {
            "title": "uniforms getter",
            "line": 60,
            "source": "const pass = new TestPass()\nexpect(pass.uniforms).toEqual({uValue: 1.0})"
          },
          {
            "title": "setUniform",
            "line": 90,
            "source": "const pass = new TestPass()\nconst result = pass.setUniform('uValue', 2.0)\n\nexpect(result).toBe(pass)\nexpect(pass.uniforms.uValue).toBe(2.0)"
          },
          {
            "title": "dispose",
            "line": 205,
            "source": "const pass = new TestPass()\nconst program = createMockProgram()\npass.init(createMockShaderRegistry(program))\n\npass.dispose()\n\nexpect(pass.program).toBeNull()\nexpect(pass.uniforms).toEqual({})"
          }
        ],
        "describes": [
          {
            "title": "init",
            "line": 66,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "registers shader with registry",
                "line": 68,
                "source": "const pass = new TestPass()\nconst program = createMockProgram()\nconst registry = createMockShaderRegistry(program)\n\npass.init(registry)\n\nexpect(registry.register).toHaveBeenCalled()\nexpect(pass.program).toBe(program)"
              },
              {
                "title": "throws if shaderDefinition not defined",
                "line": 80,
                "source": "const pass = new NoShaderPass()\nconst registry = createMockShaderRegistry(createMockProgram())\n\nexpect(() => pass.init(registry)).toThrow('NoShaderPass.shaderDefinition must be defined')"
              }
            ],
            "describes": []
          },
          {
            "title": "render",
            "line": 99,
            "beforeEach": {
              "line": 106,
              "source": "pass = new TestPass()\nprogram = createMockProgram()\npass.init(createMockShaderRegistry(program))\ngl = createMockGLWithSpies()\nquad = createMockQuad()"
            },
            "afterEach": null,
            "tests": [
              {
                "title": "uses program and binds texture",
                "line": 115,
                "source": "const texture = {}\npass.render(gl, texture, quad)\n\nexpect(program.use).toHaveBeenCalled()\nexpect(gl.activeTexture).toHaveBeenCalledWith(gl.TEXTURE0)\nexpect(gl.bindTexture).toHaveBeenCalledWith(gl.TEXTURE_2D, texture)\nexpect(program.setUniform1i).toHaveBeenCalledWith('uTexture', 0)"
              },
              {
                "title": "draws quad",
                "line": 126,
                "source": "pass.render(gl, {}, quad)\nexpect(quad.draw).toHaveBeenCalledWith(gl, program)"
              },
              {
                "title": "does nothing when disabled",
                "line": 132,
                "source": "pass.enabled = false\npass.render(gl, {}, quad)\n\nexpect(program.use).not.toHaveBeenCalled()\nexpect(quad.draw).not.toHaveBeenCalled()"
              },
              {
                "title": "does nothing when no program",
                "line": 141,
                "source": "const newPass = new TestPass()\nnewPass.render(gl, {}, quad)\n\nexpect(quad.draw).not.toHaveBeenCalled()"
              }
            ],
            "describes": []
          },
          {
            "title": "applyUniforms",
            "line": 151,
            "beforeEach": {
              "line": 156,
              "source": "pass = new TestPass()\nprogram = createMockProgram()\npass.init(createMockShaderRegistry(program))"
            },
            "afterEach": null,
            "tests": [
              {
                "title": "applies number uniforms",
                "line": 163,
                "source": "pass.setUniform('uValue', 2.5)\npass.applyUniforms()\n\nexpect(program.setUniform1f).toHaveBeenCalledWith('uValue', 2.5)"
              },
              {
                "title": "applies vec2 uniforms",
                "line": 171,
                "source": "pass.setUniform('uVec2', [1.0, 2.0])\npass.applyUniforms()\n\nexpect(program.setUniform2f).toHaveBeenCalledWith('uVec2', 1.0, 2.0)"
              },
              {
                "title": "applies vec3 uniforms",
                "line": 179,
                "source": "pass.setUniform('uVec3', [1.0, 2.0, 3.0])\npass.applyUniforms()\n\nexpect(program.setUniform3f).toHaveBeenCalledWith('uVec3', 1.0, 2.0, 3.0)"
              },
              {
                "title": "applies vec4 uniforms",
                "line": 187,
                "source": "pass.setUniform('uVec4', [1.0, 2.0, 3.0, 4.0])\npass.applyUniforms()\n\nexpect(program.setUniform4f).toHaveBeenCalledWith('uVec4', [1.0, 2.0, 3.0, 4.0])"
              },
              {
                "title": "ignores non-number non-array values",
                "line": 195,
                "source": "pass.setUniform('uObject', {})\npass.applyUniforms()\n\nexpect(program.setUniform1f).not.toHaveBeenCalledWith('uObject', expect.anything())"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/render/postprocessing/passes/color_grade_pass.doc.js": {
    "file": "/render/postprocessing/passes/color_grade_pass.test.js",
    "describes": [
      {
        "title": "ColorGradePass",
        "line": 6,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "extends RenderPass",
            "line": 8,
            "source": "const pass = new ColorGradePass()\nexpect(pass).toBeInstanceOf(RenderPass)"
          },
          {
            "title": "shaderDefinition",
            "line": 14,
            "source": "expect(ColorGradePass.shaderDefinition).toBeDefined()\nexpect(ColorGradePass.shaderDefinition.vertex).toContain('aPosition')\nexpect(ColorGradePass.shaderDefinition.vertex).toContain('aTexCoord')\nexpect(ColorGradePass.shaderDefinition.fragment).toContain('uTexture')\nexpect(ColorGradePass.shaderDefinition.fragment).toContain('uBrightness')\nexpect(ColorGradePass.shaderDefinition.fragment).toContain('uContrast')\nexpect(ColorGradePass.shaderDefinition.fragment).toContain('uSaturation')"
          },
          {
            "title": "shaderDefinition uniforms",
            "line": 25,
            "source": "expect(ColorGradePass.shaderDefinition.uniforms).toContain('uTexture')\nexpect(ColorGradePass.shaderDefinition.uniforms).toContain('uBrightness')\nexpect(ColorGradePass.shaderDefinition.uniforms).toContain('uContrast')\nexpect(ColorGradePass.shaderDefinition.uniforms).toContain('uSaturation')"
          },
          {
            "title": "shaderDefinition attributes",
            "line": 33,
            "source": "expect(ColorGradePass.shaderDefinition.attributes).toContain('aPosition')\nexpect(ColorGradePass.shaderDefinition.attributes).toContain('aTexCoord')"
          },
          {
            "title": "defaultUniforms",
            "line": 39,
            "source": "expect(ColorGradePass.defaultUniforms.uBrightness).toBe(0.0)\nexpect(ColorGradePass.defaultUniforms.uContrast).toBe(1.0)\nexpect(ColorGradePass.defaultUniforms.uSaturation).toBe(1.0)"
          },
          {
            "title": "uniformConfig",
            "line": 46,
            "source": "expect(ColorGradePass.uniformConfig.uBrightness).toEqual({min: -0.5, max: 0.5, step: 0.01})\nexpect(ColorGradePass.uniformConfig.uContrast).toEqual({min: 0.5, max: 1.5, step: 0.01})\nexpect(ColorGradePass.uniformConfig.uSaturation).toEqual({min: 0, max: 2, step: 0.01})"
          },
          {
            "title": "inherits default uniforms in instance",
            "line": 53,
            "source": "const pass = new ColorGradePass()\nexpect(pass.uniforms.uBrightness).toBe(0.0)\nexpect(pass.uniforms.uContrast).toBe(1.0)\nexpect(pass.uniforms.uSaturation).toBe(1.0)"
          },
          {
            "title": "setUniform",
            "line": 61,
            "source": "const pass = new ColorGradePass()\npass.setUniform('uBrightness', 0.2)\npass.setUniform('uContrast', 1.2)\npass.setUniform('uSaturation', 1.5)\n\nexpect(pass.uniforms.uBrightness).toBe(0.2)\nexpect(pass.uniforms.uContrast).toBe(1.2)\nexpect(pass.uniforms.uSaturation).toBe(1.5)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/render/postprocessing/passes/vignette_pass.doc.js": {
    "file": "/render/postprocessing/passes/vignette_pass.test.js",
    "describes": [
      {
        "title": "VignettePass",
        "line": 6,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "extends RenderPass",
            "line": 8,
            "source": "const pass = new VignettePass()\nexpect(pass).toBeInstanceOf(RenderPass)"
          },
          {
            "title": "shaderDefinition",
            "line": 14,
            "source": "expect(VignettePass.shaderDefinition).toBeDefined()\nexpect(VignettePass.shaderDefinition.vertex).toContain('aPosition')\nexpect(VignettePass.shaderDefinition.vertex).toContain('aTexCoord')\nexpect(VignettePass.shaderDefinition.fragment).toContain('uTexture')\nexpect(VignettePass.shaderDefinition.fragment).toContain('uIntensity')\nexpect(VignettePass.shaderDefinition.fragment).toContain('uSmoothness')\nexpect(VignettePass.shaderDefinition.fragment).toContain('uRoundness')\nexpect(VignettePass.shaderDefinition.fragment).toContain('uColor')"
          },
          {
            "title": "shaderDefinition uniforms",
            "line": 26,
            "source": "expect(VignettePass.shaderDefinition.uniforms).toContain('uTexture')\nexpect(VignettePass.shaderDefinition.uniforms).toContain('uIntensity')\nexpect(VignettePass.shaderDefinition.uniforms).toContain('uSmoothness')\nexpect(VignettePass.shaderDefinition.uniforms).toContain('uRoundness')\nexpect(VignettePass.shaderDefinition.uniforms).toContain('uColor')"
          },
          {
            "title": "shaderDefinition attributes",
            "line": 35,
            "source": "expect(VignettePass.shaderDefinition.attributes).toContain('aPosition')\nexpect(VignettePass.shaderDefinition.attributes).toContain('aTexCoord')"
          },
          {
            "title": "defaultUniforms",
            "line": 41,
            "source": "expect(VignettePass.defaultUniforms.uIntensity).toBe(0.4)\nexpect(VignettePass.defaultUniforms.uSmoothness).toBe(0.8)\nexpect(VignettePass.defaultUniforms.uRoundness).toBe(0.5)\nexpect(VignettePass.defaultUniforms.uColor).toEqual([0.0, 0.0, 0.0])"
          },
          {
            "title": "uniformConfig",
            "line": 49,
            "source": "expect(VignettePass.uniformConfig.uIntensity).toEqual({min: 0, max: 1, step: 0.01})\nexpect(VignettePass.uniformConfig.uSmoothness).toEqual({min: 0, max: 2, step: 0.01})\nexpect(VignettePass.uniformConfig.uRoundness).toEqual({min: 0, max: 1, step: 0.01})\nexpect(VignettePass.uniformConfig.uColor).toEqual({type: 'color'})"
          },
          {
            "title": "inherits default uniforms in instance",
            "line": 57,
            "source": "const pass = new VignettePass()\nexpect(pass.uniforms.uIntensity).toBe(0.4)\nexpect(pass.uniforms.uSmoothness).toBe(0.8)\nexpect(pass.uniforms.uRoundness).toBe(0.5)\nexpect(pass.uniforms.uColor).toEqual([0.0, 0.0, 0.0])"
          },
          {
            "title": "setUniform",
            "line": 66,
            "source": "const pass = new VignettePass()\npass.setUniform('uIntensity', 0.6)\npass.setUniform('uSmoothness', 1.0)\npass.setUniform('uRoundness', 0.8)\npass.setUniform('uColor', [1.0, 0.0, 0.0])\n\nexpect(pass.uniforms.uIntensity).toBe(0.6)\nexpect(pass.uniforms.uSmoothness).toBe(1.0)\nexpect(pass.uniforms.uRoundness).toBe(0.8)\nexpect(pass.uniforms.uColor).toEqual([1.0, 0.0, 0.0])"
          }
        ],
        "describes": []
      }
    ]
  },
  "/render/shaders/shader_effect.doc.js": {
    "file": "/render/shaders/shader_effect.test.js",
    "describes": [
      {
        "title": "ShaderEffect",
        "line": 5,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "enabled can be set",
            "line": 42,
            "source": "const effect = new ShaderEffect()\neffect.enabled = false\nexpect(effect.enabled).toBe(false)"
          },
          {
            "title": "getHints returns null",
            "line": 109,
            "source": "const effect = new ShaderEffect()\nexpect(effect.getHints()).toBe(null)"
          },
          {
            "title": "update exists and can be called",
            "line": 115,
            "source": "const effect = new ShaderEffect()\nexpect(() => effect.update(16)).not.toThrow()"
          },
          {
            "title": "dispose exists and can be called",
            "line": 121,
            "source": "const effect = new ShaderEffect()\nexpect(() => effect.dispose()).not.toThrow()"
          }
        ],
        "describes": [
          {
            "title": "static shader",
            "line": 7,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "has empty params by default",
                "line": 9,
                "source": "expect(ShaderEffect.shader.params).toEqual([])"
              },
              {
                "title": "has empty uniforms by default",
                "line": 14,
                "source": "expect(ShaderEffect.shader.uniforms).toEqual([])"
              },
              {
                "title": "has empty fragment by default",
                "line": 19,
                "source": "expect(ShaderEffect.shader.fragment).toBe('')"
              }
            ],
            "describes": []
          },
          {
            "title": "constructor",
            "line": 26,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates with enabled true by default",
                "line": 28,
                "source": "const effect = new ShaderEffect()\nexpect(effect.enabled).toBe(true)"
              },
              {
                "title": "creates with enabled from options",
                "line": 34,
                "source": "const effect = new ShaderEffect({enabled: false})\nexpect(effect.enabled).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "type getter",
            "line": 49,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns constructor name",
                "line": 51,
                "source": "const effect = new ShaderEffect()\nexpect(effect.type).toBe('ShaderEffect')"
              },
              {
                "title": "returns subclass name",
                "line": 57,
                "source": "class ChromaticEffect extends ShaderEffect {}\nconst effect = new ChromaticEffect()\nexpect(effect.type).toBe('ChromaticEffect')"
              }
            ],
            "describes": []
          },
          {
            "title": "getParams",
            "line": 66,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns empty array for base class",
                "line": 68,
                "source": "const effect = new ShaderEffect()\nexpect(effect.getParams()).toEqual([])"
              },
              {
                "title": "returns param values for subclass",
                "line": 74,
                "source": "class IntensityEffect extends ShaderEffect {\n    static shader = {\n        params: ['intensity', 'strength'],\n        uniforms: [],\n        fragment: ''\n    }\n\n    intensity = 0.5\n    strength = 1.0\n}\n\nconst effect = new IntensityEffect()\nexpect(effect.getParams()).toEqual([0.5, 1.0])"
              },
              {
                "title": "returns 0 for undefined params",
                "line": 91,
                "source": "class PartialEffect extends ShaderEffect {\n    static shader = {\n        params: ['defined', 'undefined'],\n        uniforms: [],\n        fragment: ''\n    }\n\n    defined = 0.8\n}\n\nconst effect = new PartialEffect()\nexpect(effect.getParams()).toEqual([0.8, 0])"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/render/shaders/shader_effect_registry.doc.js": {
    "file": "/render/shaders/shader_effect_registry.test.js",
    "describes": [
      {
        "title": "ShaderEffectRegistry",
        "line": 49,
        "beforeEach": {
          "line": 55,
          "source": "gl = createMockGLWithSpies()\nshaderRegistry = createMockShaderRegistry()\nregistry = new ShaderEffectRegistry(gl, shaderRegistry)"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "getUniform returns undefined for unset uniform",
            "line": 257,
            "source": "expect(registry.getUniform('uNonExistent')).toBeUndefined()"
          }
        ],
        "describes": [
          {
            "title": "register",
            "line": 62,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "registers an effect class",
                "line": 64,
                "source": "registry.register(ChromaticEffect)\nexpect(registry.has('ChromaticEffect')).toBe(true)"
              },
              {
                "title": "returns this for chaining",
                "line": 70,
                "source": "const result = registry.register(ChromaticEffect)\nexpect(result).toBe(registry)"
              }
            ],
            "describes": []
          },
          {
            "title": "get",
            "line": 78,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns registered effect class",
                "line": 80,
                "source": "registry.register(ChromaticEffect)\nexpect(registry.get('ChromaticEffect')).toBe(ChromaticEffect)"
              },
              {
                "title": "returns null for unregistered effect",
                "line": 86,
                "source": "expect(registry.get('NonExistent')).toBeNull()"
              }
            ],
            "describes": []
          },
          {
            "title": "has",
            "line": 93,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns true for registered effect",
                "line": 95,
                "source": "registry.register(ChromaticEffect)\nexpect(registry.has('ChromaticEffect')).toBe(true)"
              },
              {
                "title": "returns false for unregistered effect",
                "line": 101,
                "source": "expect(registry.has('ChromaticEffect')).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "getShaderForEffects",
            "line": 108,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "compiles shader for single effect",
                "line": 110,
                "source": "registry.register(ChromaticEffect)\nconst shader = registry.getShaderForEffects(['ChromaticEffect'])\n\nexpect(shaderRegistry.register).toHaveBeenCalled()\nexpect(shader).toBeDefined()"
              },
              {
                "title": "caches compiled shader",
                "line": 119,
                "source": "registry.register(ChromaticEffect)\n\nregistry.getShaderForEffects(['ChromaticEffect'])\nregistry.getShaderForEffects(['ChromaticEffect'])\n\nexpect(shaderRegistry.register).toHaveBeenCalledTimes(1)"
              },
              {
                "title": "generates different shaders for different combinations",
                "line": 129,
                "source": "registry.register(ChromaticEffect)\nregistry.register(WaveEffect)\n\nregistry.getShaderForEffects(['ChromaticEffect'])\nregistry.getShaderForEffects(['WaveEffect'])\nregistry.getShaderForEffects(['ChromaticEffect', 'WaveEffect'])\n\nexpect(shaderRegistry.register).toHaveBeenCalledTimes(3)"
              },
              {
                "title": "generates same shader regardless of effect order",
                "line": 141,
                "source": "registry.register(ChromaticEffect)\nregistry.register(WaveEffect)\n\nregistry.getShaderForEffects(['ChromaticEffect', 'WaveEffect'])\nregistry.getShaderForEffects(['WaveEffect', 'ChromaticEffect'])\n\nexpect(shaderRegistry.register).toHaveBeenCalledTimes(1)"
              },
              {
                "title": "includes effect fragment in generated shader",
                "line": 152,
                "source": "registry.register(ChromaticEffect)\nregistry.getShaderForEffects(['ChromaticEffect'])\n\nconst call = shaderRegistry.register.mock.calls[0]\nconst fragmentSource = call[1].fragment\n\nexpect(fragmentSource).toContain('ChromaticEffect')\nexpect(fragmentSource).toContain('intensity')"
              },
              {
                "title": "includes custom uniforms",
                "line": 164,
                "source": "registry.register(WaveEffect)\nregistry.getShaderForEffects(['WaveEffect'])\n\nconst call = shaderRegistry.register.mock.calls[0]\nconst uniforms = call[1].uniforms\n\nexpect(uniforms).toContain('uTime')"
              },
              {
                "title": "generates base shader for empty effects",
                "line": 175,
                "source": "const shader = registry.getShaderForEffects([])\nexpect(shader).toBeDefined()"
              }
            ],
            "describes": []
          },
          {
            "title": "param slot allocation",
            "line": 183,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "assigns correct slots for single effect",
                "line": 185,
                "source": "registry.register(ChromaticEffect)\nregistry.getShaderForEffects(['ChromaticEffect'])\n\nconst call = shaderRegistry.register.mock.calls[0]\nconst fragmentSource = call[1].fragment\n\nexpect(fragmentSource).toContain('float intensity = effectParams.x;')"
              },
              {
                "title": "assigns sequential slots for multiple effects",
                "line": 196,
                "source": "registry.register(ChromaticEffect)\nregistry.register(WaveEffect)\nregistry.getShaderForEffects(['ChromaticEffect', 'WaveEffect'])\n\nconst call = shaderRegistry.register.mock.calls[0]\nconst fragmentSource = call[1].fragment\n\nexpect(fragmentSource).toContain('float intensity = effectParams.x;')\nexpect(fragmentSource).toContain('float amplitude = effectParams.y;')\nexpect(fragmentSource).toContain('float frequency = effectParams.z;')"
              },
              {
                "title": "warns when exceeding 4 params limit",
                "line": 210,
                "source": "const warnSpy = vi.spyOn(console, 'warn').mockImplementation(() => {})\n\nclass ManyParamsEffect extends ShaderEffect {\n    static shader = {\n        params: ['p1', 'p2', 'p3', 'p4', 'p5'],\n        uniforms: [],\n        fragment: 'color.r += p1;'\n    }\n}\n\nregistry.register(ManyParamsEffect)\nregistry.getShaderForEffects(['ManyParamsEffect'])\n\nexpect(warnSpy).toHaveBeenCalledWith(\n    expect.stringContaining('p5')\n)\n\nwarnSpy.mockRestore()"
              }
            ],
            "describes": []
          },
          {
            "title": "setUniform",
            "line": 234,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "stores uniform value",
                "line": 236,
                "source": "registry.setUniform('uTime', 1.5)\nexpect(registry.getUniform('uTime')).toBe(1.5)"
              },
              {
                "title": "returns this for chaining",
                "line": 242,
                "source": "const result = registry.setUniform('uTime', 1.0)\nexpect(result).toBe(registry)"
              },
              {
                "title": "overwrites existing value",
                "line": 248,
                "source": "registry.setUniform('uTime', 1.0)\nregistry.setUniform('uTime', 2.0)\nexpect(registry.getUniform('uTime')).toBe(2.0)"
              }
            ],
            "describes": []
          },
          {
            "title": "applyUniforms",
            "line": 262,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "applies float uniform",
                "line": 264,
                "source": "const mockProgram = {\n    uniforms: {uTime: 1}\n}\ngl.uniform1f = vi.fn()\n\nregistry.setUniform('uTime', 2.5)\nregistry.applyUniforms(gl, mockProgram)\n\nexpect(gl.uniform1f).toHaveBeenCalledWith(1, 2.5)"
              },
              {
                "title": "skips uniform if not in program",
                "line": 277,
                "source": "const mockProgram = {\n    uniforms: {}\n}\ngl.uniform1f = vi.fn()\n\nregistry.setUniform('uTime', 2.5)\nregistry.applyUniforms(gl, mockProgram)\n\nexpect(gl.uniform1f).not.toHaveBeenCalled()"
              },
              {
                "title": "applies vec2 uniform",
                "line": 290,
                "source": "const mockProgram = {\n    uniforms: {uOffset: 1}\n}\ngl.uniform2fv = vi.fn()\n\nregistry.setUniform('uOffset', [0.1, 0.2], 'vec2')\nregistry.applyUniforms(gl, mockProgram)\n\nexpect(gl.uniform2fv).toHaveBeenCalledWith(1, [0.1, 0.2])"
              }
            ],
            "describes": []
          },
          {
            "title": "dispose",
            "line": 305,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "clears all registered effects",
                "line": 307,
                "source": "registry.register(ChromaticEffect)\nregistry.register(WaveEffect)\n\nregistry.dispose()\n\nexpect(registry.has('ChromaticEffect')).toBe(false)\nexpect(registry.has('WaveEffect')).toBe(false)"
              },
              {
                "title": "clears uniform values",
                "line": 318,
                "source": "registry.setUniform('uTime', 1.0)\nregistry.dispose()\nexpect(registry.getUniform('uTime')).toBeUndefined()"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/render/shaders/shader_program.doc.js": {
    "file": "/render/shaders/shader_program.test.js",
    "describes": [
      {
        "title": "ShaderProgram",
        "line": 85,
        "beforeEach": {
          "line": 90,
          "source": "gl = createMockGL()\nprogram = new ShaderProgram(gl, VERTEX_SOURCE, FRAGMENT_SOURCE)"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor creates program",
            "line": 96,
            "source": "expect(gl.createProgram).toHaveBeenCalled()\nexpect(gl.createShader).toHaveBeenCalledTimes(2)\nexpect(gl.linkProgram).toHaveBeenCalled()"
          },
          {
            "title": "program getter",
            "line": 103,
            "source": "expect(program.program).toBeDefined()\nexpect(program.program).not.toBeNull()"
          },
          {
            "title": "uniforms getter",
            "line": 109,
            "source": "expect(program.uniforms).toEqual({})"
          },
          {
            "title": "attributes getter",
            "line": 114,
            "source": "expect(program.attributes).toEqual({})"
          },
          {
            "title": "registerUniform",
            "line": 119,
            "source": "program.registerUniform('uMatrix')\nexpect(gl.getUniformLocation).toHaveBeenCalled()\nexpect(program.uniforms.uMatrix).toBeDefined()"
          },
          {
            "title": "registerUniform returns this",
            "line": 126,
            "source": "const result = program.registerUniform('uMatrix')\nexpect(result).toBe(program)"
          },
          {
            "title": "registerAttribute",
            "line": 132,
            "source": "program.registerAttribute('aPosition')\nexpect(gl.getAttribLocation).toHaveBeenCalled()\nexpect(program.attributes.aPosition).toBeDefined()"
          },
          {
            "title": "registerAttribute returns this",
            "line": 139,
            "source": "const result = program.registerAttribute('aPosition')\nexpect(result).toBe(program)"
          },
          {
            "title": "use",
            "line": 145,
            "source": "program.use()\nexpect(gl.useProgram).toHaveBeenCalled()"
          },
          {
            "title": "use returns this",
            "line": 151,
            "source": "const result = program.use()\nexpect(result).toBe(program)"
          },
          {
            "title": "setUniform1f",
            "line": 157,
            "source": "program.registerUniform('uValue')\nprogram.setUniform1f('uValue', 1.5)\nexpect(gl.uniform1f).toHaveBeenCalledWith(program.uniforms.uValue, 1.5)"
          },
          {
            "title": "setUniform2f",
            "line": 164,
            "source": "program.registerUniform('uVec')\nprogram.setUniform2f('uVec', 1.0, 2.0)\nexpect(gl.uniform2f).toHaveBeenCalledWith(program.uniforms.uVec, 1.0, 2.0)"
          },
          {
            "title": "setUniform3f",
            "line": 171,
            "source": "program.registerUniform('uVec')\nprogram.setUniform3f('uVec', 1.0, 2.0, 3.0)\nexpect(gl.uniform3f).toHaveBeenCalledWith(program.uniforms.uVec, 1.0, 2.0, 3.0)"
          },
          {
            "title": "setUniform4f",
            "line": 178,
            "source": "program.registerUniform('uColor')\nprogram.setUniform4f('uColor', [1.0, 0.5, 0.25, 1.0])\nexpect(gl.uniform4f).toHaveBeenCalledWith(program.uniforms.uColor, 1.0, 0.5, 0.25, 1.0)"
          },
          {
            "title": "setUniform1i",
            "line": 185,
            "source": "program.registerUniform('uTexture')\nprogram.setUniform1i('uTexture', 0)\nexpect(gl.uniform1i).toHaveBeenCalledWith(program.uniforms.uTexture, 0)"
          },
          {
            "title": "setUniformMatrix3fv",
            "line": 192,
            "source": "program.registerUniform('uMatrix')\nconst matrix = new Float32Array(9)\nprogram.setUniformMatrix3fv('uMatrix', false, matrix)\nexpect(gl.uniformMatrix3fv).toHaveBeenCalledWith(program.uniforms.uMatrix, false, matrix)"
          },
          {
            "title": "setUniformMatrix4fv",
            "line": 200,
            "source": "program.registerUniform('uMatrix')\nconst matrix = new Float32Array(16)\nprogram.setUniformMatrix4fv('uMatrix', false, matrix)\nexpect(gl.uniformMatrix4fv).toHaveBeenCalledWith(program.uniforms.uMatrix, false, matrix)"
          },
          {
            "title": "dispose",
            "line": 208,
            "source": "program.dispose()\nexpect(gl.deleteProgram).toHaveBeenCalled()\nexpect(program.program).toBeNull()\nexpect(program.uniforms).toEqual({})\nexpect(program.attributes).toEqual({})"
          }
        ],
        "describes": []
      },
      {
        "title": "ShaderProgram compilation errors",
        "line": 219,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "throws on shader compilation failure",
            "line": 221,
            "source": "const gl = createMockGL()\ngl.getShaderParameter = vi.fn(() => false)\ngl.getShaderInfoLog = vi.fn(() => 'Syntax error')\n\nexpect(() => new ShaderProgram(gl, VERTEX_SOURCE, FRAGMENT_SOURCE))\n    .toThrow('Shader compilation failed: Syntax error')"
          },
          {
            "title": "throws on program link failure",
            "line": 231,
            "source": "const gl = createMockGL()\ngl.getProgramParameter = vi.fn(() => false)\ngl.getProgramInfoLog = vi.fn(() => 'Link error')\n\nexpect(() => new ShaderProgram(gl, VERTEX_SOURCE, FRAGMENT_SOURCE))\n    .toThrow('Program linking failed: Link error')"
          }
        ],
        "describes": []
      }
    ]
  },
  "/render/shaders/shader_registry.doc.js": {
    "file": "/render/shaders/shader_registry.test.js",
    "describes": [
      {
        "title": "ShaderRegistry",
        "line": 20,
        "beforeEach": {
          "line": 25,
          "source": "gl = createMockGLWithSpies()\nregistry = new ShaderRegistry(gl)"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "register",
            "line": 31,
            "source": "const program = registry.register('test', {\n    vertex: VERTEX_SOURCE,\n    fragment: FRAGMENT_SOURCE\n})\nexpect(program).toBeDefined()\nexpect(program.program).toBeDefined()"
          },
          {
            "title": "register with uniforms",
            "line": 41,
            "source": "const program = registry.register('test', {\n    vertex: VERTEX_SOURCE,\n    fragment: FRAGMENT_SOURCE,\n    uniforms: ['uMatrix']\n})\nexpect(program.uniforms.uMatrix).toBeDefined()"
          },
          {
            "title": "register with attributes",
            "line": 51,
            "source": "const program = registry.register('test', {\n    vertex: VERTEX_SOURCE,\n    fragment: FRAGMENT_SOURCE,\n    attributes: ['aPosition']\n})\nexpect(program.attributes.aPosition).toBeDefined()"
          },
          {
            "title": "get returns registered program",
            "line": 61,
            "source": "const registered = registry.register('test', {\n    vertex: VERTEX_SOURCE,\n    fragment: FRAGMENT_SOURCE\n})\nconst retrieved = registry.get('test')\nexpect(retrieved).toBe(registered)"
          },
          {
            "title": "get returns null for unregistered id",
            "line": 71,
            "source": "expect(registry.get('nonexistent')).toBeNull()"
          },
          {
            "title": "has returns true for registered id",
            "line": 76,
            "source": "registry.register('test', {\n    vertex: VERTEX_SOURCE,\n    fragment: FRAGMENT_SOURCE\n})\nexpect(registry.has('test')).toBe(true)"
          },
          {
            "title": "has returns false for unregistered id",
            "line": 85,
            "source": "expect(registry.has('nonexistent')).toBe(false)"
          },
          {
            "title": "setDefault",
            "line": 90,
            "source": "registry.register('test', {\n    vertex: VERTEX_SOURCE,\n    fragment: FRAGMENT_SOURCE\n})\nconst result = registry.setDefault('sprite', 'test')\nexpect(result).toBe(registry)"
          },
          {
            "title": "getDefault returns program for registered default",
            "line": 100,
            "source": "const program = registry.register('test', {\n    vertex: VERTEX_SOURCE,\n    fragment: FRAGMENT_SOURCE\n})\nregistry.setDefault('sprite', 'test')\nexpect(registry.getDefault('sprite')).toBe(program)"
          },
          {
            "title": "getDefault returns null for unregistered default",
            "line": 110,
            "source": "expect(registry.getDefault('sprite')).toBeNull()"
          },
          {
            "title": "unregister disposes and removes program",
            "line": 115,
            "source": "registry.register('test', {\n    vertex: VERTEX_SOURCE,\n    fragment: FRAGMENT_SOURCE\n})\nregistry.unregister('test')\nexpect(registry.get('test')).toBeNull()\nexpect(gl.deleteProgram).toHaveBeenCalled()"
          },
          {
            "title": "unregister removes associated defaults",
            "line": 126,
            "source": "registry.register('test', {\n    vertex: VERTEX_SOURCE,\n    fragment: FRAGMENT_SOURCE\n})\nregistry.setDefault('sprite', 'test')\nregistry.unregister('test')\nexpect(registry.getDefault('sprite')).toBeNull()"
          },
          {
            "title": "unregister returns this",
            "line": 137,
            "source": "const result = registry.unregister('nonexistent')\nexpect(result).toBe(registry)"
          },
          {
            "title": "dispose clears all programs",
            "line": 143,
            "source": "registry.register('test1', {\n    vertex: VERTEX_SOURCE,\n    fragment: FRAGMENT_SOURCE\n})\nregistry.register('test2', {\n    vertex: VERTEX_SOURCE,\n    fragment: FRAGMENT_SOURCE\n})\nregistry.setDefault('sprite', 'test1')\n\nregistry.dispose()\n\nexpect(registry.get('test1')).toBeNull()\nexpect(registry.get('test2')).toBeNull()\nexpect(registry.getDefault('sprite')).toBeNull()\nexpect(gl.deleteProgram).toHaveBeenCalledTimes(2)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/render/shaders/builtin/primitive_shader.doc.js": {
    "file": "/render/shaders/builtin/primitive_shader.test.js",
    "describes": [
      {
        "title": "PRIMITIVE_VERTEX",
        "line": 9,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "is a string",
            "line": 11,
            "source": "expect(typeof PRIMITIVE_VERTEX).toBe('string')"
          },
          {
            "title": "contains version directive",
            "line": 16,
            "source": "expect(PRIMITIVE_VERTEX).toContain('#version 300 es')"
          },
          {
            "title": "declares aPosition attribute",
            "line": 21,
            "source": "expect(PRIMITIVE_VERTEX).toContain('in vec2 aPosition')"
          },
          {
            "title": "declares aColor attribute",
            "line": 26,
            "source": "expect(PRIMITIVE_VERTEX).toContain('in vec4 aColor')"
          },
          {
            "title": "declares uProjectionMatrix uniform",
            "line": 31,
            "source": "expect(PRIMITIVE_VERTEX).toContain('uniform mat3 uProjectionMatrix')"
          },
          {
            "title": "declares uViewMatrix uniform",
            "line": 36,
            "source": "expect(PRIMITIVE_VERTEX).toContain('uniform mat3 uViewMatrix')"
          }
        ],
        "describes": []
      },
      {
        "title": "PRIMITIVE_FRAGMENT",
        "line": 43,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "is a string",
            "line": 45,
            "source": "expect(typeof PRIMITIVE_FRAGMENT).toBe('string')"
          },
          {
            "title": "contains version directive",
            "line": 50,
            "source": "expect(PRIMITIVE_FRAGMENT).toContain('#version 300 es')"
          },
          {
            "title": "declares fragColor output",
            "line": 55,
            "source": "expect(PRIMITIVE_FRAGMENT).toContain('out vec4 fragColor')"
          }
        ],
        "describes": []
      },
      {
        "title": "PRIMITIVE_SHADER_DEF",
        "line": 62,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "has vertex property",
            "line": 64,
            "source": "expect(PRIMITIVE_SHADER_DEF.vertex).toBe(PRIMITIVE_VERTEX)"
          },
          {
            "title": "has fragment property",
            "line": 69,
            "source": "expect(PRIMITIVE_SHADER_DEF.fragment).toBe(PRIMITIVE_FRAGMENT)"
          },
          {
            "title": "has uniforms array",
            "line": 74,
            "source": "expect(PRIMITIVE_SHADER_DEF.uniforms).toEqual(['uProjectionMatrix', 'uViewMatrix'])"
          },
          {
            "title": "has attributes array",
            "line": 79,
            "source": "expect(PRIMITIVE_SHADER_DEF.attributes).toEqual(['aPosition', 'aColor'])"
          }
        ],
        "describes": []
      }
    ]
  },
  "/render/shaders/builtin/shadow_shader.doc.js": {
    "file": "/render/shaders/builtin/shadow_shader.test.js",
    "describes": [
      {
        "title": "SHADOW_VERTEX",
        "line": 9,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "is a string",
            "line": 11,
            "source": "expect(typeof SHADOW_VERTEX).toBe('string')"
          },
          {
            "title": "contains version directive",
            "line": 16,
            "source": "expect(SHADOW_VERTEX).toContain('#version 300 es')"
          },
          {
            "title": "declares aPosition attribute",
            "line": 21,
            "source": "expect(SHADOW_VERTEX).toContain('in vec2 aPosition')"
          },
          {
            "title": "declares aTexCoord attribute",
            "line": 26,
            "source": "expect(SHADOW_VERTEX).toContain('in vec2 aTexCoord')"
          },
          {
            "title": "declares aOpacity attribute",
            "line": 31,
            "source": "expect(SHADOW_VERTEX).toContain('in float aOpacity')"
          },
          {
            "title": "declares aAnchorY attribute",
            "line": 36,
            "source": "expect(SHADOW_VERTEX).toContain('in float aAnchorY')"
          },
          {
            "title": "declares shadow uniforms",
            "line": 41,
            "source": "expect(SHADOW_VERTEX).toContain('uniform float uShadowSkewX')\nexpect(SHADOW_VERTEX).toContain('uniform float uShadowScaleY')\nexpect(SHADOW_VERTEX).toContain('uniform float uShadowOffsetY')"
          }
        ],
        "describes": []
      },
      {
        "title": "SHADOW_FRAGMENT",
        "line": 50,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "is a string",
            "line": 52,
            "source": "expect(typeof SHADOW_FRAGMENT).toBe('string')"
          },
          {
            "title": "contains version directive",
            "line": 57,
            "source": "expect(SHADOW_FRAGMENT).toContain('#version 300 es')"
          },
          {
            "title": "declares uTexture uniform",
            "line": 62,
            "source": "expect(SHADOW_FRAGMENT).toContain('uniform sampler2D uTexture')"
          },
          {
            "title": "declares uShadowColor uniform",
            "line": 67,
            "source": "expect(SHADOW_FRAGMENT).toContain('uniform vec4 uShadowColor')"
          },
          {
            "title": "declares fragColor output",
            "line": 72,
            "source": "expect(SHADOW_FRAGMENT).toContain('out vec4 fragColor')"
          }
        ],
        "describes": []
      },
      {
        "title": "SHADOW_SHADER_DEF",
        "line": 79,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "has vertex property",
            "line": 81,
            "source": "expect(SHADOW_SHADER_DEF.vertex).toBe(SHADOW_VERTEX)"
          },
          {
            "title": "has fragment property",
            "line": 86,
            "source": "expect(SHADOW_SHADER_DEF.fragment).toBe(SHADOW_FRAGMENT)"
          },
          {
            "title": "has uniforms array",
            "line": 91,
            "source": "expect(SHADOW_SHADER_DEF.uniforms).toEqual([\n    'uProjectionMatrix',\n    'uViewMatrix',\n    'uModelMatrix',\n    'uShadowSkewX',\n    'uShadowScaleY',\n    'uShadowOffsetY',\n    'uTexture',\n    'uShadowColor'\n])"
          },
          {
            "title": "has attributes array",
            "line": 105,
            "source": "expect(SHADOW_SHADER_DEF.attributes).toEqual(['aPosition', 'aTexCoord', 'aOpacity', 'aAnchorY'])"
          }
        ],
        "describes": []
      }
    ]
  },
  "/render/shaders/builtin/sprite_shader.doc.js": {
    "file": "/render/shaders/builtin/sprite_shader.test.js",
    "describes": [
      {
        "title": "SPRITE_VERTEX",
        "line": 9,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "is a string",
            "line": 11,
            "source": "expect(typeof SPRITE_VERTEX).toBe('string')"
          },
          {
            "title": "contains version directive",
            "line": 16,
            "source": "expect(SPRITE_VERTEX).toContain('#version 300 es')"
          },
          {
            "title": "declares aPosition attribute",
            "line": 21,
            "source": "expect(SPRITE_VERTEX).toContain('in vec2 aPosition')"
          },
          {
            "title": "declares aTexCoord attribute",
            "line": 26,
            "source": "expect(SPRITE_VERTEX).toContain('in vec2 aTexCoord')"
          },
          {
            "title": "declares aOpacity attribute",
            "line": 31,
            "source": "expect(SPRITE_VERTEX).toContain('in float aOpacity')"
          },
          {
            "title": "declares aTintColor attribute",
            "line": 36,
            "source": "expect(SPRITE_VERTEX).toContain('in vec4 aTintColor')"
          },
          {
            "title": "declares aEffectParams attribute",
            "line": 41,
            "source": "expect(SPRITE_VERTEX).toContain('in vec4 aEffectParams')"
          },
          {
            "title": "declares matrix uniforms",
            "line": 46,
            "source": "expect(SPRITE_VERTEX).toContain('uniform mat3 uProjectionMatrix')\nexpect(SPRITE_VERTEX).toContain('uniform mat3 uViewMatrix')\nexpect(SPRITE_VERTEX).toContain('uniform mat3 uModelMatrix')"
          }
        ],
        "describes": []
      },
      {
        "title": "SPRITE_FRAGMENT",
        "line": 55,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "is a string",
            "line": 57,
            "source": "expect(typeof SPRITE_FRAGMENT).toBe('string')"
          },
          {
            "title": "contains version directive",
            "line": 62,
            "source": "expect(SPRITE_FRAGMENT).toContain('#version 300 es')"
          },
          {
            "title": "declares uTexture uniform",
            "line": 67,
            "source": "expect(SPRITE_FRAGMENT).toContain('uniform sampler2D uTexture')"
          },
          {
            "title": "declares uTexelSize uniform",
            "line": 72,
            "source": "expect(SPRITE_FRAGMENT).toContain('uniform vec2 uTexelSize')"
          },
          {
            "title": "declares fragColor output",
            "line": 77,
            "source": "expect(SPRITE_FRAGMENT).toContain('out vec4 fragColor')"
          }
        ],
        "describes": []
      },
      {
        "title": "SPRITE_SHADER_DEF",
        "line": 84,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "has vertex property",
            "line": 86,
            "source": "expect(SPRITE_SHADER_DEF.vertex).toBe(SPRITE_VERTEX)"
          },
          {
            "title": "has fragment property",
            "line": 91,
            "source": "expect(SPRITE_SHADER_DEF.fragment).toBe(SPRITE_FRAGMENT)"
          },
          {
            "title": "has uniforms array",
            "line": 96,
            "source": "expect(SPRITE_SHADER_DEF.uniforms).toEqual([\n    'uProjectionMatrix',\n    'uViewMatrix',\n    'uModelMatrix',\n    'uTexture',\n    'uTexelSize'\n])"
          },
          {
            "title": "has attributes array",
            "line": 107,
            "source": "expect(SPRITE_SHADER_DEF.attributes).toEqual([\n    'aPosition',\n    'aTexCoord',\n    'aOpacity',\n    'aTintColor',\n    'aEffectParams',\n    'aUVBounds'\n])"
          }
        ],
        "describes": []
      }
    ]
  },
  "/render/shaders/builtin/effects/outline_effect.doc.js": {
    "file": "/render/shaders/builtin/effects/outline_effect.test.js",
    "describes": [
      {
        "title": "OutlineEffect",
        "line": 6,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "extends ShaderEffect",
            "line": 8,
            "source": "const effect = new OutlineEffect()\nexpect(effect).toBeInstanceOf(ShaderEffect)"
          },
          {
            "title": "getParams returns width value",
            "line": 51,
            "source": "const effect = new OutlineEffect({width: 0.03})\nexpect(effect.getParams()).toEqual([0.03])"
          },
          {
            "title": "type returns class name",
            "line": 57,
            "source": "const effect = new OutlineEffect()\nexpect(effect.type).toBe('OutlineEffect')"
          }
        ],
        "describes": [
          {
            "title": "static shader",
            "line": 14,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "has width param",
                "line": 16,
                "source": "expect(OutlineEffect.shader.params).toContain('width')"
              },
              {
                "title": "has fragment code",
                "line": 21,
                "source": "expect(OutlineEffect.shader.fragment).toContain('neighborAlpha')\nexpect(OutlineEffect.shader.fragment).toContain('texelSize')"
              }
            ],
            "describes": []
          },
          {
            "title": "constructor",
            "line": 29,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates with default width",
                "line": 31,
                "source": "const effect = new OutlineEffect()\nexpect(effect.width).toBe(0.02)"
              },
              {
                "title": "creates with custom width",
                "line": 37,
                "source": "const effect = new OutlineEffect({width: 0.05})\nexpect(effect.width).toBe(0.05)"
              },
              {
                "title": "creates with enabled from options",
                "line": 43,
                "source": "const effect = new OutlineEffect({enabled: false})\nexpect(effect.enabled).toBe(false)"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/render/sprite_effects/outline_effect.doc.js": {
    "file": "/render/sprite_effects/outline_effect.test.js",
    "describes": [
      {
        "title": "OutlineEffect",
        "line": 6,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "extends SpriteEffect",
            "line": 8,
            "source": "const effect = new OutlineEffect()\nexpect(effect).toBeInstanceOf(SpriteEffect)"
          },
          {
            "title": "has outline type",
            "line": 14,
            "source": "expect(OutlineEffect.type).toBe('outline')\nexpect(new OutlineEffect().type).toBe('outline')"
          },
          {
            "title": "width can be set",
            "line": 43,
            "source": "const effect = new OutlineEffect()\neffect.width = 0.1\nexpect(effect.width).toBe(0.1)"
          },
          {
            "title": "color can be set",
            "line": 50,
            "source": "const effect = new OutlineEffect()\neffect.color = [0, 1, 0, 1]\nexpect(effect.color).toEqual([0, 1, 0, 1])"
          },
          {
            "title": "getHints returns width and color",
            "line": 57,
            "source": "const effect = new OutlineEffect({\n    width: 0.03,\n    color: [0, 0, 1, 1]\n})\n\nexpect(effect.getHints()).toEqual({\n    width: 0.03,\n    color: [0, 0, 1, 1]\n})"
          }
        ],
        "describes": [
          {
            "title": "constructor",
            "line": 20,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates with default values",
                "line": 22,
                "source": "const effect = new OutlineEffect()\n\nexpect(effect.width).toBe(0.02)\nexpect(effect.color).toEqual([1, 1, 1, 1])"
              },
              {
                "title": "creates with provided options",
                "line": 30,
                "source": "const effect = new OutlineEffect({\n    width: 0.05,\n    color: [1, 0, 0, 1]\n})\n\nexpect(effect.width).toBe(0.05)\nexpect(effect.color).toEqual([1, 0, 0, 1])"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/render/sprite_effects/splatter_effect.doc.js": {
    "file": "/render/sprite_effects/splatter_effect.test.js",
    "describes": [
      {
        "title": "SplatterEffect",
        "line": 6,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "extends SpriteEffect",
            "line": 8,
            "source": "const effect = new SplatterEffect()\nexpect(effect).toBeInstanceOf(SpriteEffect)"
          },
          {
            "title": "has splatter type",
            "line": 14,
            "source": "expect(SplatterEffect.type).toBe('splatter')\nexpect(new SplatterEffect().type).toBe('splatter')"
          },
          {
            "title": "pattern can be set",
            "line": 69,
            "source": "const effect = new SplatterEffect()\neffect.pattern = 5\nexpect(effect.pattern).toBe(5)"
          },
          {
            "title": "atlas can be set",
            "line": 76,
            "source": "const mockAtlas = {name: 'dirt'}\nconst effect = new SplatterEffect()\neffect.atlas = mockAtlas\nexpect(effect.atlas).toBe(mockAtlas)"
          },
          {
            "title": "getHints returns intensity, pattern and atlas",
            "line": 84,
            "source": "const mockAtlas = {name: 'blood'}\nconst effect = new SplatterEffect({\n    intensity: 0.8,\n    pattern: 2,\n    atlas: mockAtlas\n})\n\nexpect(effect.getHints()).toEqual({\n    intensity: 0.8,\n    pattern: 2,\n    atlas: mockAtlas\n})"
          }
        ],
        "describes": [
          {
            "title": "constructor",
            "line": 20,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates with default values",
                "line": 22,
                "source": "const effect = new SplatterEffect()\n\nexpect(effect.intensity).toBe(0)\nexpect(effect.pattern).toBe(0)\nexpect(effect.atlas).toBe(null)"
              },
              {
                "title": "creates with provided options",
                "line": 31,
                "source": "const mockAtlas = {name: 'blood'}\nconst effect = new SplatterEffect({\n    intensity: 0.5,\n    pattern: 3,\n    atlas: mockAtlas\n})\n\nexpect(effect.intensity).toBe(0.5)\nexpect(effect.pattern).toBe(3)\nexpect(effect.atlas).toBe(mockAtlas)"
              }
            ],
            "describes": []
          },
          {
            "title": "intensity",
            "line": 47,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "can be set",
                "line": 49,
                "source": "const effect = new SplatterEffect()\neffect.intensity = 0.7\nexpect(effect.intensity).toBe(0.7)"
              },
              {
                "title": "is clamped to 0-1",
                "line": 56,
                "source": "const effect = new SplatterEffect()\n\neffect.intensity = -0.5\nexpect(effect.intensity).toBe(0)\n\neffect.intensity = 1.5\nexpect(effect.intensity).toBe(1)"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/render/sprite_effects/sprite_effect.doc.js": {
    "file": "/render/sprite_effects/sprite_effect.test.js",
    "describes": [
      {
        "title": "SpriteEffect",
        "line": 5,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "has base type",
            "line": 7,
            "source": "expect(SpriteEffect.type).toBe('base')"
          },
          {
            "title": "enabled can be set",
            "line": 28,
            "source": "const effect = new SpriteEffect()\neffect.enabled = false\nexpect(effect.enabled).toBe(false)"
          },
          {
            "title": "getHints returns null by default",
            "line": 55,
            "source": "const effect = new SpriteEffect()\nexpect(effect.getHints()).toBe(null)"
          },
          {
            "title": "update exists and accepts deltaTime",
            "line": 61,
            "source": "const effect = new SpriteEffect()\nexpect(() => effect.update(16)).not.toThrow()"
          },
          {
            "title": "dispose exists and can be called",
            "line": 67,
            "source": "const effect = new SpriteEffect()\nexpect(() => effect.dispose()).not.toThrow()"
          }
        ],
        "describes": [
          {
            "title": "constructor",
            "line": 12,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates with enabled true by default",
                "line": 14,
                "source": "const effect = new SpriteEffect()\nexpect(effect.enabled).toBe(true)"
              },
              {
                "title": "creates with enabled from options",
                "line": 20,
                "source": "const effect = new SpriteEffect({enabled: false})\nexpect(effect.enabled).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "type getter",
            "line": 35,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns constructor type",
                "line": 37,
                "source": "const effect = new SpriteEffect()\nexpect(effect.type).toBe('base')"
              },
              {
                "title": "returns subclass type",
                "line": 43,
                "source": "class CustomEffect extends SpriteEffect {\n    static type = 'custom'\n}\n\nconst effect = new CustomEffect()\nexpect(effect.type).toBe('custom')"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/render/sprite_effects/sprite_effect_stack.doc.js": {
    "file": "/render/sprite_effects/sprite_effect_stack.test.js",
    "describes": [
      {
        "title": "SpriteEffectStack",
        "line": 68,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "creates with empty effects",
            "line": 70,
            "source": "const stack = new SpriteEffectStack()\nexpect(stack.count).toBe(0)\nexpect(stack.effects).toEqual([])"
          },
          {
            "title": "dispose clears all effects",
            "line": 293,
            "source": "const stack = new SpriteEffectStack()\nconst effect = new MockEffect()\neffect.dispose = vi.fn()\n\nstack.add(effect)\nstack.dispose()\n\nexpect(stack.count).toBe(0)\nexpect(effect.dispose).toHaveBeenCalled()"
          }
        ],
        "describes": [
          {
            "title": "add",
            "line": 77,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "adds an effect",
                "line": 79,
                "source": "const stack = new SpriteEffectStack()\nconst effect = new MockEffect()\n\nstack.add(effect)\n\nexpect(stack.count).toBe(1)\nexpect(stack.effects[0]).toBe(effect)"
              },
              {
                "title": "returns this for chaining",
                "line": 90,
                "source": "const stack = new SpriteEffectStack()\nconst effect = new MockEffect()\n\nexpect(stack.add(effect)).toBe(stack)"
              },
              {
                "title": "prevents duplicate effect types",
                "line": 98,
                "source": "const stack = new SpriteEffectStack()\nconst effect1 = new MockEffect({hints: {v: 1}})\nconst effect2 = new MockEffect({hints: {v: 2}})\n\nstack.add(effect1)\nstack.add(effect2)\n\nexpect(stack.count).toBe(1)\nexpect(stack.get(MockEffect)).toBe(effect1)"
              },
              {
                "title": "allows different effect types",
                "line": 111,
                "source": "const stack = new SpriteEffectStack()\n\nstack.add(new MockEffect())\nstack.add(new AnotherEffect())\n\nexpect(stack.count).toBe(2)"
              }
            ],
            "describes": []
          },
          {
            "title": "remove",
            "line": 123,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "removes an effect by class",
                "line": 125,
                "source": "const stack = new SpriteEffectStack()\nconst effect = new MockEffect()\neffect.dispose = vi.fn()\n\nstack.add(effect)\nstack.remove(MockEffect)\n\nexpect(stack.count).toBe(0)\nexpect(effect.dispose).toHaveBeenCalled()"
              },
              {
                "title": "returns this for chaining",
                "line": 138,
                "source": "const stack = new SpriteEffectStack()\nexpect(stack.remove(MockEffect)).toBe(stack)"
              },
              {
                "title": "does nothing if effect not found",
                "line": 144,
                "source": "const stack = new SpriteEffectStack()\nexpect(() => stack.remove(MockEffect)).not.toThrow()"
              }
            ],
            "describes": []
          },
          {
            "title": "get",
            "line": 152,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns effect by class",
                "line": 154,
                "source": "const stack = new SpriteEffectStack()\nconst effect = new MockEffect()\n\nstack.add(effect)\n\nexpect(stack.get(MockEffect)).toBe(effect)"
              },
              {
                "title": "returns null if not found",
                "line": 164,
                "source": "const stack = new SpriteEffectStack()\nexpect(stack.get(MockEffect)).toBe(null)"
              }
            ],
            "describes": []
          },
          {
            "title": "has",
            "line": 172,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns true if effect exists",
                "line": 174,
                "source": "const stack = new SpriteEffectStack()\nstack.add(new MockEffect())\n\nexpect(stack.has(MockEffect)).toBe(true)"
              },
              {
                "title": "returns false if effect does not exist",
                "line": 182,
                "source": "const stack = new SpriteEffectStack()\nexpect(stack.has(MockEffect)).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "clear",
            "line": 190,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "removes all effects",
                "line": 192,
                "source": "const stack = new SpriteEffectStack()\nconst effect1 = new MockEffect()\nconst effect2 = new AnotherEffect()\neffect1.dispose = vi.fn()\neffect2.dispose = vi.fn()\n\nstack.add(effect1)\nstack.add(effect2)\nstack.clear()\n\nexpect(stack.count).toBe(0)\nexpect(effect1.dispose).toHaveBeenCalled()\nexpect(effect2.dispose).toHaveBeenCalled()"
              },
              {
                "title": "returns this for chaining",
                "line": 209,
                "source": "const stack = new SpriteEffectStack()\nexpect(stack.clear()).toBe(stack)"
              }
            ],
            "describes": []
          },
          {
            "title": "getHints",
            "line": 217,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns null when no effects",
                "line": 219,
                "source": "const stack = new SpriteEffectStack()\nexpect(stack.getHints()).toBe(null)"
              },
              {
                "title": "returns combined hints from all enabled effects",
                "line": 225,
                "source": "const stack = new SpriteEffectStack()\nstack.add(new MockEffect({hints: {intensity: 0.5}}))\nstack.add(new AnotherEffect())\n\nconst hints = stack.getHints()\n\nexpect(hints).toEqual({\n    mock: {intensity: 0.5},\n    another: {other: true}\n})"
              },
              {
                "title": "skips disabled effects",
                "line": 239,
                "source": "const stack = new SpriteEffectStack()\nconst effect = new MockEffect()\neffect.enabled = false\nstack.add(effect)\n\nexpect(stack.getHints()).toBe(null)"
              },
              {
                "title": "returns null if all effects return null hints",
                "line": 249,
                "source": "const stack = new SpriteEffectStack()\nconst effect = new SpriteEffect()\nstack.add(effect)\n\nexpect(stack.getHints()).toBe(null)"
              }
            ],
            "describes": []
          },
          {
            "title": "update",
            "line": 260,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "calls update on all enabled effects",
                "line": 262,
                "source": "const stack = new SpriteEffectStack()\nconst effect1 = new MockEffect()\nconst effect2 = new AnotherEffect()\neffect1.update = vi.fn()\neffect2.update = vi.fn()\n\nstack.add(effect1)\nstack.add(effect2)\nstack.update(16)\n\nexpect(effect1.update).toHaveBeenCalledWith(16)\nexpect(effect2.update).toHaveBeenCalledWith(16)"
              },
              {
                "title": "skips disabled effects",
                "line": 278,
                "source": "const stack = new SpriteEffectStack()\nconst effect = new MockEffect()\neffect.enabled = false\neffect.update = vi.fn()\n\nstack.add(effect)\nstack.update(16)\n\nexpect(effect.update).not.toHaveBeenCalled()"
              }
            ],
            "describes": []
          },
          {
            "title": "getShaderEffectTypes",
            "line": 306,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns empty array when no effects",
                "line": 308,
                "source": "const stack = new SpriteEffectStack()\nexpect(stack.getShaderEffectTypes()).toEqual([])"
              },
              {
                "title": "returns types of enabled ShaderEffects only",
                "line": 314,
                "source": "const stack = new SpriteEffectStack()\nstack.add(new MockShaderEffect())\nstack.add(new AnotherShaderEffect())\n\nconst types = stack.getShaderEffectTypes()\n\nexpect(types).toEqual(['MockShaderEffect', 'AnotherShaderEffect'])"
              },
              {
                "title": "excludes regular SpriteEffects",
                "line": 325,
                "source": "const stack = new SpriteEffectStack()\nstack.add(new MockEffect())\nstack.add(new MockShaderEffect())\n\nconst types = stack.getShaderEffectTypes()\n\nexpect(types).toEqual(['MockShaderEffect'])"
              },
              {
                "title": "excludes disabled ShaderEffects",
                "line": 336,
                "source": "const stack = new SpriteEffectStack()\nconst effect = new MockShaderEffect()\neffect.enabled = false\nstack.add(effect)\n\nexpect(stack.getShaderEffectTypes()).toEqual([])"
              }
            ],
            "describes": []
          },
          {
            "title": "getShaderEffectParams",
            "line": 348,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns zeros when no effects",
                "line": 350,
                "source": "const stack = new SpriteEffectStack()\nexpect(stack.getShaderEffectParams()).toEqual([0, 0, 0, 0])"
              },
              {
                "title": "returns params from single ShaderEffect",
                "line": 356,
                "source": "const stack = new SpriteEffectStack()\nstack.add(new MockShaderEffect({intensity: 0.7, amount: 0.3}))\n\nexpect(stack.getShaderEffectParams()).toEqual([0.7, 0.3, 0, 0])"
              },
              {
                "title": "combines params from multiple ShaderEffects",
                "line": 364,
                "source": "const stack = new SpriteEffectStack()\nstack.add(new MockShaderEffect({intensity: 0.5, amount: 0.2}))\nstack.add(new AnotherShaderEffect({strength: 0.9}))\n\nexpect(stack.getShaderEffectParams()).toEqual([0.5, 0.2, 0.9, 0])"
              },
              {
                "title": "ignores params beyond 4 limit",
                "line": 373,
                "source": "const stack = new SpriteEffectStack()\nstack.add(new MockShaderEffect({intensity: 0.1, amount: 0.2}))\nstack.add(new AnotherShaderEffect({strength: 0.3}))\n\nconst params = stack.getShaderEffectParams()\n\nexpect(params).toEqual([0.1, 0.2, 0.3, 0])\nexpect(params.length).toBe(4)"
              },
              {
                "title": "excludes disabled ShaderEffects",
                "line": 385,
                "source": "const stack = new SpriteEffectStack()\nconst effect = new MockShaderEffect({intensity: 0.9, amount: 0.8})\neffect.enabled = false\nstack.add(effect)\n\nexpect(stack.getShaderEffectParams()).toEqual([0, 0, 0, 0])"
              },
              {
                "title": "excludes regular SpriteEffects",
                "line": 395,
                "source": "const stack = new SpriteEffectStack()\nstack.add(new MockEffect())\nstack.add(new MockShaderEffect({intensity: 0.5, amount: 0.3}))\n\nexpect(stack.getShaderEffectParams()).toEqual([0.5, 0.3, 0, 0])"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/render/textures/shelf_packer.doc.js": {
    "file": "/render/textures/shelf_packer.test.js",
    "describes": [
      {
        "title": "ShelfPacker",
        "line": 5,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "constructor sets dimensions and padding",
            "line": 7,
            "source": "const packer = new ShelfPacker(256, 256, 2)\n\nexpect(packer.width).toBe(256)\nexpect(packer.height).toBe(256)\nexpect(packer.padding).toBe(2)\nexpect(packer.full).toBe(false)"
          },
          {
            "title": "pack returns slot for first item",
            "line": 17,
            "source": "const packer = new ShelfPacker(256, 256, 1)\n\nconst slot = packer.pack(32, 32)\n\nexpect(slot).toEqual({x: 0, y: 0})"
          },
          {
            "title": "pack places items side by side on same shelf",
            "line": 26,
            "source": "const packer = new ShelfPacker(256, 256, 1)\n\npacker.pack(32, 32)\nconst slot2 = packer.pack(32, 32)\n\nexpect(slot2.x).toBe(33)\nexpect(slot2.y).toBe(0)"
          },
          {
            "title": "pack creates new shelf when width exceeded",
            "line": 37,
            "source": "const packer = new ShelfPacker(100, 256, 1)\n\npacker.pack(40, 20)\npacker.pack(40, 20)\nconst slot3 = packer.pack(40, 20)\n\nexpect(slot3.x).toBe(0)\nexpect(slot3.y).toBe(21)"
          },
          {
            "title": "pack returns null when height exceeded",
            "line": 49,
            "source": "const packer = new ShelfPacker(100, 50, 1)\n\npacker.pack(90, 20)\npacker.pack(90, 20)\nconst slot3 = packer.pack(90, 20)\n\nexpect(slot3).toBeNull()\nexpect(packer.full).toBe(true)"
          },
          {
            "title": "canFit returns true when space available",
            "line": 61,
            "source": "const packer = new ShelfPacker(256, 256, 1)\n\nexpect(packer.canFit(32, 32)).toBe(true)"
          },
          {
            "title": "canFit returns false when no space",
            "line": 68,
            "source": "const packer = new ShelfPacker(50, 50, 1)\n\npacker.pack(48, 48)\n\nexpect(packer.canFit(48, 48)).toBe(false)"
          },
          {
            "title": "uses existing shelf when item fits",
            "line": 77,
            "source": "const packer = new ShelfPacker(256, 256, 1)\n\npacker.pack(32, 64)\npacker.pack(32, 32)\nconst slot3 = packer.pack(32, 32)\n\nexpect(slot3.y).toBe(0)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/render/textures/texture_atlas.doc.js": {
    "file": "/render/textures/texture_atlas.test.js",
    "describes": [
      {
        "title": "TextureAtlas",
        "line": 43,
        "beforeEach": {
          "line": 47,
          "source": "atlas = new TextureAtlas({width: 256, height: 256})"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "regionCount counts added regions",
            "line": 195,
            "source": "expect(atlas.regionCount).toBe(0)\n\natlas.add('s1', createMockImage(32, 32))\nexpect(atlas.regionCount).toBe(1)\n\natlas.add('s2', createMockImage(32, 32))\nexpect(atlas.regionCount).toBe(2)"
          },
          {
            "title": "markClean clears dirty flag",
            "line": 206,
            "source": "atlas.add('sprite1', createMockImage(32, 32))\nexpect(atlas.dirty).toBe(true)\n\natlas.markClean()\nexpect(atlas.dirty).toBe(false)"
          }
        ],
        "describes": [
          {
            "title": "constructor",
            "line": 52,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "default dimensions",
                "line": 54,
                "source": "const defaultAtlas = new TextureAtlas()\nexpect(defaultAtlas.width).toBe(4096)\nexpect(defaultAtlas.height).toBe(4096)"
              },
              {
                "title": "custom dimensions",
                "line": 61,
                "source": "expect(atlas.width).toBe(256)\nexpect(atlas.height).toBe(256)"
              },
              {
                "title": "creates canvas",
                "line": 67,
                "source": "expect(atlas.canvas).toBeDefined()\nexpect(atlas.canvas.width).toBe(256)"
              }
            ],
            "describes": []
          },
          {
            "title": "add",
            "line": 75,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "adds image and returns region",
                "line": 77,
                "source": "const image = createMockImage(32, 32)\nconst region = atlas.add('sprite1', image)\n\nexpect(region).not.toBeNull()\nexpect(region.width).toBe(32)\nexpect(region.height).toBe(32)\nexpect(region.image).toBe(atlas.canvas)"
              },
              {
                "title": "marks atlas as dirty",
                "line": 88,
                "source": "expect(atlas.dirty).toBe(false)\n\nconst image = createMockImage(32, 32)\natlas.add('sprite1', image)\n\nexpect(atlas.dirty).toBe(true)"
              },
              {
                "title": "returns existing region for duplicate id",
                "line": 98,
                "source": "const image1 = createMockImage(32, 32)\nconst image2 = createMockImage(64, 64)\n\nconst region1 = atlas.add('sprite1', image1)\nconst region2 = atlas.add('sprite1', image2)\n\nexpect(region1).toBe(region2)\nexpect(region2.width).toBe(32)"
              },
              {
                "title": "places images without overlap",
                "line": 110,
                "source": "const image1 = createMockImage(64, 64)\nconst image2 = createMockImage(64, 64)\n\nconst region1 = atlas.add('sprite1', image1)\nconst region2 = atlas.add('sprite2', image2)\n\nconst noOverlap = region1.x + region1.width <= region2.x ||\n                  region2.x + region2.width <= region1.x ||\n                  region1.y + region1.height <= region2.y ||\n                  region2.y + region2.height <= region1.y ||\n                  (region1.x === region2.x && region1.y !== region2.y) ||\n                  (region1.y === region2.y && region1.x !== region2.x)\n\nexpect(noOverlap).toBe(true)"
              },
              {
                "title": "returns null when atlas is full",
                "line": 128,
                "source": "const largeImage = createMockImage(250, 250)\natlas.add('large', largeImage)\n\nconst anotherLarge = createMockImage(200, 200)\nconst result = atlas.add('another', anotherLarge)\n\nexpect(result).toBeNull()"
              }
            ],
            "describes": []
          },
          {
            "title": "get",
            "line": 141,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns region by id",
                "line": 143,
                "source": "const image = createMockImage(32, 32)\natlas.add('sprite1', image)\n\nconst region = atlas.get('sprite1')\n\nexpect(region).not.toBeNull()\nexpect(region.width).toBe(32)"
              },
              {
                "title": "returns null for unknown id",
                "line": 154,
                "source": "expect(atlas.get('unknown')).toBeNull()"
              }
            ],
            "describes": []
          },
          {
            "title": "has",
            "line": 161,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns true for existing id",
                "line": 163,
                "source": "const image = createMockImage(32, 32)\natlas.add('sprite1', image)\n\nexpect(atlas.has('sprite1')).toBe(true)"
              },
              {
                "title": "returns false for unknown id",
                "line": 171,
                "source": "expect(atlas.has('unknown')).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "canFit",
            "line": 178,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns true when space available",
                "line": 180,
                "source": "expect(atlas.canFit(64, 64)).toBe(true)"
              },
              {
                "title": "returns false when no space",
                "line": 185,
                "source": "const largeImage = createMockImage(250, 250)\natlas.add('large', largeImage)\n\nexpect(atlas.canFit(200, 200)).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "clear",
            "line": 215,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "removes all regions",
                "line": 217,
                "source": "atlas.add('s1', createMockImage(32, 32))\natlas.add('s2', createMockImage(32, 32))\n\natlas.clear()\n\nexpect(atlas.regionCount).toBe(0)\nexpect(atlas.has('s1')).toBe(false)"
              },
              {
                "title": "allows adding new images after clear",
                "line": 228,
                "source": "const largeImage = createMockImage(250, 250)\natlas.add('large', largeImage)\n\natlas.clear()\n\nconst region = atlas.add('new', createMockImage(100, 100))\nexpect(region).not.toBeNull()"
              }
            ],
            "describes": []
          },
          {
            "title": "full",
            "line": 241,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "false initially",
                "line": 243,
                "source": "expect(atlas.full).toBe(false)"
              },
              {
                "title": "true when no more space",
                "line": 248,
                "source": "const largeImage = createMockImage(250, 250)\natlas.add('large', largeImage)\n\natlas.add('overflow', createMockImage(200, 200))\n\nexpect(atlas.full).toBe(true)"
              }
            ],
            "describes": []
          },
          {
            "title": "getAllRegions",
            "line": 260,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns map of all regions",
                "line": 262,
                "source": "atlas.add('s1', createMockImage(32, 32))\natlas.add('s2', createMockImage(48, 48))\n\nconst regions = atlas.getAllRegions()\n\nexpect(regions).toBeInstanceOf(Map)\nexpect(regions.size).toBe(2)\nexpect(regions.has('s1')).toBe(true)\nexpect(regions.has('s2')).toBe(true)"
              },
              {
                "title": "returns empty map when no regions",
                "line": 275,
                "source": "const regions = atlas.getAllRegions()\n\nexpect(regions).toBeInstanceOf(Map)\nexpect(regions.size).toBe(0)"
              }
            ],
            "describes": []
          },
          {
            "title": "static properties",
            "line": 285,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "DEFAULT_SIZE",
                "line": 287,
                "source": "expect(TextureAtlas.DEFAULT_SIZE).toBe(4096)"
              },
              {
                "title": "MAX_SIZE",
                "line": 292,
                "source": "expect(TextureAtlas.MAX_SIZE).toBe(4096)"
              }
            ],
            "describes": []
          },
          {
            "title": "dispose",
            "line": 299,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "clears all internal references",
                "line": 301,
                "source": "atlas.add('s1', createMockImage(32, 32))\natlas.add('s2', createMockImage(32, 32))\n\natlas.dispose()\n\nexpect(atlas.canvas).toBeNull()\nexpect(atlas.regionCount).toBe(0)"
              },
              {
                "title": "clears regions",
                "line": 312,
                "source": "atlas.add('s1', createMockImage(32, 32))\natlas.add('s2', createMockImage(32, 32))\n\nexpect(atlas.regionCount).toBe(2)\n\natlas.dispose()\n\nexpect(atlas.getAllRegions().size).toBe(0)"
              },
              {
                "title": "can be called multiple times safely",
                "line": 324,
                "source": "atlas.add('s1', createMockImage(32, 32))\n\natlas.dispose()\n\nexpect(() => atlas.dispose()).not.toThrow()"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/render/textures/texture_atlas_manager.doc.js": {
    "file": "/render/textures/texture_atlas_manager.test.js",
    "describes": [
      {
        "title": "TextureAtlasManager",
        "line": 43,
        "beforeEach": {
          "line": 47,
          "source": "manager = new TextureAtlasManager({atlasSize: 256})"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor initializes empty",
            "line": 52,
            "source": "expect(manager.atlasCount).toBe(0)\nexpect(manager.regionCount).toBe(0)"
          },
          {
            "title": "clear removes all atlases and regions",
            "line": 210,
            "source": "manager.add('s1', createMockImage(32, 32))\nmanager.add('s2', createMockImage(32, 32))\n\nmanager.clear()\n\nexpect(manager.atlasCount).toBe(0)\nexpect(manager.regionCount).toBe(0)"
          },
          {
            "title": "atlases returns list of atlases",
            "line": 221,
            "source": "manager.add('large1', createMockImage(200, 200))\nmanager.add('large2', createMockImage(200, 200))\n\nconst atlases = manager.atlases\n\nexpect(atlases.length).toBe(2)"
          },
          {
            "title": "dispose clears all atlases and regions",
            "line": 231,
            "source": "manager.add('s1', createMockImage(32, 32))\nmanager.add('s2', createMockImage(32, 32))\n\nmanager.dispose()\n\nexpect(manager.atlasCount).toBe(0)\nexpect(manager.regionCount).toBe(0)"
          }
        ],
        "describes": [
          {
            "title": "add",
            "line": 58,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "adds image and returns region",
                "line": 60,
                "source": "const image = createMockImage(32, 32)\nconst region = manager.add('sprite1', image)\n\nexpect(region).not.toBeNull()\nexpect(region.width).toBe(32)\nexpect(region.height).toBe(32)"
              },
              {
                "title": "creates atlas on first add",
                "line": 70,
                "source": "expect(manager.atlasCount).toBe(0)\n\nmanager.add('sprite1', createMockImage(32, 32))\n\nexpect(manager.atlasCount).toBe(1)"
              },
              {
                "title": "reuses existing atlas when space available",
                "line": 79,
                "source": "manager.add('s1', createMockImage(32, 32))\nmanager.add('s2', createMockImage(32, 32))\n\nexpect(manager.atlasCount).toBe(1)"
              },
              {
                "title": "creates new atlas when current is full",
                "line": 87,
                "source": "manager.add('large1', createMockImage(200, 200))\nmanager.add('large2', createMockImage(200, 200))\n\nexpect(manager.atlasCount).toBe(2)"
              },
              {
                "title": "returns existing region for duplicate id",
                "line": 95,
                "source": "const image = createMockImage(32, 32)\nconst region1 = manager.add('sprite1', image)\nconst region2 = manager.add('sprite1', createMockImage(64, 64))\n\nexpect(region1).toBe(region2)"
              },
              {
                "title": "returns null for invalid image",
                "line": 104,
                "source": "expect(manager.add('invalid', null)).toBeNull()\nexpect(manager.add('zero', {width: 0, height: 0})).toBeNull()"
              },
              {
                "title": "handles oversized images as standalone regions",
                "line": 110,
                "source": "const oversized = createMockImage(500, 500)\nconst region = manager.add('oversized', oversized)\n\nexpect(region).not.toBeNull()\nexpect(region.image).toBe(oversized)\nexpect(manager.atlasCount).toBe(0)"
              }
            ],
            "describes": []
          },
          {
            "title": "addBatch",
            "line": 122,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "adds multiple images",
                "line": 124,
                "source": "const images = {\n    s1: createMockImage(32, 32),\n    s2: createMockImage(48, 48),\n    s3: createMockImage(24, 24)\n}\n\nconst results = manager.addBatch(images)\n\nexpect(results.size).toBe(3)\nexpect(manager.regionCount).toBe(3)"
              },
              {
                "title": "returns map of regions",
                "line": 138,
                "source": "const images = {\n    s1: createMockImage(32, 32),\n    s2: createMockImage(48, 48)\n}\n\nconst results = manager.addBatch(images)\n\nexpect(results.get('s1')).not.toBeNull()\nexpect(results.get('s2')).not.toBeNull()"
              }
            ],
            "describes": []
          },
          {
            "title": "get",
            "line": 153,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns region by id",
                "line": 155,
                "source": "manager.add('sprite1', createMockImage(32, 32))\n\nconst region = manager.get('sprite1')\n\nexpect(region).not.toBeNull()\nexpect(region.width).toBe(32)"
              },
              {
                "title": "returns null for unknown id",
                "line": 165,
                "source": "expect(manager.get('unknown')).toBeNull()"
              }
            ],
            "describes": []
          },
          {
            "title": "has",
            "line": 172,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns true for existing id",
                "line": 174,
                "source": "manager.add('sprite1', createMockImage(32, 32))\nexpect(manager.has('sprite1')).toBe(true)"
              },
              {
                "title": "returns false for unknown id",
                "line": 180,
                "source": "expect(manager.has('unknown')).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "getDirtyAtlases",
            "line": 187,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns newly modified atlases",
                "line": 189,
                "source": "manager.add('s1', createMockImage(32, 32))\n\nconst dirty = manager.getDirtyAtlases()\n\nexpect(dirty.length).toBe(1)"
              },
              {
                "title": "returns empty after markAllClean",
                "line": 198,
                "source": "manager.add('s1', createMockImage(32, 32))\nmanager.markAllClean()\n\nconst dirty = manager.getDirtyAtlases()\n\nexpect(dirty.length).toBe(0)"
              }
            ],
            "describes": []
          },
          {
            "title": "addToNamedAtlas",
            "line": 242,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "adds image to named atlas",
                "line": 244,
                "source": "const image = createMockImage(32, 32)\nconst region = manager.addToNamedAtlas('characters', 'hero', image)\n\nexpect(region).not.toBeNull()\nexpect(region.width).toBe(32)"
              },
              {
                "title": "returns existing region for duplicate id",
                "line": 253,
                "source": "const image = createMockImage(32, 32)\nconst region1 = manager.addToNamedAtlas('characters', 'hero', image)\nconst region2 = manager.addToNamedAtlas('characters', 'hero', createMockImage(64, 64))\n\nexpect(region1).toBe(region2)"
              },
              {
                "title": "creates separate atlases for different named groups",
                "line": 262,
                "source": "manager.addToNamedAtlas('characters', 'hero', createMockImage(200, 200))\nmanager.addToNamedAtlas('items', 'sword', createMockImage(200, 200))\n\nexpect(manager.atlasCount).toBe(2)"
              },
              {
                "title": "reuses named atlas when space available",
                "line": 270,
                "source": "manager.addToNamedAtlas('characters', 'hero', createMockImage(32, 32))\nmanager.addToNamedAtlas('characters', 'villain', createMockImage(32, 32))\n\nexpect(manager.atlasCount).toBe(1)"
              },
              {
                "title": "returns null for invalid image",
                "line": 278,
                "source": "expect(manager.addToNamedAtlas('test', 'invalid', null)).toBeNull()"
              },
              {
                "title": "handles oversized images as standalone regions",
                "line": 283,
                "source": "const oversized = createMockImage(500, 500)\nconst region = manager.addToNamedAtlas('test', 'oversized', oversized)\n\nexpect(region).not.toBeNull()\nexpect(region.image).toBe(oversized)\nexpect(manager.atlasCount).toBe(0)"
              },
              {
                "title": "region is retrievable by id",
                "line": 293,
                "source": "manager.addToNamedAtlas('characters', 'hero', createMockImage(32, 32))\n\nexpect(manager.has('hero')).toBe(true)\nexpect(manager.get('hero')).not.toBeNull()"
              }
            ],
            "describes": []
          },
          {
            "title": "addBatchToNamedAtlas",
            "line": 303,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "adds multiple images to named atlas",
                "line": 305,
                "source": "const images = {\n    hero: createMockImage(32, 32),\n    villain: createMockImage(48, 48),\n    npc: createMockImage(24, 24)\n}\n\nconst results = manager.addBatchToNamedAtlas('characters', images)\n\nexpect(results.size).toBe(3)\nexpect(manager.regionCount).toBe(3)"
              },
              {
                "title": "returns map of regions",
                "line": 319,
                "source": "const images = {\n    hero: createMockImage(32, 32),\n    villain: createMockImage(48, 48)\n}\n\nconst results = manager.addBatchToNamedAtlas('characters', images)\n\nexpect(results.get('hero')).not.toBeNull()\nexpect(results.get('villain')).not.toBeNull()"
              },
              {
                "title": "all images go to same named atlas group",
                "line": 332,
                "source": "const images = {\n    s1: createMockImage(32, 32),\n    s2: createMockImage(32, 32),\n    s3: createMockImage(32, 32)\n}\n\nmanager.addBatchToNamedAtlas('sprites', images)\n\nexpect(manager.atlasCount).toBe(1)"
              },
              {
                "title": "creates new atlas in group when full",
                "line": 345,
                "source": "const images = {\n    large1: createMockImage(200, 200),\n    large2: createMockImage(200, 200)\n}\n\nmanager.addBatchToNamedAtlas('large', images)\n\nexpect(manager.atlasCount).toBe(2)"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/render/textures/texture_region.doc.js": {
    "file": "/render/textures/texture_region.test.js",
    "describes": [
      {
        "title": "TextureRegion",
        "line": 10,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "bounds returns bounds object",
            "line": 115,
            "source": "const image = createMockImage(256, 256)\nconst region = new TextureRegion({\n    image,\n    x: 10,\n    y: 20,\n    width: 30,\n    height: 40\n})\n\nconst bounds = region.bounds\n\nexpect(bounds.x).toBe(10)\nexpect(bounds.y).toBe(20)\nexpect(bounds.width).toBe(30)\nexpect(bounds.height).toBe(40)"
          }
        ],
        "describes": [
          {
            "title": "constructor",
            "line": 12,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "default values",
                "line": 14,
                "source": "const region = new TextureRegion()\n\nexpect(region.image).toBe(null)\nexpect(region.x).toBe(0)\nexpect(region.y).toBe(0)\nexpect(region.width).toBe(0)\nexpect(region.height).toBe(0)"
              },
              {
                "title": "derives dimensions from image",
                "line": 25,
                "source": "const image = createMockImage(128, 64)\nconst region = new TextureRegion({image})\n\nexpect(region.image).toBe(image)\nexpect(region.width).toBe(128)\nexpect(region.height).toBe(64)"
              },
              {
                "title": "accepts explicit dimensions",
                "line": 35,
                "source": "const image = createMockImage(256, 256)\nconst region = new TextureRegion({\n    image,\n    x: 32,\n    y: 64,\n    width: 48,\n    height: 32\n})\n\nexpect(region.x).toBe(32)\nexpect(region.y).toBe(64)\nexpect(region.width).toBe(48)\nexpect(region.height).toBe(32)"
              }
            ],
            "describes": []
          },
          {
            "title": "UV coordinates",
            "line": 54,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "full image UVs",
                "line": 56,
                "source": "const image = createMockImage(256, 256)\nconst region = new TextureRegion({image})\n\nexpect(region.u0).toBe(0)\nexpect(region.v0).toBe(0)\nexpect(region.u1).toBe(1)\nexpect(region.v1).toBe(1)"
              },
              {
                "title": "sub-region UVs",
                "line": 67,
                "source": "const image = createMockImage(256, 256)\nconst region = new TextureRegion({\n    image,\n    x: 64,\n    y: 128,\n    width: 64,\n    height: 64\n})\n\nexpect(region.u0).toBe(0.25)\nexpect(region.v0).toBe(0.5)\nexpect(region.u1).toBe(0.5)\nexpect(region.v1).toBe(0.75)"
              },
              {
                "title": "default UVs when no image",
                "line": 84,
                "source": "const region = new TextureRegion()\n\nexpect(region.u0).toBe(0)\nexpect(region.v0).toBe(0)\nexpect(region.u1).toBe(1)\nexpect(region.v1).toBe(1)"
              },
              {
                "title": "uvs getter",
                "line": 94,
                "source": "const image = createMockImage(100, 100)\nconst region = new TextureRegion({\n    image,\n    x: 10,\n    y: 20,\n    width: 30,\n    height: 40\n})\n\nconst uvs = region.uvs\n\nexpect(uvs.u0).toBe(0.1)\nexpect(uvs.v0).toBe(0.2)\nexpect(uvs.u1).toBe(0.4)\nexpect(uvs.v1).toBe(0.6)"
              }
            ],
            "describes": []
          },
          {
            "title": "valid",
            "line": 134,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "invalid without image",
                "line": 136,
                "source": "const region = new TextureRegion({width: 10, height: 10})\nexpect(region.valid).toBe(false)"
              },
              {
                "title": "invalid with zero dimensions",
                "line": 142,
                "source": "const image = createMockImage()\nconst region = new TextureRegion({image, width: 0, height: 10})\nexpect(region.valid).toBe(false)"
              },
              {
                "title": "valid with image and dimensions",
                "line": 149,
                "source": "const image = createMockImage()\nconst region = new TextureRegion({image, width: 10, height: 10})\nexpect(region.valid).toBe(true)"
              }
            ],
            "describes": []
          },
          {
            "title": "fromImage",
            "line": 158,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates region covering full image",
                "line": 160,
                "source": "const image = createMockImage(200, 100)\nconst region = TextureRegion.fromImage(image)\n\nexpect(region.image).toBe(image)\nexpect(region.x).toBe(0)\nexpect(region.y).toBe(0)\nexpect(region.width).toBe(200)\nexpect(region.height).toBe(100)"
              },
              {
                "title": "handles null image",
                "line": 172,
                "source": "const region = TextureRegion.fromImage(null)\n\nexpect(region.image).toBe(null)\nexpect(region.width).toBe(0)\nexpect(region.height).toBe(0)"
              }
            ],
            "describes": []
          },
          {
            "title": "fromFrame",
            "line": 183,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates region from frame with w/h",
                "line": 185,
                "source": "const image = createMockImage(512, 512)\nconst frame = {x: 100, y: 200, w: 50, h: 60}\nconst region = TextureRegion.fromFrame(image, frame)\n\nexpect(region.image).toBe(image)\nexpect(region.x).toBe(100)\nexpect(region.y).toBe(200)\nexpect(region.width).toBe(50)\nexpect(region.height).toBe(60)"
              },
              {
                "title": "creates region from frame with width/height",
                "line": 198,
                "source": "const image = createMockImage(512, 512)\nconst frame = {x: 10, y: 20, width: 30, height: 40}\nconst region = TextureRegion.fromFrame(image, frame)\n\nexpect(region.width).toBe(30)\nexpect(region.height).toBe(40)"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/render/textures/texture_system.doc.js": {
    "file": "/render/textures/texture_system.test.js",
    "describes": [
      {
        "title": "TextureSystem",
        "line": 43,
        "beforeEach": {
          "line": 47,
          "source": "system = new TextureSystem({atlasSize: 256})"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor initializes with atlas manager",
            "line": 52,
            "source": "expect(system.atlasManager).toBeDefined()\nexpect(system.regionCount).toBe(0)"
          },
          {
            "title": "addRegions adds multiple images",
            "line": 80,
            "source": "const images = {\n    s1: createMockImage(32, 32),\n    s2: createMockImage(48, 48)\n}\n\nsystem.addRegions(images)\n\nexpect(system.regionCount).toBe(2)"
          },
          {
            "title": "atlases returns list of atlases",
            "line": 268,
            "source": "system.addRegion('s1', createMockImage(32, 32))\n\nexpect(system.atlases.length).toBe(1)"
          },
          {
            "title": "clear removes all regions",
            "line": 294,
            "source": "system.addRegion('s1', createMockImage(32, 32))\nsystem.registerManualAtlas('atlas', createMockImage(256, 256), {\n    frame1: {x: 0, y: 0, w: 32, h: 32}\n})\n\nsystem.clear()\n\nexpect(system.regionCount).toBe(0)\nexpect(system.hasRegion('s1')).toBe(false)\nexpect(system.hasRegion('atlas:frame1')).toBe(false)"
          },
          {
            "title": "onInstall delegates methods to host",
            "line": 308,
            "source": "const host = {}\nsystem.onInstall(host)\n\nexpect(host.getRegion).toBeDefined()\nexpect(host.hasRegion).toBeDefined()\nexpect(host.addRegion).toBeDefined()"
          },
          {
            "title": "onDispose clears all regions",
            "line": 318,
            "source": "system.addRegion('s1', createMockImage(32, 32))\nsystem.registerManualAtlas('atlas', createMockImage(256, 256), {\n    frame1: {x: 0, y: 0, w: 32, h: 32}\n})\n\nsystem.onDispose()\n\nexpect(system.regionCount).toBe(0)\nexpect(system.hasRegion('s1')).toBe(false)\nexpect(system.hasRegion('atlas:frame1')).toBe(false)"
          }
        ],
        "describes": [
          {
            "title": "addRegion",
            "line": 58,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "adds image to atlas",
                "line": 60,
                "source": "const image = createMockImage(32, 32)\nconst region = system.addRegion('sprite1', image)\n\nexpect(region).not.toBeNull()\nexpect(region.width).toBe(32)"
              },
              {
                "title": "returns existing region for duplicate",
                "line": 69,
                "source": "const image = createMockImage(32, 32)\nconst region1 = system.addRegion('sprite1', image)\nconst region2 = system.addRegion('sprite1', createMockImage(64, 64))\n\nexpect(region1).toBe(region2)"
              }
            ],
            "describes": []
          },
          {
            "title": "getRegion",
            "line": 92,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns region by id",
                "line": 94,
                "source": "system.addRegion('sprite1', createMockImage(32, 32))\nconst region = system.getRegion('sprite1')\n\nexpect(region).not.toBeNull()"
              },
              {
                "title": "returns null for unknown",
                "line": 102,
                "source": "expect(system.getRegion('unknown')).toBeNull()"
              }
            ],
            "describes": []
          },
          {
            "title": "hasRegion",
            "line": 109,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns true for existing",
                "line": 111,
                "source": "system.addRegion('sprite1', createMockImage(32, 32))\nexpect(system.hasRegion('sprite1')).toBe(true)"
              },
              {
                "title": "returns false for unknown",
                "line": 117,
                "source": "expect(system.hasRegion('unknown')).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "registerManualAtlas",
            "line": 124,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "registers frames from manual atlas",
                "line": 126,
                "source": "const atlasImage = createMockImage(256, 256)\nconst frames = {\n    idle: {x: 0, y: 0, w: 32, h: 32},\n    walk: {x: 32, y: 0, w: 32, h: 32}\n}\n\nsystem.registerManualAtlas('player', atlasImage, frames)\n\nexpect(system.hasRegion('player:idle')).toBe(true)\nexpect(system.hasRegion('player:walk')).toBe(true)"
              },
              {
                "title": "creates correct regions from frames",
                "line": 140,
                "source": "const atlasImage = createMockImage(256, 256)\nconst frames = {\n    frame1: {x: 64, y: 128, w: 32, h: 48}\n}\n\nsystem.registerManualAtlas('atlas', atlasImage, frames)\n\nconst region = system.getRegion('atlas:frame1')\n\nexpect(region.x).toBe(64)\nexpect(region.y).toBe(128)\nexpect(region.width).toBe(32)\nexpect(region.height).toBe(48)"
              }
            ],
            "describes": []
          },
          {
            "title": "buildFromAssets",
            "line": 159,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "builds atlas from image assets",
                "line": 161,
                "source": "const assets = [\n    {id: 'img1', type: 'image', source: createMockImage(32, 32)},\n    {id: 'img2', type: 'image', source: createMockImage(48, 48)},\n    {id: 'sound1', type: 'audio', source: {}}\n]\n\nsystem.buildFromAssets(assets)\n\nexpect(system.hasRegion('img1')).toBe(true)\nexpect(system.hasRegion('img2')).toBe(true)\nexpect(system.hasRegion('sound1')).toBe(false)"
              },
              {
                "title": "skips assets without source",
                "line": 176,
                "source": "const assets = [\n    {id: 'img1', type: 'image', source: null}\n]\n\nsystem.buildFromAssets(assets)\n\nexpect(system.hasRegion('img1')).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "addFromAsset",
            "line": 189,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "adds image asset to atlas",
                "line": 191,
                "source": "const asset = {\n    id: 'sprite1',\n    type: 'image',\n    source: createMockImage(32, 32)\n}\n\nconst region = system.addFromAsset(asset)\n\nexpect(region).not.toBeNull()\nexpect(region.width).toBe(32)\nexpect(system.hasRegion('sprite1')).toBe(true)"
              },
              {
                "title": "returns null for non-image asset",
                "line": 206,
                "source": "const asset = {\n    id: 'sound1',\n    type: 'audio',\n    source: {}\n}\n\nconst region = system.addFromAsset(asset)\n\nexpect(region).toBeNull()"
              },
              {
                "title": "returns null for asset without source",
                "line": 219,
                "source": "const asset = {\n    id: 'no-source',\n    type: 'image',\n    source: null\n}\n\nconst region = system.addFromAsset(asset)\n\nexpect(region).toBeNull()"
              },
              {
                "title": "returns existing region for duplicate asset",
                "line": 232,
                "source": "const asset = {\n    id: 'sprite1',\n    type: 'image',\n    source: createMockImage(32, 32)\n}\n\nconst region1 = system.addFromAsset(asset)\nconst region2 = system.addFromAsset({\n    id: 'sprite1',\n    type: 'image',\n    source: createMockImage(64, 64)\n})\n\nexpect(region1).toBe(region2)"
              },
              {
                "title": "stores as manual region when atlas config is false",
                "line": 250,
                "source": "const asset = {\n    id: 'standalone',\n    type: 'image',\n    source: createMockImage(32, 32),\n    config: {atlas: false}\n}\n\nconst region = system.addFromAsset(asset)\n\nexpect(region).not.toBeNull()\nexpect(system.hasRegion('standalone')).toBe(true)\nexpect(region.image).toBe(asset.source)"
              }
            ],
            "describes": []
          },
          {
            "title": "getDirtyAtlases",
            "line": 275,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns dirty atlases",
                "line": 277,
                "source": "system.addRegion('s1', createMockImage(32, 32))\n\nexpect(system.getDirtyAtlases().length).toBe(1)"
              },
              {
                "title": "empty after markAllClean",
                "line": 284,
                "source": "system.addRegion('s1', createMockImage(32, 32))\nsystem.markAllClean()\n\nexpect(system.getDirtyAtlases().length).toBe(0)"
              }
            ],
            "describes": []
          },
          {
            "title": "spritesheets",
            "line": 332,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "registerSpritesheet registers a spritesheet and returns it",
                "line": 334,
                "source": "const source = {\n    image: createMockImage(256, 256),\n    data: {\n        frames: [\n            {filename: 'frame1', frame: {x: 0, y: 0, w: 32, h: 32}}\n        ],\n        animations: {},\n        meta: {}\n    }\n}\n\nconst spritesheet = system.registerSpritesheet('player', source)\n\nexpect(spritesheet).not.toBeNull()\nexpect(spritesheet.getFrame('frame1')).not.toBeNull()"
              },
              {
                "title": "getSpritesheet retrieves registered spritesheet",
                "line": 353,
                "source": "const source = {\n    image: createMockImage(256, 256),\n    data: {\n        frames: [],\n        animations: {},\n        meta: {}\n    }\n}\n\nsystem.registerSpritesheet('player', source)\nconst spritesheet = system.getSpritesheet('player')\n\nexpect(spritesheet).not.toBeNull()"
              },
              {
                "title": "getSpritesheet returns null for non-existent spritesheet",
                "line": 370,
                "source": "expect(system.getSpritesheet('non-existent')).toBeNull()"
              },
              {
                "title": "clear also clears spritesheets",
                "line": 375,
                "source": "const source = {\n    image: createMockImage(256, 256),\n    data: {frames: [], animations: {}, meta: {}}\n}\n\nsystem.registerSpritesheet('player', source)\nsystem.clear()\n\nexpect(system.getSpritesheet('player')).toBeNull()"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/render/transforms/shadow_transform.doc.js": {
    "file": "/render/transforms/shadow_transform.test.js",
    "describes": [
      {
        "title": "ShadowTransform",
        "line": 6,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "extends RenderTransform",
            "line": 8,
            "source": "const transform = new ShadowTransform()\nexpect(transform instanceof RenderTransform).toBe(true)"
          },
          {
            "title": "constructor accepts options",
            "line": 14,
            "source": "const transform = new ShadowTransform({\n    skewX: 1.0,\n    scaleY: 0.3,\n    offsetY: 10,\n    color: [0.1, 0.2, 0.3, 0.5]\n})\nexpect(transform.skewX).toBe(1.0)\nexpect(transform.scaleY).toBe(0.3)\nexpect(transform.offsetY).toBe(10)\nexpect(transform.color).toEqual([0.1, 0.2, 0.3, 0.5])"
          },
          {
            "title": "constructor inherits enabled option",
            "line": 28,
            "source": "const transform = new ShadowTransform({enabled: false})\nexpect(transform.enabled).toBe(false)"
          },
          {
            "title": "init registers shadow shader",
            "line": 34,
            "source": "const transform = new ShadowTransform()\nconst mockProgram = {uniforms: {}}\nconst mockContext = {\n    shaderRegistry: {\n        register: vi.fn(() => mockProgram)\n    }\n}\n\ntransform.init(mockContext)\n\nexpect(mockContext.shaderRegistry.register).toHaveBeenCalledWith(\n    'shadow',\n    expect.objectContaining({\n        vertex: expect.any(String),\n        fragment: expect.any(String)\n    })\n)"
          },
          {
            "title": "getProgram returns program after init",
            "line": 55,
            "source": "const transform = new ShadowTransform()\nconst mockProgram = {uniforms: {}}\nconst mockContext = {\n    shaderRegistry: {\n        register: vi.fn(() => mockProgram)\n    }\n}\ntransform.init(mockContext)\n\nexpect(transform.getProgram()).toBe(mockProgram)"
          },
          {
            "title": "applyUniforms sets shadow uniforms",
            "line": 69,
            "source": "const transform = new ShadowTransform({\n    skewX: 0.7,\n    scaleY: 0.4,\n    offsetY: 5,\n    color: [0.2, 0.2, 0.2, 0.6]\n})\nconst mockGL = {\n    uniform1f: vi.fn(),\n    uniform4fv: vi.fn()\n}\nconst mockProgram = {\n    uniforms: {\n        uShadowSkewX: 'skewLoc',\n        uShadowScaleY: 'scaleLoc',\n        uShadowOffsetY: 'offsetLoc',\n        uShadowColor: 'colorLoc'\n    }\n}\n\ntransform.applyUniforms(mockGL, mockProgram)\n\nexpect(mockGL.uniform1f).toHaveBeenCalledWith('skewLoc', 0.7)\nexpect(mockGL.uniform1f).toHaveBeenCalledWith('scaleLoc', 0.4)\nexpect(mockGL.uniform1f).toHaveBeenCalledWith('offsetLoc', 5)\nexpect(mockGL.uniform4fv).toHaveBeenCalledWith('colorLoc', [0.2, 0.2, 0.2, 0.6])"
          },
          {
            "title": "getPropertyConfig",
            "line": 98,
            "source": "const transform = new ShadowTransform()\nconst config = transform.getPropertyConfig()\n\nexpect(config.skewX).toEqual({min: -2, max: 2, step: 0.05})\nexpect(config.scaleY).toEqual({min: -1, max: 0, step: 0.05})\nexpect(config.offsetY).toEqual({min: -0.5, max: 0.5, step: 0.01})\nexpect(config.color).toEqual({type: 'color'})"
          },
          {
            "title": "static propertyConfig",
            "line": 109,
            "source": "expect(ShadowTransform.propertyConfig).toBeDefined()\nexpect(ShadowTransform.propertyConfig.skewX).toBeDefined()"
          },
          {
            "title": "dispose clears program",
            "line": 115,
            "source": "const transform = new ShadowTransform()\nconst mockProgram = {uniforms: {}}\nconst mockContext = {\n    shaderRegistry: {\n        register: vi.fn(() => mockProgram)\n    }\n}\ntransform.init(mockContext)\n\ntransform.dispose()\n\nexpect(transform.getProgram()).toBeNull()"
          }
        ],
        "describes": []
      }
    ]
  },
  "/render/webgl/color_utils.doc.js": {
    "file": "/render/webgl/color_utils.test.js",
    "describes": [
      {
        "title": "parseColor",
        "line": 5,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "parses hex color",
            "line": 7,
            "source": "const result = parseColor('#ff8040')\nexpect(result.r).toBeCloseTo(1)\nexpect(result.g).toBeCloseTo(0.502, 2)\nexpect(result.b).toBeCloseTo(0.251, 2)\nexpect(result.a).toBe(1)"
          },
          {
            "title": "parses black",
            "line": 16,
            "source": "const result = parseColor('#000000')\nexpect(result).toEqual({r: 0, g: 0, b: 0, a: 1})"
          },
          {
            "title": "parses white",
            "line": 22,
            "source": "const result = parseColor('#ffffff')\nexpect(result.r).toBeCloseTo(1)\nexpect(result.g).toBeCloseTo(1)\nexpect(result.b).toBeCloseTo(1)\nexpect(result.a).toBe(1)"
          },
          {
            "title": "returns black for non-hex color",
            "line": 31,
            "source": "const result = parseColor('red')\nexpect(result).toEqual({r: 0, g: 0, b: 0, a: 1})"
          }
        ],
        "describes": []
      }
    ]
  },
  "/render/webgl/webgl_circle_renderer.doc.js": {
    "file": "/render/webgl/webgl_circle_renderer.test.js",
    "describes": [
      {
        "title": "WebGLCircleRenderer",
        "line": 6,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "handles returns Circle",
            "line": 8,
            "source": "expect(WebGLCircleRenderer.handles).toEqual([Circle])"
          },
          {
            "title": "renderObject is defined",
            "line": 13,
            "source": "const renderer = new WebGLCircleRenderer()\nexpect(typeof renderer.renderObject).toBe('function')"
          }
        ],
        "describes": []
      }
    ]
  },
  "/render/webgl/webgl_debug_gizmo_renderer.doc.js": {
    "file": "/render/webgl/webgl_debug_gizmo_renderer.test.js",
    "describes": [
      {
        "title": "WebGLDebugGizmoRenderer",
        "line": 5,
        "beforeEach": {
          "line": 12,
          "source": "renderer = new WebGLDebugGizmoRenderer()\nmockGl = {\n    createBuffer: () => ({}),\n    deleteBuffer: () => {},\n    bindBuffer: () => {},\n    bufferData: () => {},\n    enableVertexAttribArray: () => {},\n    vertexAttribPointer: () => {},\n    drawArrays: () => {},\n    useProgram: () => {},\n    uniformMatrix3fv: () => {},\n    ARRAY_BUFFER: 0x8892,\n    DYNAMIC_DRAW: 0x88E8,\n    FLOAT: 0x1406,\n    LINES: 0x0001,\n    TRIANGLE_FAN: 0x0006\n}\nmockContext = {\n    gl: mockGl,\n    primitiveProgram: {\n        program: {},\n        uniforms: {\n            uProjectionMatrix: 0,\n            uViewMatrix: 1\n        },\n        attributes: {\n            aPosition: 0,\n            aColor: 1\n        }\n    }\n}"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "handles returns empty array",
            "line": 47,
            "source": "expect(WebGLDebugGizmoRenderer.handles).toEqual([])"
          },
          {
            "title": "init creates vertex buffer",
            "line": 52,
            "source": "let bufferCreated = false\nmockGl.createBuffer = () => {\n    bufferCreated = true\n    return {}\n}\nrenderer.init(mockContext)\nexpect(bufferCreated).toBe(true)"
          },
          {
            "title": "collectGizmo adds object",
            "line": 63,
            "source": "renderer.init(mockContext)\nconst obj = {name: 'test'}\nrenderer.collectGizmo(obj, 0.8)\nexpect(() => renderer.flush({projectionMatrix: [], viewMatrix: []})).not.toThrow()"
          },
          {
            "title": "reset clears gizmo objects",
            "line": 71,
            "source": "renderer.init(mockContext)\nrenderer.collectGizmo({}, 1)\nrenderer.reset()\n\nlet useProgramCalled = false\nmockGl.useProgram = () => {\n    useProgramCalled = true\n}\nrenderer.flush({projectionMatrix: [], viewMatrix: []})\n\nexpect(useProgramCalled).toBe(false)"
          },
          {
            "title": "renderBounds draws lines for bounds rectangle",
            "line": 240,
            "source": "renderer.init(mockContext)\nlet drawMode = null\nmockGl.drawArrays = (mode) => {\n    drawMode = mode\n}\n\nconst m = [1, 0, 0, 1, 0, 0]\nconst bounds = {minX: 0, minY: 0, maxX: 10, maxY: 10, width: 10, height: 10}\nrenderer.renderBounds(m, bounds, 1)\n\nexpect(drawMode).toBe(mockGl.LINES)"
          },
          {
            "title": "renderAnchor draws lines and circle for anchor",
            "line": 255,
            "source": "renderer.init(mockContext)\nlet drawCallCount = 0\nmockGl.drawArrays = () => {\n    drawCallCount++\n}\n\nconst m = [1, 0, 0, 1, 0, 0]\nconst obj = {anchorX: 0.5, anchorY: 0.5}\nconst bounds = {minX: 0, minY: 0, width: 10, height: 10}\nrenderer.renderAnchor(m, obj, bounds, 1)\n\nexpect(drawCallCount).toBe(2)"
          },
          {
            "title": "renderPivot draws lines and circle outline for pivot",
            "line": 271,
            "source": "renderer.init(mockContext)\nlet drawCallCount = 0\nmockGl.drawArrays = () => {\n    drawCallCount++\n}\n\nconst m = [1, 0, 0, 1, 0, 0]\nconst obj = {pivotX: 5, pivotY: 5}\nrenderer.renderPivot(m, obj, 1)\n\nexpect(drawCallCount).toBe(2)"
          },
          {
            "title": "renderOrigin draws axis lines and center circle",
            "line": 286,
            "source": "renderer.init(mockContext)\nlet drawCallCount = 0\nmockGl.drawArrays = () => {\n    drawCallCount++\n}\n\nconst m = [1, 0, 0, 1, 0, 0]\nrenderer.renderOrigin(m, 1)\n\nexpect(drawCallCount).toBe(2)"
          },
          {
            "title": "drawCircleOutline draws with LINES mode",
            "line": 381,
            "source": "renderer.init(mockContext)\nlet drawMode = null\nmockGl.drawArrays = (mode) => {\n    drawMode = mode\n}\n\nrenderer.drawCircleOutline({x: 0, y: 0, radius: 1, color: {r: 1, g: 0, b: 0}, opacity: 1, segments: 8})\n\nexpect(drawMode).toBe(mockGl.LINES)"
          }
        ],
        "describes": [
          {
            "title": "flush",
            "line": 86,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "does nothing when no gizmo objects",
                "line": 88,
                "source": "renderer.init(mockContext)\n\nlet useProgramCalled = false\nmockGl.useProgram = () => {\n    useProgramCalled = true\n}\nrenderer.flush({projectionMatrix: [], viewMatrix: []})\n\nexpect(useProgramCalled).toBe(false)"
              },
              {
                "title": "sets up program and matrices",
                "line": 101,
                "source": "renderer.init(mockContext)\nrenderer.collectGizmo({\n    debugGizmos: null,\n    worldMatrix: [1, 0, 0, 1, 0, 0],\n    getBounds: () => ({minX: 0, minY: 0, width: 0, height: 0})\n}, 1)\n\nlet useProgramCalled = false\nlet projectionSet = false\nlet viewSet = false\n\nmockGl.useProgram = () => {\n    useProgramCalled = true\n}\nmockGl.uniformMatrix3fv = (loc) => {\n    if (loc === 0) {\n        projectionSet = true\n    }\n    if (loc === 1) {\n        viewSet = true\n    }\n}\n\nrenderer.flush({projectionMatrix: [], viewMatrix: []})\n\nexpect(useProgramCalled).toBe(true)\nexpect(projectionSet).toBe(true)\nexpect(viewSet).toBe(true)"
              }
            ],
            "describes": []
          },
          {
            "title": "renderGizmos",
            "line": 135,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns early if debugGizmos is null",
                "line": 137,
                "source": "renderer.init(mockContext)\nconst obj = {debugGizmos: null, getBounds: () => ({})}\nexpect(() => renderer.renderGizmos(obj, 1)).not.toThrow()"
              },
              {
                "title": "does not render bounds when size is zero",
                "line": 144,
                "source": "renderer.init(mockContext)\nlet drawCalled = false\nmockGl.drawArrays = () => {\n    drawCalled = true\n}\n\nconst obj = {\n    debugGizmos: {bounds: true},\n    worldMatrix: [1, 0, 0, 1, 0, 0],\n    getBounds: () => ({minX: 0, minY: 0, maxX: 0, maxY: 0, width: 0, height: 0})\n}\nrenderer.renderGizmos(obj, 1)\n\nexpect(drawCalled).toBe(false)"
              },
              {
                "title": "renders bounds when size is non-zero",
                "line": 162,
                "source": "renderer.init(mockContext)\nlet drawCalled = false\nmockGl.drawArrays = () => {\n    drawCalled = true\n}\n\nconst obj = {\n    debugGizmos: {bounds: true},\n    worldMatrix: [1, 0, 0, 1, 0, 0],\n    getBounds: () => ({minX: 0, minY: 0, maxX: 10, maxY: 10, width: 10, height: 10})\n}\nrenderer.renderGizmos(obj, 1)\n\nexpect(drawCalled).toBe(true)"
              },
              {
                "title": "renders anchor when enabled",
                "line": 180,
                "source": "renderer.init(mockContext)\nlet drawCallCount = 0\nmockGl.drawArrays = () => {\n    drawCallCount++\n}\n\nconst obj = {\n    debugGizmos: {anchor: true},\n    worldMatrix: [1, 0, 0, 1, 0, 0],\n    anchorX: 0.5,\n    anchorY: 0.5,\n    getBounds: () => ({minX: 0, minY: 0, maxX: 10, maxY: 10, width: 10, height: 10})\n}\nrenderer.renderGizmos(obj, 1)\n\nexpect(drawCallCount).toBeGreaterThan(0)"
              },
              {
                "title": "renders pivot when enabled",
                "line": 200,
                "source": "renderer.init(mockContext)\nlet drawCallCount = 0\nmockGl.drawArrays = () => {\n    drawCallCount++\n}\n\nconst obj = {\n    debugGizmos: {pivot: true},\n    worldMatrix: [1, 0, 0, 1, 0, 0],\n    pivotX: 5,\n    pivotY: 5,\n    getBounds: () => ({minX: 0, minY: 0, maxX: 10, maxY: 10, width: 10, height: 10})\n}\nrenderer.renderGizmos(obj, 1)\n\nexpect(drawCallCount).toBeGreaterThan(0)"
              },
              {
                "title": "renders origin when enabled",
                "line": 220,
                "source": "renderer.init(mockContext)\nlet drawCallCount = 0\nmockGl.drawArrays = () => {\n    drawCallCount++\n}\n\nconst obj = {\n    debugGizmos: {origin: true},\n    worldMatrix: [1, 0, 0, 1, 0, 0],\n    getBounds: () => ({minX: 0, minY: 0, maxX: 10, maxY: 10, width: 10, height: 10})\n}\nrenderer.renderGizmos(obj, 1)\n\nexpect(drawCallCount).toBeGreaterThan(0)"
              }
            ],
            "describes": []
          },
          {
            "title": "drawLines",
            "line": 300,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "binds buffer and uploads vertex data",
                "line": 302,
                "source": "renderer.init(mockContext)\nlet bufferBound = false\nlet dataUploaded = false\nmockGl.bindBuffer = () => {\n    bufferBound = true\n}\nmockGl.bufferData = () => {\n    dataUploaded = true\n}\n\nconst vertices = [0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1]\nrenderer.drawLines(vertices)\n\nexpect(bufferBound).toBe(true)\nexpect(dataUploaded).toBe(true)"
              },
              {
                "title": "sets up vertex attributes",
                "line": 321,
                "source": "renderer.init(mockContext)\nlet attribsEnabled = 0\nmockGl.enableVertexAttribArray = () => {\n    attribsEnabled++\n}\n\nconst vertices = [0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1]\nrenderer.drawLines(vertices)\n\nexpect(attribsEnabled).toBe(2)"
              },
              {
                "title": "draws with LINES mode",
                "line": 335,
                "source": "renderer.init(mockContext)\nlet drawMode = null\nmockGl.drawArrays = (mode) => {\n    drawMode = mode\n}\n\nconst vertices = [0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1]\nrenderer.drawLines(vertices)\n\nexpect(drawMode).toBe(mockGl.LINES)"
              }
            ],
            "describes": []
          },
          {
            "title": "drawCircle",
            "line": 351,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "draws with TRIANGLE_FAN mode",
                "line": 353,
                "source": "renderer.init(mockContext)\nlet drawMode = null\nmockGl.drawArrays = (mode) => {\n    drawMode = mode\n}\n\nrenderer.drawCircle({x: 0, y: 0, radius: 1, color: {r: 1, g: 0, b: 0}, opacity: 1, segments: 8})\n\nexpect(drawMode).toBe(mockGl.TRIANGLE_FAN)"
              },
              {
                "title": "creates correct number of vertices",
                "line": 366,
                "source": "renderer.init(mockContext)\nlet vertexCount = 0\nmockGl.drawArrays = (mode, offset, count) => {\n    vertexCount = count\n}\n\nrenderer.drawCircle({x: 0, y: 0, radius: 1, color: {r: 1, g: 0, b: 0}, opacity: 1, segments: 8})\n\nexpect(vertexCount).toBe(10)"
              }
            ],
            "describes": []
          },
          {
            "title": "dispose",
            "line": 394,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "deletes vertex buffer",
                "line": 396,
                "source": "renderer.init(mockContext)\nlet bufferDeleted = false\nmockGl.deleteBuffer = () => {\n    bufferDeleted = true\n}\nrenderer.dispose()\nexpect(bufferDeleted).toBe(true)"
              },
              {
                "title": "clears gizmo objects",
                "line": 407,
                "source": "renderer.init(mockContext)\nrenderer.collectGizmo({}, 1)\nrenderer.dispose()\n\nrenderer.init(mockContext)\nlet useProgramCalled = false\nmockGl.useProgram = () => {\n    useProgramCalled = true\n}\nrenderer.flush({projectionMatrix: [], viewMatrix: []})\n\nexpect(useProgramCalled).toBe(false)"
              },
              {
                "title": "clears context reference",
                "line": 423,
                "source": "renderer.init(mockContext)\nrenderer.dispose()\nexpect(renderer.context).toBeNull()"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/render/webgl/webgl_object_renderer.doc.js": {
    "file": "/render/webgl/webgl_object_renderer.test.js",
    "describes": [
      {
        "title": "WebGLObjectRenderer",
        "line": 5,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "handles returns empty array",
            "line": 7,
            "source": "expect(WebGLObjectRenderer.handles).toEqual([])"
          },
          {
            "title": "gl returns null before init",
            "line": 12,
            "source": "const renderer = new WebGLObjectRenderer()\nexpect(renderer.gl).toBeNull()"
          },
          {
            "title": "context returns null before init",
            "line": 18,
            "source": "const renderer = new WebGLObjectRenderer()\nexpect(renderer.context).toBeNull()"
          },
          {
            "title": "init sets gl and context",
            "line": 24,
            "source": "const renderer = new WebGLObjectRenderer()\nconst mockGl = {}\nconst mockContext = {gl: mockGl}\nrenderer.init(mockContext)\nexpect(renderer.gl).toBe(mockGl)\nexpect(renderer.context).toBe(mockContext)"
          },
          {
            "title": "collected returns empty array initially",
            "line": 34,
            "source": "const renderer = new WebGLObjectRenderer()\nexpect(renderer.collected).toEqual([])"
          },
          {
            "title": "collect adds object to collected",
            "line": 40,
            "source": "const renderer = new WebGLObjectRenderer()\nconst obj = {name: 'test'}\nrenderer.collect(obj, 1)\nexpect(renderer.collected).toEqual([{object: obj, opacity: 1, hints: null}])"
          },
          {
            "title": "collect with hints",
            "line": 48,
            "source": "const renderer = new WebGLObjectRenderer()\nconst obj = {name: 'test'}\nconst hints = {key: 'value'}\nrenderer.collect(obj, 0.5, hints)\nexpect(renderer.collected).toEqual([{object: obj, opacity: 0.5, hints}])"
          },
          {
            "title": "reset clears collected",
            "line": 57,
            "source": "const renderer = new WebGLObjectRenderer()\nrenderer.collect({}, 1)\nrenderer.reset()\nexpect(renderer.collected).toEqual([])"
          },
          {
            "title": "flush does not throw",
            "line": 65,
            "source": "const renderer = new WebGLObjectRenderer()\nexpect(() => renderer.flush({}, null)).not.toThrow()"
          },
          {
            "title": "dispose clears state",
            "line": 71,
            "source": "const renderer = new WebGLObjectRenderer()\nconst mockContext = {gl: {}}\nrenderer.init(mockContext)\nrenderer.collect({}, 1)\nrenderer.dispose()\nexpect(renderer.gl).toBeNull()\nexpect(renderer.context).toBeNull()\nexpect(renderer.collected).toEqual([])"
          }
        ],
        "describes": []
      }
    ]
  },
  "/render/webgl/webgl_primitive_renderer.doc.js": {
    "file": "/render/webgl/webgl_primitive_renderer.test.js",
    "describes": [
      {
        "title": "WebGLPrimitiveRenderer",
        "line": 5,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "vertexBuffer returns null before init",
            "line": 7,
            "source": "const renderer = new WebGLPrimitiveRenderer()\nexpect(renderer.vertexBuffer).toBeNull()"
          },
          {
            "title": "init creates vertex buffer",
            "line": 13,
            "source": "const renderer = new WebGLPrimitiveRenderer()\nconst mockBuffer = {}\nconst mockGl = {createBuffer: vi.fn(() => mockBuffer)}\nconst mockContext = {gl: mockGl}\nrenderer.init(mockContext)\nexpect(mockGl.createBuffer).toHaveBeenCalled()\nexpect(renderer.vertexBuffer).toBe(mockBuffer)"
          },
          {
            "title": "flush does nothing when collected is empty",
            "line": 24,
            "source": "const renderer = new WebGLPrimitiveRenderer()\nconst mockGl = {\n    createBuffer: vi.fn(() => ({})),\n    useProgram: vi.fn()\n}\nconst mockContext = {gl: mockGl}\nrenderer.init(mockContext)\nrenderer.flush({})\nexpect(mockGl.useProgram).not.toHaveBeenCalled()"
          },
          {
            "title": "renderObject is defined",
            "line": 37,
            "source": "const renderer = new WebGLPrimitiveRenderer()\nexpect(typeof renderer.renderObject).toBe('function')"
          },
          {
            "title": "dispose deletes vertex buffer",
            "line": 43,
            "source": "const renderer = new WebGLPrimitiveRenderer()\nconst mockBuffer = {}\nconst mockGl = {\n    createBuffer: vi.fn(() => mockBuffer),\n    deleteBuffer: vi.fn()\n}\nconst mockContext = {gl: mockGl}\nrenderer.init(mockContext)\nrenderer.dispose()\nexpect(mockGl.deleteBuffer).toHaveBeenCalledWith(mockBuffer)\nexpect(renderer.vertexBuffer).toBeNull()"
          }
        ],
        "describes": []
      }
    ]
  },
  "/render/webgl/webgl_rectangle_renderer.doc.js": {
    "file": "/render/webgl/webgl_rectangle_renderer.test.js",
    "describes": [
      {
        "title": "WebGLRectangleRenderer",
        "line": 6,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "handles returns Rectangle",
            "line": 8,
            "source": "expect(WebGLRectangleRenderer.handles).toEqual([Rectangle])"
          },
          {
            "title": "renderObject is defined",
            "line": 13,
            "source": "const renderer = new WebGLRectangleRenderer()\nexpect(typeof renderer.renderObject).toBe('function')"
          }
        ],
        "describes": []
      }
    ]
  },
  "/render/webgl/webgl_sprite_batch.doc.js": {
    "file": "/render/webgl/webgl_sprite_batch.test.js",
    "describes": [
      {
        "title": "WebGLSpriteBatch",
        "line": 7,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "constructor creates buffers",
            "line": 9,
            "source": "const gl = createMockGLWithSpies()\nconst batch = new WebGLSpriteBatch(gl, {}, {})\nexpect(gl.createBuffer).toHaveBeenCalledTimes(2)\nexpect(batch.vertexBuffer).toBeDefined()\nexpect(batch.indexBuffer).toBeDefined()"
          },
          {
            "title": "constructor uses default maxSprites",
            "line": 18,
            "source": "const gl = createMockGLWithSpies()\nconst batch = new WebGLSpriteBatch(gl, {}, {})\nexpect(batch.maxSprites).toBe(1000)"
          },
          {
            "title": "constructor accepts custom maxSprites",
            "line": 25,
            "source": "const gl = createMockGLWithSpies()\nconst batch = new WebGLSpriteBatch(gl, {}, {}, {maxSprites: 500})\nexpect(batch.maxSprites).toBe(500)"
          },
          {
            "title": "begin resets state",
            "line": 32,
            "source": "const gl = createMockGLWithSpies()\nconst batch = new WebGLSpriteBatch(gl, {}, {})\nbatch.spriteCount = 10\nbatch.vertexIndex = 100\nbatch.currentTexture = {}\nbatch.begin()\nexpect(batch.spriteCount).toBe(0)\nexpect(batch.vertexIndex).toBe(0)\nexpect(batch.currentTexture).toBeNull()"
          },
          {
            "title": "begin sets active program",
            "line": 45,
            "source": "const gl = createMockGLWithSpies()\nconst batch = new WebGLSpriteBatch(gl, {}, {})\nconst program = {}\nbatch.begin(program)\nexpect(batch.activeProgram).toBe(program)"
          },
          {
            "title": "flush does nothing when spriteCount is 0",
            "line": 54,
            "source": "const gl = createMockGLWithSpies()\ngl.useProgram = vi.fn()\nconst batch = new WebGLSpriteBatch(gl, {}, {})\nbatch.flush()\nexpect(gl.useProgram).not.toHaveBeenCalled()"
          },
          {
            "title": "end calls flush",
            "line": 63,
            "source": "const gl = createMockGLWithSpies()\nconst batch = new WebGLSpriteBatch(gl, {}, {})\nbatch.flush = vi.fn()\nbatch.end()\nexpect(batch.flush).toHaveBeenCalled()"
          },
          {
            "title": "end passes alternate program to flush",
            "line": 72,
            "source": "const gl = createMockGLWithSpies()\nconst batch = new WebGLSpriteBatch(gl, {}, {})\nbatch.flush = vi.fn()\nconst program = {}\nbatch.end(program)\nexpect(batch.flush).toHaveBeenCalledWith(program)"
          },
          {
            "title": "dispose deletes buffers",
            "line": 82,
            "source": "const gl = createMockGLWithSpies()\ngl.deleteBuffer = vi.fn()\nconst batch = new WebGLSpriteBatch(gl, {}, {})\nbatch.dispose()\nexpect(gl.deleteBuffer).toHaveBeenCalledTimes(2)"
          },
          {
            "title": "addSprite does nothing when image is not ready",
            "line": 91,
            "source": "const gl = createMockGLWithSpies()\nconst textureManager = {getTexture: vi.fn(() => null)}\nconst batch = new WebGLSpriteBatch(gl, {}, textureManager)\n\nconst sprite = {\n    image: {complete: false, naturalWidth: 0},\n    getBounds: () => ({minX: 0, minY: 0, maxX: 10, maxY: 10, width: 10, height: 10}),\n    worldMatrix: [1, 0, 0, 1, 0, 0],\n    anchorX: 0.5,\n    anchorY: 0.5\n}\n\nbatch.begin()\nbatch.addSprite(sprite, 1.0)\n\nexpect(batch.spriteCount).toBe(0)"
          },
          {
            "title": "addSprite increments spriteCount for valid sprites",
            "line": 111,
            "source": "const gl = createMockGLWithSpies()\nconst mockTexture = {}\nconst textureManager = {getTexture: vi.fn(() => mockTexture)}\nconst batch = new WebGLSpriteBatch(gl, {}, textureManager)\n\nconst mockImage = {complete: true, naturalWidth: 100, width: 100, height: 100}\nconst sprite = new Sprite({image: mockImage})\nsprite.updateWorldMatrix()\n\nbatch.begin()\nbatch.addSprite(sprite, 1.0)\n\nexpect(batch.spriteCount).toBe(1)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/render/webgl/webgl_sprite_renderer.doc.js": {
    "file": "/render/webgl/webgl_sprite_renderer.test.js",
    "describes": [
      {
        "title": "WebGLSpriteRenderer",
        "line": 6,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "handles returns Sprite",
            "line": 8,
            "source": "expect(WebGLSpriteRenderer.handles).toEqual([Sprite])"
          },
          {
            "title": "init creates sprite batch",
            "line": 13,
            "source": "const renderer = new WebGLSpriteRenderer()\nconst mockGl = {\n    createBuffer: vi.fn(() => ({})),\n    bindBuffer: vi.fn(),\n    bufferData: vi.fn(),\n    ARRAY_BUFFER: 'ARRAY_BUFFER',\n    ELEMENT_ARRAY_BUFFER: 'ELEMENT_ARRAY_BUFFER',\n    STATIC_DRAW: 'STATIC_DRAW'\n}\nconst mockContext = {\n    gl: mockGl,\n    spriteProgram: {},\n    textureManager: {}\n}\nrenderer.init(mockContext)\nexpect(renderer.context).toBe(mockContext)"
          },
          {
            "title": "reset calls begin on sprite batch",
            "line": 33,
            "source": "const renderer = new WebGLSpriteRenderer()\nconst mockGl = {\n    createBuffer: vi.fn(() => ({})),\n    bindBuffer: vi.fn(),\n    bufferData: vi.fn(),\n    ARRAY_BUFFER: 'ARRAY_BUFFER',\n    ELEMENT_ARRAY_BUFFER: 'ELEMENT_ARRAY_BUFFER',\n    STATIC_DRAW: 'STATIC_DRAW'\n}\nconst mockContext = {\n    gl: mockGl,\n    spriteProgram: {},\n    textureManager: {}\n}\nrenderer.init(mockContext)\nexpect(() => renderer.reset()).not.toThrow()"
          },
          {
            "title": "dispose cleans up sprite batch",
            "line": 53,
            "source": "const renderer = new WebGLSpriteRenderer()\nconst mockGl = {\n    createBuffer: vi.fn(() => ({})),\n    bindBuffer: vi.fn(),\n    bufferData: vi.fn(),\n    deleteBuffer: vi.fn(),\n    ARRAY_BUFFER: 'ARRAY_BUFFER',\n    ELEMENT_ARRAY_BUFFER: 'ELEMENT_ARRAY_BUFFER',\n    STATIC_DRAW: 'STATIC_DRAW'\n}\nconst mockContext = {\n    gl: mockGl,\n    spriteProgram: {},\n    textureManager: {}\n}\nrenderer.init(mockContext)\nrenderer.dispose()\nexpect(mockGl.deleteBuffer).toHaveBeenCalledTimes(2)"
          },
          {
            "title": "flush renders collected sprites with matrices",
            "line": 75,
            "source": "const renderer = new WebGLSpriteRenderer()\nconst mockGl = {\n    createBuffer: vi.fn(() => ({})),\n    bindBuffer: vi.fn(),\n    bufferData: vi.fn(),\n    useProgram: vi.fn(),\n    uniformMatrix3fv: vi.fn(),\n    uniform2f: vi.fn(),\n    activeTexture: vi.fn(),\n    bindTexture: vi.fn(),\n    uniform1i: vi.fn(),\n    enableVertexAttribArray: vi.fn(),\n    vertexAttribPointer: vi.fn(),\n    drawElements: vi.fn(),\n    ARRAY_BUFFER: 'ARRAY_BUFFER',\n    ELEMENT_ARRAY_BUFFER: 'ELEMENT_ARRAY_BUFFER',\n    STATIC_DRAW: 'STATIC_DRAW',\n    DYNAMIC_DRAW: 'DYNAMIC_DRAW',\n    TEXTURE0: 'TEXTURE0',\n    TEXTURE_2D: 'TEXTURE_2D',\n    FLOAT: 'FLOAT',\n    TRIANGLES: 'TRIANGLES',\n    UNSIGNED_SHORT: 'UNSIGNED_SHORT'\n}\n\nconst mockProgram = {\n    program: {},\n    uniforms: {\n        uProjectionMatrix: 'uProjectionMatrix',\n        uViewMatrix: 'uViewMatrix',\n        uModelMatrix: 'uModelMatrix',\n        uTexture: 'uTexture'\n    },\n    attributes: {\n        aPosition: 0,\n        aTexCoord: 1,\n        aOpacity: 2\n    }\n}\n\nconst mockTexture = {}\nconst mockTextureManager = {\n    getTexture: vi.fn(() => mockTexture)\n}\n\nconst mockContext = {\n    gl: mockGl,\n    spriteProgram: mockProgram,\n    textureManager: mockTextureManager\n}\n\nrenderer.init(mockContext)\nrenderer.reset()\n\nconst mockSprite = {\n    image: {complete: true, naturalWidth: 100, width: 100, height: 100},\n    getBounds: () => ({minX: 0, minY: 0, maxX: 10, maxY: 10, width: 10, height: 10}),\n    worldMatrix: [1, 0, 0, 1, 0, 0],\n    anchorX: 0.5,\n    anchorY: 0.5\n}\n\nrenderer.collect(mockSprite, 1.0)\n\nconst matrices = {\n    projectionMatrix: [1, 0, 0, 0, 1, 0, 0, 0, 1],\n    viewMatrix: [1, 0, 0, 0, 1, 0, 0, 0, 1]\n}\n\nrenderer.flush(matrices)\n\nexpect(mockGl.useProgram).toHaveBeenCalled()\nexpect(mockGl.uniformMatrix3fv).toHaveBeenCalled()"
          }
        ],
        "describes": []
      }
    ]
  },
  "/input/input_system.doc.js": {
    "file": "/input/input_system.test.js",
    "describes": [
      {
        "title": "InputSystem",
        "line": 11,
        "beforeEach": {
          "line": 16,
          "source": "mockHost = new PerkyModule({name: 'mockHost'})\nmockHost.actionDispatcher = {\n    dispatchAction: vi.fn()\n}\n\ninputSystem = new InputSystem()\ninputSystem.install(mockHost)"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor creates InputBinder",
            "line": 27,
            "source": "expect(inputSystem.inputBinder).toBeInstanceOf(InputBinder)"
          },
          {
            "title": "onInstall creates keyboard and mouse devices",
            "line": 32,
            "source": "expect(inputSystem.getDevice('keyboard')).toBeInstanceOf(KeyboardDevice)\nexpect(inputSystem.getDevice('mouse')).toBeInstanceOf(MouseDevice)"
          },
          {
            "title": "onInstall registers devices with $bind",
            "line": 38,
            "source": "expect(inputSystem.getDevice('keyboard')).toBe(inputSystem.keyboard)\nexpect(inputSystem.getDevice('mouse')).toBe(inputSystem.mouse)"
          },
          {
            "title": "onInstall delegates device management methods to host",
            "line": 44,
            "source": "expect(typeof mockHost.registerDevice).toBe('function')\nexpect(typeof mockHost.getDevice).toBe('function')\nexpect(typeof mockHost.isPressed).toBe('function')\nexpect(typeof mockHost.getControl).toBe('function')"
          },
          {
            "title": "onInstall delegates InputBinder methods to host",
            "line": 52,
            "source": "expect(typeof mockHost.bindInput).toBe('function')\nexpect(typeof mockHost.unbind).toBe('function')\nexpect(typeof mockHost.getBinding).toBe('function')\nexpect(typeof mockHost.hasBinding).toBe('function')"
          },
          {
            "title": "onInstall adds convenience methods to host",
            "line": 60,
            "source": "expect(typeof mockHost.isKeyPressed).toBe('function')\nexpect(typeof mockHost.isMousePressed).toBe('function')\nexpect(typeof mockHost.isActionPressed).toBe('function')\nexpect(typeof mockHost.getActionControls).toBe('function')"
          },
          {
            "title": "registerDevice",
            "line": 70,
            "source": "const device = inputSystem.registerDevice(InputDevice, {$id: 'gamepad', $bind: 'gamepad'})\n\nexpect(inputSystem.getDevice('gamepad')).toBe(device)\nexpect(device.host).toBe(inputSystem)\nexpect(inputSystem.gamepad).toBe(device)"
          },
          {
            "title": "registerDevice with duplicate name replaces device",
            "line": 79,
            "source": "inputSystem.registerDevice(InputDevice, {$id: 'test', $bind: 'test'})\nconst device2 = inputSystem.registerDevice(InputDevice, {$id: 'test', $bind: 'test'})\n\nexpect(inputSystem.getDevice('test')).toBe(device2)\nexpect(inputSystem.test).toBe(device2)"
          },
          {
            "title": "isPressed",
            "line": 88,
            "source": "const button = inputSystem.keyboard.findOrCreateControl(ButtonControl, {name: 'TestButton'})\n\nexpect(inputSystem.isPressed('keyboard', 'TestButton')).toBe(false)\nexpect(inputSystem.isPressed('nonExistent', 'TestButton')).toBe(false)\nexpect(inputSystem.isPressed('keyboard', 'nonExistent')).toBe(false)\n\nbutton.press()\nexpect(inputSystem.isPressed('keyboard', 'TestButton')).toBe(true)\n\nbutton.release()\nexpect(inputSystem.isPressed('keyboard', 'TestButton')).toBe(false)"
          },
          {
            "title": "getValueFor",
            "line": 103,
            "source": "const button = inputSystem.mouse.findOrCreateControl(ButtonControl, {name: 'TestButton'})\nbutton.value = 0.5\n\nexpect(inputSystem.getValueFor('mouse', 'TestButton')).toBe(0.5)\nexpect(inputSystem.getValueFor('nonExistent', 'TestButton')).toBeUndefined()\nexpect(inputSystem.getValueFor('mouse', 'nonExistent')).toBeUndefined()"
          },
          {
            "title": "getControl",
            "line": 113,
            "source": "const device = inputSystem.registerDevice(InputDevice, {$id: 'gamepad', $bind: 'gamepad'})\nconst button = device.findOrCreateControl(ButtonControl, {name: 'TestButton'})\n\nexpect(inputSystem.getControl('gamepad', 'TestButton')).toBe(button)\nexpect(inputSystem.getControl('nonExistent', 'TestButton')).toBeNull()\nexpect(inputSystem.getControl('gamepad', 'nonExistent')).toBeNull()"
          },
          {
            "title": "automatic lifecycle management",
            "line": 123,
            "source": "inputSystem.start()\nconst device = inputSystem.registerDevice(InputDevice, {$id: 'auto', $bind: 'auto'})\n\nexpect(device.started).toBe(true)"
          },
          {
            "title": "event forwarding",
            "line": 131,
            "source": "const device = inputSystem.registerDevice(InputDevice, {$id: 'test', $bind: 'test'})\n\nconst pressedListener = vi.fn()\nconst releasedListener = vi.fn()\nconst updatedListener = vi.fn()\n\ninputSystem.on('control:pressed', pressedListener)\ninputSystem.on('control:released', releasedListener)\ninputSystem.on('control:updated', updatedListener)\n\nconst button = device.findOrCreateControl(ButtonControl, {name: 'TestButton'})\n\nbutton.press()\nexpect(pressedListener).toHaveBeenCalledWith(button, null, device)\n\nbutton.release()\nexpect(releasedListener).toHaveBeenCalledWith(button, null, device)\n\nbutton.setValue(0.5)\nexpect(updatedListener).toHaveBeenCalled()"
          },
          {
            "title": "isPressedAny",
            "line": 155,
            "source": "const gamepad = inputSystem.registerDevice(InputDevice, {$id: 'gamepad', $bind: 'gamepad'})\n\nconst keyW = inputSystem.keyboard.findOrCreateControl(ButtonControl, {name: 'KeyW'})\nconst buttonA = gamepad.findOrCreateControl(ButtonControl, {name: 'ButtonA'})\n\nexpect(inputSystem.isPressedAny('KeyW')).toBe(false)\nexpect(inputSystem.isPressedAny('ButtonA')).toBe(false)\nexpect(inputSystem.isPressedAny('NonExistent')).toBe(false)\n\nkeyW.press()\nexpect(inputSystem.isPressedAny('KeyW')).toBe(true)\nexpect(inputSystem.isPressedAny('ButtonA')).toBe(false)\n\nbuttonA.press()\nexpect(inputSystem.isPressedAny('ButtonA')).toBe(true)"
          },
          {
            "title": "getValueAny",
            "line": 174,
            "source": "const keyW = inputSystem.keyboard.findOrCreateControl(ButtonControl, {name: 'KeyW'})\nconst leftButton = inputSystem.mouse.findOrCreateControl(ButtonControl, {name: 'leftButton'})\n\nkeyW.setValue(0.8)\nleftButton.setValue(0.5)\n\nexpect(inputSystem.getValueAny('KeyW')).toBe(0.8)\nexpect(inputSystem.getValueAny('leftButton')).toBe(0.5)\nexpect(inputSystem.getValueAny('NonExistent')).toBeUndefined()"
          },
          {
            "title": "getControlAny",
            "line": 187,
            "source": "const keyW = inputSystem.keyboard.findOrCreateControl(ButtonControl, {name: 'KeyW'})\nconst leftButton = inputSystem.mouse.findOrCreateControl(ButtonControl, {name: 'leftButton'})\n\nexpect(inputSystem.getControlAny('KeyW')).toBe(keyW)\nexpect(inputSystem.getControlAny('leftButton')).toBe(leftButton)\nexpect(inputSystem.getControlAny('NonExistent')).toBeNull()"
          },
          {
            "title": "getAllPressed",
            "line": 197,
            "source": "const gamepad = inputSystem.registerDevice(InputDevice, {$id: 'gamepad', $bind: 'gamepad'})\n\nconst keyEnter = inputSystem.keyboard.findOrCreateControl(ButtonControl, {name: 'Enter'})\nconst gamepadEnter = gamepad.findOrCreateControl(ButtonControl, {name: 'Enter'})\n\nexpect(inputSystem.getAllPressed('Enter')).toEqual([])\n\nkeyEnter.press()\nexpect(inputSystem.getAllPressed('Enter')).toEqual([inputSystem.keyboard])\n\ngamepadEnter.press()\nexpect(inputSystem.getAllPressed('Enter')).toEqual([inputSystem.keyboard, gamepad])\n\nkeyEnter.release()\nexpect(inputSystem.getAllPressed('Enter')).toEqual([gamepad])"
          },
          {
            "title": "getAllValues",
            "line": 216,
            "source": "const device1 = inputSystem.registerDevice(InputDevice, {$id: 'device1', $bind: 'device1'})\nconst device2 = inputSystem.registerDevice(InputDevice, {$id: 'device2', $bind: 'device2'})\n\nconst control1 = device1.findOrCreateControl(ButtonControl, {name: 'SharedControl'})\nconst control2 = device2.findOrCreateControl(ButtonControl, {name: 'SharedControl'})\n\ncontrol1.setValue(0.3)\ncontrol2.setValue(0.7)\n\nconst values = inputSystem.getAllValues('SharedControl')\nexpect(values).toHaveLength(2)\nexpect(values[0]).toEqual({device: device1, value: 0.3})\nexpect(values[1]).toEqual({device: device2, value: 0.7})"
          },
          {
            "title": "addControl - explicit form",
            "line": 233,
            "source": "const control = inputSystem.addControl('keyboard', ButtonControl, {\n    name: 'TestKey',\n    pressThreshold: 0.8\n})\n\nexpect(control).toBeInstanceOf(ButtonControl)\nexpect(control.name).toBe('TestKey')\nexpect(control.pressThreshold).toBe(0.8)\nexpect(inputSystem.keyboard.getControl('TestKey')).toBe(control)"
          },
          {
            "title": "addControl - shortcut form",
            "line": 246,
            "source": "const control = inputSystem.addControl(ButtonControl, {\n    name: 'ShortcutKey',\n    pressThreshold: 0.6\n})\n\nexpect(control).toBeInstanceOf(ButtonControl)\nexpect(control.name).toBe('ShortcutKey')\nexpect(control.pressThreshold).toBe(0.6)\n\nexpect(inputSystem.keyboard.getControl('ShortcutKey')).toBe(control)\nexpect(inputSystem.mouse.getControl('ShortcutKey')).toBeUndefined()"
          },
          {
            "title": "addControl with nonexistent device",
            "line": 261,
            "source": "expect(() => {\n    inputSystem.addControl('nonexistent', ButtonControl, {name: 'test'})\n}).toThrow(\"Device 'nonexistent' not found\")"
          },
          {
            "title": "addControlToFirst",
            "line": 268,
            "source": "const control = inputSystem.addControlToFirst(ButtonControl, {\n    name: 'FirstDeviceControl'\n})\n\nexpect(control).toBeInstanceOf(ButtonControl)\nexpect(control.name).toBe('FirstDeviceControl')\n\nexpect(inputSystem.keyboard.getControl('FirstDeviceControl')).toBe(control)\nexpect(inputSystem.mouse.getControl('FirstDeviceControl')).toBeUndefined()"
          },
          {
            "title": "addControlToAll",
            "line": 281,
            "source": "const results = inputSystem.addControlToAll(ButtonControl, {\n    name: 'SharedControl'\n})\n\nexpect(results).toHaveLength(3)\nexpect(results[0].device).toBe(inputSystem.keyboard)\nexpect(results[0].control).toBeInstanceOf(ButtonControl)\nexpect(results[0].control.name).toBe('SharedControl')\nexpect(results[1].device).toBe(inputSystem.mouse)\nexpect(results[1].control).toBeInstanceOf(ButtonControl)\nexpect(results[1].control.name).toBe('SharedControl')\nexpect(results[2].device).toBe(inputSystem.touch)\nexpect(results[2].control).toBeInstanceOf(ButtonControl)\nexpect(results[2].control.name).toBe('SharedControl')\n\nexpect(inputSystem.keyboard.getControl('SharedControl')).toBe(results[0].control)\nexpect(inputSystem.mouse.getControl('SharedControl')).toBe(results[1].control)\nexpect(inputSystem.touch.getControl('SharedControl')).toBe(results[2].control)"
          },
          {
            "title": "deviceKeyFor",
            "line": 303,
            "source": "expect(inputSystem.deviceKeyFor(inputSystem.keyboard)).toBe('keyboard')\nexpect(inputSystem.deviceKeyFor(inputSystem.mouse)).toBe('mouse')\n\nconst unknownDevice = new InputDevice({name: 'Unknown'})\nexpect(inputSystem.deviceKeyFor(unknownDevice)).toBeUndefined()"
          },
          {
            "title": "bindInput creates keyboard binding (auto-detected)",
            "line": 314,
            "source": "const binding = inputSystem.bindInput({controlName: 'Space', actionName: 'jump'})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('keyboard')\nexpect(binding.controlName).toBe('Space')\nexpect(binding.actionName).toBe('jump')"
          },
          {
            "title": "bindInput creates mouse binding (auto-detected)",
            "line": 324,
            "source": "const binding = inputSystem.bindInput({controlName: 'leftButton', actionName: 'fire'})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('mouse')\nexpect(binding.controlName).toBe('leftButton')\nexpect(binding.actionName).toBe('fire')"
          },
          {
            "title": "isKeyPressed returns correct state",
            "line": 334,
            "source": "const spaceControl = inputSystem.keyboard.findOrCreateControl(ButtonControl, {name: 'Space'})\n\nexpect(inputSystem.isKeyPressed('Space')).toBe(false)\n\nspaceControl.press()\nexpect(inputSystem.isKeyPressed('Space')).toBe(true)\n\nspaceControl.release()\nexpect(inputSystem.isKeyPressed('Space')).toBe(false)"
          },
          {
            "title": "isMousePressed returns correct state",
            "line": 347,
            "source": "const leftButtonControl = inputSystem.mouse.findOrCreateControl(ButtonControl, {name: 'leftButton'})\n\nexpect(inputSystem.isMousePressed('leftButton')).toBe(false)\n\nleftButtonControl.press()\nexpect(inputSystem.isMousePressed('leftButton')).toBe(true)\n\nleftButtonControl.release()\nexpect(inputSystem.isMousePressed('leftButton')).toBe(false)"
          },
          {
            "title": "isTouchPressed returns correct state",
            "line": 360,
            "source": "const swipeUpControl = inputSystem.touch.getControl('swipeUp')\n\nexpect(inputSystem.isTouchPressed('swipeUp')).toBe(false)\n\nswipeUpControl.press()\nexpect(inputSystem.isTouchPressed('swipeUp')).toBe(true)\n\nswipeUpControl.release()\nexpect(inputSystem.isTouchPressed('swipeUp')).toBe(false)"
          },
          {
            "title": "getTouchValue returns touch control value",
            "line": 373,
            "source": "const positionControl = inputSystem.touch.getControl('position')\n\npositionControl.setValue({x: 150, y: 250})\nconst value = inputSystem.getTouchValue('position')\nexpect(value.x).toBe(150)\nexpect(value.y).toBe(250)"
          },
          {
            "title": "isActionPressed returns false when action not bound",
            "line": 383,
            "source": "expect(inputSystem.isActionPressed('jump')).toBe(false)"
          },
          {
            "title": "isActionPressed returns true when action is pressed",
            "line": 388,
            "source": "inputSystem.bindInput({controlName: 'Space', actionName: 'jump'})\n\nconst spaceControl = inputSystem.keyboard.findOrCreateControl(ButtonControl, {name: 'Space'})\nspaceControl.press()\n\nexpect(inputSystem.isActionPressed('jump')).toBe(true)"
          },
          {
            "title": "isActionPressed works with multiple bindings",
            "line": 398,
            "source": "inputSystem.bindInput({controlName: 'Space', actionName: 'jump', controllerName: 'player1'})\ninputSystem.bindInput({controlName: 'KeyW', actionName: 'jump', controllerName: 'player2'})\n\nconst wControl = inputSystem.keyboard.findOrCreateControl(ButtonControl, {name: 'KeyW'})\nwControl.press()\n\nexpect(inputSystem.isActionPressed('jump')).toBe(true)\nexpect(inputSystem.isActionPressed('jump', 'player2')).toBe(true)\nexpect(inputSystem.isActionPressed('jump', 'player1')).toBe(false)"
          },
          {
            "title": "getActionControls returns empty array when action not bound",
            "line": 411,
            "source": "const controls = inputSystem.getActionControls('jump')\nexpect(controls).toEqual([])"
          },
          {
            "title": "getActionControls returns controls for action",
            "line": 417,
            "source": "inputSystem.bindInput({controlName: 'Space', actionName: 'jump'})\n\nconst spaceControl = inputSystem.keyboard.findOrCreateControl(ButtonControl, {name: 'Space'})\n\nconst controls = inputSystem.getActionControls('jump')\nexpect(controls).toHaveLength(1)\nexpect(controls[0]).toBe(spaceControl)"
          },
          {
            "title": "emits input:triggered event when control is pressed",
            "line": 428,
            "source": "inputSystem.bindInput({controlName: 'Space', actionName: 'jump'})\n\nconst triggeredListener = vi.fn()\nmockHost.on('input:triggered', triggeredListener)\n\nconst spaceControl = inputSystem.keyboard.findOrCreateControl(ButtonControl, {name: 'Space'})\n\nspaceControl.press({code: 'Space'})\n\nawait new Promise(resolve => setTimeout(resolve, 0))\n\nexpect(triggeredListener).toHaveBeenCalled()\nexpect(triggeredListener).toHaveBeenCalledWith(\n    expect.objectContaining({actionName: 'jump'}),\n    expect.anything(),\n    expect.anything()\n)"
          },
          {
            "title": "emits control events",
            "line": 449,
            "source": "const pressedListener = vi.fn()\nconst releasedListener = vi.fn()\n\ninputSystem.on('control:pressed', pressedListener)\ninputSystem.on('control:released', releasedListener)\n\nconst spaceControl = inputSystem.keyboard.findOrCreateControl(ButtonControl, {name: 'Space'})\n\nspaceControl.press({code: 'Space'})\nawait new Promise(resolve => setTimeout(resolve, 0))\nexpect(pressedListener).toHaveBeenCalled()\n\nspaceControl.release({code: 'Space'})\nawait new Promise(resolve => setTimeout(resolve, 0))\nexpect(releasedListener).toHaveBeenCalled()"
          },
          {
            "title": "getInputValue returns control value",
            "line": 468,
            "source": "const spaceControl = inputSystem.keyboard.findOrCreateControl(ButtonControl, {name: 'Space'})\nspaceControl.press()\n\nexpect(inputSystem.getInputValue('keyboard', 'Space')).toBe(1)"
          },
          {
            "title": "getKeyValue returns keyboard control value",
            "line": 476,
            "source": "const spaceControl = inputSystem.keyboard.findOrCreateControl(ButtonControl, {name: 'Space'})\nspaceControl.press()\n\nexpect(inputSystem.getKeyValue('Space')).toBe(1)"
          },
          {
            "title": "getMouseValue returns mouse control value",
            "line": 484,
            "source": "const leftButtonControl = inputSystem.mouse.findOrCreateControl(ButtonControl, {name: 'leftButton'})\nleftButtonControl.press()\n\nexpect(inputSystem.getMouseValue('leftButton')).toBe(1)"
          },
          {
            "title": "constructor accepts inputBinder data",
            "line": 495,
            "source": "const bindings = [\n    {\n        deviceName: 'keyboard',\n        controlName: 'Space',\n        actionName: 'jump'\n    }\n]\n\nconst customInputSystem = new InputSystem({\n    bindings\n})\n\nexpect(customInputSystem.inputBinder.hasBinding({actionName: 'jump'})).toBe(true)"
          },
          {
            "title": "listDeviceNames returns array of device names",
            "line": 631,
            "source": "const names = inputSystem.listDeviceNames()\n\nexpect(names).toContain('keyboard')\nexpect(names).toContain('mouse')\nexpect(names).toContain('touch')"
          },
          {
            "title": "getPressedControls returns pressed controls for device",
            "line": 640,
            "source": "const button1 = inputSystem.keyboard.findOrCreateControl(ButtonControl, {name: 'KeyA'})\nconst button2 = inputSystem.keyboard.findOrCreateControl(ButtonControl, {name: 'KeyB'})\n\nexpect(inputSystem.getPressedControls('keyboard')).toEqual([])\n\nbutton1.press()\nexpect(inputSystem.getPressedControls('keyboard')).toEqual([button1])\n\nbutton2.press()\nconst pressed = inputSystem.getPressedControls('keyboard')\nexpect(pressed).toHaveLength(2)\nexpect(pressed).toContain(button1)\nexpect(pressed).toContain(button2)"
          },
          {
            "title": "getPressedControls returns empty array for nonexistent device",
            "line": 657,
            "source": "expect(inputSystem.getPressedControls('nonexistent')).toEqual([])"
          },
          {
            "title": "getInputValueAny returns value from any device",
            "line": 662,
            "source": "const keyControl = inputSystem.keyboard.findOrCreateControl(ButtonControl, {name: 'TestKey'})\nkeyControl.setValue(0.75)\n\nexpect(inputSystem.getInputValueAny('TestKey')).toBe(0.75)\nexpect(inputSystem.getInputValueAny('NonExistent')).toBeUndefined()"
          }
        ],
        "describes": [
          {
            "title": "getDirection",
            "line": 512,
            "beforeEach": {
              "line": 514,
              "source": "// Setup WASD bindings\ninputSystem.bindInput({controlName: 'KeyW', actionName: 'moveUp'})\ninputSystem.bindInput({controlName: 'KeyA', actionName: 'moveLeft'})\ninputSystem.bindInput({controlName: 'KeyS', actionName: 'moveDown'})\ninputSystem.bindInput({controlName: 'KeyD', actionName: 'moveRight'})"
            },
            "afterEach": null,
            "tests": [
              {
                "title": "returns zero vector when no keys pressed",
                "line": 523,
                "source": "const dir = inputSystem.getDirection()\n\nexpect(dir.x).toBe(0)\nexpect(dir.y).toBe(0)"
              },
              {
                "title": "returns up vector when W pressed",
                "line": 531,
                "source": "const wControl = inputSystem.keyboard.findOrCreateControl(ButtonControl, {name: 'KeyW'})\nwControl.press()\n\nconst dir = inputSystem.getDirection()\n\nexpect(dir.x).toBe(0)\nexpect(dir.y).toBe(1)"
              },
              {
                "title": "returns normalized diagonal when W+D pressed",
                "line": 542,
                "source": "const wControl = inputSystem.keyboard.findOrCreateControl(ButtonControl, {name: 'KeyW'})\nconst dControl = inputSystem.keyboard.findOrCreateControl(ButtonControl, {name: 'KeyD'})\nwControl.press()\ndControl.press()\n\nconst dir = inputSystem.getDirection()\n\n// Diagonal should be normalized (0.707, 0.707)\nexpect(dir.x).toBeCloseTo(Math.SQRT1_2, 5)\nexpect(dir.y).toBeCloseTo(Math.SQRT1_2, 5)\nexpect(dir.length()).toBeCloseTo(1, 5)"
              },
              {
                "title": "returns left vector when A pressed",
                "line": 557,
                "source": "const aControl = inputSystem.keyboard.findOrCreateControl(ButtonControl, {name: 'KeyA'})\naControl.press()\n\nconst dir = inputSystem.getDirection()\n\nexpect(dir.x).toBe(-1)\nexpect(dir.y).toBe(0)"
              },
              {
                "title": "cancels opposite directions",
                "line": 568,
                "source": "const wControl = inputSystem.keyboard.findOrCreateControl(ButtonControl, {name: 'KeyW'})\nconst sControl = inputSystem.keyboard.findOrCreateControl(ButtonControl, {name: 'KeyS'})\nwControl.press()\nsControl.press()\n\nconst dir = inputSystem.getDirection()\n\nexpect(dir.x).toBe(0)\nexpect(dir.y).toBe(0)"
              },
              {
                "title": "works with custom direction name",
                "line": 581,
                "source": "inputSystem.bindInput({controlName: 'ArrowUp', actionName: 'aimUp'})\ninputSystem.bindInput({controlName: 'ArrowDown', actionName: 'aimDown'})\ninputSystem.bindInput({controlName: 'ArrowLeft', actionName: 'aimLeft'})\ninputSystem.bindInput({controlName: 'ArrowRight', actionName: 'aimRight'})\n\nconst upControl = inputSystem.keyboard.findOrCreateControl(ButtonControl, {name: 'ArrowUp'})\nupControl.press()\n\nconst dir = inputSystem.getDirection('aim')\n\nexpect(dir.x).toBe(0)\nexpect(dir.y).toBe(1)"
              },
              {
                "title": "returns correct vector for all 8 directions",
                "line": 597,
                "source": "const testDirections = [\n    {keys: ['KeyW'], expected: {x: 0, y: 1}},\n    {keys: ['KeyD'], expected: {x: 1, y: 0}},\n    {keys: ['KeyS'], expected: {x: 0, y: -1}},\n    {keys: ['KeyA'], expected: {x: -1, y: 0}},\n    {keys: ['KeyW', 'KeyD'], expected: {x: Math.SQRT1_2, y: Math.SQRT1_2}},\n    {keys: ['KeyS', 'KeyD'], expected: {x: Math.SQRT1_2, y: -Math.SQRT1_2}},\n    {keys: ['KeyS', 'KeyA'], expected: {x: -Math.SQRT1_2, y: -Math.SQRT1_2}},\n    {keys: ['KeyW', 'KeyA'], expected: {x: -Math.SQRT1_2, y: Math.SQRT1_2}}\n]\n\ntestDirections.forEach(({keys, expected}) => {\n    ['KeyW', 'KeyA', 'KeyS', 'KeyD'].forEach(key => {\n        const control = inputSystem.keyboard.getControl(key)\n        if (control) {\n            control.release()\n        }\n    })\n\n    keys.forEach(key => {\n        const control = inputSystem.keyboard.findOrCreateControl(ButtonControl, {name: key})\n        control.press()\n    })\n\n    const dir = inputSystem.getDirection()\n    expect(dir.x).toBeCloseTo(expected.x, 5)\n    expect(dir.y).toBeCloseTo(expected.y, 5)\n})"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/input/composite_binding.doc.js": {
    "file": "/input/composite_binding.test.js",
    "describes": [
      {
        "title": "CompositeBinding",
        "line": 8,
        "beforeEach": {
          "line": 14,
          "source": "inputSystem = new InputSystem()\nkeyboardDevice = inputSystem.registerDevice(KeyboardDevice, {$id: 'keyboard', $bind: 'keyboard', name: 'KeyboardDevice'})\n\ncompositeBinding = new CompositeBinding({\n    controls: [\n        {deviceName: 'keyboard', controlName: 'ControlLeft'},\n        {deviceName: 'keyboard', controlName: 'KeyS'}\n    ],\n    actionName: 'save',\n    controllerName: 'editor'\n})"
        },
        "afterEach": {
          "line": 29,
          "source": "vi.restoreAllMocks()"
        },
        "tests": [
          {
            "title": "constructor",
            "line": 34,
            "source": "expect(compositeBinding).toBeInstanceOf(CompositeBinding)\nexpect(compositeBinding.controls).toHaveLength(2)\n\nexpect(compositeBinding.actionName).toBe('save')\nexpect(compositeBinding.controllerName).toBe('editor')\nexpect(compositeBinding.deviceName).toBe('composite')"
          },
          {
            "title": "generateControlName",
            "line": 44,
            "source": "const controls = [\n    {deviceName: 'keyboard', controlName: 'ControlLeft'},\n    {deviceName: 'keyboard', controlName: 'KeyS'}\n]\n\nconst controlName = CompositeBinding.generateControlName(controls)\nexpect(controlName).toBe('combo(keyboard:ControlLeft+keyboard:KeyS)')"
          },
          {
            "title": "matches composite device",
            "line": 55,
            "source": "const result = compositeBinding.matches({\n    deviceName: 'composite',\n    controlName: compositeBinding.controlName,\n    eventType: 'pressed'\n})\n\nexpect(result).toBe(true)"
          },
          {
            "title": "matches constituent control",
            "line": 66,
            "source": "const result = compositeBinding.matches({\n    deviceName: 'keyboard',\n    controlName: 'ControlLeft',\n    eventType: 'pressed'\n})\n\nexpect(result).toBe(true)\n\nconst result2 = compositeBinding.matches({\n    deviceName: 'keyboard',\n    controlName: 'KeyS',\n    eventType: 'pressed'\n})\n\nexpect(result2).toBe(true)"
          },
          {
            "title": "does not match unrelated control",
            "line": 85,
            "source": "const result = compositeBinding.matches({\n    deviceName: 'keyboard',\n    controlName: 'KeyA',\n    eventType: 'pressed'\n})\n\nexpect(result).toBe(false)"
          },
          {
            "title": "shouldTrigger with AND operator",
            "line": 96,
            "source": "const ctrlControl = keyboardDevice.findOrCreateControl(ButtonControl, {name: 'ControlLeft'})\nconst sControl = keyboardDevice.findOrCreateControl(ButtonControl, {name: 'KeyS'})\n\nexpect(compositeBinding.shouldTrigger(inputSystem)).toBe(false)\n\nctrlControl.press()\nexpect(compositeBinding.shouldTrigger(inputSystem)).toBe(false)\n\nsControl.press()\nexpect(compositeBinding.shouldTrigger(inputSystem)).toBe(true)"
          },
          {
            "title": "key generation",
            "line": 110,
            "source": "expect(compositeBinding.key).toBe('composite:combo(keyboard:ControlLeft+keyboard:KeyS):pressed:save:editor')"
          }
        ],
        "describes": []
      }
    ]
  },
  "/input/gamepad_info.doc.js": {
    "file": "/input/gamepad_info.test.js",
    "describes": [
      {
        "title": "GamepadInfo",
        "line": 4,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "constructor with valid Firefox format",
            "line": 6,
            "source": "const gamepad = new GamepadInfo('054c-09cc-DualShock 4 Controller')\n\nexpect(gamepad.raw).toBe('054c-09cc-DualShock 4 Controller')\nexpect(gamepad.vendor).toBe('054c')\nexpect(gamepad.product).toBe('09cc')\nexpect(gamepad.name).toBe('DualShock 4 Controller')\nexpect(gamepad.type).toBe('ps4')\nexpect(gamepad.model).toBe('ds4')"
          },
          {
            "title": "constructor with valid Chrome format",
            "line": 18,
            "source": "const gamepad = new GamepadInfo('Xbox Controller (Vendor: 045e Product: 02ea)')\n\nexpect(gamepad.raw).toBe('Xbox Controller (Vendor: 045e Product: 02ea)')\nexpect(gamepad.vendor).toBe('045e')\nexpect(gamepad.product).toBe('02ea')\nexpect(gamepad.name).toBe('Xbox Controller')\nexpect(gamepad.type).toBe('xbox')\nexpect(gamepad.model).toBeNull()"
          },
          {
            "title": "constructor with invalid input",
            "line": 30,
            "source": "const gamepad = new GamepadInfo(null)\n\nexpect(gamepad.raw).toBeNull()\nexpect(gamepad.vendor).toBeNull()\nexpect(gamepad.product).toBeNull()\nexpect(gamepad.name).toBeNull()\nexpect(gamepad.type).toBe('unknown')\nexpect(gamepad.model).toBeNull()"
          },
          {
            "title": "constructor with non-string input",
            "line": 42,
            "source": "const gamepad = new GamepadInfo(123)\n\nexpect(gamepad.raw).toBe(123)\nexpect(gamepad.type).toBe('unknown')"
          },
          {
            "title": "constructor with unrecognized format",
            "line": 50,
            "source": "const gamepad = new GamepadInfo('Some Generic Controller')\n\nexpect(gamepad.raw).toBe('Some Generic Controller')\nexpect(gamepad.vendor).toBeNull()\nexpect(gamepad.product).toBeNull()\nexpect(gamepad.name).toBe('Some Generic Controller')\nexpect(gamepad.type).toBe('generic')\nexpect(gamepad.model).toBeNull()"
          },
          {
            "title": "Xbox controller identification from Chrome",
            "line": 62,
            "source": "const gamepad = new GamepadInfo('Xbox Wireless Controller (Vendor: 045e Product: 02fd)')\n\nexpect(gamepad.type).toBe('xbox')\nexpect(gamepad.vendor).toBe('045e')\nexpect(gamepad.product).toBe('02fd')"
          },
          {
            "title": "Xbox controller identification from Firefox",
            "line": 71,
            "source": "const gamepad = new GamepadInfo('045e-02fd-Xbox Wireless Controller')\n\nexpect(gamepad.type).toBe('xbox')\nexpect(gamepad.vendor).toBe('045e')\nexpect(gamepad.product).toBe('02fd')"
          },
          {
            "title": "PlayStation 5 DualSense controller",
            "line": 80,
            "source": "const gamepad = new GamepadInfo('054c-0ce6-DualSense Wireless Controller')\n\nexpect(gamepad.type).toBe('ps5')\nexpect(gamepad.model).toBe('dualsense')\nexpect(gamepad.vendor).toBe('054c')"
          },
          {
            "title": "PlayStation 3 DualShock controller",
            "line": 89,
            "source": "const gamepad = new GamepadInfo('054c-0268-DUALSHOCK 3')\n\nexpect(gamepad.type).toBe('ps3')\nexpect(gamepad.model).toBe('ds3')\nexpect(gamepad.vendor).toBe('054c')"
          },
          {
            "title": "Nintendo Switch Pro Controller",
            "line": 98,
            "source": "const gamepad = new GamepadInfo('057e-2009-Pro Controller')\n\nexpect(gamepad.type).toBe('switch')\nexpect(gamepad.vendor).toBe('057e')\nexpect(gamepad.product).toBe('2009')"
          },
          {
            "title": "Logitech controller",
            "line": 107,
            "source": "const gamepad = new GamepadInfo('046d-c21d-Logitech Gamepad F310')\n\nexpect(gamepad.type).toBe('logitech')\nexpect(gamepad.vendor).toBe('046d')"
          },
          {
            "title": "8BitDo controller",
            "line": 115,
            "source": "const gamepad = new GamepadInfo('2dc8-6101-8BitDo SN30 Pro')\n\nexpect(gamepad.type).toBe('8bitdo')\nexpect(gamepad.vendor).toBe('2dc8')"
          },
          {
            "title": "Generic gamepad detection by name pattern",
            "line": 123,
            "source": "const gamepad = new GamepadInfo('Gamepad 1')\n\nexpect(gamepad.type).toBe('xbox')\nexpect(gamepad.name).toBe('Gamepad 1')"
          },
          {
            "title": "PlayStation detection by name pattern",
            "line": 131,
            "source": "const gamepad = new GamepadInfo('PlayStation Controller')\n\nexpect(gamepad.type).toBe('playstation')\nexpect(gamepad.model).toBe('unknown')"
          },
          {
            "title": "Xbox detection by name pattern",
            "line": 139,
            "source": "const gamepad = new GamepadInfo('Microsoft Xbox Controller')\n\nexpect(gamepad.type).toBe('xbox')"
          },
          {
            "title": "Nintendo detection by name pattern",
            "line": 146,
            "source": "const gamepad = new GamepadInfo('Nintendo Switch Pro Controller')\n\nexpect(gamepad.type).toBe('switch')"
          },
          {
            "title": "Chrome format with lowercase vendor/product",
            "line": 153,
            "source": "const gamepad = new GamepadInfo('DualShock 4 (vendor: 054c product: 05c4)')\n\nexpect(gamepad.vendor).toBe('054c')\nexpect(gamepad.product).toBe('05c4')\nexpect(gamepad.type).toBe('ps4')"
          },
          {
            "title": "Firefox format with uppercase hex",
            "line": 162,
            "source": "const gamepad = new GamepadInfo('054C-05C4-DualShock 4')\n\nexpect(gamepad.vendor).toBe('054C')\nexpect(gamepad.product).toBe('05C4')\nexpect(gamepad.type).toBe('ps4')"
          },
          {
            "title": "Unknown vendor defaults to generic",
            "line": 171,
            "source": "const gamepad = new GamepadInfo('ffff-ffff-Unknown Controller')\n\nexpect(gamepad.vendor).toBe('ffff')\nexpect(gamepad.product).toBe('ffff')\nexpect(gamepad.type).toBe('generic')"
          },
          {
            "title": "Edge case: Empty string",
            "line": 180,
            "source": "const gamepad = new GamepadInfo('')\n\nexpect(gamepad.raw).toBe('')\nexpect(gamepad.type).toBe('unknown')"
          },
          {
            "title": "Edge case: Only spaces",
            "line": 188,
            "source": "const gamepad = new GamepadInfo('   ')\n\nexpect(gamepad.raw).toBe('   ')\nexpect(gamepad.name).toBe('   ')\nexpect(gamepad.type).toBe('generic')"
          },
          {
            "title": "Complex Chrome format with extra spaces",
            "line": 197,
            "source": "const gamepad = new GamepadInfo('Xbox Controller (XINPUT STANDARD GAMEPAD Vendor: 045e Product: 028e)')\n\nexpect(gamepad.name).toBe('Xbox Controller')\nexpect(gamepad.vendor).toBe('045e')\nexpect(gamepad.product).toBe('028e')\nexpect(gamepad.type).toBe('xbox')"
          },
          {
            "title": "DualShock 4 model detection variations",
            "line": 207,
            "source": "const variations = [\n    'DualShock 4 Controller',\n    'dualshock 4 wireless',\n    'DS4 Controller',\n    'ds4 gamepad'\n]\n\nvariations.forEach(name => {\n    const gamepad = new GamepadInfo(`054c-09cc-${name}`)\n    expect(gamepad.model).toBe('ds4')\n    expect(gamepad.type).toBe('ps4')\n})"
          },
          {
            "title": "DualSense model detection variations",
            "line": 223,
            "source": "const variations = [\n    'DualSense Wireless Controller',\n    'dualsense controller',\n    'DUALSENSE GAMEPAD'\n]\n\nvariations.forEach(name => {\n    const gamepad = new GamepadInfo(`054c-0ce6-${name}`)\n    expect(gamepad.model).toBe('dualsense')\n    expect(gamepad.type).toBe('ps5')\n})"
          },
          {
            "title": "Alternative Nintendo vendor ID",
            "line": 238,
            "source": "const gamepad = new GamepadInfo('0079-1234-Nintendo Controller')\n\nexpect(gamepad.vendor).toBe('0079')\nexpect(gamepad.type).toBe('switch')"
          }
        ],
        "describes": []
      }
    ]
  },
  "/input/input_binder.doc.js": {
    "file": "/input/input_binder.test.js",
    "describes": [
      {
        "title": "InputBinder",
        "line": 7,
        "beforeEach": {
          "line": 11,
          "source": "binder = new InputBinder()"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor - empty",
            "line": 16,
            "source": "const emptyBinder = new InputBinder()\nexpect(emptyBinder.getAllBindings()).toHaveLength(0)"
          },
          {
            "title": "constructor - with bindings",
            "line": 22,
            "source": "const bindings = [\n    {\n        deviceName: 'keyboard',\n        controlName: 'Space',\n        actionName: 'jump'\n    },\n    {\n        deviceName: 'keyboard',\n        controlName: 'Enter',\n        actionName: 'select',\n        controllerName: 'menu'\n    }\n]\n\nconst binderWithData = new InputBinder({bindings})\nexpect(binderWithData.getAllBindings()).toHaveLength(2)\n\nconst jumpBinding = binderWithData.getBinding({actionName: 'jump'})\nexpect(jumpBinding.deviceName).toBe('keyboard')\nexpect(jumpBinding.controlName).toBe('Space')"
          },
          {
            "title": "bind - minimal",
            "line": 46,
            "source": "const result = binder.bindInput({\n    deviceName: 'keyboard',\n    controlName: 'Space',\n    actionName: 'jump'\n})\n\nexpect(result).toBeInstanceOf(InputBinding)\nexpect(binder.getAllBindings()).toHaveLength(1)\n\nconst binding = binder.getAllBindings()[0]\nexpect(binding.deviceName).toBe('keyboard')\nexpect(binding.controlName).toBe('Space')\nexpect(binding.actionName).toBe('jump')\nexpect(binding.controllerName).toBeNull()\nexpect(binding.eventType).toBe('pressed')"
          },
          {
            "title": "bind - specific controller",
            "line": 65,
            "source": "binder.bindInput({\n    deviceName: 'keyboard',\n    controlName: 'Escape',\n    actionName: 'openMenu',\n    controllerName: 'game'\n})\n\nconst binding = binder.getAllBindings()[0]\nexpect(binding.controllerName).toBe('game')\nexpect(binding.key).toBe('keyboard:Escape:pressed:openMenu:game')"
          },
          {
            "title": "bind - specific eventType",
            "line": 79,
            "source": "binder.bindInput({\n    deviceName: 'keyboard',\n    controlName: 'Space',\n    actionName: 'stopJump',\n    eventType: 'released'\n})\n\nconst binding = binder.getAllBindings()[0]\nexpect(binding.eventType).toBe('released')\nexpect(binding.key).toBe('keyboard:Space:released:stopJump')"
          },
          {
            "title": "unbind",
            "line": 93,
            "source": "binder.bindInput({\n    deviceName: 'keyboard',\n    controlName: 'Space',\n    actionName: 'jump'\n})\n\nconst result = binder.unbind({\n    actionName: 'jump'\n})\n\nexpect(result).toBe(true)\nexpect(binder.getAllBindings()).toHaveLength(0)"
          },
          {
            "title": "unbind - invalid",
            "line": 109,
            "source": "const result = binder.unbind({\n    actionName: 'nonexistent'\n})\n\nexpect(result).toBe(false)"
          },
          {
            "title": "getBinding",
            "line": 118,
            "source": "binder.bindInput({\n    deviceName: 'keyboard',\n    controlName: 'Space',\n    actionName: 'jump',\n    controllerName: 'game'\n})\n\nconst binding = binder.getBinding({\n    actionName: 'jump',\n    controllerName: 'game'\n})\n\nexpect(binding).toBeDefined()\nexpect(binding.actionName).toBe('jump')\nexpect(binding.controllerName).toBe('game')"
          },
          {
            "title": "getBinding - non-existent",
            "line": 137,
            "source": "const binding = binder.getBinding({\n    actionName: 'nonexistent'\n})\n\nexpect(binding).toBeNull()"
          },
          {
            "title": "hasBinding",
            "line": 146,
            "source": "binder.bindInput({\n    deviceName: 'keyboard',\n    controlName: 'Space',\n    actionName: 'jump'\n})\n\nconst hasBinding = binder.hasBinding({\n    actionName: 'jump'\n})\n\nexpect(hasBinding).toBe(true)"
          },
          {
            "title": "hasBinding - non-existent",
            "line": 161,
            "source": "const hasBinding = binder.hasBinding({\n    actionName: 'nonexistent'\n})\n\nexpect(hasBinding).toBe(false)"
          },
          {
            "title": "getBindingsForInput - single binding",
            "line": 170,
            "source": "binder.bindInput({\n    deviceName: 'keyboard',\n    controlName: 'Space',\n    actionName: 'jump'\n})\n\nconst bindings = binder.getBindingsForInput({\n    deviceName: 'keyboard',\n    controlName: 'Space',\n    eventType: 'pressed'\n})\n\nexpect(bindings).toHaveLength(1)\nexpect(bindings[0].actionName).toBe('jump')"
          },
          {
            "title": "getBindingsForInput - multiple bindings",
            "line": 188,
            "source": "binder.bindInput({\n    deviceName: 'keyboard',\n    controlName: 'Space',\n    actionName: 'jump',\n    controllerName: 'game'\n})\n\nbinder.bindInput({\n    deviceName: 'keyboard',\n    controlName: 'Space',\n    actionName: 'select',\n    controllerName: 'menu'\n})\n\nconst bindings = binder.getBindingsForInput({\n    deviceName: 'keyboard',\n    controlName: 'Space',\n    eventType: 'pressed'\n})\n\nexpect(bindings).toHaveLength(2)\nexpect(bindings.map(b => b.actionName)).toContain('jump')\nexpect(bindings.map(b => b.actionName)).toContain('select')"
          },
          {
            "title": "getBindingsForInput - different event types",
            "line": 215,
            "source": "binder.bindInput({\n    deviceName: 'keyboard',\n    controlName: 'Space',\n    actionName: 'jump',\n    eventType: 'pressed'\n})\n\nbinder.bindInput({\n    deviceName: 'keyboard',\n    controlName: 'Space',\n    actionName: 'stopJump',\n    eventType: 'released'\n})\n\nconst pressedBindings = binder.getBindingsForInput({\n    deviceName: 'keyboard',\n    controlName: 'Space',\n    eventType: 'pressed'\n})\n\nconst releasedBindings = binder.getBindingsForInput({\n    deviceName: 'keyboard',\n    controlName: 'Space',\n    eventType: 'released'\n})\n\nexpect(pressedBindings).toHaveLength(1)\nexpect(pressedBindings[0].actionName).toBe('jump')\n\nexpect(releasedBindings).toHaveLength(1)\nexpect(releasedBindings[0].actionName).toBe('stopJump')"
          },
          {
            "title": "getBindingsForInput - non-existent",
            "line": 250,
            "source": "const bindings = binder.getBindingsForInput({\n    deviceName: 'keyboard',\n    controlName: 'NonExistent',\n    eventType: 'pressed'\n})\n\nexpect(bindings).toHaveLength(0)"
          },
          {
            "title": "getBindingsForInput - includes CompositeBinding",
            "line": 260,
            "source": "binder.bindCombo(['ControlLeft', 'KeyS'], 'save')\n\nconst bindings = binder.getBindingsForInput({\n    deviceName: 'keyboard',\n    controlName: 'ControlLeft',\n    eventType: 'pressed'\n})\n\nexpect(bindings).toHaveLength(1)\nexpect(bindings[0]).toBeInstanceOf(CompositeBinding)\nexpect(bindings[0].actionName).toBe('save')"
          },
          {
            "title": "getBindingsForInput - direct bindings come before CompositeBinding",
            "line": 274,
            "source": "binder.bindInput({\n    deviceName: 'keyboard',\n    controlName: 'ControlLeft',\n    actionName: 'ctrl'\n})\n\nbinder.bindCombo(['ControlLeft', 'KeyS'], 'save')\n\nconst bindings = binder.getBindingsForInput({\n    deviceName: 'keyboard',\n    controlName: 'ControlLeft',\n    eventType: 'pressed'\n})\n\nexpect(bindings).toHaveLength(2)\nexpect(bindings[0]).toBeInstanceOf(InputBinding)\nexpect(bindings[0].actionName).toBe('ctrl')\nexpect(bindings[1]).toBeInstanceOf(CompositeBinding)\nexpect(bindings[1].actionName).toBe('save')"
          },
          {
            "title": "getBindingsForInput - supports composite input key",
            "line": 296,
            "source": "const binding = binder.bindCombo(['ControlLeft', 'KeyS'], 'save')\n\nconst bindings = binder.getBindingsForInput({\n    deviceName: 'composite',\n    controlName: binding.controlName,\n    eventType: 'pressed'\n})\n\nexpect(bindings).toHaveLength(1)\nexpect(bindings[0]).toBe(binding)"
          },
          {
            "title": "getBindingsForAction - single binding",
            "line": 310,
            "source": "binder.bindInput({\n    deviceName: 'keyboard',\n    controlName: 'Space',\n    actionName: 'jump'\n})\n\nconst bindings = binder.getBindingsForAction('jump')\n\nexpect(bindings).toHaveLength(1)\nexpect(bindings[0].deviceName).toBe('keyboard')\nexpect(bindings[0].controlName).toBe('Space')"
          },
          {
            "title": "getBindingsForAction - multiple bindings for same action",
            "line": 325,
            "source": "binder.bindInput({\n    deviceName: 'keyboard',\n    controlName: 'Space',\n    actionName: 'jump',\n    controllerName: 'player1'\n})\n\nbinder.bindInput({\n    deviceName: 'keyboard',\n    controlName: 'KeyW',\n    actionName: 'jump',\n    controllerName: 'player2'\n})\n\nconst bindings = binder.getBindingsForAction('jump')\n\nexpect(bindings).toHaveLength(2)\nexpect(bindings.map(b => b.controlName)).toContain('Space')\nexpect(bindings.map(b => b.controlName)).toContain('KeyW')"
          },
          {
            "title": "getBindingsForAction - filter by controllerName",
            "line": 348,
            "source": "binder.bindInput({\n    deviceName: 'keyboard',\n    controlName: 'Space',\n    actionName: 'jump',\n    controllerName: 'player1'\n})\n\nbinder.bindInput({\n    deviceName: 'keyboard',\n    controlName: 'KeyW',\n    actionName: 'jump',\n    controllerName: 'player2'\n})\n\nbinder.bindInput({\n    deviceName: 'keyboard',\n    controlName: 'Enter',\n    actionName: 'jump'\n})\n\nconst player1Bindings = binder.getBindingsForAction('jump', 'player1')\nexpect(player1Bindings).toHaveLength(1)\nexpect(player1Bindings[0].controlName).toBe('Space')\n\nconst player2Bindings = binder.getBindingsForAction('jump', 'player2')\nexpect(player2Bindings).toHaveLength(1)\nexpect(player2Bindings[0].controlName).toBe('KeyW')\n\nconst allBindings = binder.getBindingsForAction('jump', null)\nexpect(allBindings).toHaveLength(3)"
          },
          {
            "title": "getBindingsForAction - filter by eventType",
            "line": 382,
            "source": "binder.bindInput({\n    deviceName: 'keyboard',\n    controlName: 'Space',\n    actionName: 'jump',\n    eventType: 'pressed'\n})\n\nbinder.bindInput({\n    deviceName: 'keyboard',\n    controlName: 'Space',\n    actionName: 'jump',\n    eventType: 'released'\n})\n\nconst pressedBindings = binder.getBindingsForAction('jump', null, 'pressed')\nexpect(pressedBindings).toHaveLength(1)\nexpect(pressedBindings[0].eventType).toBe('pressed')\n\nconst releasedBindings = binder.getBindingsForAction('jump', null, 'released')\nexpect(releasedBindings).toHaveLength(1)\nexpect(releasedBindings[0].eventType).toBe('released')"
          },
          {
            "title": "getBindingsForAction - non-existent action",
            "line": 407,
            "source": "const bindings = binder.getBindingsForAction('nonExistent')\nexpect(bindings).toHaveLength(0)"
          },
          {
            "title": "unbind - updates input index",
            "line": 413,
            "source": "binder.bindInput({\n    deviceName: 'keyboard',\n    controlName: 'Space',\n    actionName: 'jump'\n})\n\nlet bindings = binder.getBindingsForInput({\n    deviceName: 'keyboard',\n    controlName: 'Space',\n    eventType: 'pressed'\n})\nexpect(bindings).toHaveLength(1)\n\nbinder.unbind({actionName: 'jump'})\n\nbindings = binder.getBindingsForInput({\n    deviceName: 'keyboard',\n    controlName: 'Space',\n    eventType: 'pressed'\n})\nexpect(bindings).toHaveLength(0)"
          },
          {
            "title": "unbind - updates input index for CompositeBinding",
            "line": 437,
            "source": "binder.bindCombo(['ControlLeft', 'KeyS'], 'save')\n\nexpect(binder.getBindingsForInput({\n    deviceName: 'keyboard',\n    controlName: 'ControlLeft',\n    eventType: 'pressed'\n})).toHaveLength(1)\n\nbinder.unbind({actionName: 'save'})\n\nexpect(binder.getBindingsForInput({\n    deviceName: 'keyboard',\n    controlName: 'ControlLeft',\n    eventType: 'pressed'\n})).toHaveLength(0)"
          },
          {
            "title": "clearBindings",
            "line": 456,
            "source": "binder.bindInput({\n    deviceName: 'keyboard',\n    controlName: 'Space',\n    actionName: 'jump'\n})\n\nbinder.bindInput({\n    deviceName: 'keyboard',\n    controlName: 'Enter',\n    actionName: 'select'\n})\n\nexpect(binder.getAllBindings()).toHaveLength(2)\n\nconst spaceBindings = binder.getBindingsForInput({\n    deviceName: 'keyboard',\n    controlName: 'Space',\n    eventType: 'pressed'\n})\nexpect(spaceBindings).toHaveLength(1)\n\nbinder.clearBindings()\n\nexpect(binder.getAllBindings()).toHaveLength(0)\n\nconst bindingsAfterClear = binder.getBindingsForInput({\n    deviceName: 'keyboard',\n    controlName: 'Space',\n    eventType: 'pressed'\n})\nexpect(bindingsAfterClear).toHaveLength(0)"
          },
          {
            "title": "export",
            "line": 491,
            "source": "binder.bindInput({\n    deviceName: 'keyboard',\n    controlName: 'Space',\n    actionName: 'jump'\n})\n\nbinder.bindInput({\n    deviceName: 'mouse',\n    controlName: 'LeftButton',\n    actionName: 'fire',\n    controllerName: 'game',\n    eventType: 'released'\n})\n\nconst exported = binder.export()\n\nexpect(exported).toHaveProperty('bindings')\nexpect(exported.bindings).toHaveLength(2)\n\nconst jumpBinding = exported.bindings.find(b => b.actionName === 'jump')\nexpect(jumpBinding.deviceName).toBe('keyboard')\nexpect(jumpBinding.controlName).toBe('Space')\nexpect(jumpBinding.controllerName).toBeNull()\nexpect(jumpBinding.eventType).toBe('pressed')\n\nconst fireBinding = exported.bindings.find(b => b.actionName === 'fire')\nexpect(fireBinding.controllerName).toBe('game')\nexpect(fireBinding.eventType).toBe('released')"
          },
          {
            "title": "export - includes controls for CompositeBinding",
            "line": 523,
            "source": "binder.bindCombo(['ControlLeft', 'KeyS'], 'save')\n\nconst exported = binder.export()\n\nexpect(exported.bindings).toHaveLength(1)\nexpect(exported.bindings[0].controls).toBeDefined()\nexpect(exported.bindings[0].controls).toHaveLength(2)\nexpect(exported.bindings[0].controls[0]).toEqual({deviceName: 'keyboard', controlName: 'ControlLeft'})\nexpect(exported.bindings[0].controls[1]).toEqual({deviceName: 'keyboard', controlName: 'KeyS'})"
          },
          {
            "title": "import - restores CompositeBinding from exported data",
            "line": 536,
            "source": "binder.bindCombo(['ControlLeft', 'KeyS'], 'save')\n\nconst exported = binder.export()\nconst newBinder = new InputBinder({bindings: exported.bindings})\n\nconst bindings = newBinder.getAllBindings()\nexpect(bindings).toHaveLength(1)\nexpect(bindings[0]).toBeInstanceOf(CompositeBinding)\nexpect(bindings[0].controls).toHaveLength(2)\nexpect(bindings[0].actionName).toBe('save')"
          },
          {
            "title": "constructor - with exported data",
            "line": 550,
            "source": "const data = {\n    bindings: [\n        {\n            deviceName: 'keyboard',\n            controlName: 'Space',\n            actionName: 'jump'\n        },\n        {\n            deviceName: 'mouse',\n            controlName: 'LeftButton',\n            actionName: 'fire',\n            controllerName: 'game',\n            eventType: 'released'\n        }\n    ]\n}\n\nconst binderFromImport = new InputBinder(data)\n\nexpect(binderFromImport.getAllBindings()).toHaveLength(2)\n\nconst jumpBinding = binderFromImport.getBinding({actionName: 'jump'})\nexpect(jumpBinding.deviceName).toBe('keyboard')\nexpect(jumpBinding.controlName).toBe('Space')\n\nconst fireBinding = binderFromImport.getBinding({\n    actionName: 'fire',\n    controllerName: 'game',\n    eventType: 'released'\n})\nexpect(fireBinding.deviceName).toBe('mouse')\nexpect(fireBinding.controllerName).toBe('game')\n\nconst spaceBindings = binderFromImport.getBindingsForInput({\n    deviceName: 'keyboard',\n    controlName: 'Space',\n    eventType: 'pressed'\n})\nexpect(spaceBindings).toHaveLength(1)"
          },
          {
            "title": "import - instance method",
            "line": 593,
            "source": "const bindings = [\n    {\n        deviceName: 'keyboard',\n        controlName: 'Enter',\n        actionName: 'select'\n    }\n]\n\nbinder.import({bindings})\n\nexpect(binder.getAllBindings()).toHaveLength(1)\nexpect(binder.hasBinding({actionName: 'select'})).toBe(true)"
          },
          {
            "title": "constructor - empty data via import pattern",
            "line": 609,
            "source": "const binderFromImport = new InputBinder({})\nexpect(binderFromImport.getAllBindings()).toHaveLength(0)"
          },
          {
            "title": "accepts string format with auto-detection",
            "line": 615,
            "source": "const binding = binder.bindCombo(['ControlLeft', 'leftButton'], 'smartCombo')\n\nexpect(binding).toBeInstanceOf(CompositeBinding)\nexpect(binding.controls).toHaveLength(2)\nexpect(binding.controls[0].deviceName).toBe('keyboard')\nexpect(binding.controls[0].controlName).toBe('ControlLeft')\nexpect(binding.controls[1].deviceName).toBe('mouse')\nexpect(binding.controls[1].controlName).toBe('leftButton')\nexpect(binding.actionName).toBe('smartCombo')"
          },
          {
            "title": "accepts object format",
            "line": 628,
            "source": "const binding = binder.bindCombo([\n    {deviceName: 'keyboard', controlName: 'ShiftLeft'},\n    {deviceName: 'mouse', controlName: 'rightButton'}\n], 'objectCombo')\n\nexpect(binding).toBeInstanceOf(CompositeBinding)\nexpect(binding.controls).toHaveLength(2)\nexpect(binding.controls[0].deviceName).toBe('keyboard')\nexpect(binding.controls[0].controlName).toBe('ShiftLeft')\nexpect(binding.controls[1].deviceName).toBe('mouse')\nexpect(binding.controls[1].controlName).toBe('rightButton')"
          },
          {
            "title": "accepts mixed string and object formats",
            "line": 643,
            "source": "const binding = binder.bindCombo([\n    'ControlLeft',\n    {deviceName: 'mouse', controlName: 'leftButton'},\n    'KeyA'\n], 'mixedCombo')\n\nexpect(binding.controls).toHaveLength(3)\nexpect(binding.controls[0].deviceName).toBe('keyboard')\nexpect(binding.controls[0].controlName).toBe('ControlLeft')\nexpect(binding.controls[1].deviceName).toBe('mouse')\nexpect(binding.controls[1].controlName).toBe('leftButton')\nexpect(binding.controls[2].deviceName).toBe('keyboard')\nexpect(binding.controls[2].controlName).toBe('KeyA')"
          },
          {
            "title": "auto-detects all device types correctly",
            "line": 660,
            "source": "const binding = binder.bindCombo([\n    'KeyA',\n    'leftButton',\n    'button0',\n    'unknownControl'\n], 'deviceTypes')\n\nexpect(binding.controls[0].deviceName).toBe('keyboard')\nexpect(binding.controls[1].deviceName).toBe('mouse')\nexpect(binding.controls[2].deviceName).toBe('gamepad')\nexpect(binding.controls[3].deviceName).toBe('keyboard')"
          },
          {
            "title": "allows explicit device override with objects",
            "line": 675,
            "source": "const binding = binder.bindCombo([\n    'leftButton',\n    {deviceName: 'keyboard', controlName: 'leftButton'}\n], 'explicitOverride')\n\nexpect(binding.controls[0].deviceName).toBe('mouse')\nexpect(binding.controls[1].deviceName).toBe('keyboard')\nexpect(binding.controls[0].controlName).toBe('leftButton')\nexpect(binding.controls[1].controlName).toBe('leftButton')"
          },
          {
            "title": "validates controls array",
            "line": 688,
            "source": "expect(() => {\n    binder.bindCombo(['single'], 'invalid')\n}).toThrow('Controls must be an array with at least 2 controls')\n\nexpect(() => {\n    binder.bindCombo([], 'empty')\n}).toThrow('Controls must be an array with at least 2 controls')\n\nexpect(() => {\n    binder.bindCombo('not-array', 'invalid')\n}).toThrow('Controls must be an array with at least 2 controls')"
          },
          {
            "title": "validates control formats",
            "line": 703,
            "source": "expect(() => {\n    binder.bindCombo(['KeyA', null], 'invalid')\n}).toThrow('Control at index 1 must be a string or object with deviceName and controlName properties')\n\nexpect(() => {\n    binder.bindCombo(['KeyA', {}], 'invalid')\n}).toThrow('Control at index 1 must be a string or object with deviceName and controlName properties')\n\nexpect(() => {\n    binder.bindCombo(['KeyA', {deviceName: 'keyboard'}], 'invalid')\n}).toThrow('Control at index 1 must be a string or object with deviceName and controlName properties')"
          },
          {
            "title": "validates actionName",
            "line": 718,
            "source": "expect(() => {\n    binder.bindCombo(['KeyA', 'KeyB'], '')\n}).toThrow('actionName is required and must be a string')\n\nexpect(() => {\n    binder.bindCombo(['KeyA', 'KeyB'], null)\n}).toThrow('actionName is required and must be a string')"
          },
          {
            "title": "supports controller and eventType",
            "line": 729,
            "source": "const binding = binder.bindCombo(['KeyA', 'leftButton'], 'comboAction', 'player', 'released')\n\nexpect(binding.controllerName).toBe('player')\nexpect(binding.eventType).toBe('released')"
          },
          {
            "title": "maintains action index when bindings are added",
            "line": 737,
            "source": "binder.bindInput({\n    deviceName: 'keyboard',\n    controlName: 'KeyW',\n    actionName: 'moveUp',\n    controllerName: 'player1'\n})\n\nconst bindings = binder.getBindingsForAction('moveUp', 'player1')\nexpect(bindings).toHaveLength(1)\nexpect(bindings[0].controlName).toBe('KeyW')"
          },
          {
            "title": "maintains action index when bindings are removed",
            "line": 751,
            "source": "binder.bindInput({\n    deviceName: 'keyboard',\n    controlName: 'KeyW',\n    actionName: 'moveUp',\n    controllerName: 'player1'\n})\n\nbinder.bindInput({\n    deviceName: 'keyboard',\n    controlName: 'ArrowUp',\n    actionName: 'moveUp',\n    controllerName: 'player1'\n})\n\nexpect(binder.getBindingsForAction('moveUp', 'player1')).toHaveLength(2)\n\nbinder.unbind({\n    deviceName: 'keyboard',\n    controlName: 'KeyW',\n    actionName: 'moveUp',\n    controllerName: 'player1'\n})\n\nconst remaining = binder.getBindingsForAction('moveUp', 'player1')\nexpect(remaining).toHaveLength(1)\nexpect(remaining[0].controlName).toBe('ArrowUp')"
          },
          {
            "title": "clearBindings clears action index",
            "line": 781,
            "source": "binder.bindInput({\n    deviceName: 'keyboard',\n    controlName: 'Space',\n    actionName: 'jump'\n})\n\nbinder.bindInput({\n    deviceName: 'keyboard',\n    controlName: 'KeyW',\n    actionName: 'moveUp'\n})\n\nexpect(binder.getBindingsForAction('jump')).toHaveLength(1)\nexpect(binder.getBindingsForAction('moveUp')).toHaveLength(1)\n\nbinder.clearBindings()\n\nexpect(binder.getBindingsForAction('jump')).toHaveLength(0)\nexpect(binder.getBindingsForAction('moveUp')).toHaveLength(0)"
          },
          {
            "title": "action index handles multiple controllers",
            "line": 804,
            "source": "binder.bindInput({\n    deviceName: 'keyboard',\n    controlName: 'Space',\n    actionName: 'jump',\n    controllerName: 'player1'\n})\n\nbinder.bindInput({\n    deviceName: 'keyboard',\n    controlName: 'KeyW',\n    actionName: 'jump',\n    controllerName: 'player2'\n})\n\nexpect(binder.getBindingsForAction('jump', 'player1')).toHaveLength(1)\nexpect(binder.getBindingsForAction('jump', 'player2')).toHaveLength(1)\nexpect(binder.getBindingsForAction('jump', null)).toHaveLength(2)"
          },
          {
            "title": "importBindings adds multiple bindings from array",
            "line": 825,
            "source": "const bindings = [\n    {deviceName: 'keyboard', controlName: 'Space', actionName: 'jump'},\n    {deviceName: 'keyboard', controlName: 'KeyW', actionName: 'moveUp'},\n    {deviceName: 'mouse', controlName: 'leftButton', actionName: 'fire'}\n]\n\nbinder.importBindings(bindings)\n\nexpect(binder.getAllBindings()).toHaveLength(3)\nexpect(binder.hasBinding({actionName: 'jump'})).toBe(true)\nexpect(binder.hasBinding({actionName: 'moveUp'})).toBe(true)\nexpect(binder.hasBinding({actionName: 'fire'})).toBe(true)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/input/input_binding.doc.js": {
    "file": "/input/input_binding.test.js",
    "describes": [
      {
        "title": "InputBinding",
        "line": 4,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "construction with minimal parameters",
            "line": 6,
            "source": "const binding = new InputBinding({\n    deviceName: 'keyboard',\n    controlName: 'Space',\n    actionName: 'jump'\n})\n\nexpect(binding.deviceName).toBe('keyboard')\nexpect(binding.controlName).toBe('Space')\nexpect(binding.actionName).toBe('jump')\nexpect(binding.controllerName).toBeNull()\nexpect(binding.eventType).toBe('pressed')"
          },
          {
            "title": "construction with all parameters",
            "line": 21,
            "source": "const binding = new InputBinding({\n    deviceName: 'mouse',\n    controlName: 'LeftButton',\n    actionName: 'fire',\n    controllerName: 'game',\n    eventType: 'released'\n})\n\nexpect(binding.deviceName).toBe('mouse')\nexpect(binding.controlName).toBe('LeftButton')\nexpect(binding.actionName).toBe('fire')\nexpect(binding.controllerName).toBe('game')\nexpect(binding.eventType).toBe('released')"
          },
          {
            "title": "key generation for specific binding",
            "line": 38,
            "source": "const binding = new InputBinding({\n    deviceName: 'keyboard',\n    controlName: 'Escape',\n    actionName: 'openMenu',\n    controllerName: 'game',\n    eventType: 'pressed'\n})\n\nexpect(binding.key).toBe('keyboard:Escape:pressed:openMenu:game')"
          },
          {
            "title": "key generation for general binding",
            "line": 51,
            "source": "const binding = new InputBinding({\n    deviceName: 'keyboard',\n    controlName: 'Space',\n    actionName: 'jump',\n    eventType: 'released'\n})\n\nexpect(binding.key).toBe('keyboard:Space:released:jump')"
          },
          {
            "title": "matches with exact correspondence",
            "line": 63,
            "source": "const binding = new InputBinding({\n    deviceName: 'keyboard',\n    controlName: 'Space',\n    actionName: 'jump',\n    eventType: 'pressed'\n})\n\nexpect(binding.matches({deviceName: 'keyboard', controlName: 'Space', eventType: 'pressed'})).toBe(true)"
          },
          {
            "title": "matches with different device",
            "line": 75,
            "source": "const binding = new InputBinding({\n    deviceName: 'keyboard',\n    controlName: 'Space',\n    actionName: 'jump',\n    eventType: 'pressed'\n})\n\nexpect(binding.matches({deviceName: 'mouse', controlName: 'Space', eventType: 'pressed'})).toBe(false)"
          },
          {
            "title": "matches with different control",
            "line": 87,
            "source": "const binding = new InputBinding({\n    deviceName: 'keyboard',\n    controlName: 'Space',\n    actionName: 'jump',\n    eventType: 'pressed'\n})\n\nexpect(binding.matches({deviceName: 'keyboard', controlName: 'Enter', eventType: 'pressed'})).toBe(false)"
          },
          {
            "title": "matches with different eventType",
            "line": 99,
            "source": "const binding = new InputBinding({\n    deviceName: 'keyboard',\n    controlName: 'Space',\n    actionName: 'jump',\n    eventType: 'pressed'\n})\n\nexpect(binding.matches({deviceName: 'keyboard', controlName: 'Space', eventType: 'released'})).toBe(false)"
          },
          {
            "title": "updateInput modifies device and control",
            "line": 111,
            "source": "const binding = new InputBinding({\n    deviceName: 'keyboard',\n    controlName: 'Space',\n    actionName: 'jump'\n})\n\nbinding.updateInput({deviceName: 'mouse', controlName: 'LeftButton'})\n\nexpect(binding.deviceName).toBe('mouse')\nexpect(binding.controlName).toBe('LeftButton')\nexpect(binding.actionName).toBe('jump')\nexpect(binding.key).toBe('mouse:LeftButton:pressed:jump')"
          }
        ],
        "describes": []
      }
    ]
  },
  "/input/input_control.doc.js": {
    "file": "/input/input_control.test.js",
    "describes": [
      {
        "title": "InputControl",
        "line": 6,
        "beforeEach": {
          "line": 9,
          "source": "control = new InputControl({\n    device: null,\n    name: 'testControl'\n})"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor",
            "line": 17,
            "source": "expect(control.name).toBe('testControl')\nexpect(control.device).toBeNull()\nexpect(control.value).toBe(0)"
          },
          {
            "title": "constructor with value",
            "line": 24,
            "source": "const customControl = new InputControl({\n    device: null,\n    name: 'custom',\n    value: 42\n})\n\nexpect(customControl.value).toBe(42)"
          },
          {
            "title": "getDefaultValue",
            "line": 35,
            "source": "expect(control.getDefaultValue()).toBe(0)"
          },
          {
            "title": "value property access",
            "line": 40,
            "source": "expect(control.value).toBe(0)\n\ncontrol.value = 123\nexpect(control.value).toBe(123)\n\ncontrol.value = 'test'\nexpect(control.value).toBe('test')"
          },
          {
            "title": "oldValue property access",
            "line": 51,
            "source": "expect(control.oldValue).toBeNull()\n\ncontrol.value = 123\nexpect(control.oldValue).toBe(0)\n\ncontrol.value = 456\nexpect(control.oldValue).toBe(123)\n\ncontrol.value = 'test'\nexpect(control.oldValue).toBe(456)"
          },
          {
            "title": "value change notification",
            "line": 65,
            "source": "const listener = vi.fn()\ncontrol.on('updated', listener)\n\ncontrol.value = 456\nexpect(listener).toHaveBeenCalledWith(456, 0, null)\n\ncontrol.value = 789\nexpect(listener).toHaveBeenCalledWith(789, 456, null)"
          },
          {
            "title": "no notification when value unchanged",
            "line": 77,
            "source": "const listener = vi.fn()\ncontrol.on('updated', listener)\n\ncontrol.value = 123\nexpect(listener).toHaveBeenCalledTimes(1)\n\ncontrol.value = 123\nexpect(listener).toHaveBeenCalledTimes(1)"
          },
          {
            "title": "reset",
            "line": 89,
            "source": "control.value = 456\nexpect(control.value).toBe(456)\n\ncontrol.reset()\nexpect(control.value).toBe(0)"
          },
          {
            "title": "direct symbol access",
            "line": 98,
            "source": "expect(control[VALUE]).toBe(0)\nexpect(control[OLD_VALUE]).toBeNull()\n\ncontrol.value = 123\nexpect(control[VALUE]).toBe(123)\nexpect(control[OLD_VALUE]).toBe(0)\n\ncontrol.value = 456\nexpect(control[VALUE]).toBe(456)\nexpect(control[OLD_VALUE]).toBe(123)"
          },
          {
            "title": "symbols are shared across instances",
            "line": 112,
            "source": "const control1 = new InputControl({device: null, name: 'control1'})\nconst control2 = new InputControl({device: null, name: 'control2'})\n\nexpect(VALUE).toBe(VALUE)\nexpect(OLD_VALUE).toBe(OLD_VALUE)\n\ncontrol1.value = 123\ncontrol2.value = 456\n\nexpect(control1[VALUE]).toBe(123)\nexpect(control2[VALUE]).toBe(456)"
          },
          {
            "title": "setValue updates value and returns true",
            "line": 127,
            "source": "const result = control.setValue(100)\n\nexpect(result).toBe(true)\nexpect(control.value).toBe(100)"
          },
          {
            "title": "setValue returns false when value unchanged",
            "line": 135,
            "source": "control.setValue(50)\n\nconst result = control.setValue(50)\n\nexpect(result).toBe(false)"
          },
          {
            "title": "setValue passes event to updated notification",
            "line": 144,
            "source": "const listener = vi.fn()\ncontrol.on('updated', listener)\n\nconst mockEvent = {type: 'keydown'}\ncontrol.setValue(200, mockEvent)\n\nexpect(listener).toHaveBeenCalledWith(200, 0, mockEvent)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/input/input_device.doc.js": {
    "file": "/input/input_device.test.js",
    "describes": [
      {
        "title": "InputDevice",
        "line": 7,
        "beforeEach": {
          "line": 10,
          "source": "device = new InputDevice({\n    $id: 'testDevice'\n})"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor",
            "line": 17,
            "source": "expect(device.$id).toBe('testDevice')\nexpect(device.container).toBe(window)\nexpect(device.controls).toBeDefined()\nexpect(device.pressedNames).toBeInstanceOf(Set)\nexpect(device.pressedNames.size).toBe(0)"
          },
          {
            "title": "constructor with custom container",
            "line": 26,
            "source": "const customContainer = document.createElement('div')\nconst customDevice = new InputDevice({\n    container: customContainer,\n    $id: 'custom'\n})\n\nexpect(customDevice.container).toBe(customContainer)\nexpect(customDevice.$id).toBe('custom')"
          },
          {
            "title": "constructor with default name",
            "line": 38,
            "source": "const defaultDevice = new InputDevice()\nexpect(defaultDevice.$id).toBe('InputDevice')"
          },
          {
            "title": "registerControl",
            "line": 44,
            "source": "const control = new InputControl({\n    device: device,\n    name: 'testControl'\n})\n\nexpect(device.registerControl(control)).toBe(true)\nexpect(device.controls.has('testControl')).toBe(true)\nexpect(device.getControl('testControl')).toBe(control)"
          },
          {
            "title": "registerControl with duplicate name",
            "line": 56,
            "source": "const control1 = new InputControl({\n    device: device,\n    name: 'duplicate'\n})\nconst control2 = new InputControl({\n    device: device,\n    name: 'duplicate'\n})\n\nexpect(device.registerControl(control1)).toBe(true)\nexpect(device.registerControl(control2)).toBe(false)\nexpect(device.getControl('duplicate')).toBe(control1)"
          },
          {
            "title": "registerControl with invalid control",
            "line": 72,
            "source": "expect(() => device.registerControl(null)).toThrow('Control must have a name')\nexpect(() => device.registerControl({})).toThrow('Control must have a name')\nexpect(() => device.registerControl({name: ''})).toThrow('Control must have a name')"
          },
          {
            "title": "getControl",
            "line": 79,
            "source": "const control = new InputControl({\n    device: device,\n    name: 'getTest'\n})\n\ndevice.registerControl(control)\nexpect(device.getControl('getTest')).toBe(control)\nexpect(device.getControl('nonexistent')).toBeUndefined()"
          },
          {
            "title": "getValueFor",
            "line": 91,
            "source": "const control = device.findOrCreateControl(InputControl, {\n    name: 'valueTest'\n})\n\ncontrol.value = 123\nexpect(device.getValueFor('valueTest')).toBe(123)\n\ncontrol.value = 'hello'\nexpect(device.getValueFor('valueTest')).toBe('hello')\n\nexpect(device.getValueFor('nonexistent')).toBeUndefined()"
          },
          {
            "title": "isPressed",
            "line": 106,
            "source": "const button = device.findOrCreateControl(ButtonControl, {\n    name: 'pressTest'\n})\n\nexpect(device.isPressed('pressTest')).toBe(false)\nexpect(device.isPressed('nonexistent')).toBe(false)\n\nbutton.press()\nexpect(device.isPressed('pressTest')).toBe(true)\n\nbutton.release()\nexpect(device.isPressed('pressTest')).toBe(false)"
          },
          {
            "title": "findOrCreateControl creates new control",
            "line": 122,
            "source": "const control = device.findOrCreateControl(InputControl, {\n    name: 'newControl'\n})\n\nexpect(control).toBeInstanceOf(InputControl)\nexpect(control.name).toBe('newControl')\nexpect(control.device).toBe(device)\nexpect(device.getControl('newControl')).toBe(control)"
          },
          {
            "title": "findOrCreateControl returns existing control",
            "line": 134,
            "source": "const existingControl = new InputControl({\n    device: device,\n    name: 'existing'\n})\ndevice.registerControl(existingControl)\n\nconst foundControl = device.findOrCreateControl(InputControl, {\n    name: 'existing'\n})\n\nexpect(foundControl).toBe(existingControl)"
          },
          {
            "title": "findOrCreateControl with additional params",
            "line": 149,
            "source": "const control = device.findOrCreateControl(ButtonControl, {\n    name: 'buttonTest',\n    pressThreshold: 0.5\n})\n\nexpect(control).toBeInstanceOf(ButtonControl)\nexpect(control.name).toBe('buttonTest')\nexpect(control.pressThreshold).toBe(0.5)\nexpect(control.device).toBe(device)"
          },
          {
            "title": "findOrCreateControl without name throws error",
            "line": 162,
            "source": "expect(() => {\n    device.findOrCreateControl(InputControl, {})\n}).toThrow('Control must have a name')\n\nexpect(() => {\n    device.findOrCreateControl(InputControl, {name: ''})\n}).toThrow('Control must have a name')"
          },
          {
            "title": "control event propagation - pressed",
            "line": 173,
            "source": "const controlPressedListener = vi.fn()\ndevice.on('control:pressed', controlPressedListener)\n\nconst button = device.findOrCreateControl(ButtonControl, {\n    name: 'testButton'\n})\n\nbutton.press()\n\nexpect(controlPressedListener).toHaveBeenCalledWith(button, null, device)\nexpect(device.pressedNames.has('testButton')).toBe(true)"
          },
          {
            "title": "control event propagation - released",
            "line": 188,
            "source": "const controlReleasedListener = vi.fn()\ndevice.on('control:released', controlReleasedListener)\n\nconst button = device.findOrCreateControl(ButtonControl, {\n    name: 'testButton'\n})\n\nbutton.press()\nexpect(device.pressedNames.has('testButton')).toBe(true)\n\nbutton.release()\nexpect(controlReleasedListener).toHaveBeenCalledWith(button, null, device)\nexpect(device.pressedNames.has('testButton')).toBe(false)"
          },
          {
            "title": "control event propagation - updated",
            "line": 205,
            "source": "const controlUpdatedListener = vi.fn()\ndevice.on('control:updated', controlUpdatedListener)\n\nconst control = device.findOrCreateControl(InputControl, {\n    name: 'testControl'\n})\n\ncontrol.value = 42\n\nexpect(controlUpdatedListener).toHaveBeenCalledWith(control, 42, 0, null, device)"
          },
          {
            "title": "control event propagation - updated forwards event for ButtonControl",
            "line": 218,
            "source": "const controlUpdatedListener = vi.fn()\ndevice.on('control:updated', controlUpdatedListener)\n\nconst button = device.findOrCreateControl(ButtonControl, {\n    name: 'testButton'\n})\n\nconst mockEvent = {type: 'mock'}\nbutton.setValue(0.5, mockEvent)\n\nexpect(controlUpdatedListener).toHaveBeenCalledWith(button, 0.5, 0, mockEvent, device)"
          },
          {
            "title": "multiple pressed controls tracking",
            "line": 233,
            "source": "const button1 = device.findOrCreateControl(ButtonControl, {name: 'button1'})\nconst button2 = device.findOrCreateControl(ButtonControl, {name: 'button2'})\n\nbutton1.press()\nexpect(device.pressedNames.size).toBe(1)\nexpect(device.pressedNames.has('button1')).toBe(true)\n\nbutton2.press()\nexpect(device.pressedNames.size).toBe(2)\nexpect(device.pressedNames.has('button1')).toBe(true)\nexpect(device.pressedNames.has('button2')).toBe(true)\n\nbutton1.release()\nexpect(device.pressedNames.size).toBe(1)\nexpect(device.pressedNames.has('button1')).toBe(false)\nexpect(device.pressedNames.has('button2')).toBe(true)"
          },
          {
            "title": "control removal cleans up event listeners",
            "line": 253,
            "source": "const button = device.findOrCreateControl(ButtonControl, {name: 'removeTest'})\n\nbutton.press()\nexpect(device.pressedNames.has('removeTest')).toBe(true)\n\ndevice.controls.delete('removeTest')\n\nexpect(device.pressedNames.has('removeTest')).toBe(false)"
          },
          {
            "title": "shouldPreventDefaultFor with undefined/false",
            "line": 265,
            "source": "const event = {preventDefault: vi.fn()}\nconst control = {name: 'test'}\n\nexpect(device.shouldPreventDefaultFor(event, control)).toBe(false)\n\ndevice.shouldPreventDefault = false\nexpect(device.shouldPreventDefaultFor(event, control)).toBe(false)"
          },
          {
            "title": "shouldPreventDefaultFor with true",
            "line": 276,
            "source": "const event = {preventDefault: vi.fn()}\nconst control = {name: 'test'}\n\ndevice.shouldPreventDefault = true\nexpect(device.shouldPreventDefaultFor(event, control)).toBe(true)"
          },
          {
            "title": "shouldPreventDefaultFor with function",
            "line": 285,
            "source": "const event = {preventDefault: vi.fn(), ctrlKey: true}\nconst control = {name: 'KeyR'}\n\ndevice.shouldPreventDefault = (evt, ctrl, dev) => {\n    expect(dev).toBe(device)\n    return ctrl.name === 'KeyR' && evt.ctrlKey\n}\n\nexpect(device.shouldPreventDefaultFor(event, control)).toBe(true)\n\nconst anotherEvent = {preventDefault: vi.fn(), ctrlKey: false}\nexpect(device.shouldPreventDefaultFor(anotherEvent, control)).toBe(false)"
          },
          {
            "title": "preventDefault when shouldPreventDefaultFor returns true",
            "line": 301,
            "source": "const target = document.createElement('div')\nconst event = {preventDefault: vi.fn(), stopPropagation: vi.fn(), target}\nconst control = {name: 'test'}\n\ndevice.shouldPreventDefault = true\ndevice.preventDefault(event, control)\n\nexpect(event.preventDefault).toHaveBeenCalledTimes(1)\nexpect(event.stopPropagation).toHaveBeenCalledTimes(1)"
          },
          {
            "title": "preventDefault when shouldPreventDefaultFor returns false",
            "line": 314,
            "source": "const event = {preventDefault: vi.fn(), stopPropagation: vi.fn()}\nconst control = {name: 'test'}\n\ndevice.shouldPreventDefault = false\ndevice.preventDefault(event, control)\n\nexpect(event.preventDefault).not.toHaveBeenCalled()\nexpect(event.stopPropagation).not.toHaveBeenCalled()"
          },
          {
            "title": "preventDefault with null control",
            "line": 326,
            "source": "const event = {preventDefault: vi.fn(), stopPropagation: vi.fn()}\n\ndevice.shouldPreventDefault = true\ndevice.preventDefault(event, null)\n\nexpect(event.preventDefault).not.toHaveBeenCalled()\nexpect(event.stopPropagation).not.toHaveBeenCalled()"
          },
          {
            "title": "preventDefault with function condition",
            "line": 337,
            "source": "const target = document.createElement('div')\nconst event = {preventDefault: vi.fn(), stopPropagation: vi.fn(), ctrlKey: true, target}\nconst control = {name: 'KeyR'}\n\ndevice.shouldPreventDefault = (evt, ctrl) => ctrl.name === 'KeyR' && evt.ctrlKey\ndevice.preventDefault(event, control)\n\nexpect(event.preventDefault).toHaveBeenCalledTimes(1)\nexpect(event.stopPropagation).toHaveBeenCalledTimes(1)"
          },
          {
            "title": "preventDefault skips interactive button target",
            "line": 350,
            "source": "const target = document.createElement('button')\nconst event = {preventDefault: vi.fn(), stopPropagation: vi.fn(), target}\nconst control = {name: 'test'}\n\ndevice.shouldPreventDefault = true\ndevice.preventDefault(event, control)\n\nexpect(event.preventDefault).not.toHaveBeenCalled()\nexpect(event.stopPropagation).not.toHaveBeenCalled()"
          },
          {
            "title": "preventDefault skips interactive input target",
            "line": 363,
            "source": "const target = document.createElement('input')\nconst event = {preventDefault: vi.fn(), stopPropagation: vi.fn(), target}\nconst control = {name: 'test'}\n\ndevice.shouldPreventDefault = true\ndevice.preventDefault(event, control)\n\nexpect(event.preventDefault).not.toHaveBeenCalled()\nexpect(event.stopPropagation).not.toHaveBeenCalled()"
          },
          {
            "title": "preventDefault skips element with interactive class",
            "line": 376,
            "source": "const target = document.createElement('div')\ntarget.classList.add('interactive')\nconst event = {preventDefault: vi.fn(), stopPropagation: vi.fn(), target}\nconst control = {name: 'test'}\n\ndevice.shouldPreventDefault = true\ndevice.preventDefault(event, control)\n\nexpect(event.preventDefault).not.toHaveBeenCalled()\nexpect(event.stopPropagation).not.toHaveBeenCalled()"
          },
          {
            "title": "preventDefault skips child of interactive element",
            "line": 390,
            "source": "const button = document.createElement('button')\nconst span = document.createElement('span')\nbutton.appendChild(span)\nconst event = {preventDefault: vi.fn(), stopPropagation: vi.fn(), target: span}\nconst control = {name: 'test'}\n\ndevice.shouldPreventDefault = true\ndevice.preventDefault(event, control)\n\nexpect(event.preventDefault).not.toHaveBeenCalled()\nexpect(event.stopPropagation).not.toHaveBeenCalled()"
          },
          {
            "title": "event listeners are properly removed when control is deleted from registry",
            "line": 405,
            "source": "const button = new ButtonControl({device: device, name: 'listenerTest'})\n\nconst onSpy = vi.spyOn(button, 'on')\nconst offSpy = vi.spyOn(button, 'off')\n\ndevice.registerControl(button)\n\nexpect(onSpy).toHaveBeenCalledTimes(3)\nexpect(onSpy).toHaveBeenCalledWith('pressed', expect.any(Function))\nexpect(onSpy).toHaveBeenCalledWith('released', expect.any(Function))\nexpect(onSpy).toHaveBeenCalledWith('updated', expect.any(Function))\n\nconst pressedListener = onSpy.mock.calls.find(call => call[0] === 'pressed')[1]\nconst releasedListener = onSpy.mock.calls.find(call => call[0] === 'released')[1]\nconst updatedListener = onSpy.mock.calls.find(call => call[0] === 'updated')[1]\n\ndevice.controls.delete('listenerTest')\n\nexpect(offSpy).toHaveBeenCalledTimes(3)\nexpect(offSpy).toHaveBeenCalledWith('pressed', pressedListener)\nexpect(offSpy).toHaveBeenCalledWith('released', releasedListener)\nexpect(offSpy).toHaveBeenCalledWith('updated', updatedListener)"
          },
          {
            "title": "onDispose clears all controls",
            "line": 431,
            "source": "const button1 = device.findOrCreateControl(ButtonControl, {name: 'button1'})\nconst button2 = device.findOrCreateControl(ButtonControl, {name: 'button2'})\n\nbutton1.press()\nbutton2.press()\n\nexpect(device.controls.size).toBe(2)\nexpect(device.pressedNames.size).toBe(2)\n\ndevice.dispose()\n\nexpect(device.controls.size).toBe(0)\nexpect(device.pressedNames.size).toBe(0)"
          },
          {
            "title": "getPressedControls returns array of pressed control objects",
            "line": 448,
            "source": "const button1 = device.findOrCreateControl(ButtonControl, {name: 'button1'})\nconst button2 = device.findOrCreateControl(ButtonControl, {name: 'button2'})\ndevice.findOrCreateControl(ButtonControl, {name: 'button3'})\n\nexpect(device.getPressedControls()).toEqual([])\n\nbutton1.press()\nexpect(device.getPressedControls()).toEqual([button1])\n\nbutton2.press()\nconst pressed = device.getPressedControls()\nexpect(pressed).toHaveLength(2)\nexpect(pressed).toContain(button1)\nexpect(pressed).toContain(button2)\n\nbutton1.release()\nexpect(device.getPressedControls()).toEqual([button2])"
          }
        ],
        "describes": []
      }
    ]
  },
  "/input/input_controls/button_control.doc.js": {
    "file": "/input/input_controls/button_control.test.js",
    "describes": [
      {
        "title": "ButtonControl",
        "line": 6,
        "beforeEach": {
          "line": 10,
          "source": "control = new ButtonControl({\n    device: null,\n    name: 'testButton'\n})"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "static defaultPressThreshold",
            "line": 18,
            "source": "expect(ButtonControl.defaultPressThreshold).toBe(0.1)"
          },
          {
            "title": "constructor",
            "line": 23,
            "source": "expect(control).toBeInstanceOf(InputControl)\nexpect(control.name).toBe('testButton')\nexpect(control.value).toBe(0)\nexpect(control.pressThreshold).toBe(0.1)"
          },
          {
            "title": "constructor with custom pressThreshold",
            "line": 31,
            "source": "const customControl = new ButtonControl({\n    device: null,\n    name: 'custom',\n    pressThreshold: 0.2\n})\n\nexpect(customControl.pressThreshold).toBe(0.2)"
          },
          {
            "title": "isPressed getter",
            "line": 42,
            "source": "expect(control.isPressed).toBe(false)\n\ncontrol.value = 0.05\nexpect(control.isPressed).toBe(false)\n\ncontrol.value = 0.1\nexpect(control.isPressed).toBe(true)\n\ncontrol.value = 0.8\nexpect(control.isPressed).toBe(true)"
          },
          {
            "title": "wasPressed getter",
            "line": 56,
            "source": "expect(control.wasPressed).toBe(false)\n\ncontrol.value = 0.15\nexpect(control.wasPressed).toBe(false)\n\ncontrol.value = 0.05\nexpect(control.wasPressed).toBe(true)"
          },
          {
            "title": "pressed event emission",
            "line": 67,
            "source": "const pressedListener = vi.fn()\ncontrol.on('pressed', pressedListener)\n\ncontrol.value = 0.15\nexpect(pressedListener).toHaveBeenCalledTimes(1)\nexpect(pressedListener).toHaveBeenCalledWith(null)\n\ncontrol.value = 0.5\nexpect(pressedListener).toHaveBeenCalledTimes(1)"
          },
          {
            "title": "released event emission",
            "line": 80,
            "source": "const releasedListener = vi.fn()\ncontrol.on('released', releasedListener)\n\ncontrol.value = 0.15\ncontrol.value = 0.05\nexpect(releasedListener).toHaveBeenCalledTimes(1)\n\ncontrol.value = 0.02\nexpect(releasedListener).toHaveBeenCalledTimes(1)"
          },
          {
            "title": "press and release cycle",
            "line": 93,
            "source": "const pressedListener = vi.fn()\nconst releasedListener = vi.fn()\n\ncontrol.on('pressed', pressedListener)\ncontrol.on('released', releasedListener)\n\ncontrol.value = 0.2\nexpect(pressedListener).toHaveBeenCalledTimes(1)\nexpect(releasedListener).toHaveBeenCalledTimes(0)\n\ncontrol.value = 0.05\nexpect(pressedListener).toHaveBeenCalledTimes(1)\nexpect(releasedListener).toHaveBeenCalledTimes(1)"
          },
          {
            "title": "setValue return value",
            "line": 110,
            "source": "expect(control.setValue(0.5)).toBe(true)\nexpect(control.setValue(0.5)).toBe(false)\nexpect(control.setValue(0.3)).toBe(true)"
          },
          {
            "title": "no events when value unchanged",
            "line": 117,
            "source": "const pressedListener = vi.fn()\nconst releasedListener = vi.fn()\n\ncontrol.on('pressed', pressedListener)\ncontrol.on('released', releasedListener)\n\ncontrol.value = 0.5\ncontrol.value = 0.5\n\nexpect(pressedListener).toHaveBeenCalledTimes(1)\nexpect(releasedListener).toHaveBeenCalledTimes(0)"
          },
          {
            "title": "custom threshold behavior",
            "line": 132,
            "source": "const customControl = new ButtonControl({\n    device: null,\n    name: 'custom',\n    pressThreshold: 0.1\n})\n\nexpect(customControl.isPressed).toBe(false)\n\ncustomControl.value = 0.05\nexpect(customControl.isPressed).toBe(false)\n\ncustomControl.value = 0.15\nexpect(customControl.isPressed).toBe(true)"
          },
          {
            "title": "press method",
            "line": 149,
            "source": "const pressedListener = vi.fn()\ncontrol.on('pressed', pressedListener)\n\ncontrol.press()\nexpect(control.value).toBe(1)\nexpect(control.isPressed).toBe(true)\nexpect(pressedListener).toHaveBeenCalledTimes(1)\nexpect(pressedListener).toHaveBeenCalledWith(null)"
          },
          {
            "title": "press method with event",
            "line": 160,
            "source": "const pressedListener = vi.fn()\ncontrol.on('pressed', pressedListener)\n\nconst mockEvent = {preventDefault: vi.fn()}\ncontrol.press(mockEvent)\n\nexpect(pressedListener).toHaveBeenCalledWith(mockEvent)"
          },
          {
            "title": "setValue with event",
            "line": 171,
            "source": "const pressedListener = vi.fn()\ncontrol.on('pressed', pressedListener)\n\nconst mockEvent = {preventDefault: vi.fn()}\ncontrol.setValue(1, mockEvent)\n\nexpect(pressedListener).toHaveBeenCalledWith(mockEvent)"
          },
          {
            "title": "updated includes event when provided",
            "line": 181,
            "source": "const updatedListener = vi.fn()\ncontrol.on('updated', updatedListener)\n\nconst mockEvent = {type: 'mock'}\ncontrol.setValue(0.2, mockEvent)\n\nexpect(updatedListener).toHaveBeenCalledWith(0.2, 0, mockEvent)"
          },
          {
            "title": "release method",
            "line": 192,
            "source": "const releasedListener = vi.fn()\ncontrol.on('released', releasedListener)\n\ncontrol.value = 0.8\nexpect(control.isPressed).toBe(true)\n\ncontrol.release()\nexpect(control.value).toBe(0)\nexpect(control.isPressed).toBe(false)\nexpect(releasedListener).toHaveBeenCalledTimes(1)"
          },
          {
            "title": "press and release methods cycle",
            "line": 206,
            "source": "const pressedListener = vi.fn()\nconst releasedListener = vi.fn()\n\ncontrol.on('pressed', pressedListener)\ncontrol.on('released', releasedListener)\n\ncontrol.press()\nexpect(pressedListener).toHaveBeenCalledTimes(1)\nexpect(releasedListener).toHaveBeenCalledTimes(0)\n\ncontrol.release()\nexpect(pressedListener).toHaveBeenCalledTimes(1)\nexpect(releasedListener).toHaveBeenCalledTimes(1)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/input/input_controls/navigation_control.doc.js": {
    "file": "/input/input_controls/navigation_control.test.js",
    "describes": [
      {
        "title": "NavigationControl",
        "line": 6,
        "beforeEach": {
          "line": 12,
          "source": "mockDevice = {name: 'testDevice'}\ncontrol = new NavigationControl({\n    device: mockDevice,\n    name: 'navigation'\n})"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor",
            "line": 21,
            "source": "expect(control).toBeInstanceOf(InputControl)\nexpect(control.device).toBe(mockDevice)\nexpect(control.name).toBe('navigation')"
          },
          {
            "title": "getDefaultValue returns zero deltas",
            "line": 28,
            "source": "const defaultValue = control.getDefaultValue()\nexpect(defaultValue).toEqual({deltaX: 0, deltaY: 0, deltaZ: 0, event: null})"
          },
          {
            "title": "initial value is zero deltas",
            "line": 34,
            "source": "expect(control.value).toEqual({deltaX: 0, deltaY: 0, deltaZ: 0, event: null})\nexpect(control.deltaX).toBe(0)\nexpect(control.deltaY).toBe(0)\nexpect(control.deltaZ).toBe(0)"
          },
          {
            "title": "setValue with wheel event updates deltas",
            "line": 42,
            "source": "const wheelEvent = {deltaX: 10, deltaY: -5, deltaZ: 2}\n\ncontrol.setValue(wheelEvent)\n\nexpect(control.value).toEqual({deltaX: 10, deltaY: -5, deltaZ: 2, event: wheelEvent})\nexpect(control.deltaX).toBe(10)\nexpect(control.deltaY).toBe(-5)\nexpect(control.deltaZ).toBe(2)"
          },
          {
            "title": "setValue with partial wheel event fills missing deltas with zero",
            "line": 54,
            "source": "const wheelEvent = {deltaY: 100}\n\ncontrol.setValue(wheelEvent)\n\nexpect(control.value).toEqual({deltaX: 0, deltaY: 100, deltaZ: 0, event: wheelEvent})\nexpect(control.deltaY).toBe(100)"
          },
          {
            "title": "setValue emits updated event",
            "line": 64,
            "source": "const listener = vi.fn()\ncontrol.on('updated', listener)\n\nconst wheelEvent = {deltaY: 50}\nconst mockEvent = {type: 'wheel'}\n\ncontrol.setValue(wheelEvent, mockEvent)\n\nexpect(listener).toHaveBeenCalledWith(\n    {deltaX: 0, deltaY: 50, deltaZ: 0, event: wheelEvent},\n    {deltaX: 0, deltaY: 0, deltaZ: 0, event: null},\n    mockEvent\n)"
          },
          {
            "title": "setValue always returns true and emits even for identical deltas",
            "line": 81,
            "source": "const listener = vi.fn()\ncontrol.on('updated', listener)\n\nconst wheelEvent = {deltaY: 25}\n\nconst result1 = control.setValue(wheelEvent)\nconst result2 = control.setValue(wheelEvent)\n\nexpect(result1).toBe(true)\nexpect(result2).toBe(true)\nexpect(listener).toHaveBeenCalledTimes(2)"
          },
          {
            "title": "setValue preserves value until next setValue",
            "line": 96,
            "source": "const wheelEvent1 = {deltaY: 75}\ncontrol.setValue(wheelEvent1)\n\nexpect(control.value).toEqual({deltaX: 0, deltaY: 75, deltaZ: 0, event: wheelEvent1})\n\nconst wheelEvent2 = {deltaY: 100}\ncontrol.setValue(wheelEvent2)\n\nexpect(control.value).toEqual({deltaX: 0, deltaY: 100, deltaZ: 0, event: wheelEvent2})"
          },
          {
            "title": "oldValue tracking works correctly",
            "line": 109,
            "source": "const wheelEvent1 = {deltaY: 10}\nconst wheelEvent2 = {deltaY: 20}\n\ncontrol.setValue(wheelEvent1)\nexpect(control.oldValue).toEqual({deltaX: 0, deltaY: 0, deltaZ: 0, event: null})\n\ncontrol.setValue(wheelEvent2)\nexpect(control.oldValue).toEqual({deltaX: 0, deltaY: 10, deltaZ: 0, event: wheelEvent1})"
          }
        ],
        "describes": []
      }
    ]
  },
  "/input/input_controls/vec2_control.doc.js": {
    "file": "/input/input_controls/vec2_control.test.js",
    "describes": [
      {
        "title": "Vec2Control",
        "line": 8,
        "beforeEach": {
          "line": 12,
          "source": "control = new Vec2Control({\n    device: null,\n    name: 'testVec2'\n})"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor",
            "line": 20,
            "source": "expect(control).toBeInstanceOf(InputControl)\nexpect(control.name).toBe('testVec2')\nexpect(control.value).toBeInstanceOf(Vec2)\nexpect(control.value.x).toBe(0)\nexpect(control.value.y).toBe(0)"
          },
          {
            "title": "constructor with Vec2 value",
            "line": 29,
            "source": "const customControl = new Vec2Control({\n    device: null,\n    name: 'custom',\n    value: new Vec2(3, 4)\n})\n\nexpect(customControl.value).toBeInstanceOf(Vec2)\nexpect(customControl.value.x).toBe(3)\nexpect(customControl.value.y).toBe(4)"
          },
          {
            "title": "getDefaultValue",
            "line": 41,
            "source": "const defaultValue = control.getDefaultValue()\nexpect(defaultValue).toBeInstanceOf(Vec2)\nexpect(defaultValue.x).toBe(0)\nexpect(defaultValue.y).toBe(0)"
          },
          {
            "title": "setValue with Vec2",
            "line": 49,
            "source": "const newVec = new Vec2(5, 6)\nexpect(control.setValue(newVec)).toBe(true)\nexpect(control.value.x).toBe(5)\nexpect(control.value.y).toBe(6)\nexpect(control.value).not.toBe(newVec) // Should be a new instance"
          },
          {
            "title": "setValue with object",
            "line": 57,
            "source": "expect(control.setValue({x: 7, y: 8})).toBe(true)\nexpect(control.value).toBeInstanceOf(Vec2)\nexpect(control.value.x).toBe(7)\nexpect(control.value.y).toBe(8)"
          },
          {
            "title": "setValue with array",
            "line": 65,
            "source": "expect(control.setValue([9, 10])).toBe(true)\nexpect(control.value).toBeInstanceOf(Vec2)\nexpect(control.value.x).toBe(9)\nexpect(control.value.y).toBe(10)"
          },
          {
            "title": "setValue with single number",
            "line": 73,
            "source": "expect(control.setValue(11)).toBe(true)\nexpect(control.value).toBeInstanceOf(Vec2)\nexpect(control.value.x).toBe(11)\nexpect(control.value.y).toBe(0)"
          },
          {
            "title": "setValue return value",
            "line": 81,
            "source": "expect(control.setValue(new Vec2(1, 2))).toBe(true)\nexpect(control.setValue(new Vec2(1, 2))).toBe(false) // Same value\nexpect(control.setValue(new Vec2(3, 4))).toBe(true)"
          },
          {
            "title": "value change notification",
            "line": 88,
            "source": "const listener = vi.fn()\ncontrol.on('updated', listener)\n\nconst newVec = new Vec2(13, 14)\ncontrol.setValue(newVec)\n\nexpect(listener).toHaveBeenCalledTimes(1)\nexpect(listener).toHaveBeenCalledWith(\n    expect.objectContaining({x: 13, y: 14}),\n    expect.objectContaining({x: 0, y: 0}),\n    null\n)"
          },
          {
            "title": "no notification when value unchanged",
            "line": 104,
            "source": "const listener = vi.fn()\ncontrol.on('updated', listener)\n\ncontrol.setValue(new Vec2(15, 16))\nexpect(listener).toHaveBeenCalledTimes(1)\n\ncontrol.setValue(new Vec2(15, 16))\nexpect(listener).toHaveBeenCalledTimes(1) // No additional call"
          },
          {
            "title": "oldValue tracking",
            "line": 116,
            "source": "control.setValue(new Vec2(17, 18))\nexpect(control.oldValue.x).toBe(0)\nexpect(control.oldValue.y).toBe(0)\n\ncontrol.setValue(new Vec2(19, 20))\nexpect(control.oldValue.x).toBe(17)\nexpect(control.oldValue.y).toBe(18)"
          },
          {
            "title": "value property setter",
            "line": 127,
            "source": "control.value = new Vec2(21, 22)\nexpect(control.value.x).toBe(21)\nexpect(control.value.y).toBe(22)"
          },
          {
            "title": "reset",
            "line": 134,
            "source": "control.setValue(new Vec2(23, 24))\nexpect(control.value.x).toBe(23)\nexpect(control.value.y).toBe(24)\n\ncontrol.reset()\nexpect(control.value.x).toBe(0)\nexpect(control.value.y).toBe(0)"
          },
          {
            "title": "direct symbol access",
            "line": 145,
            "source": "expect(control[VALUE]).toBeInstanceOf(Vec2)\nexpect(control[OLD_VALUE]).toBeNull()\n\ncontrol.setValue(new Vec2(25, 26))\nexpect(control[VALUE].x).toBe(25)\nexpect(control[VALUE].y).toBe(26)\nexpect(control[OLD_VALUE].x).toBe(0)\nexpect(control[OLD_VALUE].y).toBe(0)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/input/input_controls/vec3_control.doc.js": {
    "file": "/input/input_controls/vec3_control.test.js",
    "describes": [
      {
        "title": "Vec3Control",
        "line": 9,
        "beforeEach": {
          "line": 12,
          "source": "control = new Vec3Control({\n    device: null,\n    name: 'testVec3'\n})"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor",
            "line": 20,
            "source": "expect(control).toBeInstanceOf(InputControl)\nexpect(control.name).toBe('testVec3')\nexpect(control.value).toBeInstanceOf(Vec3)\nexpect(control.value.x).toBe(0)\nexpect(control.value.y).toBe(0)\nexpect(control.value.z).toBe(0)"
          },
          {
            "title": "constructor with Vec3 value",
            "line": 30,
            "source": "const customControl = new Vec3Control({\n    device: null,\n    name: 'custom',\n    value: new Vec3(3, 4, 5)\n})\n\nexpect(customControl.value).toBeInstanceOf(Vec3)\nexpect(customControl.value.x).toBe(3)\nexpect(customControl.value.y).toBe(4)\nexpect(customControl.value.z).toBe(5)"
          },
          {
            "title": "getDefaultValue",
            "line": 44,
            "source": "const defaultValue = control.getDefaultValue()\nexpect(defaultValue).toBeInstanceOf(Vec3)\nexpect(defaultValue.x).toBe(0)\nexpect(defaultValue.y).toBe(0)\nexpect(defaultValue.z).toBe(0)"
          },
          {
            "title": "setValue with Vec3",
            "line": 53,
            "source": "const newVec = new Vec3(5, 6, 7)\nexpect(control.setValue(newVec)).toBe(true)\nexpect(control.value.x).toBe(5)\nexpect(control.value.y).toBe(6)\nexpect(control.value.z).toBe(7)\nexpect(control.value).not.toBe(newVec)"
          },
          {
            "title": "setValue with object",
            "line": 63,
            "source": "expect(control.setValue({x: 7, y: 8, z: 9})).toBe(true)\nexpect(control.value).toBeInstanceOf(Vec3)\nexpect(control.value.x).toBe(7)\nexpect(control.value.y).toBe(8)\nexpect(control.value.z).toBe(9)"
          },
          {
            "title": "setValue with array",
            "line": 72,
            "source": "expect(control.setValue([9, 10, 11])).toBe(true)\nexpect(control.value).toBeInstanceOf(Vec3)\nexpect(control.value.x).toBe(9)\nexpect(control.value.y).toBe(10)\nexpect(control.value.z).toBe(11)"
          },
          {
            "title": "setValue with single number",
            "line": 80,
            "source": "expect(control.setValue(12)).toBe(true)\nexpect(control.value).toBeInstanceOf(Vec3)\nexpect(control.value.x).toBe(12)\nexpect(control.value.y).toBe(0)\nexpect(control.value.z).toBe(0)"
          },
          {
            "title": "setValue return value",
            "line": 89,
            "source": "expect(control.setValue(new Vec3(1, 2, 3))).toBe(true)\nexpect(control.setValue(new Vec3(1, 2, 3))).toBe(false)\nexpect(control.setValue(new Vec3(4, 5, 6))).toBe(true)"
          },
          {
            "title": "value change notification",
            "line": 96,
            "source": "const listener = vi.fn()\ncontrol.on('updated', listener)\n\nconst newVec = new Vec3(13, 14, 15)\ncontrol.setValue(newVec)\n\nexpect(listener).toHaveBeenCalledTimes(1)\nexpect(listener).toHaveBeenCalledWith(\n    expect.objectContaining({x: 13, y: 14, z: 15}),\n    expect.objectContaining({x: 0, y: 0, z: 0}),\n    null\n)"
          },
          {
            "title": "value change notification with event",
            "line": 112,
            "source": "const listener = vi.fn()\ncontrol.on('updated', listener)\n\nconst event = {type: 'test'}\nconst newVec = new Vec3(13, 14, 15)\ncontrol.setValue(newVec, event)\n\nexpect(listener).toHaveBeenCalledTimes(1)\nexpect(listener).toHaveBeenCalledWith(\n    expect.objectContaining({x: 13, y: 14, z: 15}),\n    expect.objectContaining({x: 0, y: 0, z: 0}),\n    event\n)"
          },
          {
            "title": "no notification when value unchanged",
            "line": 129,
            "source": "const listener = vi.fn()\ncontrol.on('updated', listener)\n\ncontrol.setValue(new Vec3(16, 17, 18))\nexpect(listener).toHaveBeenCalledTimes(1)\n\ncontrol.setValue(new Vec3(16, 17, 18))\nexpect(listener).toHaveBeenCalledTimes(1)"
          },
          {
            "title": "oldValue tracking",
            "line": 141,
            "source": "control.setValue(new Vec3(19, 20, 21))\nexpect(control.oldValue.x).toBe(0)\nexpect(control.oldValue.y).toBe(0)\nexpect(control.oldValue.z).toBe(0)\n\ncontrol.setValue(new Vec3(22, 23, 24))\nexpect(control.oldValue.x).toBe(19)\nexpect(control.oldValue.y).toBe(20)\nexpect(control.oldValue.z).toBe(21)"
          },
          {
            "title": "value property setter",
            "line": 154,
            "source": "control.value = new Vec3(25, 26, 27)\nexpect(control.value.x).toBe(25)\nexpect(control.value.y).toBe(26)\nexpect(control.value.z).toBe(27)"
          },
          {
            "title": "reset",
            "line": 162,
            "source": "control.setValue(new Vec3(28, 29, 30))\nexpect(control.value.x).toBe(28)\nexpect(control.value.y).toBe(29)\nexpect(control.value.z).toBe(30)\n\ncontrol.reset()\nexpect(control.value.x).toBe(0)\nexpect(control.value.y).toBe(0)\nexpect(control.value.z).toBe(0)"
          },
          {
            "title": "direct symbol access",
            "line": 175,
            "source": "expect(control[VALUE]).toBeInstanceOf(Vec3)\nexpect(control[OLD_VALUE]).toBeNull()\n\ncontrol.setValue(new Vec3(31, 32, 33))\nexpect(control[VALUE].x).toBe(31)\nexpect(control[VALUE].y).toBe(32)\nexpect(control[VALUE].z).toBe(33)\nexpect(control[OLD_VALUE].x).toBe(0)\nexpect(control[OLD_VALUE].y).toBe(0)\nexpect(control[OLD_VALUE].z).toBe(0)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/input/input_devices/keyboard_device.doc.js": {
    "file": "/input/input_devices/keyboard_device.test.js",
    "describes": [
      {
        "title": "KeyboardDevice",
        "line": 16,
        "beforeEach": {
          "line": 21,
          "source": "mockContainer = {\n    addEventListener: vi.fn(),\n    removeEventListener: vi.fn()\n}\n\ndevice = new KeyboardDevice({\n    container: mockContainer,\n    $id: 'testKeyboard'\n})"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor",
            "line": 34,
            "source": "expect(device).toBeInstanceOf(InputDevice)\nexpect(device.$id).toBe('testKeyboard')\nexpect(device.container).toBe(mockContainer)"
          },
          {
            "title": "constructor with default params",
            "line": 41,
            "source": "const defaultDevice = new KeyboardDevice()\nexpect(defaultDevice.$id).toBe('keyboard')\nexpect(defaultDevice.container).toBe(window)"
          },
          {
            "title": "start attaches event listeners",
            "line": 48,
            "source": "device.start()\n\nexpect(mockContainer.addEventListener).toHaveBeenCalledWith('keydown', expect.any(Function), true)\nexpect(mockContainer.addEventListener).toHaveBeenCalledWith('keyup', expect.any(Function), true)\nexpect(mockContainer.addEventListener).toHaveBeenCalledWith('blur', expect.any(Function))\nexpect(mockContainer.addEventListener).toHaveBeenCalledTimes(3)"
          },
          {
            "title": "stop removes event listeners",
            "line": 58,
            "source": "device.start()\ndevice.stop()\n\nexpect(mockContainer.removeEventListener).toHaveBeenCalledWith('keydown', expect.any(Function), true)\nexpect(mockContainer.removeEventListener).toHaveBeenCalledWith('keyup', expect.any(Function), true)\nexpect(mockContainer.removeEventListener).toHaveBeenCalledWith('blur', expect.any(Function))\nexpect(mockContainer.removeEventListener).toHaveBeenCalledTimes(3)"
          },
          {
            "title": "dispose calls stop",
            "line": 69,
            "source": "const stopSpy = vi.spyOn(device, 'stop')\ndevice.start()\ndevice.dispose()\nexpect(stopSpy).toHaveBeenCalled()"
          },
          {
            "title": "keydown event creates and presses control",
            "line": 78,
            "source": "device.start()\n\nconst keydownListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'keydown')[1]\n\nconst event = createKeyEvent('KeyA')\nkeydownListener(event)\n\nconst control = device.getControl('KeyA')\nexpect(control).toBeInstanceOf(ButtonControl)\nexpect(control.isPressed).toBe(true)\nexpect(device.isPressed('KeyA')).toBe(true)"
          },
          {
            "title": "keydown event does not press already pressed control",
            "line": 94,
            "source": "device.start()\n\nconst keydownListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'keydown')[1]\n\nconst event = createKeyEvent('KeyA')\nkeydownListener(event)\n\nconst control = device.getControl('KeyA')\nconst pressSpy = vi.spyOn(control, 'press')\n\nkeydownListener(event)\nexpect(pressSpy).not.toHaveBeenCalled()"
          },
          {
            "title": "keyup event releases control",
            "line": 111,
            "source": "device.start()\n\nconst keydownListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'keydown')[1]\nconst keyupListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'keyup')[1]\n\nconst event = createKeyEvent('KeyA')\nkeydownListener(event)\nexpect(device.isPressed('KeyA')).toBe(true)\n\nkeyupListener(event)\nexpect(device.isPressed('KeyA')).toBe(false)"
          },
          {
            "title": "keyup event does nothing for non-existent control",
            "line": 128,
            "source": "device.start()\n\nconst keyupListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'keyup')[1]\n\nconst event = createKeyEvent('KeyA')\nexpect(() => keyupListener(event)).not.toThrow()\nexpect(device.getControl('KeyA')).toBeUndefined()"
          },
          {
            "title": "blur event releases all pressed keys",
            "line": 140,
            "source": "device.start()\n\nconst keydownListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'keydown')[1]\nconst blurListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'blur')[1]\n\nkeydownListener(createKeyEvent('KeyA'))\nkeydownListener(createKeyEvent('KeyB'))\nexpect(device.isPressed('KeyA')).toBe(true)\nexpect(device.isPressed('KeyB')).toBe(true)\n\nblurListener()\nexpect(device.isPressed('KeyA')).toBe(false)\nexpect(device.isPressed('KeyB')).toBe(false)"
          },
          {
            "title": "integration test - full key press cycle",
            "line": 159,
            "source": "const controlPressedListener = vi.fn()\nconst controlReleasedListener = vi.fn()\n\ndevice.on('control:pressed', controlPressedListener)\ndevice.on('control:released', controlReleasedListener)\n\ndevice.start()\n\nconst keydownListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'keydown')[1]\nconst keyupListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'keyup')[1]\n\nconst event = createKeyEvent('Space')\n\nkeydownListener(event)\nexpect(controlPressedListener).toHaveBeenCalledTimes(1)\nexpect(device.isPressed('Space')).toBe(true)\n\nkeyupListener(event)\nexpect(controlReleasedListener).toHaveBeenCalledTimes(1)\nexpect(device.isPressed('Space')).toBe(false)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/input/input_devices/mouse_device.doc.js": {
    "file": "/input/input_devices/mouse_device.test.js",
    "describes": [
      {
        "title": "MouseDevice",
        "line": 16,
        "beforeEach": {
          "line": 21,
          "source": "mockContainer = {\n    addEventListener: vi.fn(),\n    removeEventListener: vi.fn()\n}\n\ndevice = new MouseDevice({\n    container: mockContainer,\n    $id: 'testMouse'\n})"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor",
            "line": 34,
            "source": "expect(device).toBeInstanceOf(InputDevice)\nexpect(device.$id).toBe('testMouse')\nexpect(device.container).toBe(mockContainer)"
          },
          {
            "title": "constructor with default params",
            "line": 41,
            "source": "const defaultDevice = new MouseDevice()\nexpect(defaultDevice.$id).toBe('mouse')\nexpect(defaultDevice.container).toBe(window)"
          },
          {
            "title": "creates all mouse controls",
            "line": 48,
            "source": "expect(device.getControl('leftButton')).toBeInstanceOf(ButtonControl)\nexpect(device.getControl('rightButton')).toBeInstanceOf(ButtonControl)\nexpect(device.getControl('middleButton')).toBeInstanceOf(ButtonControl)\nexpect(device.getControl('backButton')).toBeInstanceOf(ButtonControl)\nexpect(device.getControl('forwardButton')).toBeInstanceOf(ButtonControl)\nexpect(device.getControl('position')).toBeInstanceOf(Vec2Control)\nexpect(device.getControl('navigation')).toBeInstanceOf(NavigationControl)"
          },
          {
            "title": "start attaches event listeners",
            "line": 59,
            "source": "device.start()\n\nexpect(mockContainer.addEventListener).toHaveBeenCalledWith('mousedown', expect.any(Function))\nexpect(mockContainer.addEventListener).toHaveBeenCalledWith('mouseup', expect.any(Function))\nexpect(mockContainer.addEventListener).toHaveBeenCalledWith('mousemove', expect.any(Function))\nexpect(mockContainer.addEventListener).toHaveBeenCalledWith('contextmenu', expect.any(Function))\nexpect(mockContainer.addEventListener).toHaveBeenCalledWith('wheel', expect.any(Function), {passive: false})\nexpect(mockContainer.addEventListener).toHaveBeenCalledTimes(5)"
          },
          {
            "title": "stop removes event listeners",
            "line": 71,
            "source": "device.start()\ndevice.stop()\n\nexpect(mockContainer.removeEventListener).toHaveBeenCalledWith('mousedown', expect.any(Function))\nexpect(mockContainer.removeEventListener).toHaveBeenCalledWith('mouseup', expect.any(Function))\nexpect(mockContainer.removeEventListener).toHaveBeenCalledWith('mousemove', expect.any(Function))\nexpect(mockContainer.removeEventListener).toHaveBeenCalledWith('contextmenu', expect.any(Function))\nexpect(mockContainer.removeEventListener).toHaveBeenCalledWith('wheel', expect.any(Function), {passive: false})\nexpect(mockContainer.removeEventListener).toHaveBeenCalledTimes(5)"
          },
          {
            "title": "dispose calls stop",
            "line": 84,
            "source": "const stopSpy = vi.spyOn(device, 'stop')\ndevice.dispose()\nexpect(stopSpy).toHaveBeenCalled()"
          },
          {
            "title": "mousedown event presses correct button",
            "line": 91,
            "source": "device.start()\n\nconst mousedownListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'mousedown')[1]\n\nmousedownListener(createMockEvent({button: 0}))\nexpect(device.isPressed('leftButton')).toBe(true)\n\nmousedownListener(createMockEvent({button: 2}))\nexpect(device.isPressed('rightButton')).toBe(true)\n\nmousedownListener(createMockEvent({button: 1}))\nexpect(device.isPressed('middleButton')).toBe(true)"
          },
          {
            "title": "mouseup event releases correct button",
            "line": 108,
            "source": "device.start()\n\nconst mousedownListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'mousedown')[1]\nconst mouseupListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'mouseup')[1]\n\nmousedownListener(createMockEvent({button: 0}))\nexpect(device.isPressed('leftButton')).toBe(true)\n\nmouseupListener(createMockEvent({button: 0}))\nexpect(device.isPressed('leftButton')).toBe(false)"
          },
          {
            "title": "side buttons work correctly",
            "line": 124,
            "source": "device.start()\n\nconst mousedownListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'mousedown')[1]\n\nmousedownListener(createMockEvent({button: 3}))\nexpect(device.isPressed('backButton')).toBe(true)\n\nmousedownListener(createMockEvent({button: 4}))\nexpect(device.isPressed('forwardButton')).toBe(true)"
          },
          {
            "title": "mousemove updates position",
            "line": 138,
            "source": "device.start()\n\nconst mousemoveListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'mousemove')[1]\n\nconst positionControl = device.getControl('position')\nexpect(positionControl.value.x).toBe(0)\nexpect(positionControl.value.y).toBe(0)\n\nmousemoveListener(createMockEvent({clientX: 100, clientY: 200}))\nexpect(positionControl.value.x).toBe(100)\nexpect(positionControl.value.y).toBe(200)\n\nmousemoveListener(createMockEvent({clientX: 300, clientY: 400}))\nexpect(positionControl.value.x).toBe(300)\nexpect(positionControl.value.y).toBe(400)"
          },
          {
            "title": "mousedown does not press already pressed button",
            "line": 158,
            "source": "device.start()\n\nconst mousedownListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'mousedown')[1]\n\nmousedownListener(createMockEvent({button: 0}))\nconst leftButton = device.getControl('leftButton')\nconst pressSpy = vi.spyOn(leftButton, 'press')\n\nmousedownListener(createMockEvent({button: 0}))\nexpect(pressSpy).not.toHaveBeenCalled()"
          },
          {
            "title": "wheel event updates navigation control",
            "line": 173,
            "source": "device.start()\n\nconst wheelListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'wheel')[1]\n\nconst navigationControl = device.getControl('navigation')\nexpect(navigationControl.value).toEqual({deltaX: 0, deltaY: 0, deltaZ: 0, event: null})\n\nconst mockEvent = createMockEvent({deltaX: 10, deltaY: -50, deltaZ: 0})\nwheelListener(mockEvent)\nexpect(navigationControl.value).toEqual({deltaX: 10, deltaY: -50, deltaZ: 0, event: mockEvent})"
          },
          {
            "title": "integration test - full mouse interaction",
            "line": 188,
            "source": "const controlPressedListener = vi.fn()\nconst controlReleasedListener = vi.fn()\nconst controlUpdatedListener = vi.fn()\n\ndevice.on('control:pressed', controlPressedListener)\ndevice.on('control:released', controlReleasedListener)\ndevice.on('control:updated', controlUpdatedListener)\n\ndevice.start()\n\nconst mousedownListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'mousedown')[1]\nconst mouseupListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'mouseup')[1]\nconst mousemoveListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'mousemove')[1]\n\nmousemoveListener(createMockEvent({clientX: 50, clientY: 75}))\nexpect(controlUpdatedListener).toHaveBeenCalledTimes(1)\n\nmousedownListener(createMockEvent({button: 0}))\nexpect(controlPressedListener).toHaveBeenCalledTimes(1)\nexpect(device.isPressed('leftButton')).toBe(true)\n\nmouseupListener(createMockEvent({button: 0}))\nexpect(controlReleasedListener).toHaveBeenCalledTimes(1)\nexpect(device.isPressed('leftButton')).toBe(false)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/input/input_devices/touch_device.doc.js": {
    "file": "/input/input_devices/touch_device.test.js",
    "describes": [
      {
        "title": "TouchDevice",
        "line": 27,
        "beforeEach": {
          "line": 32,
          "source": "mockContainer = {\n    addEventListener: vi.fn(),\n    removeEventListener: vi.fn()\n}\n\ndevice = new TouchDevice({\n    container: mockContainer,\n    $id: 'testTouch',\n    swipeThreshold: 30\n})"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor",
            "line": 46,
            "source": "expect(device).toBeInstanceOf(InputDevice)\nexpect(device.$id).toBe('testTouch')\nexpect(device.container).toBe(mockContainer)\nexpect(device.swipeThreshold).toBe(30)"
          },
          {
            "title": "constructor with default params",
            "line": 54,
            "source": "const defaultDevice = new TouchDevice()\nexpect(defaultDevice.$id).toBe('touch')\nexpect(defaultDevice.container).toBe(window)\nexpect(defaultDevice.swipeThreshold).toBe(30)"
          },
          {
            "title": "creates controls on construction",
            "line": 62,
            "source": "expect(device.getControl('swipeUp')).toBeInstanceOf(ButtonControl)\nexpect(device.getControl('swipeDown')).toBeInstanceOf(ButtonControl)\nexpect(device.getControl('swipeLeft')).toBeInstanceOf(ButtonControl)\nexpect(device.getControl('swipeRight')).toBeInstanceOf(ButtonControl)\nexpect(device.getControl('position')).toBeInstanceOf(Vec2Control)\nexpect(device.getControl('delta')).toBeInstanceOf(Vec2Control)\nexpect(device.getControl('tap')).toBeInstanceOf(ButtonControl)"
          },
          {
            "title": "start attaches event listeners",
            "line": 73,
            "source": "device.start()\n\nexpect(mockContainer.addEventListener).toHaveBeenCalledWith('touchstart', expect.any(Function), {passive: false})\nexpect(mockContainer.addEventListener).toHaveBeenCalledWith('touchmove', expect.any(Function), {passive: false})\nexpect(mockContainer.addEventListener).toHaveBeenCalledWith('touchend', expect.any(Function))\nexpect(mockContainer.addEventListener).toHaveBeenCalledWith('touchcancel', expect.any(Function))\nexpect(mockContainer.addEventListener).toHaveBeenCalledTimes(4)"
          },
          {
            "title": "stop removes event listeners",
            "line": 84,
            "source": "device.start()\ndevice.stop()\n\nexpect(mockContainer.removeEventListener).toHaveBeenCalledWith('touchstart', expect.any(Function))\nexpect(mockContainer.removeEventListener).toHaveBeenCalledWith('touchmove', expect.any(Function))\nexpect(mockContainer.removeEventListener).toHaveBeenCalledWith('touchend', expect.any(Function))\nexpect(mockContainer.removeEventListener).toHaveBeenCalledWith('touchcancel', expect.any(Function))\nexpect(mockContainer.removeEventListener).toHaveBeenCalledTimes(4)"
          },
          {
            "title": "touchstart updates position",
            "line": 96,
            "source": "device.start()\n\nconst touchstartListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchstart')[1]\n\nconst event = createTouchEvent('touchstart', [{clientX: 100, clientY: 200}])\ntouchstartListener(event)\n\nconst position = device.getControl('position')\nexpect(position.value.x).toBe(100)\nexpect(position.value.y).toBe(200)"
          },
          {
            "title": "touchmove triggers swipeUp when moving up past threshold",
            "line": 111,
            "source": "device.start()\n\nconst touchstartListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchstart')[1]\nconst touchmoveListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchmove')[1]\n\ntouchstartListener(createTouchEvent('touchstart', [{clientY: 200}]))\ntouchmoveListener(createTouchEvent('touchmove', [{clientY: 150}]))\n\nexpect(device.isPressed('swipeUp')).toBe(true)\nexpect(device.isPressed('swipeDown')).toBe(false)"
          },
          {
            "title": "touchmove triggers swipeDown when moving down past threshold",
            "line": 127,
            "source": "device.start()\n\nconst touchstartListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchstart')[1]\nconst touchmoveListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchmove')[1]\n\ntouchstartListener(createTouchEvent('touchstart', [{clientY: 200}]))\ntouchmoveListener(createTouchEvent('touchmove', [{clientY: 250}]))\n\nexpect(device.isPressed('swipeDown')).toBe(true)\nexpect(device.isPressed('swipeUp')).toBe(false)"
          },
          {
            "title": "touchmove does not trigger swipe when below threshold",
            "line": 143,
            "source": "device.start()\n\nconst touchstartListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchstart')[1]\nconst touchmoveListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchmove')[1]\n\ntouchstartListener(createTouchEvent('touchstart', [{clientX: 200, clientY: 200}]))\ntouchmoveListener(createTouchEvent('touchmove', [{clientX: 210, clientY: 210}]))\n\nexpect(device.isPressed('swipeUp')).toBe(false)\nexpect(device.isPressed('swipeDown')).toBe(false)\nexpect(device.isPressed('swipeLeft')).toBe(false)\nexpect(device.isPressed('swipeRight')).toBe(false)"
          },
          {
            "title": "touchmove triggers swipeLeft when moving left past threshold",
            "line": 161,
            "source": "device.start()\n\nconst touchstartListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchstart')[1]\nconst touchmoveListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchmove')[1]\n\ntouchstartListener(createTouchEvent('touchstart', [{clientX: 200, clientY: 200}]))\ntouchmoveListener(createTouchEvent('touchmove', [{clientX: 150, clientY: 200}]))\n\nexpect(device.isPressed('swipeLeft')).toBe(true)\nexpect(device.isPressed('swipeRight')).toBe(false)"
          },
          {
            "title": "touchmove triggers swipeRight when moving right past threshold",
            "line": 177,
            "source": "device.start()\n\nconst touchstartListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchstart')[1]\nconst touchmoveListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchmove')[1]\n\ntouchstartListener(createTouchEvent('touchstart', [{clientX: 200, clientY: 200}]))\ntouchmoveListener(createTouchEvent('touchmove', [{clientX: 250, clientY: 200}]))\n\nexpect(device.isPressed('swipeRight')).toBe(true)\nexpect(device.isPressed('swipeLeft')).toBe(false)"
          },
          {
            "title": "switching from swipeLeft to swipeRight releases swipeLeft",
            "line": 193,
            "source": "device.start()\n\nconst touchstartListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchstart')[1]\nconst touchmoveListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchmove')[1]\n\ntouchstartListener(createTouchEvent('touchstart', [{clientX: 200, clientY: 200}]))\ntouchmoveListener(createTouchEvent('touchmove', [{clientX: 150, clientY: 200}]))\nexpect(device.isPressed('swipeLeft')).toBe(true)\n\ntouchmoveListener(createTouchEvent('touchmove', [{clientX: 250, clientY: 200}]))\nexpect(device.isPressed('swipeLeft')).toBe(false)\nexpect(device.isPressed('swipeRight')).toBe(true)"
          },
          {
            "title": "touchend releases all swipes",
            "line": 211,
            "source": "device.start()\n\nconst touchstartListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchstart')[1]\nconst touchmoveListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchmove')[1]\nconst touchendListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchend')[1]\n\ntouchstartListener(createTouchEvent('touchstart', [{identifier: 0, clientY: 200}]))\ntouchmoveListener(createTouchEvent('touchmove', [{identifier: 0, clientY: 150}]))\nexpect(device.isPressed('swipeUp')).toBe(true)\n\ntouchendListener(createTouchEvent('touchend', [], [{identifier: 0, clientY: 150}]))\nexpect(device.isPressed('swipeUp')).toBe(false)"
          },
          {
            "title": "touchcancel releases all swipes",
            "line": 230,
            "source": "device.start()\n\nconst touchstartListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchstart')[1]\nconst touchmoveListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchmove')[1]\nconst touchcancelListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchcancel')[1]\n\ntouchstartListener(createTouchEvent('touchstart', [{identifier: 0, clientY: 200}]))\ntouchmoveListener(createTouchEvent('touchmove', [{identifier: 0, clientY: 150}]))\nexpect(device.isPressed('swipeUp')).toBe(true)\n\ntouchcancelListener(createTouchEvent('touchcancel', [], [{identifier: 0}]))\nexpect(device.isPressed('swipeUp')).toBe(false)"
          },
          {
            "title": "ignores second touch when first is active",
            "line": 249,
            "source": "device.start()\n\nconst touchstartListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchstart')[1]\n\ntouchstartListener(createTouchEvent('touchstart', [{identifier: 0, clientX: 100, clientY: 200}]))\n\nconst position = device.getControl('position')\nexpect(position.value.x).toBe(100)\n\ntouchstartListener(createTouchEvent('touchstart', [\n    {identifier: 0, clientX: 100, clientY: 200},\n    {identifier: 1, clientX: 300, clientY: 400}\n]))\n\nexpect(position.value.x).toBe(100)"
          },
          {
            "title": "updates delta on touchmove",
            "line": 269,
            "source": "device.start()\n\nconst touchstartListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchstart')[1]\nconst touchmoveListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchmove')[1]\n\ntouchstartListener(createTouchEvent('touchstart', [{clientY: 200}]))\ntouchmoveListener(createTouchEvent('touchmove', [{clientY: 180}]))\n\nconst delta = device.getControl('delta')\nexpect(delta.value.y).toBe(-20)"
          },
          {
            "title": "switching from swipeUp to swipeDown releases swipeUp",
            "line": 285,
            "source": "device.start()\n\nconst touchstartListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchstart')[1]\nconst touchmoveListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchmove')[1]\n\ntouchstartListener(createTouchEvent('touchstart', [{clientY: 200}]))\ntouchmoveListener(createTouchEvent('touchmove', [{clientY: 150}]))\nexpect(device.isPressed('swipeUp')).toBe(true)\n\ntouchmoveListener(createTouchEvent('touchmove', [{clientY: 250}]))\nexpect(device.isPressed('swipeUp')).toBe(false)\nexpect(device.isPressed('swipeDown')).toBe(true)"
          },
          {
            "title": "integration test - full swipe cycle with events",
            "line": 303,
            "source": "const controlPressedListener = vi.fn()\nconst controlReleasedListener = vi.fn()\n\ndevice.on('control:pressed', controlPressedListener)\ndevice.on('control:released', controlReleasedListener)\n\ndevice.start()\n\nconst touchstartListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchstart')[1]\nconst touchmoveListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchmove')[1]\nconst touchendListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchend')[1]\n\ntouchstartListener(createTouchEvent('touchstart', [{identifier: 0, clientY: 200}]))\ntouchmoveListener(createTouchEvent('touchmove', [{identifier: 0, clientY: 150}]))\n\nexpect(controlPressedListener).toHaveBeenCalledTimes(1)\nexpect(controlPressedListener).toHaveBeenCalledWith(\n    expect.objectContaining({name: 'swipeUp'}),\n    expect.anything(),\n    device\n)\n\ntouchendListener(createTouchEvent('touchend', [], [{identifier: 0}]))\n\nexpect(controlReleasedListener).toHaveBeenCalledWith(\n    expect.objectContaining({name: 'swipeUp'}),\n    expect.anything(),\n    device\n)"
          },
          {
            "title": "tap triggers on quick touch without movement",
            "line": 339,
            "source": "const controlPressedListener = vi.fn()\nconst controlReleasedListener = vi.fn()\n\ndevice.on('control:pressed', controlPressedListener)\ndevice.on('control:released', controlReleasedListener)\n\ndevice.start()\n\nconst touchstartListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchstart')[1]\nconst touchendListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchend')[1]\n\ntouchstartListener(createTouchEvent('touchstart', [{identifier: 0, clientX: 100, clientY: 200}]))\ntouchendListener(createTouchEvent('touchend', [], [{identifier: 0, clientX: 100, clientY: 200}]))\n\nexpect(controlPressedListener).toHaveBeenCalledWith(\n    expect.objectContaining({name: 'tap'}),\n    expect.anything(),\n    device\n)\nexpect(controlReleasedListener).toHaveBeenCalledWith(\n    expect.objectContaining({name: 'tap'}),\n    expect.anything(),\n    device\n)"
          },
          {
            "title": "tap does not trigger when movement exceeds threshold",
            "line": 369,
            "source": "const controlPressedListener = vi.fn()\n\ndevice.on('control:pressed', controlPressedListener)\n\ndevice.start()\n\nconst touchstartListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchstart')[1]\nconst touchendListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchend')[1]\n\ntouchstartListener(createTouchEvent('touchstart', [{identifier: 0, clientX: 100, clientY: 200}]))\ntouchendListener(createTouchEvent('touchend', [], [{identifier: 0, clientX: 100, clientY: 250}]))\n\nconst tapCalls = controlPressedListener.mock.calls.filter(\n    call => call[0].name === 'tap'\n)\nexpect(tapCalls).toHaveLength(0)"
          },
          {
            "title": "tap does not trigger on touchcancel",
            "line": 391,
            "source": "const controlPressedListener = vi.fn()\n\ndevice.on('control:pressed', controlPressedListener)\n\ndevice.start()\n\nconst touchstartListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchstart')[1]\nconst touchcancelListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchcancel')[1]\n\ntouchstartListener(createTouchEvent('touchstart', [{identifier: 0, clientX: 100, clientY: 200}]))\ntouchcancelListener(createTouchEvent('touchcancel', [], [{identifier: 0}]))\n\nconst tapCalls = controlPressedListener.mock.calls.filter(\n    call => call[0].name === 'tap'\n)\nexpect(tapCalls).toHaveLength(0)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/audio/audio_system.doc.js": {
    "file": "/audio/audio_system.test.js",
    "describes": [
      {
        "title": "AudioSystem",
        "line": 13,
        "beforeEach": {
          "line": 21,
          "source": "// Get the mocked onAudioUnlock\nconst audioUnlockModule = await import('./audio_unlock.js')\nmockOnAudioUnlock = audioUnlockModule.onAudioUnlock\nmockOnAudioUnlock.mockClear()\n\nmockContext = createMockAudioContextWithSpies()\ncleanupAudioContext = setupGlobalAudioContext(mockContext)\ncleanupFetch = setupGlobalFetch()\n\nsystem = new AudioSystem()"
        },
        "afterEach": {
          "line": 35,
          "source": "cleanupAudioContext()\ncleanupFetch()"
        },
        "tests": [
          {
            "title": "audioContext returns the audio context",
            "line": 61,
            "source": "expect(system.audioContext).toBeDefined()"
          },
          {
            "title": "unlocked starts as false",
            "line": 66,
            "source": "expect(system.unlocked).toBe(false)"
          },
          {
            "title": "currentTime returns context current time",
            "line": 71,
            "source": "expect(system.currentTime).toBe(0)"
          },
          {
            "title": "onStart registers audio unlock callback",
            "line": 107,
            "source": "system.onStart()\nexpect(mockOnAudioUnlock).toHaveBeenCalledWith(expect.any(Function))"
          },
          {
            "title": "onStop suspends audio context when unlocked",
            "line": 113,
            "source": "// Mark system as unlocked first\nawait system.unlock()\nconst suspendSpy = vi.spyOn(system.audioContext, 'suspend')\nsystem.onStop()\nexpect(suspendSpy).toHaveBeenCalled()"
          },
          {
            "title": "onStop does nothing when not unlocked",
            "line": 121,
            "source": "const suspendSpy = vi.spyOn(system.audioContext, 'suspend')\nsystem.onStop()\nexpect(suspendSpy).not.toHaveBeenCalled()"
          },
          {
            "title": "listChannels returns channel names",
            "line": 213,
            "source": "const channels = system.listChannels()\nexpect(channels).toContain('music')\nexpect(channels).toContain('sfx')\nexpect(channels).toContain('ambiance')"
          },
          {
            "title": "stopAll stops all channels",
            "line": 427,
            "source": "const musicChannel = system.getChannel('music')\nconst sfxChannel = system.getChannel('sfx')\nconst musicSpy = vi.spyOn(musicChannel, 'stopAll')\nconst sfxSpy = vi.spyOn(sfxChannel, 'stopAll')\nsystem.stopAll()\nexpect(musicSpy).toHaveBeenCalled()\nexpect(sfxSpy).toHaveBeenCalled()"
          },
          {
            "title": "getVolume returns master volume from context",
            "line": 458,
            "source": "const spy = vi.spyOn(system.audioContext, 'getMasterVolume').mockReturnValue(0.7)\nexpect(system.getVolume()).toBe(0.7)\nexpect(spy).toHaveBeenCalled()"
          }
        ],
        "describes": [
          {
            "title": "constructor",
            "line": 41,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "sets static category",
                "line": 42,
                "source": "expect(AudioSystem.$category).toBe('audioSystem')"
              },
              {
                "title": "creates default channels",
                "line": 46,
                "source": "expect(system.hasChannel('music')).toBe(true)\nexpect(system.hasChannel('sfx')).toBe(true)\nexpect(system.hasChannel('ambiance')).toBe(true)"
              },
              {
                "title": "accepts custom channels",
                "line": 52,
                "source": "const custom = new AudioSystem({channels: ['voice', 'effects']})\nexpect(custom.hasChannel('voice')).toBe(true)\nexpect(custom.hasChannel('effects')).toBe(true)\nexpect(custom.hasChannel('music')).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "masterVolume",
            "line": 76,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "get returns master volume",
                "line": 77,
                "source": "expect(system.masterVolume).toBeDefined()"
              },
              {
                "title": "set calls setMasterVolume on context",
                "line": 81,
                "source": "const spy = vi.spyOn(system.audioContext, 'setMasterVolume')\nsystem.masterVolume = 0.5\nexpect(spy).toHaveBeenCalledWith(0.5)"
              }
            ],
            "describes": []
          },
          {
            "title": "onInstall",
            "line": 89,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "delegates audio methods to host",
                "line": 90,
                "source": "const host = {emit: vi.fn()}\nsystem.onInstall(host)\nexpect(host.playSound).toBeDefined()\nexpect(host.stopSound).toBeDefined()\nexpect(host.unlockAudio).toBeDefined()"
              },
              {
                "title": "delegates audio events to host",
                "line": 98,
                "source": "const host = {emit: vi.fn(), on: vi.fn()}\nsystem.onInstall(host)\nsystem.emit('audio:play', 'test')\nexpect(host.emit).toHaveBeenCalled()"
              }
            ],
            "describes": []
          },
          {
            "title": "onDispose",
            "line": 128,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "stops all sounds",
                "line": 129,
                "source": "const stopAllSpy = vi.spyOn(system, 'stopAll')\nsystem.onDispose()\nexpect(stopAllSpy).toHaveBeenCalled()"
              },
              {
                "title": "disposes audio context",
                "line": 135,
                "source": "const disposeSpy = vi.spyOn(system.audioContext, 'dispose')\nsystem.onDispose()\nexpect(disposeSpy).toHaveBeenCalled()"
              }
            ],
            "describes": []
          },
          {
            "title": "unlock",
            "line": 143,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "resumes audio context",
                "line": 144,
                "source": "await system.unlock()\nexpect(mockContext.resume).toHaveBeenCalled()"
              },
              {
                "title": "sets unlocked to true",
                "line": 149,
                "source": "await system.unlock()\nexpect(system.unlocked).toBe(true)"
              },
              {
                "title": "emits audio:unlocked event",
                "line": 154,
                "source": "const listener = vi.fn()\nsystem.on('audio:unlocked', listener)\nawait system.unlock()\nexpect(listener).toHaveBeenCalled()"
              },
              {
                "title": "returns true on success",
                "line": 161,
                "source": "expect(await system.unlock()).toBe(true)"
              },
              {
                "title": "returns true if already unlocked",
                "line": 165,
                "source": "await system.unlock()\nexpect(await system.unlock()).toBe(true)"
              },
              {
                "title": "returns false on error",
                "line": 170,
                "source": "mockContext.resume.mockRejectedValue(new Error('failed'))\nexpect(await system.unlock()).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "createChannel",
            "line": 177,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates new channel",
                "line": 178,
                "source": "const channel = system.createChannel('custom')\nexpect(channel).toBeInstanceOf(AudioChannel)"
              },
              {
                "title": "registers channel by name",
                "line": 183,
                "source": "system.createChannel('custom')\nexpect(system.hasChannel('custom')).toBe(true)"
              }
            ],
            "describes": []
          },
          {
            "title": "getChannel",
            "line": 190,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns existing channel",
                "line": 191,
                "source": "const channel = system.getChannel('sfx')\nexpect(channel).toBeInstanceOf(AudioChannel)"
              },
              {
                "title": "returns null for unknown channel",
                "line": 196,
                "source": "expect(system.getChannel('unknown')).toBeNull()"
              }
            ],
            "describes": []
          },
          {
            "title": "hasChannel",
            "line": 202,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns true for existing channel",
                "line": 203,
                "source": "expect(system.hasChannel('sfx')).toBe(true)"
              },
              {
                "title": "returns false for unknown channel",
                "line": 207,
                "source": "expect(system.hasChannel('unknown')).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "registerBuffer",
            "line": 221,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "stores buffer by id",
                "line": 222,
                "source": "const buffer = {duration: 10}\nsystem.registerBuffer('test', buffer)\nexpect(system.getBuffer('test')).toBe(buffer)"
              },
              {
                "title": "emits buffer:registered event",
                "line": 228,
                "source": "const listener = vi.fn()\nsystem.on('buffer:registered', listener)\nconst buffer = {}\nsystem.registerBuffer('test', buffer)\nexpect(listener).toHaveBeenCalledWith('test', buffer)"
              }
            ],
            "describes": []
          },
          {
            "title": "getBuffer",
            "line": 238,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns registered buffer",
                "line": 239,
                "source": "const buffer = {}\nsystem.registerBuffer('test', buffer)\nexpect(system.getBuffer('test')).toBe(buffer)"
              },
              {
                "title": "returns null for unknown buffer",
                "line": 245,
                "source": "expect(system.getBuffer('unknown')).toBeNull()"
              }
            ],
            "describes": []
          },
          {
            "title": "hasBuffer",
            "line": 251,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns true for registered buffer",
                "line": 252,
                "source": "system.registerBuffer('test', {})\nexpect(system.hasBuffer('test')).toBe(true)"
              },
              {
                "title": "returns false for unknown buffer",
                "line": 257,
                "source": "expect(system.hasBuffer('unknown')).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "loadBuffer",
            "line": 263,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "fetches and decodes audio",
                "line": 264,
                "source": "// Set context to running so decodeAudioData doesn't queue\nmockContext.state = 'running'\nconst buffer = await system.loadBuffer('test', 'http://example.com/audio.mp3')\nexpect(global.fetch).toHaveBeenCalledWith('http://example.com/audio.mp3')\nexpect(buffer).toBeDefined()"
              },
              {
                "title": "registers loaded buffer",
                "line": 272,
                "source": "// Set context to running so decodeAudioData doesn't queue\nmockContext.state = 'running'\nawait system.loadBuffer('test', 'http://example.com/audio.mp3')\nexpect(system.hasBuffer('test')).toBe(true)"
              },
              {
                "title": "returns null on error",
                "line": 279,
                "source": "global.fetch.mockRejectedValue(new Error('network error'))\nconst buffer = await system.loadBuffer('test', 'http://example.com/audio.mp3')\nexpect(buffer).toBeNull()"
              },
              {
                "title": "emits buffer:error on failure",
                "line": 285,
                "source": "const listener = vi.fn()\nsystem.on('buffer:error', listener)\nglobal.fetch.mockRejectedValue(new Error('network error'))\nawait system.loadBuffer('test', 'http://example.com/audio.mp3')\nexpect(listener).toHaveBeenCalled()"
              }
            ],
            "describes": []
          },
          {
            "title": "play",
            "line": 295,
            "beforeEach": {
              "line": 296,
              "source": "// Unlock the system so play() works\nawait system.unlock()"
            },
            "afterEach": null,
            "tests": [
              {
                "title": "returns null for unknown buffer",
                "line": 301,
                "source": "expect(system.play('unknown')).toBeNull()"
              },
              {
                "title": "creates audio source for registered buffer",
                "line": 305,
                "source": "system.registerBuffer('test', {duration: 1})\nconst source = system.play('test')\nexpect(source).not.toBeNull()"
              },
              {
                "title": "uses sfx channel by default",
                "line": 311,
                "source": "system.registerBuffer('test', {})\nconst source = system.play('test')\nexpect(source.channel).toBe(system.getChannel('sfx'))"
              },
              {
                "title": "uses specified channel",
                "line": 317,
                "source": "system.registerBuffer('test', {})\nconst source = system.play('test', {channel: 'music'})\nexpect(source.channel).toBe(system.getChannel('music'))"
              },
              {
                "title": "emits audio:play event",
                "line": 323,
                "source": "const listener = vi.fn()\nsystem.on('audio:play', listener)\nsystem.registerBuffer('test', {})\nsystem.play('test')\nexpect(listener).toHaveBeenCalled()"
              },
              {
                "title": "accepts loop option",
                "line": 331,
                "source": "system.registerBuffer('test', {})\nconst source = system.play('test', {loop: true})\nexpect(source.loop).toBe(true)"
              },
              {
                "title": "accepts volume option",
                "line": 337,
                "source": "system.registerBuffer('test', {})\nconst source = system.play('test', {volume: 0.5})\nexpect(source.volume).toBe(0.5)"
              },
              {
                "title": "accepts playbackRate option",
                "line": 343,
                "source": "system.registerBuffer('test', {})\nconst source = system.play('test', {playbackRate: 2})\nexpect(source.playbackRate).toBe(2)"
              }
            ],
            "describes": []
          },
          {
            "title": "playOscillator",
            "line": 351,
            "beforeEach": {
              "line": 352,
              "source": "// Unlock the system so playOscillator() works\nawait system.unlock()"
            },
            "afterEach": null,
            "tests": [
              {
                "title": "creates oscillator source",
                "line": 357,
                "source": "const source = system.playOscillator()\nexpect(source).not.toBeNull()"
              },
              {
                "title": "uses sfx channel by default",
                "line": 362,
                "source": "const source = system.playOscillator()\nexpect(source.channel).toBe(system.getChannel('sfx'))"
              },
              {
                "title": "accepts type option",
                "line": 367,
                "source": "const source = system.playOscillator({type: 'square'})\nexpect(source).not.toBeNull()"
              },
              {
                "title": "emits audio:play event",
                "line": 372,
                "source": "const listener = vi.fn()\nsystem.on('audio:play', listener)\nsystem.playOscillator()\nexpect(listener).toHaveBeenCalled()"
              }
            ],
            "describes": []
          },
          {
            "title": "stop",
            "line": 381,
            "beforeEach": {
              "line": 382,
              "source": "// Unlock the system so play() works\nawait system.unlock()"
            },
            "afterEach": null,
            "tests": [
              {
                "title": "returns false for unknown source",
                "line": 387,
                "source": "expect(system.stop('unknown')).toBe(false)"
              },
              {
                "title": "stops playing source",
                "line": 391,
                "source": "system.registerBuffer('test', {})\nconst source = system.play('test')\nconst result = system.stop(source.$id)\nexpect(result).toBe(true)"
              },
              {
                "title": "emits audio:stop event",
                "line": 398,
                "source": "const listener = vi.fn()\nsystem.on('audio:stop', listener)\nsystem.registerBuffer('test', {})\nconst source = system.play('test')\nsystem.stop(source.$id)\nexpect(listener).toHaveBeenCalled()"
              }
            ],
            "describes": []
          },
          {
            "title": "stopChannel",
            "line": 409,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns false for unknown channel",
                "line": 410,
                "source": "expect(system.stopChannel('unknown')).toBe(false)"
              },
              {
                "title": "stops all sources in channel",
                "line": 414,
                "source": "const channel = system.getChannel('sfx')\nconst stopAllSpy = vi.spyOn(channel, 'stopAll')\nsystem.stopChannel('sfx')\nexpect(stopAllSpy).toHaveBeenCalled()"
              },
              {
                "title": "returns true on success",
                "line": 421,
                "source": "expect(system.stopChannel('sfx')).toBe(true)"
              }
            ],
            "describes": []
          },
          {
            "title": "setVolume",
            "line": 438,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "sets master volume",
                "line": 439,
                "source": "const spy = vi.spyOn(system.audioContext, 'setMasterVolume')\nsystem.setVolume(0.5)\nexpect(spy).toHaveBeenCalledWith(0.5)"
              },
              {
                "title": "emits volume:changed event",
                "line": 445,
                "source": "const listener = vi.fn()\nsystem.on('volume:changed', listener)\nsystem.setVolume(0.5)\nexpect(listener).toHaveBeenCalledWith(0.5)"
              },
              {
                "title": "returns self for chaining",
                "line": 452,
                "source": "expect(system.setVolume(0.5)).toBe(system)"
              }
            ],
            "describes": []
          },
          {
            "title": "setChannelVolume",
            "line": 465,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "sets channel volume",
                "line": 466,
                "source": "system.setChannelVolume('sfx', 0.5)\nexpect(system.getChannel('sfx').volume).toBe(0.5)"
              },
              {
                "title": "does nothing for unknown channel",
                "line": 471,
                "source": "expect(() => system.setChannelVolume('unknown', 0.5)).not.toThrow()"
              },
              {
                "title": "returns self for chaining",
                "line": 475,
                "source": "expect(system.setChannelVolume('sfx', 0.5)).toBe(system)"
              }
            ],
            "describes": []
          },
          {
            "title": "getChannelVolume",
            "line": 481,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns channel volume",
                "line": 482,
                "source": "system.setChannelVolume('sfx', 0.7)\nexpect(system.getChannelVolume('sfx')).toBe(0.7)"
              },
              {
                "title": "returns 0 for unknown channel",
                "line": 487,
                "source": "expect(system.getChannelVolume('unknown')).toBe(0)"
              }
            ],
            "describes": []
          },
          {
            "title": "muteChannel",
            "line": 493,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "mutes channel",
                "line": 494,
                "source": "system.muteChannel('sfx')\nexpect(system.getChannel('sfx').muted).toBe(true)"
              },
              {
                "title": "does nothing for unknown channel",
                "line": 499,
                "source": "expect(() => system.muteChannel('unknown')).not.toThrow()"
              },
              {
                "title": "returns self for chaining",
                "line": 503,
                "source": "expect(system.muteChannel('sfx')).toBe(system)"
              }
            ],
            "describes": []
          },
          {
            "title": "unmuteChannel",
            "line": 509,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "unmutes channel",
                "line": 510,
                "source": "system.muteChannel('sfx')\nsystem.unmuteChannel('sfx')\nexpect(system.getChannel('sfx').muted).toBe(false)"
              },
              {
                "title": "does nothing for unknown channel",
                "line": 516,
                "source": "expect(() => system.unmuteChannel('unknown')).not.toThrow()"
              },
              {
                "title": "returns self for chaining",
                "line": 520,
                "source": "expect(system.unmuteChannel('sfx')).toBe(system)"
              }
            ],
            "describes": []
          },
          {
            "title": "playAt",
            "line": 526,
            "beforeEach": {
              "line": 527,
              "source": "// Unlock the system so playAt() works\nawait system.unlock()"
            },
            "afterEach": null,
            "tests": [
              {
                "title": "returns null for unknown buffer",
                "line": 532,
                "source": "expect(system.playAt('unknown', 10, 20)).toBeNull()"
              },
              {
                "title": "creates audio source",
                "line": 536,
                "source": "system.registerBuffer('test', {})\nconst source = system.playAt('test', 100, 200)\nexpect(source).not.toBeNull()"
              },
              {
                "title": "calls play with spatial options",
                "line": 542,
                "source": "system.registerBuffer('test', {})\nconst playSpy = vi.spyOn(system, 'play')\nsystem.playAt('test', 150, 250, {volume: 0.5})\nexpect(playSpy).toHaveBeenCalledWith('test', expect.objectContaining({\n    spatial: true,\n    x: 150,\n    y: 250,\n    volume: 0.5\n}))"
              },
              {
                "title": "emits audio:play event",
                "line": 554,
                "source": "const listener = vi.fn()\nsystem.on('audio:play', listener)\nsystem.registerBuffer('test', {})\nsystem.playAt('test', 10, 20)\nexpect(listener).toHaveBeenCalled()"
              }
            ],
            "describes": []
          },
          {
            "title": "playOscillatorAt",
            "line": 564,
            "beforeEach": {
              "line": 565,
              "source": "// Unlock the system so playOscillatorAt() works\nawait system.unlock()"
            },
            "afterEach": null,
            "tests": [
              {
                "title": "creates oscillator source with spatial audio enabled",
                "line": 570,
                "source": "const source = system.playOscillatorAt(100, 200)\nexpect(source).not.toBeNull()\n\n// Verify spatial audio is enabled by checking position properties\nconst pos = source.getPosition()\nexpect(pos.x).toBe(100)\nexpect(pos.y).toBe(200)"
              },
              {
                "title": "sets position coordinates",
                "line": 580,
                "source": "const source = system.playOscillatorAt(150, 250)\nconst pos = source.getPosition()\nexpect(pos.x).toBe(150)\nexpect(pos.y).toBe(250)"
              },
              {
                "title": "accepts options",
                "line": 587,
                "source": "const source = system.playOscillatorAt(10, 20, {type: 'square', frequency: 880, volume: 0.3})\nexpect(source.volume).toBe(0.3)"
              },
              {
                "title": "emits audio:play event",
                "line": 592,
                "source": "const listener = vi.fn()\nsystem.on('audio:play', listener)\nsystem.playOscillatorAt(10, 20)\nexpect(listener).toHaveBeenCalled()"
              }
            ],
            "describes": []
          },
          {
            "title": "setListenerPosition",
            "line": 601,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "sets listener position on audio context",
                "line": 602,
                "source": "const spy = vi.spyOn(system.audioContext, 'setListenerPosition')\nsystem.setListenerPosition(50, 75)\nexpect(spy).toHaveBeenCalledWith(50, 75, 0)"
              },
              {
                "title": "returns self for chaining",
                "line": 608,
                "source": "expect(system.setListenerPosition(10, 20)).toBe(system)"
              }
            ],
            "describes": []
          },
          {
            "title": "getListenerPosition",
            "line": 614,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "calls getListenerPosition on audio context",
                "line": 615,
                "source": "const spy = vi.spyOn(system.audioContext, 'getListenerPosition')\nsystem.getListenerPosition()\nexpect(spy).toHaveBeenCalled()"
              },
              {
                "title": "returns object with x and y properties",
                "line": 621,
                "source": "const pos = system.getListenerPosition()\nexpect(pos).toHaveProperty('x')\nexpect(pos).toHaveProperty('y')\nexpect(pos.z).toBeUndefined()"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/audio/audio_channel.doc.js": {
    "file": "/audio/audio_channel.test.js",
    "describes": [
      {
        "title": "AudioChannel",
        "line": 6,
        "beforeEach": {
          "line": 11,
          "source": "mockAudioContext = createMockPerkyAudioContext()\n\nchannel = new AudioChannel({\n    audioContext: mockAudioContext,\n    volume: 0.8\n})"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "getVolume returns current volume",
            "line": 271,
            "source": "channel.volume = 0.7\nexpect(channel.getVolume()).toBe(0.7)"
          }
        ],
        "describes": [
          {
            "title": "constructor",
            "line": 21,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "sets default volume to 1",
                "line": 22,
                "source": "const defaultChannel = new AudioChannel({})\nexpect(defaultChannel.volume).toBe(1)"
              },
              {
                "title": "accepts custom volume",
                "line": 27,
                "source": "expect(channel.volume).toBe(0.8)"
              },
              {
                "title": "sets static category",
                "line": 31,
                "source": "expect(AudioChannel.$category).toBe('audioChannel')"
              }
            ],
            "describes": []
          },
          {
            "title": "volume",
            "line": 37,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "get returns current volume",
                "line": 38,
                "source": "expect(channel.volume).toBe(0.8)"
              },
              {
                "title": "set updates volume",
                "line": 42,
                "source": "channel.volume = 0.5\nexpect(channel.volume).toBe(0.5)"
              },
              {
                "title": "clamps volume to minimum 0",
                "line": 47,
                "source": "channel.volume = -1\nexpect(channel.volume).toBe(0)"
              },
              {
                "title": "clamps volume to maximum 1",
                "line": 52,
                "source": "channel.volume = 2\nexpect(channel.volume).toBe(1)"
              }
            ],
            "describes": []
          },
          {
            "title": "muted",
            "line": 59,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "defaults to false",
                "line": 60,
                "source": "expect(channel.muted).toBe(false)"
              },
              {
                "title": "set updates muted state",
                "line": 64,
                "source": "channel.muted = true\nexpect(channel.muted).toBe(true)"
              },
              {
                "title": "converts truthy values to boolean",
                "line": 69,
                "source": "channel.muted = 1\nexpect(channel.muted).toBe(true)\nchannel.muted = 0\nexpect(channel.muted).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "gainNode",
            "line": 78,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns null without audio context",
                "line": 79,
                "source": "const noCtxChannel = new AudioChannel({})\nexpect(noCtxChannel.gainNode).toBeNull()"
              },
              {
                "title": "creates gain node lazily when accessed with audio context",
                "line": 84,
                "source": "expect(channel.gainNode).not.toBeNull()\nexpect(mockAudioContext.createGain).toHaveBeenCalled()"
              }
            ],
            "describes": []
          },
          {
            "title": "sources",
            "line": 91,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns empty array initially",
                "line": 92,
                "source": "expect(channel.sources).toEqual([])"
              },
              {
                "title": "sourceCount returns 0 initially",
                "line": 96,
                "source": "expect(channel.sourceCount).toBe(0)"
              }
            ],
            "describes": []
          },
          {
            "title": "onInstall",
            "line": 102,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "is a no-op as gain node is created lazily",
                "line": 103,
                "source": "// onInstall is empty, gain node is created lazily on first access\nexpect(() => channel.onInstall()).not.toThrow()"
              },
              {
                "title": "gain node connects to master gain when accessed",
                "line": 108,
                "source": "const gainNode = channel.gainNode\nexpect(gainNode.connect).toHaveBeenCalledWith(mockAudioContext.masterGain)"
              },
              {
                "title": "does nothing without audio context",
                "line": 113,
                "source": "const noCtxChannel = new AudioChannel({})\nexpect(() => noCtxChannel.onInstall()).not.toThrow()\nexpect(noCtxChannel.gainNode).toBeNull()"
              }
            ],
            "describes": []
          },
          {
            "title": "onDispose",
            "line": 121,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "stops all sources",
                "line": 122,
                "source": "const mockSource = {$id: 'test', stop: vi.fn()}\nchannel.registerSource(mockSource)\nchannel.onDispose()\nexpect(mockSource.stop).toHaveBeenCalled()"
              },
              {
                "title": "disconnects gain node if it exists",
                "line": 129,
                "source": "const gainNode = channel.gainNode // Force creation\nchannel.onDispose()\nexpect(gainNode.disconnect).toHaveBeenCalled()"
              },
              {
                "title": "clears internal gain node reference",
                "line": 135,
                "source": "// Access gainNode to create it\nconst gainNode = channel.gainNode\nexpect(gainNode).not.toBeNull()\nchannel.onDispose()\n\n// After dispose, the internal #gainNode is set to null\n// Accessing gainNode again would create a new one (lazy)\n// We verify dispose worked by checking disconnect was called\nexpect(gainNode.disconnect).toHaveBeenCalled()"
              }
            ],
            "describes": []
          },
          {
            "title": "registerSource",
            "line": 149,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "registers source by id",
                "line": 150,
                "source": "const source = {$id: 'test-source'}\nconst result = channel.registerSource(source)\nexpect(result).toBe(true)\nexpect(channel.sourceCount).toBe(1)"
              },
              {
                "title": "returns false for null source",
                "line": 157,
                "source": "expect(channel.registerSource(null)).toBe(false)"
              },
              {
                "title": "returns false for source without id",
                "line": 161,
                "source": "expect(channel.registerSource({})).toBe(false)"
              },
              {
                "title": "emits source:added event",
                "line": 165,
                "source": "const listener = vi.fn()\nchannel.on('source:added', listener)\nconst source = {$id: 'test'}\nchannel.registerSource(source)\nexpect(listener).toHaveBeenCalledWith(source)"
              }
            ],
            "describes": []
          },
          {
            "title": "unregisterSource",
            "line": 175,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "unregisters existing source",
                "line": 176,
                "source": "const source = {$id: 'test'}\nchannel.registerSource(source)\nconst result = channel.unregisterSource(source)\nexpect(result).toBe(true)\nexpect(channel.sourceCount).toBe(0)"
              },
              {
                "title": "returns false for null source",
                "line": 184,
                "source": "expect(channel.unregisterSource(null)).toBe(false)"
              },
              {
                "title": "returns false for non-registered source",
                "line": 188,
                "source": "expect(channel.unregisterSource({$id: 'unknown'})).toBe(false)"
              },
              {
                "title": "emits source:removed event",
                "line": 192,
                "source": "const listener = vi.fn()\nchannel.on('source:removed', listener)\nconst source = {$id: 'test'}\nchannel.registerSource(source)\nchannel.unregisterSource(source)\nexpect(listener).toHaveBeenCalledWith(source)"
              }
            ],
            "describes": []
          },
          {
            "title": "getSource",
            "line": 203,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns registered source",
                "line": 204,
                "source": "const source = {$id: 'test'}\nchannel.registerSource(source)\nexpect(channel.getSource('test')).toBe(source)"
              },
              {
                "title": "returns null for unknown source",
                "line": 210,
                "source": "expect(channel.getSource('unknown')).toBeNull()"
              }
            ],
            "describes": []
          },
          {
            "title": "hasSource",
            "line": 216,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns true for registered source",
                "line": 217,
                "source": "channel.registerSource({$id: 'test'})\nexpect(channel.hasSource('test')).toBe(true)"
              },
              {
                "title": "returns false for unknown source",
                "line": 222,
                "source": "expect(channel.hasSource('unknown')).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "stopAll",
            "line": 228,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "stops all registered sources",
                "line": 229,
                "source": "const source1 = {$id: 's1', stop: vi.fn()}\nconst source2 = {$id: 's2', stop: vi.fn()}\nchannel.registerSource(source1)\nchannel.registerSource(source2)\nchannel.stopAll()\nexpect(source1.stop).toHaveBeenCalled()\nexpect(source2.stop).toHaveBeenCalled()"
              },
              {
                "title": "clears sources map",
                "line": 239,
                "source": "channel.registerSource({$id: 'test', stop: vi.fn()})\nchannel.stopAll()\nexpect(channel.sourceCount).toBe(0)"
              },
              {
                "title": "handles sources without stop method",
                "line": 245,
                "source": "channel.registerSource({$id: 'test'})\nexpect(() => channel.stopAll()).not.toThrow()"
              }
            ],
            "describes": []
          },
          {
            "title": "setVolume",
            "line": 252,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "sets volume",
                "line": 253,
                "source": "channel.setVolume(0.5)\nexpect(channel.volume).toBe(0.5)"
              },
              {
                "title": "emits volume:changed event",
                "line": 258,
                "source": "const listener = vi.fn()\nchannel.on('volume:changed', listener)\nchannel.setVolume(0.5)\nexpect(listener).toHaveBeenCalledWith(0.5)"
              },
              {
                "title": "returns self for chaining",
                "line": 265,
                "source": "expect(channel.setVolume(0.5)).toBe(channel)"
              }
            ],
            "describes": []
          },
          {
            "title": "mute",
            "line": 277,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "sets muted to true",
                "line": 278,
                "source": "channel.mute()\nexpect(channel.muted).toBe(true)"
              },
              {
                "title": "emits muted event",
                "line": 283,
                "source": "const listener = vi.fn()\nchannel.on('muted', listener)\nchannel.mute()\nexpect(listener).toHaveBeenCalled()"
              },
              {
                "title": "returns self for chaining",
                "line": 290,
                "source": "expect(channel.mute()).toBe(channel)"
              }
            ],
            "describes": []
          },
          {
            "title": "unmute",
            "line": 296,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "sets muted to false",
                "line": 297,
                "source": "channel.muted = true\nchannel.unmute()\nexpect(channel.muted).toBe(false)"
              },
              {
                "title": "emits unmuted event",
                "line": 303,
                "source": "const listener = vi.fn()\nchannel.on('unmuted', listener)\nchannel.muted = true\nchannel.unmute()\nexpect(listener).toHaveBeenCalled()"
              },
              {
                "title": "returns self for chaining",
                "line": 311,
                "source": "expect(channel.unmute()).toBe(channel)"
              }
            ],
            "describes": []
          },
          {
            "title": "toggleMute",
            "line": 317,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "mutes when unmuted",
                "line": 318,
                "source": "channel.toggleMute()\nexpect(channel.muted).toBe(true)"
              },
              {
                "title": "unmutes when muted",
                "line": 323,
                "source": "channel.muted = true\nchannel.toggleMute()\nexpect(channel.muted).toBe(false)"
              },
              {
                "title": "returns self for chaining",
                "line": 329,
                "source": "expect(channel.toggleMute()).toBe(channel)"
              }
            ],
            "describes": []
          },
          {
            "title": "gain updates",
            "line": 335,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "updates gain when volume changes",
                "line": 336,
                "source": "channel.onInstall()\nchannel.volume = 0.5\nexpect(channel.gainNode.gain.setValueAtTime).toHaveBeenCalledWith(0.5, 0)"
              },
              {
                "title": "sets gain to 0 when muted",
                "line": 342,
                "source": "channel.onInstall()\nchannel.muted = true\nexpect(channel.gainNode.gain.setValueAtTime).toHaveBeenCalledWith(0, 0)"
              },
              {
                "title": "restores volume when unmuted",
                "line": 348,
                "source": "channel.onInstall()\nchannel.muted = true\nchannel.muted = false\nexpect(channel.gainNode.gain.setValueAtTime).toHaveBeenLastCalledWith(0.8, 0)"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/audio/audio_context.doc.js": {
    "file": "/audio/audio_context.test.js",
    "describes": [
      {
        "title": "AudioContext",
        "line": 6,
        "beforeEach": {
          "line": 12,
          "source": "mockNativeContext = createMockAudioContextWithSpies()\ncleanup = setupGlobalAudioContext(mockNativeContext)\naudioContext = new AudioContext()"
        },
        "afterEach": {
          "line": 19,
          "source": "cleanup()"
        },
        "tests": [],
        "describes": [
          {
            "title": "constructor",
            "line": 24,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "starts with null context",
                "line": 25,
                "source": "expect(audioContext.context).toBeNull()"
              },
              {
                "title": "starts with null masterGain",
                "line": 29,
                "source": "expect(audioContext.masterGain).toBeNull()"
              },
              {
                "title": "starts suspended",
                "line": 33,
                "source": "expect(audioContext.suspended).toBe(true)"
              }
            ],
            "describes": []
          },
          {
            "title": "getters",
            "line": 39,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "currentTime returns 0 when no context",
                "line": 40,
                "source": "expect(audioContext.currentTime).toBe(0)"
              },
              {
                "title": "sampleRate returns 44100 when no context",
                "line": 44,
                "source": "expect(audioContext.sampleRate).toBe(44100)"
              },
              {
                "title": "currentTime returns context time after init",
                "line": 48,
                "source": "mockNativeContext.currentTime = 5.5\naudioContext.init()\nexpect(audioContext.currentTime).toBe(5.5)"
              },
              {
                "title": "sampleRate returns context rate after init",
                "line": 54,
                "source": "audioContext.init()\nexpect(audioContext.sampleRate).toBe(48000)"
              }
            ],
            "describes": []
          },
          {
            "title": "init",
            "line": 61,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates native audio context",
                "line": 62,
                "source": "audioContext.init()\nexpect(global.window.AudioContext).toHaveBeenCalled()"
              },
              {
                "title": "creates master gain node",
                "line": 67,
                "source": "audioContext.init()\nexpect(mockNativeContext.createGain).toHaveBeenCalled()\nexpect(audioContext.masterGain).not.toBeNull()"
              },
              {
                "title": "connects master gain to destination",
                "line": 73,
                "source": "audioContext.init()\nconst masterGain = audioContext.masterGain\nexpect(masterGain.connect).toHaveBeenCalledWith(mockNativeContext.destination)"
              },
              {
                "title": "returns existing context if already initialized",
                "line": 79,
                "source": "const first = audioContext.init()\nconst second = audioContext.init()\nexpect(first).toBe(second)\nexpect(global.window.AudioContext).toHaveBeenCalledTimes(1)"
              },
              {
                "title": "uses webkitAudioContext fallback",
                "line": 86,
                "source": "delete global.window.AudioContext\nglobal.window.webkitAudioContext = vi.fn(() => mockNativeContext)\naudioContext.init()\nexpect(global.window.webkitAudioContext).toHaveBeenCalled()"
              },
              {
                "title": "throws error if no AudioContext available",
                "line": 93,
                "source": "// Create a fresh AudioContext without the global mock\ncleanup()\nglobal.window = {}\nconst freshContext = new AudioContext()\nexpect(() => freshContext.init()).toThrow('Web Audio API is not supported')\n\n// Restore for other tests\ncleanup = setupGlobalAudioContext(mockNativeContext)"
              },
              {
                "title": "sets suspended based on context state",
                "line": 104,
                "source": "mockNativeContext.state = 'running'\naudioContext.init()\nexpect(audioContext.suspended).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "resume",
            "line": 112,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "initializes context if not yet created",
                "line": 113,
                "source": "await audioContext.resume()\nexpect(audioContext.context).not.toBeNull()"
              },
              {
                "title": "resumes suspended context",
                "line": 118,
                "source": "await audioContext.resume()\nexpect(mockNativeContext.resume).toHaveBeenCalled()"
              },
              {
                "title": "sets suspended to false",
                "line": 123,
                "source": "await audioContext.resume()\nexpect(audioContext.suspended).toBe(false)"
              },
              {
                "title": "does not resume if already running",
                "line": 128,
                "source": "mockNativeContext.state = 'running'\naudioContext.init()\nawait audioContext.resume()\nexpect(mockNativeContext.resume).not.toHaveBeenCalled()"
              },
              {
                "title": "returns self for chaining",
                "line": 135,
                "source": "const result = await audioContext.resume()\nexpect(result).toBe(audioContext)"
              }
            ],
            "describes": []
          },
          {
            "title": "suspend",
            "line": 142,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "suspends running context",
                "line": 143,
                "source": "audioContext.init()\nmockNativeContext.state = 'running'\naudioContext.suspend()\nexpect(mockNativeContext.suspend).toHaveBeenCalled()"
              },
              {
                "title": "sets suspended to true",
                "line": 150,
                "source": "audioContext.init()\nmockNativeContext.state = 'running'\naudioContext.suspend()\nexpect(audioContext.suspended).toBe(true)"
              },
              {
                "title": "does nothing if already suspended",
                "line": 157,
                "source": "audioContext.init()\naudioContext.suspend()\nexpect(mockNativeContext.suspend).not.toHaveBeenCalled()"
              },
              {
                "title": "does nothing if no context",
                "line": 163,
                "source": "audioContext.suspend()\nexpect(mockNativeContext.suspend).not.toHaveBeenCalled()"
              },
              {
                "title": "returns self for chaining",
                "line": 168,
                "source": "const result = audioContext.suspend()\nexpect(result).toBe(audioContext)"
              }
            ],
            "describes": []
          },
          {
            "title": "setMasterVolume",
            "line": 175,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "sets gain value",
                "line": 176,
                "source": "audioContext.init()\naudioContext.setMasterVolume(0.5)\nexpect(audioContext.masterGain.gain.setValueAtTime).toHaveBeenCalledWith(0.5, 0)"
              },
              {
                "title": "clamps volume to 0-1 range",
                "line": 182,
                "source": "audioContext.init()\naudioContext.setMasterVolume(2)\nexpect(audioContext.masterGain.gain.setValueAtTime).toHaveBeenCalledWith(1, 0)\naudioContext.setMasterVolume(-1)\nexpect(audioContext.masterGain.gain.setValueAtTime).toHaveBeenCalledWith(0, 0)"
              },
              {
                "title": "does nothing without masterGain",
                "line": 190,
                "source": "expect(() => audioContext.setMasterVolume(0.5)).not.toThrow()"
              },
              {
                "title": "returns self for chaining",
                "line": 194,
                "source": "const result = audioContext.setMasterVolume(0.5)\nexpect(result).toBe(audioContext)"
              }
            ],
            "describes": []
          },
          {
            "title": "getMasterVolume",
            "line": 201,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns current gain value",
                "line": 202,
                "source": "audioContext.init()\nexpect(audioContext.getMasterVolume()).toBe(1)"
              },
              {
                "title": "returns 1 if no masterGain",
                "line": 207,
                "source": "expect(audioContext.getMasterVolume()).toBe(1)"
              }
            ],
            "describes": []
          },
          {
            "title": "factory methods",
            "line": 213,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "createGain initializes and creates gain node",
                "line": 214,
                "source": "const gain = audioContext.createGain()\nexpect(mockNativeContext.createGain).toHaveBeenCalled()\nexpect(gain).toBeDefined()"
              },
              {
                "title": "createOscillator initializes and creates oscillator",
                "line": 220,
                "source": "audioContext.createOscillator()\nexpect(mockNativeContext.createOscillator).toHaveBeenCalled()"
              },
              {
                "title": "createBufferSource initializes and creates buffer source",
                "line": 225,
                "source": "audioContext.createBufferSource()\nexpect(mockNativeContext.createBufferSource).toHaveBeenCalled()"
              },
              {
                "title": "createPanner initializes and creates panner",
                "line": 230,
                "source": "audioContext.createPanner()\nexpect(mockNativeContext.createPanner).toHaveBeenCalled()"
              },
              {
                "title": "createStereoPanner initializes and creates stereo panner",
                "line": 235,
                "source": "audioContext.createStereoPanner()\nexpect(mockNativeContext.createStereoPanner).toHaveBeenCalled()"
              }
            ],
            "describes": []
          },
          {
            "title": "decodeAudioData",
            "line": 242,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "decodes array buffer when context is running",
                "line": 243,
                "source": "audioContext.init()\nmockNativeContext.state = 'running'\nconst buffer = new ArrayBuffer(100)\nconst result = await audioContext.decodeAudioData(buffer)\nexpect(mockNativeContext.decodeAudioData).toHaveBeenCalledWith(buffer)\nexpect(result).toBe(buffer)"
              },
              {
                "title": "queues decoding when context is suspended",
                "line": 252,
                "source": "const buffer = new ArrayBuffer(100)\n\n// Decode is queued when suspended, returns a pending promise\nconst decodePromise = audioContext.decodeAudioData(buffer)\n\n// Decode should not be called yet (still suspended)\nexpect(mockNativeContext.decodeAudioData).not.toHaveBeenCalled()\n\n// The promise exists but won't resolve until context is resumed\nexpect(decodePromise).toBeInstanceOf(Promise)"
              },
              {
                "title": "initializes context before decoding",
                "line": 265,
                "source": "mockNativeContext.state = 'running'\nawait audioContext.decodeAudioData(new ArrayBuffer(100))\nexpect(audioContext.context).not.toBeNull()"
              }
            ],
            "describes": []
          },
          {
            "title": "dispose",
            "line": 273,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "closes context",
                "line": 274,
                "source": "audioContext.init()\naudioContext.dispose()\nexpect(mockNativeContext.close).toHaveBeenCalled()"
              },
              {
                "title": "sets context to null",
                "line": 280,
                "source": "audioContext.init()\naudioContext.dispose()\nexpect(audioContext.context).toBeNull()"
              },
              {
                "title": "sets masterGain to null",
                "line": 286,
                "source": "audioContext.init()\naudioContext.dispose()\nexpect(audioContext.masterGain).toBeNull()"
              },
              {
                "title": "does nothing if no context",
                "line": 292,
                "source": "expect(() => audioContext.dispose()).not.toThrow()"
              }
            ],
            "describes": []
          },
          {
            "title": "setListenerPosition",
            "line": 298,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "initializes context if needed",
                "line": 299,
                "source": "audioContext.setListenerPosition(10, 20, 30)\nexpect(audioContext.context).not.toBeNull()"
              },
              {
                "title": "sets position using positionX/Y/Z when available",
                "line": 304,
                "source": "audioContext.init()\nconst listener = mockNativeContext.listener\naudioContext.setListenerPosition(10, 20, 30)\nexpect(listener.positionX.setValueAtTime).toHaveBeenCalledWith(10, 0)\nexpect(listener.positionY.setValueAtTime).toHaveBeenCalledWith(20, 0)\nexpect(listener.positionZ.setValueAtTime).toHaveBeenCalledWith(30, 0)"
              },
              {
                "title": "uses z=0 by default",
                "line": 313,
                "source": "audioContext.init()\nconst listener = mockNativeContext.listener\naudioContext.setListenerPosition(10, 20)\nexpect(listener.positionZ.setValueAtTime).toHaveBeenCalledWith(0, 0)"
              },
              {
                "title": "falls back to setPosition method if positionX not available",
                "line": 320,
                "source": "audioContext.init()\nconst listener = mockNativeContext.listener\ndelete listener.positionX\nlistener.setPosition = vi.fn()\naudioContext.setListenerPosition(10, 20, 30)\nexpect(listener.setPosition).toHaveBeenCalledWith(10, 20, 30)"
              },
              {
                "title": "returns self for chaining",
                "line": 329,
                "source": "const result = audioContext.setListenerPosition(10, 20)\nexpect(result).toBe(audioContext)"
              }
            ],
            "describes": []
          },
          {
            "title": "getListenerPosition",
            "line": 336,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns default position when no context",
                "line": 337,
                "source": "expect(audioContext.getListenerPosition()).toEqual({x: 0, y: 0, z: 0})"
              },
              {
                "title": "returns position from positionX/Y/Z when available",
                "line": 341,
                "source": "audioContext.init()\nconst listener = mockNativeContext.listener\nlistener.positionX.value = 15\nlistener.positionY.value = 25\nlistener.positionZ.value = 35\nexpect(audioContext.getListenerPosition()).toEqual({x: 15, y: 25, z: 35})"
              },
              {
                "title": "returns default position when positionX not available",
                "line": 350,
                "source": "audioContext.init()\nconst listener = mockNativeContext.listener\ndelete listener.positionX\nexpect(audioContext.getListenerPosition()).toEqual({x: 0, y: 0, z: 0})"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/audio/audio_source.doc.js": {
    "file": "/audio/audio_source.test.js",
    "describes": [
      {
        "title": "AudioSource",
        "line": 6,
        "beforeEach": {
          "line": 14,
          "source": "mockGainNode = createMockGainNodeWithSpies()\nmockSourceNode = createMockBufferSourceNode()\n\nmockAudioContext = createMockPerkyAudioContext()\nmockAudioContext.createGain = vi.fn(() => mockGainNode)\nmockAudioContext.createBufferSource = vi.fn(() => mockSourceNode)\nmockAudioContext.createOscillator = vi.fn(() => createMockOscillatorNode())\n\nmockChannel = createMockChannel({audioContext: mockAudioContext})\n\nsource = new AudioSource({\n    audioContext: mockAudioContext,\n    channel: mockChannel,\n    loop: false,\n    volume: 0.8,\n    playbackRate: 1.5\n})"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "channel returns the channel",
            "line": 153,
            "source": "expect(source.channel).toBe(mockChannel)"
          },
          {
            "title": "getVolume returns current volume",
            "line": 436,
            "source": "expect(source.getVolume()).toBe(0.8)"
          },
          {
            "title": "onDispose stops playback",
            "line": 578,
            "source": "source.playBuffer({})\nsource.onDispose()\nexpect(source.playing).toBe(false)"
          }
        ],
        "describes": [
          {
            "title": "constructor",
            "line": 35,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "sets static category",
                "line": 36,
                "source": "expect(AudioSource.$category).toBe('audioSource')"
              },
              {
                "title": "sets static lifecycle to false",
                "line": 40,
                "source": "expect(AudioSource.$lifecycle).toBe(false)"
              },
              {
                "title": "accepts loop option",
                "line": 44,
                "source": "expect(source.loop).toBe(false)"
              },
              {
                "title": "accepts volume option",
                "line": 48,
                "source": "expect(source.volume).toBe(0.8)"
              },
              {
                "title": "accepts playbackRate option",
                "line": 52,
                "source": "expect(source.playbackRate).toBe(1.5)"
              },
              {
                "title": "defaults loop to false",
                "line": 56,
                "source": "const s = new AudioSource({})\nexpect(s.loop).toBe(false)"
              },
              {
                "title": "defaults volume to 1",
                "line": 61,
                "source": "const s = new AudioSource({})\nexpect(s.volume).toBe(1)"
              },
              {
                "title": "defaults playbackRate to 1",
                "line": 66,
                "source": "const s = new AudioSource({})\nexpect(s.playbackRate).toBe(1)"
              }
            ],
            "describes": []
          },
          {
            "title": "playing",
            "line": 73,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns false initially",
                "line": 74,
                "source": "expect(source.playing).toBe(false)"
              },
              {
                "title": "returns true while playing",
                "line": 78,
                "source": "source.playBuffer({})\nexpect(source.playing).toBe(true)"
              }
            ],
            "describes": []
          },
          {
            "title": "loop",
            "line": 85,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "get returns current loop state",
                "line": 86,
                "source": "expect(source.loop).toBe(false)"
              },
              {
                "title": "set updates loop state",
                "line": 90,
                "source": "source.loop = true\nexpect(source.loop).toBe(true)"
              },
              {
                "title": "updates source node loop property",
                "line": 95,
                "source": "source.playBuffer({})\nsource.loop = true\nexpect(mockSourceNode.loop).toBe(true)"
              }
            ],
            "describes": []
          },
          {
            "title": "volume",
            "line": 103,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "get returns current volume",
                "line": 104,
                "source": "expect(source.volume).toBe(0.8)"
              },
              {
                "title": "set updates volume",
                "line": 108,
                "source": "source.volume = 0.5\nexpect(source.volume).toBe(0.5)"
              },
              {
                "title": "clamps to minimum 0",
                "line": 113,
                "source": "source.volume = -1\nexpect(source.volume).toBe(0)"
              },
              {
                "title": "clamps to maximum 1",
                "line": 118,
                "source": "source.volume = 2\nexpect(source.volume).toBe(1)"
              }
            ],
            "describes": []
          },
          {
            "title": "playbackRate",
            "line": 125,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "get returns current rate",
                "line": 126,
                "source": "expect(source.playbackRate).toBe(1.5)"
              },
              {
                "title": "set updates rate",
                "line": 130,
                "source": "source.playbackRate = 2\nexpect(source.playbackRate).toBe(2)"
              },
              {
                "title": "clamps to minimum 0.1",
                "line": 135,
                "source": "source.playbackRate = 0\nexpect(source.playbackRate).toBe(0.1)"
              },
              {
                "title": "clamps to maximum 10",
                "line": 140,
                "source": "source.playbackRate = 20\nexpect(source.playbackRate).toBe(10)"
              },
              {
                "title": "updates source node rate when playing",
                "line": 145,
                "source": "source.playBuffer({})\nsource.playbackRate = 2\nexpect(mockSourceNode.playbackRate.setValueAtTime).toHaveBeenCalledWith(2, 0)"
              }
            ],
            "describes": []
          },
          {
            "title": "gainNode",
            "line": 158,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns null before playing",
                "line": 159,
                "source": "expect(source.gainNode).toBeNull()"
              },
              {
                "title": "returns gain node while playing",
                "line": 163,
                "source": "source.playBuffer({})\nexpect(source.gainNode).toBe(mockGainNode)"
              }
            ],
            "describes": []
          },
          {
            "title": "sourceNode",
            "line": 170,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns null before playing",
                "line": 171,
                "source": "expect(source.sourceNode).toBeNull()"
              },
              {
                "title": "returns source node while playing",
                "line": 175,
                "source": "source.playBuffer({})\nexpect(source.sourceNode).toBe(mockSourceNode)"
              }
            ],
            "describes": []
          },
          {
            "title": "currentTime",
            "line": 182,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns 0 when not playing",
                "line": 183,
                "source": "expect(source.currentTime).toBe(0)"
              },
              {
                "title": "returns elapsed time when playing",
                "line": 187,
                "source": "source.playBuffer({})\nmockAudioContext.currentTime = 5\nexpect(source.currentTime).toBe(5)"
              }
            ],
            "describes": []
          },
          {
            "title": "playBuffer",
            "line": 195,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates gain node",
                "line": 196,
                "source": "source.playBuffer({})\nexpect(mockAudioContext.createGain).toHaveBeenCalled()"
              },
              {
                "title": "creates buffer source",
                "line": 201,
                "source": "source.playBuffer({})\nexpect(mockAudioContext.createBufferSource).toHaveBeenCalled()"
              },
              {
                "title": "sets buffer on source node",
                "line": 206,
                "source": "const buffer = {duration: 10}\nsource.playBuffer(buffer)\nexpect(mockSourceNode.buffer).toBe(buffer)"
              },
              {
                "title": "sets loop on source node",
                "line": 212,
                "source": "source.loop = true\nsource.playBuffer({})\nexpect(mockSourceNode.loop).toBe(true)"
              },
              {
                "title": "starts playback",
                "line": 218,
                "source": "source.playBuffer({})\nexpect(mockSourceNode.start).toHaveBeenCalledWith(0, 0)"
              },
              {
                "title": "starts with offset",
                "line": 223,
                "source": "source.playBuffer({}, 5)\nexpect(mockSourceNode.start).toHaveBeenCalledWith(0, 5)"
              },
              {
                "title": "registers with channel",
                "line": 228,
                "source": "source.playBuffer({})\nexpect(mockChannel.registerSource).toHaveBeenCalledWith(source)"
              },
              {
                "title": "emits play event",
                "line": 233,
                "source": "const listener = vi.fn()\nsource.on('play', listener)\nsource.playBuffer({})\nexpect(listener).toHaveBeenCalled()"
              },
              {
                "title": "returns true on success",
                "line": 240,
                "source": "expect(source.playBuffer({})).toBe(true)"
              },
              {
                "title": "returns false without audio context",
                "line": 244,
                "source": "const s = new AudioSource({})\nexpect(s.playBuffer({})).toBe(false)"
              },
              {
                "title": "returns false without buffer",
                "line": 249,
                "source": "expect(source.playBuffer(null)).toBe(false)"
              },
              {
                "title": "stops previous playback",
                "line": 253,
                "source": "source.playBuffer({})\nsource.playBuffer({})\nexpect(mockSourceNode.stop).toHaveBeenCalled()"
              },
              {
                "title": "connects to channel gain node",
                "line": 259,
                "source": "source.playBuffer({})\nexpect(mockGainNode.connect).toHaveBeenCalledWith(mockChannel.gainNode)"
              },
              {
                "title": "connects to master gain when no channel",
                "line": 264,
                "source": "const s = new AudioSource({audioContext: mockAudioContext})\ns.playBuffer({})\nexpect(mockGainNode.connect).toHaveBeenCalledWith(mockAudioContext.masterGain)"
              },
              {
                "title": "handles onended event",
                "line": 270,
                "source": "source.playBuffer({})\nconst listener = vi.fn()\nsource.on('ended', listener)\nmockSourceNode.onended()\nexpect(listener).toHaveBeenCalled()"
              },
              {
                "title": "unregisters from channel on end",
                "line": 278,
                "source": "source.playBuffer({})\nmockSourceNode.onended()\nexpect(mockChannel.unregisterSource).toHaveBeenCalledWith(source)"
              },
              {
                "title": "does not emit ended when looping",
                "line": 284,
                "source": "source.loop = true\nsource.playBuffer({})\nconst listener = vi.fn()\nsource.on('ended', listener)\nmockSourceNode.onended()\nexpect(listener).not.toHaveBeenCalled()"
              }
            ],
            "describes": []
          },
          {
            "title": "playOscillator",
            "line": 295,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates gain node",
                "line": 296,
                "source": "source.playOscillator()\nexpect(mockAudioContext.createGain).toHaveBeenCalled()"
              },
              {
                "title": "creates oscillator",
                "line": 301,
                "source": "source.playOscillator()\nexpect(mockAudioContext.createOscillator).toHaveBeenCalled()"
              },
              {
                "title": "sets oscillator type",
                "line": 306,
                "source": "source.playOscillator('square')\nconst oscillator = mockAudioContext.createOscillator.mock.results[0].value\nexpect(oscillator.type).toBe('square')"
              },
              {
                "title": "sets oscillator frequency",
                "line": 312,
                "source": "source.playOscillator('sine', 880)\nconst oscillator = mockAudioContext.createOscillator.mock.results[0].value\nexpect(oscillator.frequency.setValueAtTime).toHaveBeenCalledWith(880, 0)"
              },
              {
                "title": "starts oscillator",
                "line": 318,
                "source": "source.playOscillator()\nconst oscillator = mockAudioContext.createOscillator.mock.results[0].value\nexpect(oscillator.start).toHaveBeenCalled()"
              },
              {
                "title": "schedules stop with duration",
                "line": 324,
                "source": "source.playOscillator('sine', 440, 2)\nconst oscillator = mockAudioContext.createOscillator.mock.results[0].value\nexpect(oscillator.stop).toHaveBeenCalledWith(2)"
              },
              {
                "title": "does not schedule stop without duration",
                "line": 330,
                "source": "source.playOscillator('sine', 440, null)\nconst oscillator = mockAudioContext.createOscillator.mock.results[0].value\nexpect(oscillator.stop).not.toHaveBeenCalled()"
              },
              {
                "title": "registers with channel",
                "line": 336,
                "source": "source.playOscillator()\nexpect(mockChannel.registerSource).toHaveBeenCalledWith(source)"
              },
              {
                "title": "emits play event",
                "line": 341,
                "source": "const listener = vi.fn()\nsource.on('play', listener)\nsource.playOscillator()\nexpect(listener).toHaveBeenCalled()"
              },
              {
                "title": "returns true on success",
                "line": 348,
                "source": "expect(source.playOscillator()).toBe(true)"
              },
              {
                "title": "returns false without audio context",
                "line": 352,
                "source": "const s = new AudioSource({})\nexpect(s.playOscillator()).toBe(false)"
              },
              {
                "title": "uses default values",
                "line": 357,
                "source": "source.playOscillator()\nconst oscillator = mockAudioContext.createOscillator.mock.results[0].value\nexpect(oscillator.type).toBe('sine')\nexpect(oscillator.frequency.setValueAtTime).toHaveBeenCalledWith(440, 0)"
              }
            ],
            "describes": []
          },
          {
            "title": "stop",
            "line": 366,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns false when not playing",
                "line": 367,
                "source": "expect(source.stop()).toBe(false)"
              },
              {
                "title": "stops source node",
                "line": 371,
                "source": "source.playBuffer({})\nsource.stop()\nexpect(mockSourceNode.stop).toHaveBeenCalled()"
              },
              {
                "title": "disconnects source node",
                "line": 377,
                "source": "source.playBuffer({})\nsource.stop()\nexpect(mockSourceNode.disconnect).toHaveBeenCalled()"
              },
              {
                "title": "disconnects gain node",
                "line": 383,
                "source": "source.playBuffer({})\nsource.stop()\nexpect(mockGainNode.disconnect).toHaveBeenCalled()"
              },
              {
                "title": "unregisters from channel",
                "line": 389,
                "source": "source.playBuffer({})\nsource.stop()\nexpect(mockChannel.unregisterSource).toHaveBeenCalledWith(source)"
              },
              {
                "title": "emits stop event",
                "line": 395,
                "source": "source.playBuffer({})\nconst listener = vi.fn()\nsource.on('stop', listener)\nsource.stop()\nexpect(listener).toHaveBeenCalled()"
              },
              {
                "title": "returns true on success",
                "line": 403,
                "source": "source.playBuffer({})\nexpect(source.stop()).toBe(true)"
              },
              {
                "title": "sets playing to false",
                "line": 408,
                "source": "source.playBuffer({})\nsource.stop()\nexpect(source.playing).toBe(false)"
              },
              {
                "title": "handles source node stop error",
                "line": 414,
                "source": "source.playBuffer({})\nmockSourceNode.stop.mockImplementation(() => {\n    throw new Error('already stopped')\n})\nexpect(() => source.stop()).not.toThrow()"
              }
            ],
            "describes": []
          },
          {
            "title": "setVolume",
            "line": 424,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "sets volume",
                "line": 425,
                "source": "source.setVolume(0.5)\nexpect(source.volume).toBe(0.5)"
              },
              {
                "title": "returns self for chaining",
                "line": 430,
                "source": "expect(source.setVolume(0.5)).toBe(source)"
              }
            ],
            "describes": []
          },
          {
            "title": "setLoop",
            "line": 441,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "sets loop",
                "line": 442,
                "source": "source.setLoop(true)\nexpect(source.loop).toBe(true)"
              },
              {
                "title": "returns self for chaining",
                "line": 447,
                "source": "expect(source.setLoop(true)).toBe(source)"
              }
            ],
            "describes": []
          },
          {
            "title": "setPlaybackRate",
            "line": 453,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "sets playback rate",
                "line": 454,
                "source": "source.setPlaybackRate(2)\nexpect(source.playbackRate).toBe(2)"
              },
              {
                "title": "returns self for chaining",
                "line": 459,
                "source": "expect(source.setPlaybackRate(2)).toBe(source)"
              }
            ],
            "describes": []
          },
          {
            "title": "fadeIn",
            "line": 465,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns self without gain node",
                "line": 466,
                "source": "expect(source.fadeIn()).toBe(source)"
              },
              {
                "title": "sets initial gain to 0",
                "line": 470,
                "source": "source.playBuffer({})\nsource.fadeIn(1)\nexpect(mockGainNode.gain.setValueAtTime).toHaveBeenCalledWith(0, 0)"
              },
              {
                "title": "ramps to target volume",
                "line": 476,
                "source": "source.playBuffer({})\nsource.fadeIn(2)\nexpect(mockGainNode.gain.linearRampToValueAtTime).toHaveBeenCalledWith(0.8, 2)"
              },
              {
                "title": "uses default duration of 1",
                "line": 482,
                "source": "source.playBuffer({})\nsource.fadeIn()\nexpect(mockGainNode.gain.linearRampToValueAtTime).toHaveBeenCalledWith(0.8, 1)"
              },
              {
                "title": "returns self for chaining",
                "line": 488,
                "source": "source.playBuffer({})\nexpect(source.fadeIn()).toBe(source)"
              }
            ],
            "describes": []
          },
          {
            "title": "fadeOut",
            "line": 495,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns self without gain node",
                "line": 496,
                "source": "expect(source.fadeOut()).toBe(source)"
              },
              {
                "title": "sets current gain value",
                "line": 500,
                "source": "source.playBuffer({})\nsource.fadeOut(1)\nexpect(mockGainNode.gain.setValueAtTime).toHaveBeenCalled()"
              },
              {
                "title": "ramps to 0",
                "line": 506,
                "source": "source.playBuffer({})\nsource.fadeOut(2)\nexpect(mockGainNode.gain.linearRampToValueAtTime).toHaveBeenCalledWith(0, 2)"
              },
              {
                "title": "stops after fade by default",
                "line": 512,
                "source": "vi.useFakeTimers()\nsource.playBuffer({})\nsource.fadeOut(1)\nvi.advanceTimersByTime(1000)\nexpect(source.playing).toBe(false)\nvi.useRealTimers()"
              },
              {
                "title": "does not stop when stopAfter is false",
                "line": 521,
                "source": "vi.useFakeTimers()\nsource.playBuffer({})\nsource.fadeOut(1, false)\nvi.advanceTimersByTime(1000)\nexpect(source.playing).toBe(true)\nvi.useRealTimers()"
              },
              {
                "title": "returns self for chaining",
                "line": 530,
                "source": "source.playBuffer({})\nexpect(source.fadeOut()).toBe(source)"
              }
            ],
            "describes": []
          },
          {
            "title": "setPosition",
            "line": 537,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "sets x and y coordinates",
                "line": 538,
                "source": "source.setPosition(100, 200)\nexpect(source.x).toBe(100)\nexpect(source.y).toBe(200)"
              },
              {
                "title": "updates panner position when playing with spatial audio",
                "line": 544,
                "source": "const spatialSource = new AudioSource({\n    audioContext: mockAudioContext,\n    channel: mockChannel,\n    spatial: true\n})\nconst mockPanner = createMockPannerNode()\nmockPanner.positionX = {value: 0, setValueAtTime: vi.fn()}\nmockPanner.positionY = {value: 0, setValueAtTime: vi.fn()}\nmockAudioContext.createPanner = vi.fn(() => mockPanner)\nspatialSource.playBuffer({})\nspatialSource.setPosition(50, 75)\nexpect(mockPanner.positionX.setValueAtTime).toHaveBeenCalledWith(50, 0)\nexpect(mockPanner.positionY.setValueAtTime).toHaveBeenCalledWith(75, 0)"
              },
              {
                "title": "returns self for chaining",
                "line": 560,
                "source": "expect(source.setPosition(10, 20)).toBe(source)"
              }
            ],
            "describes": []
          },
          {
            "title": "getPosition",
            "line": 566,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns current position",
                "line": 567,
                "source": "source.setPosition(30, 40)\nexpect(source.getPosition()).toEqual({x: 30, y: 40})"
              },
              {
                "title": "returns default position when not set",
                "line": 572,
                "source": "expect(source.getPosition()).toEqual({x: 0, y: 0})"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/audio/audio_unlock.doc.js": {
    "file": "/audio/audio_unlock.test.js",
    "describes": [
      {
        "title": "isAudioUnlocked",
        "line": 58,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "returns false initially",
            "line": 59,
            "source": "expect(module.isAudioUnlocked()).toBe(false)"
          },
          {
            "title": "returns true after unlock event",
            "line": 63,
            "source": "const clickListeners = documentListeners.click\nexpect(clickListeners).toBeDefined()\nexpect(clickListeners.length).toBeGreaterThan(0)\n\nconst handleUnlock = clickListeners[0].handler\nhandleUnlock()\n\nexpect(module.isAudioUnlocked()).toBe(true)"
          }
        ],
        "describes": []
      },
      {
        "title": "onAudioUnlock",
        "line": 76,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "queues callback when audio is locked",
            "line": 77,
            "source": "const callback = vi.fn()\n\nmodule.onAudioUnlock(callback)\n\nexpect(callback).not.toHaveBeenCalled()"
          },
          {
            "title": "executes immediately when already unlocked",
            "line": 85,
            "source": "const callback = vi.fn()\n\n// Trigger unlock\nconst clickListeners = documentListeners.click\nconst handleUnlock = clickListeners[0].handler\nhandleUnlock()\n\nmodule.onAudioUnlock(callback)\n\nexpect(callback).toHaveBeenCalledTimes(1)"
          },
          {
            "title": "executes queued callbacks on unlock",
            "line": 98,
            "source": "const callback1 = vi.fn()\nconst callback2 = vi.fn()\nconst callback3 = vi.fn()\n\nmodule.onAudioUnlock(callback1)\nmodule.onAudioUnlock(callback2)\nmodule.onAudioUnlock(callback3)\n\nexpect(callback1).not.toHaveBeenCalled()\nexpect(callback2).not.toHaveBeenCalled()\nexpect(callback3).not.toHaveBeenCalled()\n\n// Trigger unlock via click\nconst clickListeners = documentListeners.click\nconst handleUnlock = clickListeners[0].handler\nhandleUnlock()\n\nexpect(callback1).toHaveBeenCalledTimes(1)\nexpect(callback2).toHaveBeenCalledTimes(1)\nexpect(callback3).toHaveBeenCalledTimes(1)"
          },
          {
            "title": "executes callbacks in registration order",
            "line": 121,
            "source": "const callOrder = []\nconst callback1 = vi.fn(() => callOrder.push('callback1'))\nconst callback2 = vi.fn(() => callOrder.push('callback2'))\nconst callback3 = vi.fn(() => callOrder.push('callback3'))\n\nmodule.onAudioUnlock(callback1)\nmodule.onAudioUnlock(callback2)\nmodule.onAudioUnlock(callback3)\n\n// Trigger unlock\nconst clickListeners = documentListeners.click\nconst handleUnlock = clickListeners[0].handler\nhandleUnlock()\n\nexpect(callOrder).toEqual(['callback1', 'callback2', 'callback3'])"
          }
        ],
        "describes": []
      },
      {
        "title": "unlock events",
        "line": 141,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "click unlocks audio",
            "line": 142,
            "source": "const callback = vi.fn()\nmodule.onAudioUnlock(callback)\n\nconst clickListeners = documentListeners.click\nconst handleUnlock = clickListeners[0].handler\nhandleUnlock()\n\nexpect(callback).toHaveBeenCalledTimes(1)\nexpect(module.isAudioUnlocked()).toBe(true)"
          },
          {
            "title": "touchstart unlocks audio",
            "line": 154,
            "source": "const callback = vi.fn()\nmodule.onAudioUnlock(callback)\n\nconst touchstartListeners = documentListeners.touchstart\nconst handleUnlock = touchstartListeners[0].handler\nhandleUnlock()\n\nexpect(callback).toHaveBeenCalledTimes(1)\nexpect(module.isAudioUnlocked()).toBe(true)"
          },
          {
            "title": "keydown unlocks audio",
            "line": 166,
            "source": "const callback = vi.fn()\nmodule.onAudioUnlock(callback)\n\nconst keydownListeners = documentListeners.keydown\nconst handleUnlock = keydownListeners[0].handler\nhandleUnlock()\n\nexpect(callback).toHaveBeenCalledTimes(1)\nexpect(module.isAudioUnlocked()).toBe(true)"
          },
          {
            "title": "gamepadconnected unlocks audio",
            "line": 178,
            "source": "const callback = vi.fn()\nmodule.onAudioUnlock(callback)\n\nconst gamepadListeners = windowListeners.gamepadconnected\nconst handleUnlock = gamepadListeners[0].handler\nhandleUnlock()\n\nexpect(callback).toHaveBeenCalledTimes(1)\nexpect(module.isAudioUnlocked()).toBe(true)"
          },
          {
            "title": "unlocks only once with multiple events",
            "line": 190,
            "source": "const callback = vi.fn()\nmodule.onAudioUnlock(callback)\n\n// Trigger multiple unlock events\nconst clickListeners = documentListeners.click\nconst touchstartListeners = documentListeners.touchstart\nconst keydownListeners = documentListeners.keydown\n\nclickListeners[0].handler()\ntouchstartListeners[0].handler()\nkeydownListeners[0].handler()\n\nexpect(callback).toHaveBeenCalledTimes(1)\nexpect(module.isAudioUnlocked()).toBe(true)"
          }
        ],
        "describes": []
      },
      {
        "title": "event cleanup",
        "line": 209,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "removes all event listeners after unlock",
            "line": 210,
            "source": "// Trigger unlock\nconst clickListeners = documentListeners.click\nconst handleUnlock = clickListeners[0].handler\nhandleUnlock()\n\nexpect(mockDocument.removeEventListener).toHaveBeenCalledWith('click', handleUnlock, true)\nexpect(mockDocument.removeEventListener).toHaveBeenCalledWith('touchstart', handleUnlock, true)\nexpect(mockDocument.removeEventListener).toHaveBeenCalledWith('keydown', handleUnlock, true)\nexpect(mockWindow.removeEventListener).toHaveBeenCalledWith('gamepadconnected', handleUnlock)"
          },
          {
            "title": "callbacks after unlock execute immediately",
            "line": 222,
            "source": "const callback1 = vi.fn()\nconst callback2 = vi.fn()\n\nmodule.onAudioUnlock(callback1)\n\n// Trigger unlock\nconst clickListeners = documentListeners.click\nconst handleUnlock = clickListeners[0].handler\nhandleUnlock()\n\nexpect(callback1).toHaveBeenCalledTimes(1)\n\n// Add callback after unlock\nmodule.onAudioUnlock(callback2)\n\nexpect(callback2).toHaveBeenCalledTimes(1)"
          }
        ],
        "describes": []
      },
      {
        "title": "edge cases",
        "line": 243,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "handles callback throwing error",
            "line": 244,
            "source": "const errorCallback = vi.fn(() => {\n    throw new Error('Callback error')\n})\nconst successCallback = vi.fn()\n\nmodule.onAudioUnlock(errorCallback)\nmodule.onAudioUnlock(successCallback)\n\nconst clickListeners = documentListeners.click\nconst handleUnlock = clickListeners[0].handler\n\nexpect(() => handleUnlock()).toThrow('Callback error')\n\n// Due to error, remaining callbacks might not execute\n// This tests the actual behavior\nexpect(errorCallback).toHaveBeenCalledTimes(1)"
          },
          {
            "title": "handles multiple calls after unlock",
            "line": 263,
            "source": "// Trigger unlock first\nconst clickListeners = documentListeners.click\nconst handleUnlock = clickListeners[0].handler\nhandleUnlock()\n\nconst callback1 = vi.fn()\nconst callback2 = vi.fn()\nconst callback3 = vi.fn()\n\nmodule.onAudioUnlock(callback1)\nmodule.onAudioUnlock(callback2)\nmodule.onAudioUnlock(callback3)\n\nexpect(callback1).toHaveBeenCalledTimes(1)\nexpect(callback2).toHaveBeenCalledTimes(1)\nexpect(callback3).toHaveBeenCalledTimes(1)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/audio/patterns/pattern.doc.js": {
    "file": "/audio/patterns/pattern.test.js",
    "describes": [
      {
        "title": "Pattern",
        "line": 5,
        "beforeEach": {
          "line": 9,
          "source": "pattern = new Pattern({\n    steps: ['a', 'b', null, 'c'],\n    bpm: 140,\n    loop: true,\n    swing: 0.2\n})"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "steps returns the steps array",
            "line": 71,
            "source": "expect(pattern.steps).toEqual(['a', 'b', null, 'c'])"
          },
          {
            "title": "currentStep returns 0 initially",
            "line": 128,
            "source": "expect(pattern.currentStep).toBe(0)"
          }
        ],
        "describes": [
          {
            "title": "constructor",
            "line": 19,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "sets static category",
                "line": 20,
                "source": "expect(Pattern.$category).toBe('pattern')"
              },
              {
                "title": "sets static lifecycle to false",
                "line": 24,
                "source": "expect(Pattern.$lifecycle).toBe(false)"
              },
              {
                "title": "accepts steps option",
                "line": 28,
                "source": "expect(pattern.steps).toEqual(['a', 'b', null, 'c'])"
              },
              {
                "title": "accepts bpm option",
                "line": 32,
                "source": "expect(pattern.bpm).toBe(140)"
              },
              {
                "title": "accepts loop option",
                "line": 36,
                "source": "expect(pattern.loop).toBe(true)"
              },
              {
                "title": "accepts swing option",
                "line": 40,
                "source": "expect(pattern.swing).toBe(0.2)"
              },
              {
                "title": "parses pattern string",
                "line": 44,
                "source": "const p = new Pattern({pattern: 'a b c'})\nexpect(p.steps).toEqual(['a', 'b', 'c'])"
              },
              {
                "title": "defaults bpm to 120",
                "line": 49,
                "source": "const p = new Pattern({})\nexpect(p.bpm).toBe(120)"
              },
              {
                "title": "defaults loop to true",
                "line": 54,
                "source": "const p = new Pattern({})\nexpect(p.loop).toBe(true)"
              },
              {
                "title": "defaults swing to 0",
                "line": 59,
                "source": "const p = new Pattern({})\nexpect(p.swing).toBe(0)"
              },
              {
                "title": "defaults steps to empty array",
                "line": 64,
                "source": "const p = new Pattern({})\nexpect(p.steps).toEqual([])"
              }
            ],
            "describes": []
          },
          {
            "title": "stepCount",
            "line": 76,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns number of steps",
                "line": 77,
                "source": "expect(pattern.stepCount).toBe(4)"
              },
              {
                "title": "returns 0 for empty pattern",
                "line": 81,
                "source": "const p = new Pattern({})\nexpect(p.stepCount).toBe(0)"
              }
            ],
            "describes": []
          },
          {
            "title": "bpm",
            "line": 88,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "get returns current bpm",
                "line": 89,
                "source": "expect(pattern.bpm).toBe(140)"
              },
              {
                "title": "set updates bpm",
                "line": 93,
                "source": "pattern.bpm = 180\nexpect(pattern.bpm).toBe(180)"
              },
              {
                "title": "clamps to minimum 1",
                "line": 98,
                "source": "pattern.bpm = 0\nexpect(pattern.bpm).toBe(1)"
              },
              {
                "title": "clamps to maximum 999",
                "line": 103,
                "source": "pattern.bpm = 1500\nexpect(pattern.bpm).toBe(999)"
              }
            ],
            "describes": []
          },
          {
            "title": "playing",
            "line": 110,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns false initially",
                "line": 111,
                "source": "expect(pattern.playing).toBe(false)"
              },
              {
                "title": "returns true after play",
                "line": 115,
                "source": "pattern.play()\nexpect(pattern.playing).toBe(true)"
              },
              {
                "title": "returns false after stop",
                "line": 120,
                "source": "pattern.play()\npattern.stop()\nexpect(pattern.playing).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "loop",
            "line": 133,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "get returns current loop state",
                "line": 134,
                "source": "expect(pattern.loop).toBe(true)"
              },
              {
                "title": "set updates loop state",
                "line": 138,
                "source": "pattern.loop = false\nexpect(pattern.loop).toBe(false)"
              },
              {
                "title": "coerces to boolean",
                "line": 143,
                "source": "pattern.loop = 0\nexpect(pattern.loop).toBe(false)\npattern.loop = 1\nexpect(pattern.loop).toBe(true)"
              }
            ],
            "describes": []
          },
          {
            "title": "swing",
            "line": 152,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "get returns current swing",
                "line": 153,
                "source": "expect(pattern.swing).toBe(0.2)"
              },
              {
                "title": "set updates swing",
                "line": 157,
                "source": "pattern.swing = 0.5\nexpect(pattern.swing).toBe(0.5)"
              },
              {
                "title": "clamps to minimum 0",
                "line": 162,
                "source": "pattern.swing = -0.5\nexpect(pattern.swing).toBe(0)"
              },
              {
                "title": "clamps to maximum 1",
                "line": 167,
                "source": "pattern.swing = 1.5\nexpect(pattern.swing).toBe(1)"
              }
            ],
            "describes": []
          },
          {
            "title": "progress",
            "line": 174,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns 0 initially",
                "line": 175,
                "source": "expect(pattern.progress).toBe(0)"
              },
              {
                "title": "returns 0 for empty pattern",
                "line": 179,
                "source": "const p = new Pattern({})\nexpect(p.progress).toBe(0)"
              }
            ],
            "describes": []
          },
          {
            "title": "setPattern",
            "line": 186,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "sets steps from string",
                "line": 187,
                "source": "pattern.setPattern('x . y')\nexpect(pattern.steps).toEqual(['x', null, 'y'])"
              },
              {
                "title": "sets steps from array",
                "line": 192,
                "source": "pattern.setPattern(['x', 'y', 'z'])\nexpect(pattern.steps).toEqual(['x', 'y', 'z'])"
              },
              {
                "title": "resets pattern state",
                "line": 197,
                "source": "pattern.play()\npattern.update(1)\npattern.setPattern('a b')\nexpect(pattern.currentStep).toBe(0)"
              },
              {
                "title": "returns self for chaining",
                "line": 204,
                "source": "expect(pattern.setPattern('a')).toBe(pattern)"
              }
            ],
            "describes": []
          },
          {
            "title": "setSteps",
            "line": 210,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "sets steps array",
                "line": 211,
                "source": "pattern.setSteps(['x', 'y'])\nexpect(pattern.steps).toEqual(['x', 'y'])"
              },
              {
                "title": "resets pattern state",
                "line": 216,
                "source": "pattern.play()\npattern.update(1)\npattern.setSteps(['a'])\nexpect(pattern.currentStep).toBe(0)"
              },
              {
                "title": "returns self for chaining",
                "line": 223,
                "source": "expect(pattern.setSteps(['a'])).toBe(pattern)"
              }
            ],
            "describes": []
          },
          {
            "title": "setBpm",
            "line": 229,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "sets bpm",
                "line": 230,
                "source": "pattern.setBpm(200)\nexpect(pattern.bpm).toBe(200)"
              },
              {
                "title": "returns self for chaining",
                "line": 235,
                "source": "expect(pattern.setBpm(120)).toBe(pattern)"
              }
            ],
            "describes": []
          },
          {
            "title": "setSwing",
            "line": 241,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "sets swing",
                "line": 242,
                "source": "pattern.setSwing(0.8)\nexpect(pattern.swing).toBe(0.8)"
              },
              {
                "title": "returns self for chaining",
                "line": 247,
                "source": "expect(pattern.setSwing(0.5)).toBe(pattern)"
              }
            ],
            "describes": []
          },
          {
            "title": "play",
            "line": 253,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "sets playing to true",
                "line": 254,
                "source": "pattern.play()\nexpect(pattern.playing).toBe(true)"
              },
              {
                "title": "emits play event",
                "line": 259,
                "source": "const listener = vi.fn()\npattern.on('play', listener)\npattern.play()\nexpect(listener).toHaveBeenCalled()"
              },
              {
                "title": "returns self for chaining",
                "line": 266,
                "source": "expect(pattern.play()).toBe(pattern)"
              },
              {
                "title": "does not emit when already playing",
                "line": 270,
                "source": "pattern.play()\nconst listener = vi.fn()\npattern.on('play', listener)\npattern.play()\nexpect(listener).not.toHaveBeenCalled()"
              }
            ],
            "describes": []
          },
          {
            "title": "stop",
            "line": 280,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "sets playing to false",
                "line": 281,
                "source": "pattern.play()\npattern.stop()\nexpect(pattern.playing).toBe(false)"
              },
              {
                "title": "emits stop event",
                "line": 287,
                "source": "pattern.play()\nconst listener = vi.fn()\npattern.on('stop', listener)\npattern.stop()\nexpect(listener).toHaveBeenCalled()"
              },
              {
                "title": "returns self for chaining",
                "line": 295,
                "source": "expect(pattern.stop()).toBe(pattern)"
              },
              {
                "title": "does not emit when already stopped",
                "line": 299,
                "source": "const listener = vi.fn()\npattern.on('stop', listener)\npattern.stop()\nexpect(listener).not.toHaveBeenCalled()"
              }
            ],
            "describes": []
          },
          {
            "title": "reset",
            "line": 308,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "resets currentStep to 0",
                "line": 309,
                "source": "pattern.play()\npattern.update(1)\npattern.reset()\nexpect(pattern.currentStep).toBe(0)"
              },
              {
                "title": "emits reset event",
                "line": 316,
                "source": "const listener = vi.fn()\npattern.on('reset', listener)\npattern.reset()\nexpect(listener).toHaveBeenCalled()"
              },
              {
                "title": "returns self for chaining",
                "line": 323,
                "source": "expect(pattern.reset()).toBe(pattern)"
              }
            ],
            "describes": []
          },
          {
            "title": "update",
            "line": 329,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "does nothing when not playing",
                "line": 330,
                "source": "const listener = vi.fn()\npattern.on('step', listener)\npattern.update(1)\nexpect(listener).not.toHaveBeenCalled()"
              },
              {
                "title": "does nothing with empty steps",
                "line": 337,
                "source": "const p = new Pattern({})\np.play()\nconst listener = vi.fn()\np.on('step', listener)\np.update(1)\nexpect(listener).not.toHaveBeenCalled()"
              },
              {
                "title": "triggers step event for active steps",
                "line": 346,
                "source": "const listener = vi.fn()\npattern.on('step', listener)\npattern.play()\npattern.update(0.2)\nexpect(listener).toHaveBeenCalledWith('a', 0)"
              },
              {
                "title": "does not trigger for null steps",
                "line": 354,
                "source": "const p = new Pattern({steps: [null, 'a'], bpm: 120})\nconst listener = vi.fn()\np.on('step', listener)\np.play()\np.update(0.3)\nexpect(listener).toHaveBeenCalledTimes(1)\nexpect(listener).toHaveBeenCalledWith('a', 1)"
              },
              {
                "title": "does not trigger for underscore steps",
                "line": 364,
                "source": "const p = new Pattern({steps: ['_', 'a'], bpm: 120})\nconst listener = vi.fn()\np.on('step', listener)\np.play()\np.update(0.3)\nexpect(listener).toHaveBeenCalledTimes(1)"
              },
              {
                "title": "does not trigger for dot steps",
                "line": 373,
                "source": "const p = new Pattern({steps: ['.', 'a'], bpm: 120})\nconst listener = vi.fn()\np.on('step', listener)\np.play()\np.update(0.3)\nexpect(listener).toHaveBeenCalledTimes(1)"
              },
              {
                "title": "emits step:name event",
                "line": 382,
                "source": "const listener = vi.fn()\npattern.on('step:a', listener)\npattern.play()\npattern.update(0.2)\nexpect(listener).toHaveBeenCalledWith(0)"
              },
              {
                "title": "loops when reaching end with loop enabled",
                "line": 390,
                "source": "const loopListener = vi.fn()\npattern.on('loop', loopListener)\npattern.play()\npattern.update(2)\nexpect(loopListener).toHaveBeenCalled()"
              },
              {
                "title": "stops and emits complete when reaching end with loop disabled",
                "line": 398,
                "source": "pattern.loop = false\nconst completeListener = vi.fn()\npattern.on('complete', completeListener)\npattern.play()\npattern.update(2)\nexpect(completeListener).toHaveBeenCalled()\nexpect(pattern.playing).toBe(false)"
              },
              {
                "title": "handles array steps by triggering each substep",
                "line": 408,
                "source": "const p = new Pattern({steps: [['a', 'b']], bpm: 120})\nconst listener = vi.fn()\np.on('step', listener)\np.play()\np.update(0.2)\nexpect(listener).toHaveBeenCalledTimes(2)\nexpect(listener).toHaveBeenCalledWith('a', 0)\nexpect(listener).toHaveBeenCalledWith('b', 0)"
              },
              {
                "title": "applies swing to odd-indexed steps",
                "line": 419,
                "source": "const p = new Pattern({\n    steps: ['a', 'b'],\n    bpm: 120,\n    swing: 0.5\n})\np.play()\nconst stepDuration = 60 / 120 / 4\np.update(stepDuration + 0.001)\nexpect(p.currentStep).toBe(1)"
              }
            ],
            "describes": []
          },
          {
            "title": "onStep",
            "line": 433,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "registers step callback",
                "line": 434,
                "source": "const callback = vi.fn()\npattern.onStep(callback)\npattern.play()\npattern.update(0.2)\nexpect(callback).toHaveBeenCalled()"
              },
              {
                "title": "returns self for chaining",
                "line": 442,
                "source": "expect(pattern.onStep(() => {})).toBe(pattern)"
              }
            ],
            "describes": []
          },
          {
            "title": "map",
            "line": 448,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns new pattern with mapped steps",
                "line": 449,
                "source": "const mapped = pattern.map(step => (step ? step.toUpperCase() : step))\nexpect(mapped.steps).toEqual(['A', 'B', null, 'C'])"
              },
              {
                "title": "preserves bpm",
                "line": 454,
                "source": "const mapped = pattern.map(s => s)\nexpect(mapped.bpm).toBe(140)"
              },
              {
                "title": "preserves loop",
                "line": 459,
                "source": "const mapped = pattern.map(s => s)\nexpect(mapped.loop).toBe(true)"
              },
              {
                "title": "preserves swing",
                "line": 464,
                "source": "const mapped = pattern.map(s => s)\nexpect(mapped.swing).toBe(0.2)"
              },
              {
                "title": "does not modify original",
                "line": 469,
                "source": "pattern.map(step => (step ? step.toUpperCase() : step))\nexpect(pattern.steps).toEqual(['a', 'b', null, 'c'])"
              }
            ],
            "describes": []
          },
          {
            "title": "reverse",
            "line": 476,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns new pattern with reversed steps",
                "line": 477,
                "source": "const reversed = pattern.reverse()\nexpect(reversed.steps).toEqual(['c', null, 'b', 'a'])"
              },
              {
                "title": "preserves bpm",
                "line": 482,
                "source": "const reversed = pattern.reverse()\nexpect(reversed.bpm).toBe(140)"
              },
              {
                "title": "preserves loop",
                "line": 487,
                "source": "const reversed = pattern.reverse()\nexpect(reversed.loop).toBe(true)"
              },
              {
                "title": "preserves swing",
                "line": 492,
                "source": "const reversed = pattern.reverse()\nexpect(reversed.swing).toBe(0.2)"
              },
              {
                "title": "does not modify original",
                "line": 497,
                "source": "pattern.reverse()\nexpect(pattern.steps).toEqual(['a', 'b', null, 'c'])"
              }
            ],
            "describes": []
          },
          {
            "title": "fast",
            "line": 504,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns new pattern with multiplied bpm",
                "line": 505,
                "source": "const faster = pattern.fast(2)\nexpect(faster.bpm).toBe(280)"
              },
              {
                "title": "preserves steps",
                "line": 510,
                "source": "const faster = pattern.fast(2)\nexpect(faster.steps).toEqual(['a', 'b', null, 'c'])"
              },
              {
                "title": "preserves loop",
                "line": 515,
                "source": "const faster = pattern.fast(2)\nexpect(faster.loop).toBe(true)"
              },
              {
                "title": "preserves swing",
                "line": 520,
                "source": "const faster = pattern.fast(2)\nexpect(faster.swing).toBe(0.2)"
              },
              {
                "title": "does not modify original",
                "line": 525,
                "source": "pattern.fast(2)\nexpect(pattern.bpm).toBe(140)"
              }
            ],
            "describes": []
          },
          {
            "title": "slow",
            "line": 532,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns new pattern with divided bpm",
                "line": 533,
                "source": "const slower = pattern.slow(2)\nexpect(slower.bpm).toBe(70)"
              },
              {
                "title": "does not modify original",
                "line": 538,
                "source": "pattern.slow(2)\nexpect(pattern.bpm).toBe(140)"
              }
            ],
            "describes": []
          },
          {
            "title": "every",
            "line": 545,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns new pattern",
                "line": 546,
                "source": "const result = pattern.every(2, () => {})\nexpect(result).toBeInstanceOf(Pattern)\nexpect(result).not.toBe(pattern)"
              },
              {
                "title": "executes callback every n loops",
                "line": 552,
                "source": "const callback = vi.fn()\nconst p = new Pattern({steps: ['a'], bpm: 120})\nconst result = p.every(2, callback)\nresult.play()\nconst stepDuration = 60 / 120 / 4\nresult.update(stepDuration + 0.001)\nexpect(callback).not.toHaveBeenCalled()\nresult.update(stepDuration + 0.001)\nexpect(callback).toHaveBeenCalledTimes(1)"
              },
              {
                "title": "preserves bpm",
                "line": 564,
                "source": "const result = pattern.every(2, () => {})\nexpect(result.bpm).toBe(140)"
              },
              {
                "title": "preserves loop",
                "line": 569,
                "source": "const result = pattern.every(2, () => {})\nexpect(result.loop).toBe(true)"
              },
              {
                "title": "preserves swing",
                "line": 574,
                "source": "const result = pattern.every(2, () => {})\nexpect(result.swing).toBe(0.2)"
              }
            ],
            "describes": []
          }
        ]
      },
      {
        "title": "parsePattern",
        "line": 583,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "parses simple tokens",
            "line": 585,
            "source": "expect(parsePattern('a b c')).toEqual(['a', 'b', 'c'])"
          },
          {
            "title": "parses dots as null",
            "line": 589,
            "source": "expect(parsePattern('a . b')).toEqual(['a', null, 'b'])"
          },
          {
            "title": "parses underscores as null",
            "line": 593,
            "source": "expect(parsePattern('a _ b')).toEqual(['a', null, 'b'])"
          },
          {
            "title": "parses tildes as null",
            "line": 597,
            "source": "expect(parsePattern('a ~ b')).toEqual(['a', null, 'b'])"
          },
          {
            "title": "parses groups",
            "line": 601,
            "source": "expect(parsePattern('[a b] c')).toEqual([['a', 'b'], 'c'])"
          },
          {
            "title": "parses nested groups",
            "line": 605,
            "source": "expect(parsePattern('[a [b c]] d')).toEqual([['a', ['b', 'c']], 'd'])"
          },
          {
            "title": "handles empty string",
            "line": 609,
            "source": "expect(parsePattern('')).toEqual([])"
          },
          {
            "title": "handles null input",
            "line": 613,
            "source": "expect(parsePattern(null)).toEqual([])"
          },
          {
            "title": "handles undefined input",
            "line": 617,
            "source": "expect(parsePattern(undefined)).toEqual([])"
          },
          {
            "title": "handles non-string input",
            "line": 621,
            "source": "expect(parsePattern(123)).toEqual([])"
          },
          {
            "title": "handles multiple spaces",
            "line": 625,
            "source": "expect(parsePattern('a    b')).toEqual(['a', 'b'])"
          },
          {
            "title": "handles groups with null steps",
            "line": 629,
            "source": "expect(parsePattern('[a . b]')).toEqual([['a', null, 'b']])"
          },
          {
            "title": "parses multi-character tokens",
            "line": 633,
            "source": "expect(parsePattern('kick snare hihat')).toEqual(['kick', 'snare', 'hihat'])"
          },
          {
            "title": "handles leading spaces",
            "line": 637,
            "source": "expect(parsePattern('  a b')).toEqual(['a', 'b'])"
          },
          {
            "title": "handles trailing spaces",
            "line": 641,
            "source": "expect(parsePattern('a b  ')).toEqual(['a', 'b'])"
          }
        ],
        "describes": []
      }
    ]
  },
  "/audio/patterns/sequencer.doc.js": {
    "file": "/audio/patterns/sequencer.test.js",
    "describes": [
      {
        "title": "Sequencer",
        "line": 7,
        "beforeEach": {
          "line": 12,
          "source": "mockAudioSystem = createMockAudioSystem()\n\nsequencer = new Sequencer({\n    audioSystem: mockAudioSystem,\n    bpm: 140\n})"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "onInstall delegates methods to host",
            "line": 134,
            "source": "const host = {delegate: vi.fn()}\nsequencer.delegateTo = vi.fn()\nsequencer.onInstall(host)\nexpect(sequencer.delegateTo).toHaveBeenCalledWith(host, [\n    'addPattern',\n    'removePattern',\n    'getPattern',\n    'hasPattern',\n    'playPatterns',\n    'stopPatterns',\n    'setBpm'\n])"
          },
          {
            "title": "onDispose clears all patterns",
            "line": 448,
            "source": "sequencer.addPattern('test', 'a b')\nsequencer.onDispose()\nexpect(sequencer.patternCount).toBe(0)"
          }
        ],
        "describes": [
          {
            "title": "constructor",
            "line": 22,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "sets static category",
                "line": 23,
                "source": "expect(Sequencer.$category).toBe('sequencer')"
              },
              {
                "title": "accepts audioSystem option",
                "line": 27,
                "source": "expect(sequencer.audioSystem).toBe(mockAudioSystem)"
              },
              {
                "title": "accepts bpm option",
                "line": 31,
                "source": "expect(sequencer.bpm).toBe(140)"
              },
              {
                "title": "defaults bpm to 120",
                "line": 35,
                "source": "const s = new Sequencer({})\nexpect(s.bpm).toBe(120)"
              },
              {
                "title": "starts with no patterns",
                "line": 40,
                "source": "expect(sequencer.patternCount).toBe(0)"
              },
              {
                "title": "starts not playing",
                "line": 44,
                "source": "expect(sequencer.playing).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "audioSystem",
            "line": 50,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns the audio system",
                "line": 51,
                "source": "expect(sequencer.audioSystem).toBe(mockAudioSystem)"
              },
              {
                "title": "returns undefined when not set",
                "line": 55,
                "source": "const s = new Sequencer({})\nexpect(s.audioSystem).toBeUndefined()"
              }
            ],
            "describes": []
          },
          {
            "title": "playing",
            "line": 62,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns false initially",
                "line": 63,
                "source": "expect(sequencer.playing).toBe(false)"
              },
              {
                "title": "returns true after playPatterns",
                "line": 67,
                "source": "sequencer.playPatterns()\nexpect(sequencer.playing).toBe(true)"
              },
              {
                "title": "returns false after stopPatterns",
                "line": 72,
                "source": "sequencer.playPatterns()\nsequencer.stopPatterns()\nexpect(sequencer.playing).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "bpm",
            "line": 80,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "get returns current bpm",
                "line": 81,
                "source": "expect(sequencer.bpm).toBe(140)"
              },
              {
                "title": "set updates bpm",
                "line": 85,
                "source": "sequencer.bpm = 180\nexpect(sequencer.bpm).toBe(180)"
              },
              {
                "title": "clamps to minimum 1",
                "line": 90,
                "source": "sequencer.bpm = 0\nexpect(sequencer.bpm).toBe(1)"
              },
              {
                "title": "clamps to maximum 999",
                "line": 95,
                "source": "sequencer.bpm = 1500\nexpect(sequencer.bpm).toBe(999)"
              },
              {
                "title": "updates all pattern bpms",
                "line": 100,
                "source": "sequencer.addPattern('test', 'a b c')\nsequencer.bpm = 200\nexpect(sequencer.getPattern('test').bpm).toBe(200)"
              }
            ],
            "describes": []
          },
          {
            "title": "patterns",
            "line": 108,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns empty array initially",
                "line": 109,
                "source": "expect(sequencer.patterns).toEqual([])"
              },
              {
                "title": "returns array of patterns",
                "line": 113,
                "source": "sequencer.addPattern('test1', 'a b')\nsequencer.addPattern('test2', 'c d')\nexpect(sequencer.patterns).toHaveLength(2)"
              }
            ],
            "describes": []
          },
          {
            "title": "patternCount",
            "line": 121,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns 0 initially",
                "line": 122,
                "source": "expect(sequencer.patternCount).toBe(0)"
              },
              {
                "title": "returns number of patterns",
                "line": 126,
                "source": "sequencer.addPattern('test1', 'a b')\nsequencer.addPattern('test2', 'c d')\nexpect(sequencer.patternCount).toBe(2)"
              }
            ],
            "describes": []
          },
          {
            "title": "setBpm",
            "line": 150,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "sets bpm",
                "line": 151,
                "source": "sequencer.setBpm(200)\nexpect(sequencer.bpm).toBe(200)"
              },
              {
                "title": "returns self for chaining",
                "line": 156,
                "source": "expect(sequencer.setBpm(120)).toBe(sequencer)"
              }
            ],
            "describes": []
          },
          {
            "title": "addPattern",
            "line": 162,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates pattern from string",
                "line": 163,
                "source": "const pattern = sequencer.addPattern('test', 'a b c')\nexpect(pattern).toBeInstanceOf(Pattern)\nexpect(pattern.steps).toEqual(['a', 'b', 'c'])"
              },
              {
                "title": "accepts existing Pattern instance",
                "line": 169,
                "source": "const existing = new Pattern({steps: ['x', 'y']})\nconst pattern = sequencer.addPattern('test', existing)\nexpect(pattern).toBe(existing)"
              },
              {
                "title": "sets pattern id",
                "line": 175,
                "source": "const pattern = sequencer.addPattern('test', 'a b')\nexpect(pattern.$id).toBe('test')"
              },
              {
                "title": "uses sequencer bpm",
                "line": 180,
                "source": "const pattern = sequencer.addPattern('test', 'a b')\nexpect(pattern.bpm).toBe(140)"
              },
              {
                "title": "accepts additional options",
                "line": 185,
                "source": "const pattern = sequencer.addPattern('test', 'a b', {loop: false})\nexpect(pattern.loop).toBe(false)"
              },
              {
                "title": "binds pattern to sounds when provided",
                "line": 190,
                "source": "mockAudioSystem.hasBuffer.mockReturnValue(true)\nconst pattern = sequencer.addPattern('test', 'a b', {\n    sounds: {a: 'kick', b: 'snare'}\n})\npattern.play()\npattern.update(0.2)\nexpect(mockAudioSystem.play).toHaveBeenCalledWith('kick')"
              },
              {
                "title": "registers onStep callback",
                "line": 200,
                "source": "const callback = vi.fn()\nconst pattern = sequencer.addPattern('test', 'a b', {onStep: callback})\npattern.play()\npattern.update(0.2)\nexpect(callback).toHaveBeenCalled()"
              },
              {
                "title": "starts pattern if sequencer is playing",
                "line": 208,
                "source": "sequencer.playPatterns()\nconst pattern = sequencer.addPattern('test', 'a b')\nexpect(pattern.playing).toBe(true)"
              },
              {
                "title": "emits pattern:added event",
                "line": 214,
                "source": "const listener = vi.fn()\nsequencer.on('pattern:added', listener)\nconst pattern = sequencer.addPattern('test', 'a b')\nexpect(listener).toHaveBeenCalledWith('test', pattern)"
              },
              {
                "title": "returns the pattern",
                "line": 221,
                "source": "const pattern = sequencer.addPattern('test', 'a b')\nexpect(pattern).toBeInstanceOf(Pattern)"
              },
              {
                "title": "plays sound by step name when not in sounds map",
                "line": 226,
                "source": "mockAudioSystem.hasBuffer.mockImplementation(id => id === 'kick')\nsequencer.addPattern('test', 'kick', {sounds: {}})\nsequencer.playPatterns()\nsequencer.update(0.2)\nexpect(mockAudioSystem.play).toHaveBeenCalledWith('kick')"
              },
              {
                "title": "plays oscillator for note names",
                "line": 234,
                "source": "mockAudioSystem.hasBuffer.mockReturnValue(false)\nconst pattern = sequencer.addPattern('test', 'C', {sounds: {}})\npattern.play()\npattern.update(0.2)\nexpect(mockAudioSystem.playOscillator).toHaveBeenCalledWith({\n    frequency: 261.63,\n    duration: 0.1,\n    volume: 0.3,\n    type: 'triangle'\n})"
              }
            ],
            "describes": []
          },
          {
            "title": "removePattern",
            "line": 249,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "removes pattern by name",
                "line": 250,
                "source": "sequencer.addPattern('test', 'a b')\nsequencer.removePattern('test')\nexpect(sequencer.hasPattern('test')).toBe(false)"
              },
              {
                "title": "stops pattern before removing",
                "line": 256,
                "source": "const pattern = sequencer.addPattern('test', 'a b')\npattern.play()\nsequencer.removePattern('test')\nexpect(pattern.playing).toBe(false)"
              },
              {
                "title": "emits pattern:removed event",
                "line": 263,
                "source": "sequencer.addPattern('test', 'a b')\nconst listener = vi.fn()\nsequencer.on('pattern:removed', listener)\nsequencer.removePattern('test')\nexpect(listener).toHaveBeenCalledWith('test')"
              },
              {
                "title": "returns true when pattern exists",
                "line": 271,
                "source": "sequencer.addPattern('test', 'a b')\nexpect(sequencer.removePattern('test')).toBe(true)"
              },
              {
                "title": "returns false when pattern does not exist",
                "line": 276,
                "source": "expect(sequencer.removePattern('nonexistent')).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "getPattern",
            "line": 282,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns pattern by name",
                "line": 283,
                "source": "const pattern = sequencer.addPattern('test', 'a b')\nexpect(sequencer.getPattern('test')).toBe(pattern)"
              },
              {
                "title": "returns null for nonexistent pattern",
                "line": 288,
                "source": "expect(sequencer.getPattern('nonexistent')).toBeNull()"
              }
            ],
            "describes": []
          },
          {
            "title": "hasPattern",
            "line": 294,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns true when pattern exists",
                "line": 295,
                "source": "sequencer.addPattern('test', 'a b')\nexpect(sequencer.hasPattern('test')).toBe(true)"
              },
              {
                "title": "returns false when pattern does not exist",
                "line": 300,
                "source": "expect(sequencer.hasPattern('nonexistent')).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "playPatterns",
            "line": 306,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "sets playing to true",
                "line": 307,
                "source": "sequencer.playPatterns()\nexpect(sequencer.playing).toBe(true)"
              },
              {
                "title": "plays all patterns",
                "line": 312,
                "source": "const pattern1 = sequencer.addPattern('test1', 'a b')\nconst pattern2 = sequencer.addPattern('test2', 'c d')\nsequencer.playPatterns()\nexpect(pattern1.playing).toBe(true)\nexpect(pattern2.playing).toBe(true)"
              },
              {
                "title": "emits play event",
                "line": 320,
                "source": "const listener = vi.fn()\nsequencer.on('play', listener)\nsequencer.playPatterns()\nexpect(listener).toHaveBeenCalled()"
              },
              {
                "title": "returns self for chaining",
                "line": 327,
                "source": "expect(sequencer.playPatterns()).toBe(sequencer)"
              },
              {
                "title": "does not emit when already playing",
                "line": 331,
                "source": "sequencer.playPatterns()\nconst listener = vi.fn()\nsequencer.on('play', listener)\nsequencer.playPatterns()\nexpect(listener).not.toHaveBeenCalled()"
              }
            ],
            "describes": []
          },
          {
            "title": "stopPatterns",
            "line": 341,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "sets playing to false",
                "line": 342,
                "source": "sequencer.playPatterns()\nsequencer.stopPatterns()\nexpect(sequencer.playing).toBe(false)"
              },
              {
                "title": "stops all patterns",
                "line": 348,
                "source": "const pattern1 = sequencer.addPattern('test1', 'a b')\nconst pattern2 = sequencer.addPattern('test2', 'c d')\nsequencer.playPatterns()\nsequencer.stopPatterns()\nexpect(pattern1.playing).toBe(false)\nexpect(pattern2.playing).toBe(false)"
              },
              {
                "title": "emits stop event",
                "line": 357,
                "source": "sequencer.playPatterns()\nconst listener = vi.fn()\nsequencer.on('stop', listener)\nsequencer.stopPatterns()\nexpect(listener).toHaveBeenCalled()"
              },
              {
                "title": "returns self for chaining",
                "line": 365,
                "source": "expect(sequencer.stopPatterns()).toBe(sequencer)"
              },
              {
                "title": "does not emit when already stopped",
                "line": 369,
                "source": "const listener = vi.fn()\nsequencer.on('stop', listener)\nsequencer.stopPatterns()\nexpect(listener).not.toHaveBeenCalled()"
              }
            ],
            "describes": []
          },
          {
            "title": "resetAll",
            "line": 378,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "resets all patterns",
                "line": 379,
                "source": "const pattern1 = sequencer.addPattern('test1', 'a b')\nconst pattern2 = sequencer.addPattern('test2', 'c d')\npattern1.play()\npattern2.play()\npattern1.update(1)\npattern2.update(1)\nsequencer.resetAll()\nexpect(pattern1.currentStep).toBe(0)\nexpect(pattern2.currentStep).toBe(0)"
              },
              {
                "title": "emits reset event",
                "line": 391,
                "source": "const listener = vi.fn()\nsequencer.on('reset', listener)\nsequencer.resetAll()\nexpect(listener).toHaveBeenCalled()"
              },
              {
                "title": "returns self for chaining",
                "line": 398,
                "source": "expect(sequencer.resetAll()).toBe(sequencer)"
              }
            ],
            "describes": []
          },
          {
            "title": "update",
            "line": 404,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "does nothing when not playing",
                "line": 405,
                "source": "const pattern = sequencer.addPattern('test', 'a b')\nconst listener = vi.fn()\npattern.on('step', listener)\nsequencer.update(1)\nexpect(listener).not.toHaveBeenCalled()"
              },
              {
                "title": "updates all patterns when playing",
                "line": 413,
                "source": "const pattern1 = sequencer.addPattern('test1', 'a b')\nconst pattern2 = sequencer.addPattern('test2', 'c d')\nconst listener1 = vi.fn()\nconst listener2 = vi.fn()\npattern1.on('step', listener1)\npattern2.on('step', listener2)\nsequencer.playPatterns()\nsequencer.update(0.2)\nexpect(listener1).toHaveBeenCalled()\nexpect(listener2).toHaveBeenCalled()"
              }
            ],
            "describes": []
          },
          {
            "title": "clear",
            "line": 428,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "removes all patterns",
                "line": 429,
                "source": "sequencer.addPattern('test1', 'a b')\nsequencer.addPattern('test2', 'c d')\nsequencer.clear()\nexpect(sequencer.patternCount).toBe(0)"
              },
              {
                "title": "stops patterns before clearing",
                "line": 436,
                "source": "sequencer.playPatterns()\nsequencer.clear()\nexpect(sequencer.playing).toBe(false)"
              },
              {
                "title": "returns self for chaining",
                "line": 442,
                "source": "expect(sequencer.clear()).toBe(sequencer)"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/editor/number_input.doc.js": {
    "file": "/editor/number_input.test.js",
    "describes": [
      {
        "title": "NumberInput",
        "line": 5,
        "beforeEach": {
          "line": 11,
          "source": "container = document.createElement('div')\ndocument.body.appendChild(container)\n\ninput = document.createElement('number-input')\ncontainer.appendChild(input)"
        },
        "afterEach": {
          "line": 20,
          "source": "container.remove()"
        },
        "tests": [
          {
            "title": "setValue should set value directly",
            "line": 66,
            "source": "input.setValue(100)\nexpect(input.value).toBe(100)"
          },
          {
            "title": "setStep should set step value",
            "line": 72,
            "source": "input.setStep(0.5)\nexpect(input.value).toBe(0)"
          },
          {
            "title": "setPrecision should set precision value",
            "line": 78,
            "source": "input.setPrecision(3)\ninput.setValue(1.23456)\nexpect(input.value).toBe(1.23456)"
          },
          {
            "title": "setLabel should set label text",
            "line": 85,
            "source": "input.setLabel('x')\nconst label = input.shadowRoot.querySelector('.number-input-label')\nexpect(label.textContent).toBe('x')"
          },
          {
            "title": "observedAttributes should include expected attributes",
            "line": 110,
            "source": "const observed = input.constructor.observedAttributes\nexpect(observed).toContain('value')\nexpect(observed).toContain('step')\nexpect(observed).toContain('precision')\nexpect(observed).toContain('label')\nexpect(observed).toContain('min')\nexpect(observed).toContain('max')"
          },
          {
            "title": "change event should emit change event when value changes via stepper",
            "line": 121,
            "source": "const handler = vi.fn()\ninput.addEventListener('change', handler)\n\nconst incrementBtn = input.shadowRoot.querySelectorAll('.number-input-stepper')[1]\nincrementBtn.click()\n\nexpect(handler).toHaveBeenCalled()\nexpect(handler.mock.calls[0][0].detail.value).toBeGreaterThan(0)"
          }
        ],
        "describes": [
          {
            "title": "initialization",
            "line": 25,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "extends HTMLElement",
                "line": 27,
                "source": "expect(input).toBeInstanceOf(HTMLElement)"
              },
              {
                "title": "has shadow DOM",
                "line": 32,
                "source": "expect(input.shadowRoot).not.toBeNull()"
              },
              {
                "title": "has default value of 0",
                "line": 37,
                "source": "expect(input.value).toBe(0)"
              }
            ],
            "describes": []
          },
          {
            "title": "value property",
            "line": 44,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "gets and sets value",
                "line": 46,
                "source": "input.value = 42\nexpect(input.value).toBe(42)"
              },
              {
                "title": "parses string values",
                "line": 52,
                "source": "input.value = '3.14'\nexpect(input.value).toBe(3.14)"
              },
              {
                "title": "defaults invalid values to 0",
                "line": 58,
                "source": "input.value = 'invalid'\nexpect(input.value).toBe(0)"
              }
            ],
            "describes": []
          },
          {
            "title": "min/max constraints",
            "line": 92,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "clamps value to min",
                "line": 94,
                "source": "input.setMin(0)\ninput.value = -10\nexpect(input.value).toBe(0)"
              },
              {
                "title": "clamps value to max",
                "line": 101,
                "source": "input.setMax(100)\ninput.value = 200\nexpect(input.value).toBe(100)"
              }
            ],
            "describes": []
          },
          {
            "title": "setCompact",
            "line": 133,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "adds compact attribute when true",
                "line": 135,
                "source": "input.setCompact(true)\nexpect(input.hasAttribute('compact')).toBe(true)"
              },
              {
                "title": "removes compact attribute when false",
                "line": 141,
                "source": "input.setCompact(true)\ninput.setCompact(false)\nexpect(input.hasAttribute('compact')).toBe(false)"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/editor/perky_explorer.doc.js": {
    "file": "/editor/perky_explorer.test.js",
    "describes": [
      {
        "title": "PerkyExplorer",
        "line": 58,
        "beforeEach": {
          "line": 64,
          "source": "container = document.createElement('div')\ndocument.body.appendChild(container)\n\nexplorer = document.createElement('perky-explorer')\ncontainer.appendChild(explorer)"
        },
        "afterEach": {
          "line": 73,
          "source": "container.remove()"
        },
        "tests": [],
        "describes": [
          {
            "title": "initialization",
            "line": 78,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "is a custom element",
                "line": 80,
                "source": "expect(explorer).toBeInstanceOf(PerkyExplorer)\nexpect(explorer).toBeInstanceOf(HTMLElement)"
              },
              {
                "title": "has shadow DOM",
                "line": 86,
                "source": "expect(explorer.shadowRoot).not.toBeNull()"
              },
              {
                "title": "shows empty state when no module is set",
                "line": 91,
                "source": "const emptyMessage = explorer.shadowRoot.querySelector('.explorer-empty')\nexpect(emptyMessage).not.toBeNull()\nexpect(emptyMessage.textContent).toContain('No module attached')"
              },
              {
                "title": "has a header with title",
                "line": 98,
                "source": "const title = explorer.shadowRoot.querySelector('.explorer-title')\nexpect(title).not.toBeNull()\nexpect(title.textContent).toContain('Perky Explorer')"
              }
            ],
            "describes": []
          },
          {
            "title": "setModule",
            "line": 107,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "renders the module tree",
                "line": 109,
                "source": "const module = new PerkyModule({$id: 'root', $category: 'app'})\nexplorer.setModule(module)\n\nconst rootNode = getRootNode(explorer)\nexpect(rootNode).not.toBeNull()\n\nconst id = getNodeId(rootNode)\nexpect(id.textContent).toBe('root')"
              },
              {
                "title": "returns the module via getModule",
                "line": 121,
                "source": "const module = new PerkyModule({$id: 'root'})\nexplorer.setModule(module)\n\nexpect(explorer.getModule()).toBe(module)"
              },
              {
                "title": "expands the root node by default",
                "line": 129,
                "source": "const parent = new PerkyModule({$id: 'parent'})\nparent.create(PerkyModule, {$id: 'child'})\n\nexplorer.setModule(parent)\n\nconst rootNode = getRootNode(explorer)\nconst childrenContainer = getNodeChildren(rootNode)\nexpect(childrenContainer.classList.contains('expanded')).toBe(true)"
              },
              {
                "title": "renders children in the tree",
                "line": 141,
                "source": "const parent = new PerkyModule({$id: 'parent'})\nparent.create(PerkyModule, {$id: 'child1', $category: 'test'})\nparent.create(PerkyModule, {$id: 'child2', $category: 'test'})\n\nexplorer.setModule(parent)\n\nconst rootNode = getRootNode(explorer)\nconst nodeIds = collectAllNodeIds(rootNode)\n\nexpect(nodeIds).toContain('parent')\nexpect(nodeIds).toContain('child1')\nexpect(nodeIds).toContain('child2')"
              }
            ],
            "describes": []
          },
          {
            "title": "status indicators",
            "line": 159,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "shows stopped status when module not started",
                "line": 161,
                "source": "const module = new PerkyModule({$id: 'test'})\nexplorer.setModule(module)\n\nconst rootNode = getRootNode(explorer)\nconst status = getNodeStatus(rootNode)\nexpect(status.classList.contains('stopped')).toBe(true)"
              },
              {
                "title": "shows started status when module is running",
                "line": 171,
                "source": "const module = new PerkyModule({$id: 'test'})\nmodule.start()\nexplorer.setModule(module)\n\nconst rootNode = getRootNode(explorer)\nconst status = getNodeStatus(rootNode)\nexpect(status.classList.contains('started')).toBe(true)"
              },
              {
                "title": "shows disposed status when module is disposed",
                "line": 182,
                "source": "const module = new PerkyModule({$id: 'test'})\nmodule.dispose()\nexplorer.setModule(module)\n\nconst rootNode = getRootNode(explorer)\nconst status = getNodeStatus(rootNode)\nexpect(status.classList.contains('disposed')).toBe(true)"
              }
            ],
            "describes": []
          },
          {
            "title": "collapse/expand",
            "line": 195,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "toggles tree visibility when clicking header",
                "line": 197,
                "source": "const module = new PerkyModule({$id: 'test'})\nexplorer.setModule(module)\n\nconst header = explorer.shadowRoot.querySelector('.explorer-header')\nconst tree = explorer.shadowRoot.querySelector('.explorer-tree')\n\nexpect(tree.classList.contains('hidden')).toBe(false)\n\nheader.click()\n\nconst treeAfter = explorer.shadowRoot.querySelector('.explorer-tree')\nexpect(treeAfter.classList.contains('hidden')).toBe(true)"
              },
              {
                "title": "toggles child nodes when clicking arrow",
                "line": 213,
                "source": "const parent = new PerkyModule({$id: 'parent'})\nparent.create(PerkyModule, {$id: 'child'})\nexplorer.setModule(parent)\n\nconst rootNode = getRootNode(explorer)\n\nlet childContainer = getNodeChildren(rootNode)\nexpect(childContainer.classList.contains('expanded')).toBe(true)\n\nconst toggle = getNodeToggle(rootNode)\ntoggle.click()\n\nchildContainer = getNodeChildren(rootNode)\nexpect(childContainer.classList.contains('expanded')).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "selection and details",
            "line": 233,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "shows details panel when node is clicked",
                "line": 235,
                "source": "const module = new PerkyModule({\n    $id: 'test-module',\n    $name: 'TestModule',\n    $category: 'testing',\n    $tags: ['tag1', 'tag2']\n})\nexplorer.setModule(module)\n\nconst rootNode = getRootNode(explorer)\nconst nodeContent = getNodeContent(rootNode)\nnodeContent.click()\n\nconst details = getDetails(explorer)\nexpect(details).not.toBeNull()"
              },
              {
                "title": "displays module properties in details",
                "line": 253,
                "source": "const module = new PerkyModule({\n    $id: 'test-module',\n    $name: 'TestName',\n    $category: 'testing'\n})\nexplorer.setModule(module)\n\nconst rootNode = getRootNode(explorer)\nconst nodeContent = getNodeContent(rootNode)\nnodeContent.click()\n\nconst details = getDetails(explorer)\nconst detailsContent = details.shadowRoot.textContent\nexpect(detailsContent).toContain('TestName')\nexpect(detailsContent).toContain('testing')"
              },
              {
                "title": "displays tags in details",
                "line": 272,
                "source": "const module = new PerkyModule({\n    $id: 'test',\n    $tags: ['alpha', 'beta']\n})\nexplorer.setModule(module)\n\nconst rootNode = getRootNode(explorer)\nconst nodeContent = getNodeContent(rootNode)\nnodeContent.click()\n\nconst details = getDetails(explorer)\nconst tags = details.shadowRoot.querySelectorAll('.details-tag')\nconst tagTexts = [...tags].map(t => t.textContent)\n\nexpect(tagTexts).toContain('alpha')\nexpect(tagTexts).toContain('beta')"
              },
              {
                "title": "marks selected node with selected class",
                "line": 292,
                "source": "const module = new PerkyModule({$id: 'test'})\nexplorer.setModule(module)\n\nconst rootNode = getRootNode(explorer)\nconst nodeContent = getNodeContent(rootNode)\nnodeContent.click()\n\nconst selectedContent = getNodeContent(rootNode)\nexpect(selectedContent.classList.contains('selected')).toBe(true)"
              }
            ],
            "describes": []
          },
          {
            "title": "minimize",
            "line": 307,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "minimizes when clicking minimize button",
                "line": 309,
                "source": "const module = new PerkyModule({$id: 'test'})\nexplorer.setModule(module)\n\nconst minimizeBtn = explorer.shadowRoot.querySelectorAll('.explorer-btn')[3]\nminimizeBtn.click()\n\nconst minimized = explorer.shadowRoot.querySelector('.explorer-minimized')\nexpect(minimized.classList.contains('hidden')).toBe(false)"
              },
              {
                "title": "restores when clicking minimized icon",
                "line": 321,
                "source": "const module = new PerkyModule({$id: 'test'})\nexplorer.setModule(module)\n\nconst minimizeBtn = explorer.shadowRoot.querySelectorAll('.explorer-btn')[3]\nminimizeBtn.click()\n\nconst minimized = explorer.shadowRoot.querySelector('.explorer-minimized')\nminimized.click()\n\nconst explorerPanel = explorer.shadowRoot.querySelector('.explorer')\nexpect(explorerPanel.classList.contains('hidden')).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "live updates",
            "line": 338,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "updates when child is added",
                "line": 340,
                "source": "const parent = new PerkyModule({$id: 'parent'})\nexplorer.setModule(parent)\n\nconst rootNode = getRootNode(explorer)\nlet nodeIds = collectAllNodeIds(rootNode)\nexpect(nodeIds).not.toContain('new-child')\n\nparent.create(PerkyModule, {$id: 'new-child', $category: 'perkyModule'})\n\nnodeIds = collectAllNodeIds(rootNode)\nexpect(nodeIds).toContain('new-child')"
              },
              {
                "title": "updates when module starts",
                "line": 355,
                "source": "const module = new PerkyModule({$id: 'test'})\nexplorer.setModule(module)\n\nconst rootNode = getRootNode(explorer)\nlet status = getNodeStatus(rootNode)\nexpect(status.classList.contains('stopped')).toBe(true)\n\nmodule.start()\n\nstatus = getNodeStatus(rootNode)\nexpect(status.classList.contains('started')).toBe(true)"
              }
            ],
            "describes": []
          },
          {
            "title": "cleanup",
            "line": 372,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "cleans up listeners when disconnected",
                "line": 374,
                "source": "const module = new PerkyModule({$id: 'test'})\nexplorer.setModule(module)\n\nconst rootNode = getRootNode(explorer)\nconst offSpy = vi.spyOn(module, 'off')\n\nrootNode.remove()\n\nexpect(offSpy).toHaveBeenCalled()"
              },
              {
                "title": "cleans up listeners when setting new module",
                "line": 387,
                "source": "const module1 = new PerkyModule({$id: 'first'})\nconst module2 = new PerkyModule({$id: 'second'})\n\nexplorer.setModule(module1)\n\nconst rootNode = getRootNode(explorer)\nconst offSpy = vi.spyOn(module1, 'off')\n\nrootNode.setModule(module2)\n\nexpect(offSpy).toHaveBeenCalled()"
              }
            ],
            "describes": []
          },
          {
            "title": "isSystemModule",
            "line": 404,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns true for system category modules",
                "line": 406,
                "source": "const systemModule = new PerkyModule({$id: 'input', $category: 'inputSystem'})\n\nexpect(explorer.isSystemModule(systemModule)).toBe(true)"
              },
              {
                "title": "returns false for non-system category modules",
                "line": 413,
                "source": "const regularModule = new PerkyModule({$id: 'player', $category: 'entity'})\n\nexpect(explorer.isSystemModule(regularModule)).toBe(false)"
              },
              {
                "title": "returns falsy for null module",
                "line": 420,
                "source": "expect(explorer.isSystemModule(null)).toBeFalsy()"
              },
              {
                "title": "returns falsy for undefined module",
                "line": 425,
                "source": "expect(explorer.isSystemModule(undefined)).toBeFalsy()"
              },
              {
                "title": "recognizes all default system categories",
                "line": 430,
                "source": "const systemCategories = [\n    'actionDispatcher',\n    'inputSystem',\n    'renderSystem',\n    'sourceManager',\n    'perkyView',\n    'gameLoop',\n    'textureSystem',\n    'audioSystem',\n    'manifest'\n]\n\nfor (const category of systemCategories) {\n    const module = new PerkyModule({$id: 'test', $category: category})\n    expect(explorer.isSystemModule(module)).toBe(true)\n}"
              },
              {
                "title": "respects custom systemCategories",
                "line": 450,
                "source": "explorer.systemCategories = ['customSystem', 'anotherSystem']\n\nconst customSystem = new PerkyModule({$id: 'test', $category: 'customSystem'})\nconst defaultSystem = new PerkyModule({$id: 'test2', $category: 'inputSystem'})\n\nexpect(explorer.isSystemModule(customSystem)).toBe(true)\nexpect(explorer.isSystemModule(defaultSystem)).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "focusModule",
            "line": 463,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "changes root to focused module",
                "line": 465,
                "source": "const parent = new PerkyModule({$id: 'parent'})\nconst child = parent.create(PerkyModule, {$id: 'child', $category: 'test'})\n\nexplorer.setModule(parent)\n\nconst rootNode = getRootNode(explorer)\nlet nodeIds = collectAllNodeIds(rootNode)\nexpect(nodeIds).toContain('parent')\nexpect(nodeIds).toContain('child')\n\nexplorer.focusModule(child)\n\nconst focusedRootNode = getRootNode(explorer)\nconst focusedId = getNodeId(focusedRootNode)\nexpect(focusedId.textContent).toBe('child')"
              },
              {
                "title": "does nothing if module is null",
                "line": 484,
                "source": "const module = new PerkyModule({$id: 'test'})\nexplorer.setModule(module)\n\nconst rootNode = getRootNode(explorer)\nconst idBefore = getNodeId(rootNode).textContent\n\nexplorer.focusModule(null)\n\nconst idAfter = getNodeId(getRootNode(explorer)).textContent\nexpect(idAfter).toBe(idBefore)"
              },
              {
                "title": "expands focused module",
                "line": 498,
                "source": "const parent = new PerkyModule({$id: 'parent'})\nconst child = parent.create(PerkyModule, {$id: 'child', $category: 'test'})\nchild.create(PerkyModule, {$id: 'grandchild', $category: 'test'})\n\nexplorer.setModule(parent)\nexplorer.focusModule(child)\n\nconst rootNode = getRootNode(explorer)\nconst childrenContainer = getNodeChildren(rootNode)\nexpect(childrenContainer.classList.contains('expanded')).toBe(true)"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/editor/perky_logger.doc.js": {
    "file": "/editor/perky_logger.test.js",
    "describes": [
      {
        "title": "PerkyLogger",
        "line": 5,
        "beforeEach": {
          "line": 10,
          "source": "logger = new PerkyLogger()\ndocument.body.appendChild(logger)"
        },
        "afterEach": {
          "line": 16,
          "source": "document.body.innerHTML = ''"
        },
        "tests": [
          {
            "title": "custom element creation",
            "line": 21,
            "source": "expect(logger).toBeInstanceOf(PerkyLogger)\nexpect(logger.tagName).toBe('PERKY-LOGGER')"
          },
          {
            "title": "constructor initializes with default options",
            "line": 27,
            "source": "expect(logger.maxEntries).toBe(50)\nexpect(logger.position).toBe('bottom')\nexpect(logger.timestamp).toBe(false)\nexpect(logger.entries).toEqual([])"
          },
          {
            "title": "constructor accepts custom attributes",
            "line": 35,
            "source": "const customLogger = new PerkyLogger()\ncustomLogger.maxEntries = 100\ncustomLogger.position = 'top'\ncustomLogger.timestamp = true\n\nexpect(customLogger.maxEntries).toBe(100)\nexpect(customLogger.position).toBe('top')\nexpect(customLogger.timestamp).toBe(true)"
          },
          {
            "title": "log creates a log entry with the specified type",
            "line": 47,
            "source": "const message = 'Test message'\nconst type = 'info'\n\nconst entry = logger.log(message, type)\n\nexpect(entry.className).toContain('logger-entry')\nexpect(entry.className).toContain('log-info')\nexpect(entry.querySelector('.logger-message').textContent).toBe(message)\nexpect(logger.entries.length).toBe(1)\nexpect(logger.entries[0]).toBe(entry)"
          },
          {
            "title": "log creates timestamp when enabled",
            "line": 61,
            "source": "logger.timestamp = true\nconst message = 'Test message with timestamp'\n\nconst entry = logger.log(message, 'info')\n\nconst timestamp = entry.querySelector('.logger-timestamp')\nexpect(timestamp).not.toBeNull()\nexpect(entry.textContent).toContain(message)"
          },
          {
            "title": "log removes oldest entries when limit is reached",
            "line": 73,
            "source": "logger.maxEntries = 3\n\nconst entry1 = logger.log('Message 1', 'info')\nconst entry2 = logger.log('Message 2', 'info')\nconst entry3 = logger.log('Message 3', 'info')\nconst entry4 = logger.log('Message 4', 'info')\n\nexpect(logger.entries.length).toBe(3)\nexpect(logger.entries).not.toContain(entry1)\nexpect(logger.entries).toContain(entry2)\nexpect(logger.entries).toContain(entry3)\nexpect(logger.entries).toContain(entry4)"
          },
          {
            "title": "info logs a message with info type",
            "line": 89,
            "source": "vi.spyOn(logger, 'log')\n\nlogger.info('Info message')\n\nexpect(logger.log).toHaveBeenCalledWith('Info message', 'info')"
          },
          {
            "title": "warn logs a message with warn type",
            "line": 98,
            "source": "vi.spyOn(logger, 'log')\n\nlogger.warn('Warning message')\n\nexpect(logger.log).toHaveBeenCalledWith('Warning message', 'warn')"
          },
          {
            "title": "error logs a message with error type",
            "line": 107,
            "source": "vi.spyOn(logger, 'log')\n\nlogger.error('Error message')\n\nexpect(logger.log).toHaveBeenCalledWith('Error message', 'error')"
          },
          {
            "title": "success logs a message with success type",
            "line": 116,
            "source": "vi.spyOn(logger, 'log')\n\nlogger.success('Success message')\n\nexpect(logger.log).toHaveBeenCalledWith('Success message', 'success')"
          },
          {
            "title": "notice logs a message with notice type",
            "line": 125,
            "source": "vi.spyOn(logger, 'log')\n\nlogger.notice('Notice message')\n\nexpect(logger.log).toHaveBeenCalledWith('Notice message', 'notice')"
          },
          {
            "title": "spacer creates a spacer entry",
            "line": 134,
            "source": "logger.spacer()\n\nexpect(logger.entries.length).toBe(1)\nexpect(logger.entries[0].className).toContain('logger-spacer')"
          },
          {
            "title": "title creates a title entry",
            "line": 142,
            "source": "logger.title('Test Title')\n\nexpect(logger.entries.length).toBe(1)\nexpect(logger.entries[0].className).toContain('logger-title-entry')\nexpect(logger.entries[0].textContent).toBe('Test Title')"
          },
          {
            "title": "clear removes all entries",
            "line": 151,
            "source": "logger.log('Message 1', 'info')\nlogger.log('Message 2', 'warn')\nlogger.log('Message 3', 'error')\n\nexpect(logger.entries.length).toBe(3)\n\nlogger.clear()\n\nexpect(logger.entries.length).toBe(0)"
          },
          {
            "title": "render displays correct structure",
            "line": 164,
            "source": "const loggerDiv = logger.shadowRoot.querySelector('.logger')\nconst content = logger.shadowRoot.querySelector('.logger-content')\n\nexpect(loggerDiv).toBeTruthy()\nexpect(content).toBeTruthy()"
          },
          {
            "title": "entries are rendered in content",
            "line": 173,
            "source": "logger.log('Test message', 'info')\n\nconst content = logger.shadowRoot.querySelector('.logger-content')\nexpect(content.children.length).toBe(1)"
          },
          {
            "title": "position updates logger classes",
            "line": 181,
            "source": "logger.position = 'top'\n\nconst loggerDiv = logger.shadowRoot.querySelector('.logger')\n\nexpect(loggerDiv.className).toContain('logger')\nexpect(loggerDiv.className).toContain('logger-top')"
          },
          {
            "title": "multiple message arguments are formatted correctly",
            "line": 191,
            "source": "logger.info('Message', 123, {key: 'value'})\n\nexpect(logger.entries.length).toBe(1)\nexpect(logger.entries[0].textContent).toContain('Message')\nexpect(logger.entries[0].textContent).toContain('123')\nexpect(logger.entries[0].textContent).toContain('key')"
          },
          {
            "title": "can be used like a DOM element",
            "line": 201,
            "source": "const container = document.createElement('div')\nconst newLogger = new PerkyLogger()\n\ncontainer.appendChild(newLogger)\n\nexpect(container.contains(newLogger)).toBe(true)\nexpect(newLogger.parentElement).toBe(container)\n\nnewLogger.info('Test message')\nexpect(newLogger.entries.length).toBe(1)"
          },
          {
            "title": "theme property works correctly",
            "line": 215,
            "source": "expect(logger.theme).toBe('')\n\nlogger.theme = 'light'\n\nexpect(logger.theme).toBe('light')\nexpect(logger.hasAttribute('theme')).toBe(true)\nexpect(logger.getAttribute('theme')).toBe('light')\n\nlogger.theme = ''\n\nexpect(logger.theme).toBe('')\nexpect(logger.hasAttribute('theme')).toBe(false)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/editor/toggle_input.doc.js": {
    "file": "/editor/toggle_input.test.js",
    "describes": [
      {
        "title": "ToggleInput",
        "line": 5,
        "beforeEach": {
          "line": 11,
          "source": "container = document.createElement('div')\ndocument.body.appendChild(container)\n\ntoggle = document.createElement('toggle-input')\ncontainer.appendChild(toggle)"
        },
        "afterEach": {
          "line": 20,
          "source": "container.remove()"
        },
        "tests": [
          {
            "title": "setChecked sets checked directly",
            "line": 63,
            "source": "toggle.setChecked(true)\nexpect(toggle.checked).toBe(true)"
          },
          {
            "title": "setLabel sets label text",
            "line": 69,
            "source": "toggle.setLabel('Enabled')\nconst label = toggle.shadowRoot.querySelector('.toggle-input-label')\nexpect(label.textContent).toBe('Enabled')"
          },
          {
            "title": "observedAttributes includes expected attributes",
            "line": 76,
            "source": "const observed = toggle.constructor.observedAttributes\nexpect(observed).toContain('checked')\nexpect(observed).toContain('label')"
          }
        ],
        "describes": [
          {
            "title": "initialization",
            "line": 25,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "extends HTMLElement",
                "line": 27,
                "source": "expect(toggle).toBeInstanceOf(HTMLElement)"
              },
              {
                "title": "has shadow DOM",
                "line": 32,
                "source": "expect(toggle.shadowRoot).not.toBeNull()"
              },
              {
                "title": "has default checked of false",
                "line": 37,
                "source": "expect(toggle.checked).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "checked property",
            "line": 44,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "gets and sets checked",
                "line": 46,
                "source": "toggle.checked = true\nexpect(toggle.checked).toBe(true)"
              },
              {
                "title": "coerces to boolean",
                "line": 52,
                "source": "toggle.checked = 1\nexpect(toggle.checked).toBe(true)\n\ntoggle.checked = 0\nexpect(toggle.checked).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "visual state",
            "line": 83,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "adds checked class when checked",
                "line": 85,
                "source": "toggle.setChecked(true)\nconst track = toggle.shadowRoot.querySelector('.toggle-input-track')\nexpect(track.classList.contains('checked')).toBe(true)"
              },
              {
                "title": "removes checked class when unchecked",
                "line": 92,
                "source": "toggle.setChecked(true)\ntoggle.setChecked(false)\nconst track = toggle.shadowRoot.querySelector('.toggle-input-track')\nexpect(track.classList.contains('checked')).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "click behavior",
            "line": 102,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "toggles when track clicked",
                "line": 104,
                "source": "const track = toggle.shadowRoot.querySelector('.toggle-input-track')\ntrack.click()\nexpect(toggle.checked).toBe(true)\n\ntrack.click()\nexpect(toggle.checked).toBe(false)"
              },
              {
                "title": "toggles when label clicked",
                "line": 114,
                "source": "toggle.setLabel('Test')\nconst label = toggle.shadowRoot.querySelector('.toggle-input-label')\nlabel.click()\nexpect(toggle.checked).toBe(true)"
              }
            ],
            "describes": []
          },
          {
            "title": "change event",
            "line": 124,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "emits change event when toggled",
                "line": 126,
                "source": "const handler = vi.fn()\ntoggle.addEventListener('change', handler)\n\nconst track = toggle.shadowRoot.querySelector('.toggle-input-track')\ntrack.click()\n\nexpect(handler).toHaveBeenCalled()\nexpect(handler.mock.calls[0][0].detail.checked).toBe(true)"
              },
              {
                "title": "emits correct state in change event",
                "line": 138,
                "source": "toggle.setChecked(true)\n\nconst handler = vi.fn()\ntoggle.addEventListener('change', handler)\n\nconst track = toggle.shadowRoot.querySelector('.toggle-input-track')\ntrack.click()\n\nexpect(handler.mock.calls[0][0].detail.checked).toBe(false)"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/editor/inspectors/action_controller_inspector.doc.js": {
    "file": "/editor/inspectors/action_controller_inspector.test.js",
    "describes": [
      {
        "title": "ActionControllerInspector",
        "line": 34,
        "beforeEach": {
          "line": 40,
          "source": "container = document.createElement('div')\ndocument.body.appendChild(container)\n\ninspector = document.createElement('action-controller-inspector')\ncontainer.appendChild(inspector)"
        },
        "afterEach": {
          "line": 49,
          "source": "container.remove()"
        },
        "tests": [
          {
            "title": "matches returns true for ActionController instances",
            "line": 73,
            "source": "const mock = new MockActionController()\nObject.setPrototypeOf(mock, {constructor: {name: 'ActionController'}})\n\nconst matches = ActionControllerInspector.matches\nexpect(typeof matches).toBe('function')"
          },
          {
            "title": "execute button calls module.execute when clicked",
            "line": 157,
            "source": "const module = new MockActionController(['jump'])\nmodule.execute = vi.fn()\ninspector.setModule(module)\n\nconst btn = inspector.shadowRoot.querySelector('.execute-btn')\nbtn.click()\n\nexpect(module.execute).toHaveBeenCalledWith('jump')"
          }
        ],
        "describes": [
          {
            "title": "initialization",
            "line": 54,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "extends HTMLElement",
                "line": 56,
                "source": "expect(inspector).toBeInstanceOf(HTMLElement)"
              },
              {
                "title": "has shadow DOM",
                "line": 61,
                "source": "expect(inspector.shadowRoot).not.toBeNull()"
              },
              {
                "title": "hides gridEl",
                "line": 66,
                "source": "expect(inspector.gridEl.style.display).toBe('none')"
              }
            ],
            "describes": []
          },
          {
            "title": "setModule",
            "line": 82,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "stores the module",
                "line": 84,
                "source": "const module = new MockActionController(['jump'])\ninspector.setModule(module)\nexpect(inspector.getModule()).toBe(module)"
              },
              {
                "title": "renders actions when module is set",
                "line": 91,
                "source": "const module = new MockActionController(['jump', 'run'])\ninspector.setModule(module)\n\nconst actionCards = inspector.shadowRoot.querySelectorAll('.action-card')\nexpect(actionCards.length).toBe(2)"
              }
            ],
            "describes": []
          },
          {
            "title": "rendering",
            "line": 102,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "shows header with action count",
                "line": 104,
                "source": "const module = new MockActionController(['a', 'b', 'c'])\ninspector.setModule(module)\n\nconst header = inspector.shadowRoot.querySelector('.actions-header')\nexpect(header).not.toBeNull()\nexpect(header.textContent).toContain('3')"
              },
              {
                "title": "shows empty message when no actions",
                "line": 114,
                "source": "const module = new MockActionController([])\ninspector.setModule(module)\n\nconst empty = inspector.shadowRoot.querySelector('.empty-message')\nexpect(empty).not.toBeNull()\nexpect(empty.textContent).toBe('No actions defined')"
              },
              {
                "title": "renders action names",
                "line": 124,
                "source": "const module = new MockActionController(['jump', 'attack'])\ninspector.setModule(module)\n\nconst names = inspector.shadowRoot.querySelectorAll('.action-name')\nexpect(names.length).toBe(2)\nexpect(names[0].textContent).toBe('jump')\nexpect(names[1].textContent).toBe('attack')"
              },
              {
                "title": "shows propagable badge for propagable actions",
                "line": 135,
                "source": "const module = new MockActionController(['jump', 'attack'], ['jump'])\ninspector.setModule(module)\n\nconst badges = inspector.shadowRoot.querySelectorAll('.action-badge.propagable')\nexpect(badges.length).toBe(1)\nexpect(badges[0].textContent).toBe('propagable')"
              },
              {
                "title": "renders execute button for each action",
                "line": 145,
                "source": "const module = new MockActionController(['jump'])\ninspector.setModule(module)\n\nconst btn = inspector.shadowRoot.querySelector('.execute-btn')\nexpect(btn).not.toBeNull()\nexpect(btn.textContent).toContain('Run')"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/editor/inspectors/action_dispatcher_inspector.doc.js": {
    "file": "/editor/inspectors/action_dispatcher_inspector.test.js",
    "describes": [
      {
        "title": "ActionDispatcherInspector",
        "line": 39,
        "beforeEach": {
          "line": 45,
          "source": "container = document.createElement('div')\ndocument.body.appendChild(container)\n\ninspector = document.createElement('action-dispatcher-inspector')\ncontainer.appendChild(inspector)"
        },
        "afterEach": {
          "line": 54,
          "source": "container.remove()"
        },
        "tests": [
          {
            "title": "matches static matches method exists",
            "line": 78,
            "source": "expect(typeof ActionDispatcherInspector.matches).toBe('function')"
          },
          {
            "title": "execute button calls module.executeTo when clicked",
            "line": 176,
            "source": "const actionsMap = new Map([\n    ['player', [{name: 'jump'}]]\n])\nconst module = new MockActionDispatcher(actionsMap, ['player'])\nmodule.executeTo = vi.fn()\ninspector.setModule(module)\n\nconst btn = inspector.shadowRoot.querySelector('.execute-btn')\nbtn.click()\n\nexpect(module.executeTo).toHaveBeenCalledWith('player', 'jump')"
          }
        ],
        "describes": [
          {
            "title": "initialization",
            "line": 59,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "extends HTMLElement",
                "line": 61,
                "source": "expect(inspector).toBeInstanceOf(HTMLElement)"
              },
              {
                "title": "has shadow DOM",
                "line": 66,
                "source": "expect(inspector.shadowRoot).not.toBeNull()"
              },
              {
                "title": "hides gridEl",
                "line": 71,
                "source": "expect(inspector.gridEl.style.display).toBe('none')"
              }
            ],
            "describes": []
          },
          {
            "title": "setModule",
            "line": 83,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "stores the module",
                "line": 85,
                "source": "const module = new MockActionDispatcher()\ninspector.setModule(module)\nexpect(inspector.getModule()).toBe(module)"
              },
              {
                "title": "renders controller groups when module is set",
                "line": 92,
                "source": "const actionsMap = new Map([\n    ['player', [{name: 'jump'}, {name: 'run'}]],\n    ['enemy', [{name: 'attack'}]]\n])\nconst module = new MockActionDispatcher(actionsMap)\ninspector.setModule(module)\n\nconst groups = inspector.shadowRoot.querySelectorAll('.controller-group')\nexpect(groups.length).toBe(2)"
              }
            ],
            "describes": []
          },
          {
            "title": "rendering",
            "line": 107,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "shows header with total action and controller count",
                "line": 109,
                "source": "const actionsMap = new Map([\n    ['player', [{name: 'jump'}, {name: 'run'}]],\n    ['enemy', [{name: 'attack'}]]\n])\nconst module = new MockActionDispatcher(actionsMap)\ninspector.setModule(module)\n\nconst header = inspector.shadowRoot.querySelector('.actions-header')\nexpect(header).not.toBeNull()\nexpect(header.textContent).toContain('3')\nexpect(header.textContent).toContain('2')"
              },
              {
                "title": "shows empty message when no controllers",
                "line": 124,
                "source": "const module = new MockActionDispatcher(new Map())\ninspector.setModule(module)\n\nconst empty = inspector.shadowRoot.querySelector('.empty-message')\nexpect(empty).not.toBeNull()\nexpect(empty.textContent).toBe('No controllers registered')"
              },
              {
                "title": "renders controller group headers",
                "line": 134,
                "source": "const actionsMap = new Map([\n    ['player', [{name: 'jump'}]]\n])\nconst module = new MockActionDispatcher(actionsMap)\ninspector.setModule(module)\n\nconst groupName = inspector.shadowRoot.querySelector('.group-name')\nexpect(groupName).not.toBeNull()\nexpect(groupName.textContent).toBe('player')"
              },
              {
                "title": "renders action cards with names",
                "line": 147,
                "source": "const actionsMap = new Map([\n    ['player', [{name: 'jump'}, {name: 'attack'}]]\n])\nconst module = new MockActionDispatcher(actionsMap)\ninspector.setModule(module)\n\nconst names = inspector.shadowRoot.querySelectorAll('.action-name')\nexpect(names.length).toBe(2)\nexpect(names[0].textContent).toBe('jump')\nexpect(names[1].textContent).toBe('attack')"
              },
              {
                "title": "shows empty message in group when controller has no actions",
                "line": 161,
                "source": "const actionsMap = new Map([\n    ['player', []]\n])\nconst module = new MockActionDispatcher(actionsMap)\ninspector.setModule(module)\n\nconst empty = inspector.shadowRoot.querySelector('.controller-group .empty-message')\nexpect(empty).not.toBeNull()\nexpect(empty.textContent).toBe('No actions')"
              }
            ],
            "describes": []
          },
          {
            "title": "active controller toggle",
            "line": 191,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "renders toggle for each controller group",
                "line": 193,
                "source": "const actionsMap = new Map([\n    ['player', [{name: 'jump'}]],\n    ['enemy', [{name: 'attack'}]]\n])\nconst module = new MockActionDispatcher(actionsMap, ['player'])\ninspector.setModule(module)\n\nconst toggles = inspector.shadowRoot.querySelectorAll('toggle-input')\nexpect(toggles.length).toBe(2)"
              },
              {
                "title": "toggle is checked when controller is active",
                "line": 206,
                "source": "const actionsMap = new Map([\n    ['player', [{name: 'jump'}]]\n])\nconst module = new MockActionDispatcher(actionsMap, ['player'])\ninspector.setModule(module)\n\nconst toggle = inspector.shadowRoot.querySelector('toggle-input')\nexpect(toggle.checked).toBe(true)"
              },
              {
                "title": "toggle is unchecked when controller is inactive",
                "line": 218,
                "source": "const actionsMap = new Map([\n    ['player', [{name: 'jump'}]]\n])\nconst module = new MockActionDispatcher(actionsMap, [])\ninspector.setModule(module)\n\nconst toggle = inspector.shadowRoot.querySelector('toggle-input')\nexpect(toggle.checked).toBe(false)"
              },
              {
                "title": "inactive controller group has group-inactive class",
                "line": 230,
                "source": "const actionsMap = new Map([\n    ['player', [{name: 'jump'}]]\n])\nconst module = new MockActionDispatcher(actionsMap, [])\ninspector.setModule(module)\n\nconst group = inspector.shadowRoot.querySelector('.controller-group')\nexpect(group.classList.contains('group-inactive')).toBe(true)"
              },
              {
                "title": "active controller group does not have group-inactive class",
                "line": 242,
                "source": "const actionsMap = new Map([\n    ['player', [{name: 'jump'}]]\n])\nconst module = new MockActionDispatcher(actionsMap, ['player'])\ninspector.setModule(module)\n\nconst group = inspector.shadowRoot.querySelector('.controller-group')\nexpect(group.classList.contains('group-inactive')).toBe(false)"
              },
              {
                "title": "clicking toggle activates inactive controller",
                "line": 254,
                "source": "const actionsMap = new Map([\n    ['player', [{name: 'jump'}]]\n])\nconst module = new MockActionDispatcher(actionsMap, [])\nmodule.setActive = vi.fn()\ninspector.setModule(module)\n\nconst toggle = inspector.shadowRoot.querySelector('toggle-input')\ntoggle.dispatchEvent(new CustomEvent('change', {detail: {checked: true}}))\n\nexpect(module.setActive).toHaveBeenCalledWith(['player'])"
              },
              {
                "title": "clicking toggle deactivates active controller",
                "line": 269,
                "source": "const actionsMap = new Map([\n    ['player', [{name: 'jump'}]],\n    ['enemy', [{name: 'attack'}]]\n])\nconst module = new MockActionDispatcher(actionsMap, ['player', 'enemy'])\nmodule.setActive = vi.fn()\ninspector.setModule(module)\n\nconst toggle = inspector.shadowRoot.querySelector('toggle-input')\ntoggle.dispatchEvent(new CustomEvent('change', {detail: {checked: false}}))\n\nexpect(module.setActive).toHaveBeenCalledWith(['enemy'])"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/editor/interactive/editor_button.doc.js": {
    "file": "/editor/interactive/editor_button.test.js",
    "describes": [
      {
        "title": "EditorButton",
        "line": 5,
        "beforeEach": {
          "line": 9,
          "source": "button = document.createElement('editor-button')\ndocument.body.appendChild(button)"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor creates shadow root",
            "line": 15,
            "source": "expect(button.shadowRoot).not.toBeNull()"
          },
          {
            "title": "icon attribute applies icon-only class",
            "line": 147,
            "source": "button.setAttribute('icon', '')\nconst btn = button.shadowRoot.querySelector('button')\nexpect(btn.classList.contains('icon-only')).toBe(true)"
          },
          {
            "title": "attributeChangedCallback does not update if values are same",
            "line": 221,
            "source": "const btn = button.shadowRoot.querySelector('button')\nconst initialClass = btn.className\nbutton.attributeChangedCallback('variant', 'primary', 'primary')\nexpect(btn.className).toBe(initialClass)"
          }
        ],
        "describes": [
          {
            "title": "connectedCallback",
            "line": 20,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "renders button element",
                "line": 22,
                "source": "const btn = button.shadowRoot.querySelector('button')\nexpect(btn).not.toBeNull()"
              },
              {
                "title": "button has type button",
                "line": 28,
                "source": "const btn = button.shadowRoot.querySelector('button')\nexpect(btn.getAttribute('type')).toBe('button')"
              },
              {
                "title": "button contains slot",
                "line": 34,
                "source": "const btn = button.shadowRoot.querySelector('button')\nexpect(btn.innerHTML).toContain('slot')"
              }
            ],
            "describes": []
          },
          {
            "title": "variant property",
            "line": 42,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns default when no attribute",
                "line": 44,
                "source": "expect(button.variant).toBe('default')"
              },
              {
                "title": "returns attribute value",
                "line": 49,
                "source": "button.setAttribute('variant', 'primary')\nexpect(button.variant).toBe('primary')"
              },
              {
                "title": "setter updates attribute",
                "line": 55,
                "source": "button.variant = 'danger'\nexpect(button.getAttribute('variant')).toBe('danger')"
              },
              {
                "title": "applies variant class to button",
                "line": 61,
                "source": "button.variant = 'primary'\nconst btn = button.shadowRoot.querySelector('button')\nexpect(btn.classList.contains('primary')).toBe(true)"
              },
              {
                "title": "does not add class for default variant",
                "line": 68,
                "source": "button.variant = 'default'\nconst btn = button.shadowRoot.querySelector('button')\nexpect(btn.classList.contains('default')).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "disabled property",
            "line": 77,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns false when no attribute",
                "line": 79,
                "source": "expect(button.disabled).toBe(false)"
              },
              {
                "title": "returns true when attribute present",
                "line": 84,
                "source": "button.setAttribute('disabled', '')\nexpect(button.disabled).toBe(true)"
              },
              {
                "title": "setter adds attribute when true",
                "line": 90,
                "source": "button.disabled = true\nexpect(button.hasAttribute('disabled')).toBe(true)"
              },
              {
                "title": "setter removes attribute when false",
                "line": 96,
                "source": "button.setAttribute('disabled', '')\nbutton.disabled = false\nexpect(button.hasAttribute('disabled')).toBe(false)"
              },
              {
                "title": "disables internal button",
                "line": 103,
                "source": "button.disabled = true\nconst btn = button.shadowRoot.querySelector('button')\nexpect(btn.disabled).toBe(true)"
              }
            ],
            "describes": []
          },
          {
            "title": "active property",
            "line": 112,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns false when no attribute",
                "line": 114,
                "source": "expect(button.active).toBe(false)"
              },
              {
                "title": "returns true when attribute present",
                "line": 119,
                "source": "button.setAttribute('active', '')\nexpect(button.active).toBe(true)"
              },
              {
                "title": "setter adds attribute when true",
                "line": 125,
                "source": "button.active = true\nexpect(button.hasAttribute('active')).toBe(true)"
              },
              {
                "title": "setter removes attribute when false",
                "line": 131,
                "source": "button.setAttribute('active', '')\nbutton.active = false\nexpect(button.hasAttribute('active')).toBe(false)"
              },
              {
                "title": "applies active class to button",
                "line": 138,
                "source": "button.active = true\nconst btn = button.shadowRoot.querySelector('button')\nexpect(btn.classList.contains('active')).toBe(true)"
              }
            ],
            "describes": []
          },
          {
            "title": "click behavior",
            "line": 154,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "dispatches press event on click",
                "line": 156,
                "source": "const handler = vi.fn()\nbutton.addEventListener('press', handler)\n\nconst btn = button.shadowRoot.querySelector('button')\nbtn.click()\n\nexpect(handler).toHaveBeenCalled()"
              },
              {
                "title": "press event bubbles",
                "line": 167,
                "source": "const handler = vi.fn()\ndocument.body.addEventListener('press', handler)\n\nconst btn = button.shadowRoot.querySelector('button')\nbtn.click()\n\nexpect(handler).toHaveBeenCalled()\ndocument.body.removeEventListener('press', handler)"
              },
              {
                "title": "does not dispatch press when disabled",
                "line": 179,
                "source": "const handler = vi.fn()\nbutton.addEventListener('press', handler)\nbutton.disabled = true\n\nconst btn = button.shadowRoot.querySelector('button')\nbtn.click()\n\nexpect(handler).not.toHaveBeenCalled()"
              }
            ],
            "describes": []
          },
          {
            "title": "focus methods",
            "line": 193,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "focus calls internal button focus",
                "line": 195,
                "source": "const btn = button.shadowRoot.querySelector('button')\nconst spy = vi.spyOn(btn, 'focus')\nbutton.focus()\nexpect(spy).toHaveBeenCalled()"
              },
              {
                "title": "blur calls internal button blur",
                "line": 203,
                "source": "const btn = button.shadowRoot.querySelector('button')\nconst spy = vi.spyOn(btn, 'blur')\nbutton.blur()\nexpect(spy).toHaveBeenCalled()"
              },
              {
                "title": "click calls internal button click",
                "line": 211,
                "source": "const btn = button.shadowRoot.querySelector('button')\nconst spy = vi.spyOn(btn, 'click')\nbutton.click()\nexpect(spy).toHaveBeenCalled()"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/editor/interactive/tab_bar.doc.js": {
    "file": "/editor/interactive/tab_bar.test.js",
    "describes": [
      {
        "title": "TabBar",
        "line": 5,
        "beforeEach": {
          "line": 9,
          "source": "tabBar = document.createElement('tab-bar')\ndocument.body.appendChild(tabBar)"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "creates component with shadow DOM",
            "line": 15,
            "source": "expect(tabBar.shadowRoot).toBeTruthy()"
          },
          {
            "title": "sets tabs programmatically",
            "line": 20,
            "source": "tabBar.setTabs([\n    {value: 'a', label: 'Tab A'},\n    {value: 'b', label: 'Tab B'}\n])\n\nconst buttons = tabBar.shadowRoot.querySelectorAll('.tab')\nexpect(buttons.length).toBe(2)\nexpect(buttons[0].textContent).toBe('Tab A')\nexpect(buttons[1].textContent).toBe('Tab B')"
          },
          {
            "title": "sets value via property",
            "line": 33,
            "source": "tabBar.setTabs([\n    {value: 'a', label: 'Tab A'},\n    {value: 'b', label: 'Tab B'}\n])\ntabBar.value = 'b'\n\nexpect(tabBar.value).toBe('b')\nexpect(tabBar.getAttribute('value')).toBe('b')"
          },
          {
            "title": "sets value via attribute",
            "line": 45,
            "source": "tabBar.setTabs([\n    {value: 'a', label: 'Tab A'},\n    {value: 'b', label: 'Tab B'}\n])\ntabBar.setAttribute('value', 'a')\n\nexpect(tabBar.value).toBe('a')"
          },
          {
            "title": "marks active tab",
            "line": 56,
            "source": "tabBar.setTabs([\n    {value: 'a', label: 'Tab A'},\n    {value: 'b', label: 'Tab B'}\n])\ntabBar.value = 'b'\n\nconst buttons = tabBar.shadowRoot.querySelectorAll('.tab')\nexpect(buttons[0].classList.contains('active')).toBe(false)\nexpect(buttons[1].classList.contains('active')).toBe(true)"
          },
          {
            "title": "emits change event when tab is clicked",
            "line": 69,
            "source": "tabBar.setTabs([\n    {value: 'a', label: 'Tab A'},\n    {value: 'b', label: 'Tab B'}\n])\ntabBar.value = 'a'\n\nlet eventValue = null\ntabBar.addEventListener('change', (e) => {\n    eventValue = e.detail.value\n})\n\nconst buttons = tabBar.shadowRoot.querySelectorAll('.tab')\nbuttons[1].click()\n\nexpect(eventValue).toBe('b')\nexpect(tabBar.value).toBe('b')"
          },
          {
            "title": "does not emit change when clicking active tab",
            "line": 89,
            "source": "tabBar.setTabs([\n    {value: 'a', label: 'Tab A'},\n    {value: 'b', label: 'Tab B'}\n])\ntabBar.value = 'a'\n\nlet eventCount = 0\ntabBar.addEventListener('change', () => {\n    eventCount++\n})\n\nconst buttons = tabBar.shadowRoot.querySelectorAll('.tab')\nbuttons[0].click()\n\nexpect(eventCount).toBe(0)"
          },
          {
            "title": "has slot for custom tab content",
            "line": 108,
            "source": "const slot = tabBar.shadowRoot.querySelector('slot[name=\"tab\"]')\nexpect(slot).toBeTruthy()"
          }
        ],
        "describes": []
      }
    ]
  },
  "/editor/layout/app_layout.doc.js": {
    "file": "/editor/layout/app_layout.test.js",
    "describes": [
      {
        "title": "AppLayout",
        "line": 5,
        "beforeEach": {
          "line": 9,
          "source": "layout = document.createElement('app-layout')\ndocument.body.appendChild(layout)"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "creates component with shadow DOM",
            "line": 15,
            "source": "expect(layout.shadowRoot).toBeTruthy()"
          },
          {
            "title": "has default structure with header, content, and footer",
            "line": 20,
            "source": "const header = layout.shadowRoot.querySelector('.header')\nconst content = layout.shadowRoot.querySelector('.content')\nconst footer = layout.shadowRoot.querySelector('.footer')\n\nexpect(header).toBeTruthy()\nexpect(content).toBeTruthy()\nexpect(footer).toBeTruthy()"
          },
          {
            "title": "sets title via property",
            "line": 31,
            "source": "layout.title = 'Test App'\nconst titleEl = layout.shadowRoot.querySelector('.title')\nexpect(titleEl.textContent).toBe('Test App')"
          },
          {
            "title": "sets title via attribute",
            "line": 38,
            "source": "layout.setAttribute('title', 'Attribute Title')\nconst titleEl = layout.shadowRoot.querySelector('.title')\nexpect(titleEl.textContent).toBe('Attribute Title')"
          },
          {
            "title": "hides header when no-header attribute is set",
            "line": 45,
            "source": "layout.setAttribute('no-header', '')\nconst header = layout.shadowRoot.querySelector('.header')\nconst computedDisplay = window.getComputedStyle(header).display\nexpect(computedDisplay === 'none' || layout.hasAttribute('no-header')).toBe(true)"
          },
          {
            "title": "hides footer when no-footer attribute is set",
            "line": 53,
            "source": "layout.setAttribute('no-footer', '')\nexpect(layout.hasAttribute('no-footer')).toBe(true)"
          },
          {
            "title": "emits menu event when menu button is clicked",
            "line": 59,
            "source": "let eventFired = false\nlayout.addEventListener('menu', () => {\n    eventFired = true\n})\n\nconst menuBtn = layout.shadowRoot.querySelector('.menu-btn')\nmenuBtn.click()\n\nexpect(eventFired).toBe(true)"
          },
          {
            "title": "emits close event when close button is clicked",
            "line": 72,
            "source": "let eventFired = false\nlayout.addEventListener('close', () => {\n    eventFired = true\n})\n\nconst closeBtn = layout.shadowRoot.querySelector('.close-btn')\ncloseBtn.click()\n\nexpect(eventFired).toBe(true)"
          },
          {
            "title": "hides menu button when no-menu attribute is set",
            "line": 85,
            "source": "layout.setAttribute('no-menu', '')\nconst menuBtn = layout.shadowRoot.querySelector('.menu-btn')\nexpect(menuBtn.classList.contains('hidden')).toBe(true)"
          },
          {
            "title": "hides close button when no-close attribute is set",
            "line": 92,
            "source": "layout.setAttribute('no-close', '')\nconst closeBtn = layout.shadowRoot.querySelector('.close-btn')\nexpect(closeBtn.classList.contains('hidden')).toBe(true)"
          },
          {
            "title": "shows menu button by default",
            "line": 99,
            "source": "const menuBtn = layout.shadowRoot.querySelector('.menu-btn')\nexpect(menuBtn.classList.contains('hidden')).toBe(false)"
          },
          {
            "title": "shows close button by default",
            "line": 105,
            "source": "const closeBtn = layout.shadowRoot.querySelector('.close-btn')\nexpect(closeBtn.classList.contains('hidden')).toBe(false)"
          },
          {
            "title": "has slots for header customization",
            "line": 111,
            "source": "const headerStart = layout.shadowRoot.querySelector('slot[name=\"header-start\"]')\nconst headerCenter = layout.shadowRoot.querySelector('slot[name=\"header-center\"]')\nconst headerEnd = layout.shadowRoot.querySelector('slot[name=\"header-end\"]')\n\nexpect(headerStart).toBeTruthy()\nexpect(headerCenter).toBeTruthy()\nexpect(headerEnd).toBeTruthy()"
          },
          {
            "title": "has slots for footer customization",
            "line": 122,
            "source": "const footerStart = layout.shadowRoot.querySelector('slot[name=\"footer-start\"]')\nconst footerCenter = layout.shadowRoot.querySelector('slot[name=\"footer-center\"]')\nconst footerEnd = layout.shadowRoot.querySelector('slot[name=\"footer-end\"]')\n\nexpect(footerStart).toBeTruthy()\nexpect(footerCenter).toBeTruthy()\nexpect(footerEnd).toBeTruthy()"
          },
          {
            "title": "has default slot for main content",
            "line": 133,
            "source": "const defaultSlot = layout.shadowRoot.querySelector('.content slot:not([name])')\nexpect(defaultSlot).toBeTruthy()"
          },
          {
            "title": "has overlay slot for modals",
            "line": 139,
            "source": "const overlaySlot = layout.shadowRoot.querySelector('slot[name=\"overlay\"]')\nexpect(overlaySlot).toBeTruthy()"
          },
          {
            "title": "gets title via getter",
            "line": 145,
            "source": "layout.setAttribute('title', 'My Title')\nexpect(layout.title).toBe('My Title')"
          },
          {
            "title": "sets title via setTitle method",
            "line": 151,
            "source": "layout.setTitle('Method Title')\nexpect(layout.title).toBe('Method Title')"
          }
        ],
        "describes": []
      }
    ]
  },
  "/editor/layout/overlay.doc.js": {
    "file": "/editor/layout/overlay.test.js",
    "describes": [
      {
        "title": "Overlay",
        "line": 5,
        "beforeEach": {
          "line": 9,
          "source": "overlay = document.createElement('editor-overlay')\ndocument.body.appendChild(overlay)"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "creates component with shadow DOM",
            "line": 15,
            "source": "expect(overlay.shadowRoot).toBeTruthy()"
          },
          {
            "title": "is closed by default",
            "line": 20,
            "source": "expect(overlay.isOpen).toBe(false)\nexpect(overlay.hasAttribute('open')).toBe(false)"
          },
          {
            "title": "opens with open() method",
            "line": 26,
            "source": "overlay.open()\nexpect(overlay.isOpen).toBe(true)\nexpect(overlay.hasAttribute('open')).toBe(true)"
          },
          {
            "title": "closes with close() method",
            "line": 33,
            "source": "overlay.open()\noverlay.close()\nexpect(overlay.isOpen).toBe(false)\nexpect(overlay.hasAttribute('open')).toBe(false)"
          },
          {
            "title": "toggles with toggle() method",
            "line": 41,
            "source": "expect(overlay.isOpen).toBe(false)\n\noverlay.toggle()\nexpect(overlay.isOpen).toBe(true)\n\noverlay.toggle()\nexpect(overlay.isOpen).toBe(false)"
          },
          {
            "title": "emits open event",
            "line": 52,
            "source": "let eventFired = false\noverlay.addEventListener('open', () => {\n    eventFired = true\n})\n\noverlay.open()\nexpect(eventFired).toBe(true)"
          },
          {
            "title": "emits close event",
            "line": 63,
            "source": "let eventFired = false\noverlay.addEventListener('close', () => {\n    eventFired = true\n})\n\noverlay.open()\noverlay.close()\nexpect(eventFired).toBe(true)"
          },
          {
            "title": "does not emit open event if already open",
            "line": 75,
            "source": "overlay.open()\n\nlet eventCount = 0\noverlay.addEventListener('open', () => {\n    eventCount++\n})\n\noverlay.open()\nexpect(eventCount).toBe(0)"
          },
          {
            "title": "does not emit close event if already closed",
            "line": 88,
            "source": "let eventCount = 0\noverlay.addEventListener('close', () => {\n    eventCount++\n})\n\noverlay.close()\nexpect(eventCount).toBe(0)"
          },
          {
            "title": "has backdrop element",
            "line": 99,
            "source": "const backdrop = overlay.shadowRoot.querySelector('.backdrop')\nexpect(backdrop).toBeTruthy()"
          },
          {
            "title": "has container element",
            "line": 105,
            "source": "const container = overlay.shadowRoot.querySelector('.container')\nexpect(container).toBeTruthy()"
          },
          {
            "title": "has default slot for content",
            "line": 111,
            "source": "const slot = overlay.shadowRoot.querySelector('slot')\nexpect(slot).toBeTruthy()"
          },
          {
            "title": "closes on backdrop click by default",
            "line": 117,
            "source": "overlay.open()\n\nconst backdrop = overlay.shadowRoot.querySelector('.backdrop')\nbackdrop.click()\n\nexpect(overlay.isOpen).toBe(false)"
          },
          {
            "title": "does not close on backdrop click with no-close-on-backdrop",
            "line": 127,
            "source": "overlay.setAttribute('no-close-on-backdrop', '')\noverlay.open()\n\nconst backdrop = overlay.shadowRoot.querySelector('.backdrop')\nbackdrop.click()\n\nexpect(overlay.isOpen).toBe(true)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/editor/layout/panel.doc.js": {
    "file": "/editor/layout/panel.test.js",
    "describes": [
      {
        "title": "Panel",
        "line": 5,
        "beforeEach": {
          "line": 9,
          "source": "panel = document.createElement('editor-panel')\ndocument.body.appendChild(panel)"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "creates component with shadow DOM",
            "line": 15,
            "source": "expect(panel.shadowRoot).toBeTruthy()"
          },
          {
            "title": "has header and content elements",
            "line": 20,
            "source": "const header = panel.shadowRoot.querySelector('.panel-header')\nconst content = panel.shadowRoot.querySelector('.panel-content')\n\nexpect(header).toBeTruthy()\nexpect(content).toBeTruthy()"
          },
          {
            "title": "sets title via property",
            "line": 29,
            "source": "panel.title = 'Test Panel'\nconst titleEl = panel.shadowRoot.querySelector('.panel-title')\nexpect(titleEl.textContent).toBe('Test Panel')"
          },
          {
            "title": "sets title via attribute",
            "line": 36,
            "source": "panel.setAttribute('title', 'Attribute Title')\nconst titleEl = panel.shadowRoot.querySelector('.panel-title')\nexpect(titleEl.textContent).toBe('Attribute Title')"
          },
          {
            "title": "toggles collapsed state",
            "line": 43,
            "source": "expect(panel.collapsed).toBe(false)\n\npanel.toggle()\nexpect(panel.collapsed).toBe(true)\nexpect(panel.hasAttribute('collapsed')).toBe(true)\n\npanel.toggle()\nexpect(panel.collapsed).toBe(false)\nexpect(panel.hasAttribute('collapsed')).toBe(false)"
          },
          {
            "title": "sets collapsed via property",
            "line": 56,
            "source": "panel.collapsed = true\nexpect(panel.hasAttribute('collapsed')).toBe(true)\n\npanel.collapsed = false\nexpect(panel.hasAttribute('collapsed')).toBe(false)"
          },
          {
            "title": "sets floating via property",
            "line": 65,
            "source": "expect(panel.floating).toBe(false)\n\npanel.floating = true\nexpect(panel.hasAttribute('floating')).toBe(true)\nexpect(panel.floating).toBe(true)\n\npanel.floating = false\nexpect(panel.hasAttribute('floating')).toBe(false)"
          },
          {
            "title": "emits close event when close button is clicked",
            "line": 77,
            "source": "let eventFired = false\npanel.addEventListener('close', () => {\n    eventFired = true\n})\n\nconst buttons = panel.shadowRoot.querySelectorAll('.panel-btn')\nconst closeBtn = buttons[buttons.length - 1]\ncloseBtn.click()\n\nexpect(eventFired).toBe(true)"
          },
          {
            "title": "toggles when collapse button is clicked",
            "line": 91,
            "source": "const collapseBtn = panel.shadowRoot.querySelector('.panel-btn')\nexpect(panel.collapsed).toBe(false)\n\ncollapseBtn.click()\nexpect(panel.collapsed).toBe(true)\n\ncollapseBtn.click()\nexpect(panel.collapsed).toBe(false)"
          },
          {
            "title": "updates collapse icon based on state",
            "line": 103,
            "source": "const collapseBtn = panel.shadowRoot.querySelector('.panel-btn')\n\nexpect(collapseBtn.innerHTML).toBe('')\n\npanel.collapsed = true\nexpect(collapseBtn.innerHTML).toBe('+')\n\npanel.collapsed = false\nexpect(collapseBtn.innerHTML).toBe('')"
          },
          {
            "title": "has default slot for content",
            "line": 116,
            "source": "const slot = panel.shadowRoot.querySelector('.panel-content slot')\nexpect(slot).toBeTruthy()"
          }
        ],
        "describes": []
      }
    ]
  },
  "/editor/layout/toolbar.doc.js": {
    "file": "/editor/layout/toolbar.test.js",
    "describes": [
      {
        "title": "Toolbar",
        "line": 5,
        "beforeEach": {
          "line": 9,
          "source": "toolbar = document.createElement('editor-toolbar')\ndocument.body.appendChild(toolbar)"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "creates component with shadow DOM",
            "line": 15,
            "source": "expect(toolbar.shadowRoot).toBeTruthy()"
          },
          {
            "title": "has start, center, and end sections",
            "line": 20,
            "source": "const start = toolbar.shadowRoot.querySelector('.toolbar-start')\nconst center = toolbar.shadowRoot.querySelector('.toolbar-center')\nconst end = toolbar.shadowRoot.querySelector('.toolbar-end')\n\nexpect(start).toBeTruthy()\nexpect(center).toBeTruthy()\nexpect(end).toBeTruthy()"
          },
          {
            "title": "has slots for start, center, and end",
            "line": 31,
            "source": "const startSlot = toolbar.shadowRoot.querySelector('slot[name=\"start\"]')\nconst centerSlot = toolbar.shadowRoot.querySelector('slot[name=\"center\"]')\nconst endSlot = toolbar.shadowRoot.querySelector('slot[name=\"end\"]')\n\nexpect(startSlot).toBeTruthy()\nexpect(centerSlot).toBeTruthy()\nexpect(endSlot).toBeTruthy()"
          },
          {
            "title": "has default slot for center content",
            "line": 42,
            "source": "const defaultSlot = toolbar.shadowRoot.querySelector('.toolbar-center slot:not([name])')\nexpect(defaultSlot).toBeTruthy()"
          },
          {
            "title": "accepts variant attribute",
            "line": 48,
            "source": "toolbar.setAttribute('variant', 'compact')\nexpect(toolbar.getAttribute('variant')).toBe('compact')"
          },
          {
            "title": "accepts footer variant",
            "line": 54,
            "source": "toolbar.setAttribute('variant', 'footer')\nexpect(toolbar.getAttribute('variant')).toBe('footer')"
          },
          {
            "title": "accepts no-border attribute",
            "line": 60,
            "source": "toolbar.setAttribute('no-border', '')\nexpect(toolbar.hasAttribute('no-border')).toBe(true)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/doc/api_parser.doc.js": {
    "file": "/doc/api_parser.test.js",
    "describes": [
      {
        "title": "api_parser",
        "line": 5,
        "beforeEach": null,
        "afterEach": null,
        "tests": [],
        "describes": [
          {
            "title": "parseSourceFile",
            "line": 7,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "simple class",
                "line": 9,
                "source": "const source = `\n    export default class Foo {\n        static $category = 'foo'\n\n        constructor (options) {\n            this.options = options\n        }\n\n        start () {\n            return true\n        }\n\n        get running () {\n            return this._running\n        }\n\n        set running (value) {\n            this._running = value\n        }\n    }\n`\n\nconst result = parseSourceFile(source, 'foo.js')\n\nexpect(result.file).toBe('foo.js')\nexpect(result.classes).toHaveLength(1)\n\nconst cls = result.classes[0]\nexpect(cls.name).toBe('Foo')\nexpect(cls.isDefault).toBe(true)\nexpect(cls.statics).toHaveLength(1)\nexpect(cls.statics[0].name).toBe('$category')\nexpect(cls.constructor).not.toBeNull()\nexpect(cls.constructor.params).toEqual(['options'])\nexpect(cls.methods).toHaveLength(1)\nexpect(cls.methods[0].name).toBe('start')\nexpect(cls.getters).toHaveLength(1)\nexpect(cls.getters[0].name).toBe('running')\nexpect(cls.setters).toHaveLength(1)\nexpect(cls.setters[0].name).toBe('running')"
              },
              {
                "title": "skips private members",
                "line": 53,
                "source": "const source = `\n    class Bar {\n        #privateField = 1\n        publicField = 2\n\n        #privateMethod () {}\n        publicMethod () {}\n\n        get #privateGetter () {}\n        get publicGetter () {}\n    }\n`\n\nconst result = parseSourceFile(source)\nconst cls = result.classes[0]\n\nexpect(cls.statics).toHaveLength(0)\nexpect(cls.methods).toHaveLength(1)\nexpect(cls.methods[0].name).toBe('publicMethod')\nexpect(cls.getters).toHaveLength(1)\nexpect(cls.getters[0].name).toBe('publicGetter')"
              },
              {
                "title": "class inheritance",
                "line": 78,
                "source": "const source = `\n    class Child extends Parent {\n        foo () {}\n    }\n`\n\nconst result = parseSourceFile(source)\nexpect(result.classes[0].extends).toBe('Parent')"
              },
              {
                "title": "exported functions",
                "line": 90,
                "source": "const source = `\n    export function doSomething (a, b = 10, ...rest) {\n        return a + b\n    }\n`\n\nconst result = parseSourceFile(source)\n\nexpect(result.functions).toHaveLength(1)\nexpect(result.functions[0].name).toBe('doSomething')\nexpect(result.functions[0].params).toEqual(['a', 'b = ...', '...rest'])"
              },
              {
                "title": "named exports",
                "line": 105,
                "source": "const source = `\n    export const FOO = 'bar'\n`\n\nconst result = parseSourceFile(source)\n\nexpect(result.exports).toHaveLength(1)\nexpect(result.exports[0].name).toBe('FOO')\nexpect(result.exports[0].kind).toBe('variable')"
              },
              {
                "title": "line numbers",
                "line": 118,
                "source": "const source = `class Test {\n    foo () {}\n}`\n            const result = parseSourceFile(source)\n\n            expect(result.classes[0].line).toBe(1)\n            expect(result.classes[0].methods[0].line).toBe(2)"
              },
              {
                "title": "source code extraction",
                "line": 129,
                "source": "const source = `class Test {\n    get value () {\n        return 42\n    }\n}`\n            const result = parseSourceFile(source)\n            const getter = result.classes[0].getters[0]\n\n            expect(getter.source).toContain('get value')\n            expect(getter.source).toContain('return 42')"
              }
            ],
            "describes": []
          },
          {
            "title": "getApiForFile",
            "line": 145,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "class type for single class",
                "line": 147,
                "source": "const source = `\n    export default class Foo {\n        bar () {}\n    }\n`\n\nconst api = getApiForFile(source, 'foo.js')\n\nexpect(api.type).toBe('class')\nexpect(api.name).toBe('Foo')\nexpect(api.file).toBe('foo.js')"
              },
              {
                "title": "module type for multiple classes",
                "line": 162,
                "source": "const source = `\n    export class Foo {}\n    export class Bar {}\n`\n\nconst api = getApiForFile(source)\n\nexpect(api.type).toBe('module')\nexpect(api.classes).toHaveLength(2)"
              },
              {
                "title": "module type for functions only",
                "line": 175,
                "source": "const source = `\n    export function foo () {}\n    export function bar () {}\n`\n\nconst api = getApiForFile(source)\n\nexpect(api.type).toBe('module')\nexpect(api.functions).toHaveLength(2)"
              },
              {
                "title": "null for empty file",
                "line": 188,
                "source": "const api = getApiForFile('')\n\nexpect(api).toBeNull()"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/doc/discovery.doc.js": {
    "file": "/doc/discovery.test.js",
    "describes": [
      {
        "title": "discovery",
        "line": 4,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "module exists",
            "line": 6,
            "source": "const module = await import('./discovery.js')\nexpect(module).toBeDefined()"
          }
        ],
        "describes": []
      }
    ]
  },
  "/doc/doc_page.doc.js": {
    "file": "/doc/doc_page.test.js",
    "describes": [
      {
        "title": "doc_page",
        "line": 30,
        "beforeEach": {
          "line": 34,
          "source": "if (!globalThis.customElements) {\n    globalThis.customElements = {\n        define: vi.fn(),\n        get: vi.fn()\n    }\n}\n\nif (!globalThis.HTMLElement) {\n    globalThis.HTMLElement = class {\n        attachShadow () {\n            return {\n                appendChild: vi.fn(),\n                querySelector: vi.fn(() => ({innerHTML: '', appendChild: vi.fn()})),\n                querySelectorAll: vi.fn(() => []),\n                getElementById: vi.fn(),\n                addEventListener: vi.fn()\n            }\n        }\n    }\n}\n\nconst module = await import('./doc_page.js')\nDocPage = module.default"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "exports DocPage class",
            "line": 61,
            "source": "expect(DocPage).toBeDefined()\nexpect(typeof DocPage).toBe('function')"
          },
          {
            "title": "DocPage extends HTMLElement",
            "line": 67,
            "source": "expect(DocPage.prototype).toBeInstanceOf(HTMLElement)"
          },
          {
            "title": "renderBlock handles see block type",
            "line": 123,
            "source": "const page = new DocPage()\nconst seeBlock = {\n    type: 'see',\n    name: 'ActionController',\n    pageType: 'doc',\n    section: null\n}\n\npage.doc = {\n    title: 'Test',\n    blocks: [seeBlock]\n}"
          }
        ],
        "describes": [
          {
            "title": "properties",
            "line": 72,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "doc getter and setter",
                "line": 74,
                "source": "const page = new DocPage()\nexpect(page.doc).toBeNull()\n\nconst docData = {title: 'Test', blocks: []}\npage.doc = docData\nexpect(page.doc).toBe(docData)"
              },
              {
                "title": "api getter and setter",
                "line": 84,
                "source": "const page = new DocPage()\nexpect(page.api).toBeNull()\n\nconst apiData = {type: 'class', name: 'Test'}\npage.api = apiData\nexpect(page.api).toBe(apiData)"
              },
              {
                "title": "sources getter and setter",
                "line": 94,
                "source": "const page = new DocPage()\nexpect(page.sources).toBeNull()\n\nconst sources = [{type: 'code', title: 'Example', source: 'code'}]\npage.sources = sources\nexpect(page.sources).toBe(sources)"
              },
              {
                "title": "tests getter and setter",
                "line": 104,
                "source": "const page = new DocPage()\nexpect(page.tests).toBeNull()\n\nconst tests = {describes: []}\npage.tests = tests\nexpect(page.tests).toBe(tests)"
              },
              {
                "title": "initialTab setter validates values",
                "line": 114,
                "source": "const page = new DocPage()\npage.initialTab = 'api'\npage.initialTab = 'invalid'"
              }
            ],
            "describes": []
          },
          {
            "title": "inline see links in text",
            "line": 139,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "parses [[Name]] as doc link",
                "line": 141,
                "source": "const page = new DocPage()\npage.doc = {\n    title: 'Test',\n    blocks: [{\n        type: 'text',\n        content: 'See [[ActionController]] for more.'\n    }]\n}"
              },
              {
                "title": "parses [[Name#Section]] as doc link with section",
                "line": 153,
                "source": "const page = new DocPage()\npage.doc = {\n    title: 'Test',\n    blocks: [{\n        type: 'text',\n        content: 'See [[ActionController#Propagation]] for details.'\n    }]\n}"
              },
              {
                "title": "parses [[Name:api]] as API link",
                "line": 165,
                "source": "const page = new DocPage()\npage.doc = {\n    title: 'Test',\n    blocks: [{\n        type: 'text',\n        content: 'Check [[ActionController:api]] for methods.'\n    }]\n}"
              },
              {
                "title": "parses [[Name:api#Section]] as API link with section",
                "line": 177,
                "source": "const page = new DocPage()\npage.doc = {\n    title: 'Test',\n    blocks: [{\n        type: 'text',\n        content: 'See [[ActionController:api#methods]] for the full list.'\n    }]\n}"
              },
              {
                "title": "parses [[Name:guide]] as guide link",
                "line": 189,
                "source": "const page = new DocPage()\npage.doc = {\n    title: 'Test',\n    blocks: [{\n        type: 'text',\n        content: 'Read [[foreword:guide]] for the overview.'\n    }]\n}"
              },
              {
                "title": "parses multiple inline links in same text",
                "line": 201,
                "source": "const page = new DocPage()\npage.doc = {\n    title: 'Test',\n    blocks: [{\n        type: 'text',\n        content: 'See [[ActionController]] and [[ActionDispatcher#Stack]].'\n    }]\n}"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/doc/doc_registry.doc.js": {
    "file": "/doc/doc_registry.test.js",
    "describes": [
      {
        "title": "doc_registry",
        "line": 5,
        "beforeEach": null,
        "afterEach": null,
        "tests": [],
        "describes": [
          {
            "title": "lookupDoc",
            "line": 20,
            "beforeEach": {
              "line": 22,
              "source": "initRegistry(mockDocs, mockGuides)"
            },
            "afterEach": null,
            "tests": [
              {
                "title": "initializes the registry",
                "line": 27,
                "source": "expect(isRegistryInitialized()).toBe(true)"
              },
              {
                "title": "finds doc by exact title",
                "line": 32,
                "source": "const doc = lookupDoc('WebGLRenderer')\nexpect(doc).not.toBeNull()\nexpect(doc.file).toBe('/render/webgl_renderer.doc.js')"
              },
              {
                "title": "finds doc case-insensitively",
                "line": 39,
                "source": "const doc = lookupDoc('webglrenderer')\nexpect(doc).not.toBeNull()\nexpect(doc.file).toBe('/render/webgl_renderer.doc.js')"
              },
              {
                "title": "finds Object2D",
                "line": 46,
                "source": "const doc = lookupDoc('Object2D')\nexpect(doc).not.toBeNull()\nexpect(doc.file).toBe('/render/object_2d.doc.js')"
              },
              {
                "title": "returns null for non-existent doc",
                "line": 53,
                "source": "const doc = lookupDoc('NonExistent')\nexpect(doc).toBeNull()"
              }
            ],
            "describes": []
          },
          {
            "title": "lookupGuide",
            "line": 61,
            "beforeEach": {
              "line": 63,
              "source": "initRegistry(mockDocs, mockGuides)"
            },
            "afterEach": null,
            "tests": [
              {
                "title": "finds guide by title",
                "line": 68,
                "source": "const guide = lookupGuide('Foreword')\nexpect(guide).not.toBeNull()\nexpect(guide.id).toBe('foreword')"
              },
              {
                "title": "finds guide by id",
                "line": 75,
                "source": "const guide = lookupGuide('getting_started')\nexpect(guide).not.toBeNull()\nexpect(guide.title).toBe('Getting Started')"
              },
              {
                "title": "returns null for non-existent guide",
                "line": 82,
                "source": "const guide = lookupGuide('NonExistent')\nexpect(guide).toBeNull()"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/doc/runtime.doc.js": {
    "file": "/doc/runtime.test.js",
    "describes": [
      {
        "title": "doc",
        "line": 19,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "creates doc with title and blocks",
            "line": 21,
            "source": "const result = doc('My Doc', () => {\n    text('Hello')\n})\n\nexpect(result.title).toBe('My Doc')\nexpect(result.blocks).toHaveLength(1)\nexpect(result.blocks[0].type).toBe('text')"
          },
          {
            "title": "accepts options object",
            "line": 32,
            "source": "const result = doc('My Doc', {foo: 'bar'}, () => {\n    text('Hello')\n})\n\nexpect(result.title).toBe('My Doc')\nexpect(result.options.foo).toBe('bar')"
          },
          {
            "title": "options defaults to empty object when callback is second arg",
            "line": 42,
            "source": "const result = doc('My Doc', () => {})\n\nexpect(result.options).toEqual({})"
          }
        ],
        "describes": []
      },
      {
        "title": "section",
        "line": 51,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "creates section block",
            "line": 53,
            "source": "const result = doc('Test', () => {\n    section('Section 1', () => {\n        text('Content')\n    })\n})\n\nexpect(result.blocks).toHaveLength(1)\nexpect(result.blocks[0].type).toBe('section')\nexpect(result.blocks[0].title).toBe('Section 1')\nexpect(result.blocks[0].blocks).toHaveLength(1)"
          },
          {
            "title": "throws when called outside doc",
            "line": 67,
            "source": "expect(() => {\n    section('Test', () => {})\n}).toThrow('section() must be called inside doc()')"
          },
          {
            "title": "captures setup from within section",
            "line": 74,
            "source": "const setupFn = () => {}\n\nconst result = doc('Test', () => {\n    section('With Setup', () => {\n        setup(setupFn)\n        text('Content')\n    })\n})\n\nexpect(result.blocks[0].setup).not.toBeNull()\nexpect(result.blocks[0].setup.fn).toBe(setupFn)"
          }
        ],
        "describes": []
      },
      {
        "title": "text",
        "line": 91,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "creates text block",
            "line": 93,
            "source": "const result = doc('Test', () => {\n    text('Hello world')\n})\n\nexpect(result.blocks[0].type).toBe('text')\nexpect(result.blocks[0].content).toBe('Hello world')"
          },
          {
            "title": "throws when called outside doc",
            "line": 103,
            "source": "expect(() => {\n    text('Hello')\n}).toThrow('text() must be called inside doc()')"
          },
          {
            "title": "dedents content",
            "line": 110,
            "source": "const result = doc('Test', () => {\n    text(`\n        First line\n        Second line\n    `)\n})\n\nexpect(result.blocks[0].content).toBe('First line\\nSecond line')"
          }
        ],
        "describes": []
      },
      {
        "title": "code",
        "line": 124,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "creates code block",
            "line": 126,
            "source": "const result = doc('Test', () => {\n    code('Example', () => {\n        const x = 1\n        return x\n    })\n})\n\nexpect(result.blocks[0].type).toBe('code')\nexpect(result.blocks[0].title).toBe('Example')\nexpect(result.blocks[0].source).toContain('const x = 1')"
          },
          {
            "title": "throws when called outside doc",
            "line": 140,
            "source": "expect(() => {\n    code('Test', () => {})\n}).toThrow('code() must be called inside doc()')"
          }
        ],
        "describes": []
      },
      {
        "title": "action",
        "line": 149,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "creates action block with fn",
            "line": 151,
            "source": "const fn = () => console.log('action')\n\nconst result = doc('Test', () => {\n    action('Run', fn)\n})\n\nexpect(result.blocks[0].type).toBe('action')\nexpect(result.blocks[0].title).toBe('Run')\nexpect(result.blocks[0].fn).toBe(fn)"
          },
          {
            "title": "throws when called outside doc",
            "line": 164,
            "source": "expect(() => {\n    action('Test', () => {})\n}).toThrow('action() must be called inside doc()')"
          }
        ],
        "describes": []
      },
      {
        "title": "container",
        "line": 173,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "creates container with default height",
            "line": 175,
            "source": "const result = doc('Test', () => {\n    container(() => {})\n})\n\nexpect(result.blocks[0].type).toBe('container')\nexpect(result.blocks[0].height).toBe(300)\nexpect(result.blocks[0].width).toBeNull()"
          },
          {
            "title": "creates container with options",
            "line": 186,
            "source": "const result = doc('Test', () => {\n    container({width: 400, height: 500, title: 'Demo'}, () => {})\n})\n\nexpect(result.blocks[0].width).toBe(400)\nexpect(result.blocks[0].height).toBe(500)\nexpect(result.blocks[0].title).toBe('Demo')"
          },
          {
            "title": "supports preset option",
            "line": 197,
            "source": "const result = doc('Test', () => {\n    container({preset: 'interactive'}, () => {})\n})\n\nexpect(result.blocks[0].preset).toBe('interactive')"
          },
          {
            "title": "supports scrollable option",
            "line": 206,
            "source": "const result = doc('Test', () => {\n    container({scrollable: true}, () => {})\n})\n\nexpect(result.blocks[0].scrollable).toBe(true)"
          },
          {
            "title": "throws when called outside doc",
            "line": 215,
            "source": "expect(() => {\n    container(() => {})\n}).toThrow('container() must be called inside doc()')"
          }
        ],
        "describes": []
      },
      {
        "title": "see",
        "line": 224,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "creates see block with defaults",
            "line": 226,
            "source": "const result = doc('Test', () => {\n    see('ActionController')\n})\n\nexpect(result.blocks[0].type).toBe('see')\nexpect(result.blocks[0].name).toBe('ActionController')\nexpect(result.blocks[0].pageType).toBe('doc')\nexpect(result.blocks[0].section).toBeNull()"
          },
          {
            "title": "creates see block with section",
            "line": 238,
            "source": "const result = doc('Test', () => {\n    see('ActionController', {section: 'Propagation'})\n})\n\nexpect(result.blocks[0].name).toBe('ActionController')\nexpect(result.blocks[0].section).toBe('Propagation')"
          },
          {
            "title": "creates see block with type",
            "line": 248,
            "source": "const result = doc('Test', () => {\n    see('ActionController', {type: 'api'})\n})\n\nexpect(result.blocks[0].pageType).toBe('api')"
          },
          {
            "title": "creates see block with type and section",
            "line": 257,
            "source": "const result = doc('Test', () => {\n    see('ActionController', {type: 'api', section: 'methods'})\n})\n\nexpect(result.blocks[0].pageType).toBe('api')\nexpect(result.blocks[0].section).toBe('methods')"
          },
          {
            "title": "throws when called outside doc",
            "line": 267,
            "source": "expect(() => {\n    see('ActionController')\n}).toThrow('see() must be called inside doc()')"
          },
          {
            "title": "creates see block with category",
            "line": 274,
            "source": "const result = doc('Test', () => {\n    see('Application', {category: 'application'})\n})\n\nexpect(result.blocks[0].name).toBe('Application')\nexpect(result.blocks[0].category).toBe('application')"
          },
          {
            "title": "creates see block with category and type",
            "line": 284,
            "source": "const result = doc('Test', () => {\n    see('GameLoop', {category: 'game', type: 'api'})\n})\n\nexpect(result.blocks[0].name).toBe('GameLoop')\nexpect(result.blocks[0].category).toBe('game')\nexpect(result.blocks[0].pageType).toBe('api')"
          },
          {
            "title": "category defaults to null",
            "line": 295,
            "source": "const result = doc('Test', () => {\n    see('PerkyModule')\n})\n\nexpect(result.blocks[0].category).toBeNull()"
          }
        ],
        "describes": []
      },
      {
        "title": "disclaimer",
        "line": 306,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "creates disclaimer block",
            "line": 308,
            "source": "const result = doc('Test', () => {\n    disclaimer('This is a disclaimer')\n})\n\nexpect(result.blocks[0].type).toBe('disclaimer')\nexpect(result.blocks[0].content).toBe('This is a disclaimer')"
          },
          {
            "title": "dedents content",
            "line": 318,
            "source": "const result = doc('Test', () => {\n    disclaimer(`\n        First line\n        Second line\n    `)\n})\n\nexpect(result.blocks[0].content).toBe('First line\\nSecond line')"
          },
          {
            "title": "throws when called outside doc",
            "line": 330,
            "source": "expect(() => {\n    disclaimer('Test')\n}).toThrow('disclaimer() must be called inside doc()')"
          }
        ],
        "describes": []
      },
      {
        "title": "applyContainerPreset",
        "line": 339,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "applies interactive preset",
            "line": 341,
            "source": "const element = {\n    style: {},\n    tabIndex: -1\n}\n\napplyContainerPreset(element, 'interactive')\n\nexpect(element.tabIndex).toBe(0)\nexpect(element.style.outline).toBe('none')\nexpect(element.style.background).toBe('#1a1a2e')"
          },
          {
            "title": "applies interactive-alt preset",
            "line": 355,
            "source": "const element = {\n    style: {},\n    tabIndex: -1\n}\n\napplyContainerPreset(element, 'interactive-alt')\n\nexpect(element.style.background).toBe('#16213e')"
          },
          {
            "title": "applies inspector preset",
            "line": 367,
            "source": "const element = {style: {}}\n\napplyContainerPreset(element, 'inspector')\n\nexpect(element.style.padding).toBe('12px')\nexpect(element.style.overflow).toBe('auto')"
          },
          {
            "title": "applies centered preset",
            "line": 377,
            "source": "const element = {style: {}}\n\napplyContainerPreset(element, 'centered')\n\nexpect(element.style.display).toBe('flex')\nexpect(element.style.alignItems).toBe('center')\nexpect(element.style.justifyContent).toBe('center')"
          },
          {
            "title": "ignores unknown preset",
            "line": 388,
            "source": "const element = {style: {}}\n\napplyContainerPreset(element, 'unknown')\n\nexpect(Object.keys(element.style)).toHaveLength(0)"
          }
        ],
        "describes": []
      },
      {
        "title": "addSpacerIfNeeded",
        "line": 399,
        "beforeEach": {
          "line": 401,
          "source": "logger.history.length = 0\nvi.clearAllMocks()"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "adds spacer when history has logs and no trailing spacer",
            "line": 407,
            "source": "logger.history.push({event: 'log'})\n\naddSpacerIfNeeded()\n\nexpect(logger.spacer).toHaveBeenCalled()"
          },
          {
            "title": "does not add spacer when history is empty",
            "line": 416,
            "source": "addSpacerIfNeeded()\n\nexpect(logger.spacer).not.toHaveBeenCalled()"
          },
          {
            "title": "does not add spacer when last entry is already spacer",
            "line": 423,
            "source": "logger.history.push({event: 'log'}, {event: 'spacer'})\n\naddSpacerIfNeeded()\n\nexpect(logger.spacer).not.toHaveBeenCalled()"
          }
        ],
        "describes": []
      },
      {
        "title": "executeAction",
        "line": 434,
        "beforeEach": {
          "line": 436,
          "source": "logger.history.length = 0\nvi.clearAllMocks()"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "executes block function",
            "line": 442,
            "source": "const fn = vi.fn()\nconst block = {fn}\n\nawait executeAction(block)\n\nexpect(fn).toHaveBeenCalledWith({})"
          },
          {
            "title": "executes setup function before block",
            "line": 452,
            "source": "const order = []\nconst setupFn = vi.fn(() => order.push('setup'))\nconst blockFn = vi.fn(() => order.push('block'))\nconst block = {fn: blockFn}\nconst sectionSetup = {fn: setupFn}\n\nawait executeAction(block, sectionSetup)\n\nexpect(order).toEqual(['setup', 'block'])"
          },
          {
            "title": "logs error on failure",
            "line": 465,
            "source": "const block = {fn: () => {\n    throw new Error('Test error')\n}}\n\nawait executeAction(block)\n\nexpect(logger.error).toHaveBeenCalledWith('Action error:', 'Test error')"
          }
        ],
        "describes": []
      },
      {
        "title": "executeContainer",
        "line": 478,
        "beforeEach": {
          "line": 480,
          "source": "logger.history.length = 0\nvi.clearAllMocks()"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "clears container before execution",
            "line": 486,
            "source": "const containerEl = {\n    innerHTML: '<div>old</div>',\n    _currentApp: null,\n    style: {},\n    tabIndex: -1\n}\nconst block = {fn: vi.fn()}\n\nawait executeContainer(block, containerEl)\n\nexpect(containerEl.innerHTML).toBe('')"
          },
          {
            "title": "disposes previous app",
            "line": 501,
            "source": "const dispose = vi.fn()\nconst containerEl = {\n    innerHTML: '',\n    _currentApp: {dispose},\n    style: {},\n    tabIndex: -1\n}\nconst block = {fn: vi.fn()}\n\nawait executeContainer(block, containerEl)\n\nexpect(dispose).toHaveBeenCalled()"
          },
          {
            "title": "applies preset when specified",
            "line": 517,
            "source": "const containerEl = {\n    innerHTML: '',\n    _currentApp: null,\n    style: {},\n    tabIndex: -1\n}\nconst block = {preset: 'interactive', fn: vi.fn()}\n\nawait executeContainer(block, containerEl)\n\nexpect(containerEl.tabIndex).toBe(0)"
          },
          {
            "title": "sets overflow when scrollable",
            "line": 532,
            "source": "const containerEl = {\n    innerHTML: '',\n    _currentApp: null,\n    style: {},\n    tabIndex: -1\n}\nconst block = {scrollable: true, fn: vi.fn()}\n\nawait executeContainer(block, containerEl)\n\nexpect(containerEl.style.overflow).toBe('auto')"
          },
          {
            "title": "logs error on failure",
            "line": 547,
            "source": "const containerEl = {\n    innerHTML: '',\n    _currentApp: null,\n    style: {},\n    tabIndex: -1\n}\nconst block = {fn: () => {\n    throw new Error('Container error')\n}}\n\nawait executeContainer(block, containerEl)\n\nexpect(logger.error).toHaveBeenCalledWith('Container error:', 'Container error')"
          }
        ],
        "describes": []
      },
      {
        "title": "renderAction",
        "line": 566,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "creates action block wrapper",
            "line": 568,
            "source": "const block = {title: 'Run Test', source: 'console.log(\"test\")'}\n\nconst el = renderAction(block)\n\nexpect(el.className).toBe('doc-action-block')"
          },
          {
            "title": "creates perky-code element with title",
            "line": 577,
            "source": "const block = {title: 'Example', source: 'const x = 1'}\n\nconst el = renderAction(block)\nconst codeEl = el.querySelector('perky-code')\n\nexpect(codeEl.getAttribute('title')).toBe('Example')"
          },
          {
            "title": "uses extracted source when provided",
            "line": 587,
            "source": "const block = {title: 'Test', source: 'original'}\n\nconst el = renderAction(block, null, 'extracted')\nconst codeEl = el.querySelector('perky-code')\n\nexpect(codeEl.code).toBe('extracted')"
          },
          {
            "title": "creates run button",
            "line": 597,
            "source": "const block = {title: 'Test', source: ''}\n\nconst el = renderAction(block)\nconst button = el.querySelector('.doc-action-btn')\n\nexpect(button).toBeTruthy()\nexpect(button.textContent).toContain('Run')"
          }
        ],
        "describes": []
      }
    ]
  },
  "/doc/doc_viewer.doc.js": {
    "file": "/doc/doc_viewer.test.js",
    "describes": [
      {
        "title": "doc_viewer",
        "line": 4,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "module exists",
            "line": 6,
            "source": "const module = await import('./doc_viewer.js')\nexpect(module).toBeDefined()"
          }
        ],
        "describes": []
      }
    ]
  },
  "/doc/generate_pages.doc.js": {
    "file": "/doc/generate_pages.test.js",
    "describes": [
      {
        "title": "generate_pages",
        "line": 4,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "module exists",
            "line": 6,
            "source": "const module = await import('./generate_pages.js')\nexpect(module).toBeDefined()"
          }
        ],
        "describes": []
      }
    ]
  },
  "/doc/parse_markdown.doc.js": {
    "file": "/doc/parse_markdown.test.js",
    "describes": [
      {
        "title": "parse_markdown",
        "line": 9,
        "beforeEach": {
          "line": 13,
          "source": "const module = await import('./parse_markdown.js')\nparseMarkdown = module.parseMarkdown"
        },
        "afterEach": null,
        "tests": [],
        "describes": [
          {
            "title": "inline formatting",
            "line": 19,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "code with backticks",
                "line": 21,
                "source": "const result = parseMarkdown('Use `code` here')\nexpect(result).toContain('<code>code</code>')"
              },
              {
                "title": "bold with double asterisks",
                "line": 27,
                "source": "const result = parseMarkdown('This is **bold** text')\nexpect(result).toContain('<strong>bold</strong>')"
              },
              {
                "title": "italic with single asterisks",
                "line": 33,
                "source": "const result = parseMarkdown('This is *italic* text')\nexpect(result).toContain('<em>italic</em>')"
              },
              {
                "title": "multiple inline formats",
                "line": 39,
                "source": "const result = parseMarkdown('Use `code` and **bold** and *italic*')\nexpect(result).toContain('<code>code</code>')\nexpect(result).toContain('<strong>bold</strong>')\nexpect(result).toContain('<em>italic</em>')"
              }
            ],
            "describes": []
          },
          {
            "title": "paragraphs",
            "line": 49,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "single paragraph",
                "line": 51,
                "source": "const result = parseMarkdown('Hello world')\nexpect(result).toBe('<p>Hello world</p>')"
              },
              {
                "title": "multiple paragraphs separated by blank lines",
                "line": 57,
                "source": "const result = parseMarkdown('First paragraph\\n\\nSecond paragraph')\nexpect(result).toBe('<p>First paragraph</p><p>Second paragraph</p>')"
              },
              {
                "title": "trims whitespace",
                "line": 63,
                "source": "const result = parseMarkdown('  Hello world  ')\nexpect(result).toBe('<p>Hello world</p>')"
              },
              {
                "title": "renders --- as hr",
                "line": 68,
                "source": "const result = parseMarkdown('Before\\n\\n---\\n\\nAfter')\nexpect(result).toBe('<p>Before</p><hr><p>After</p>')"
              }
            ],
            "describes": []
          },
          {
            "title": "lists",
            "line": 76,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "unordered list",
                "line": 78,
                "source": "const result = parseMarkdown('- Item 1\\n- Item 2\\n- Item 3')\nexpect(result).toBe('<ul><li>Item 1</li><li>Item 2</li><li>Item 3</li></ul>')"
              },
              {
                "title": "list with inline formatting",
                "line": 84,
                "source": "const result = parseMarkdown('- Use `code` here\\n- **Bold** item')\nexpect(result).toContain('<li>Use <code>code</code> here</li>')\nexpect(result).toContain('<li><strong>Bold</strong> item</li>')"
              },
              {
                "title": "paragraph followed by list",
                "line": 91,
                "source": "const result = parseMarkdown('Some text\\n\\n- Item 1\\n- Item 2')\nexpect(result).toBe('<p>Some text</p><ul><li>Item 1</li><li>Item 2</li></ul>')"
              },
              {
                "title": "list followed by paragraph",
                "line": 97,
                "source": "const result = parseMarkdown('- Item 1\\n- Item 2\\n\\nSome text')\nexpect(result).toBe('<ul><li>Item 1</li><li>Item 2</li></ul><p>Some text</p>')"
              },
              {
                "title": "text and list in same block (no blank line)",
                "line": 103,
                "source": "const result = parseMarkdown('Properties:\\n- Item 1\\n- Item 2')\nexpect(result).toBe('<p>Properties:</p><ul><li>Item 1</li><li>Item 2</li></ul>')"
              }
            ],
            "describes": []
          },
          {
            "title": "see links",
            "line": 111,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "basic doc link [[Name]]",
                "line": 113,
                "source": "const result = parseMarkdown('See [[PerkyModule]] for more')\nexpect(result).toContain('class=\"doc-see-inline\"')\nexpect(result).toContain('PerkyModule</a>')"
              },
              {
                "title": "doc link with section [[Name#Section]]",
                "line": 120,
                "source": "const result = parseMarkdown('See [[PerkyModule#Lifecycle]]')\nexpect(result).toContain('PerkyModule > Lifecycle</a>')"
              },
              {
                "title": "guide link [[Name:guide]]",
                "line": 126,
                "source": "const result = parseMarkdown('Read [[PerkyModule:guide]]')\nexpect(result).toContain('guide')\nexpect(result).toContain('PerkyModule</a>')"
              },
              {
                "title": "api link [[Name:api]]",
                "line": 133,
                "source": "const result = parseMarkdown('Check [[PerkyModule:api]]')\nexpect(result).toContain('core_perky_module_api.html')"
              },
              {
                "title": "multiple links in same text",
                "line": 139,
                "source": "const result = parseMarkdown('See [[Registry]] and [[Notifier]]')\nexpect(result).toContain('Registry</a>')\nexpect(result).toContain('Notifier</a>')"
              },
              {
                "title": "doc link with category [[Name@category]]",
                "line": 146,
                "source": "const result = parseMarkdown('See [[Application@application]]')\nexpect(result).toContain('application_application.html')\nexpect(result).toContain('Application</a>')"
              },
              {
                "title": "doc link with category and section [[Name@category#Section]]",
                "line": 153,
                "source": "const result = parseMarkdown('See [[Game@game#Lifecycle]]')\nexpect(result).toContain('game_game.html#lifecycle')\nexpect(result).toContain('Game > Lifecycle</a>')"
              }
            ],
            "describes": []
          },
          {
            "title": "custom buildSeeUrl",
            "line": 162,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "uses provided buildSeeUrl function",
                "line": 164,
                "source": "const customBuildUrl = vi.fn(() => '/custom/url')\nconst result = parseMarkdown('See [[Test]]', {buildSeeUrl: customBuildUrl})\n\nexpect(customBuildUrl).toHaveBeenCalledWith({name: 'Test', pageType: 'doc', section: null, category: null})\nexpect(result).toContain('href=\"/custom/url\"')"
              },
              {
                "title": "passes category to buildSeeUrl",
                "line": 173,
                "source": "const customBuildUrl = vi.fn(() => '/custom/url')\nparseMarkdown('See [[Game@game]]', {buildSeeUrl: customBuildUrl})\n\nexpect(customBuildUrl).toHaveBeenCalledWith({name: 'Game', pageType: 'doc', section: null, category: 'game'})"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/doc/test_parser.doc.js": {
    "file": "/doc/test_parser.test.js",
    "describes": [
      {
        "title": "parseTestFile",
        "line": 5,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "parses describe block",
            "line": 7,
            "source": "const source = `\n    describe('MyClass', () => {\n        test('does something', () => {\n            expect(true).toBe(true)\n        })\n    })\n`\n\nconst result = parseTestFile(source, 'test.js')\n\nexpect(result.file).toBe('test.js')\nexpect(result.describes).toHaveLength(1)\nexpect(result.describes[0].title).toBe('MyClass')"
          },
          {
            "title": "parses test cases",
            "line": 24,
            "source": "const source = `\n    describe('Tests', () => {\n        test('first test', () => {\n            const x = 1\n        })\n\n        test('second test', () => {\n            const y = 2\n        })\n    })\n`\n\nconst result = parseTestFile(source)\nconst tests = result.describes[0].tests\n\nexpect(tests).toHaveLength(2)\nexpect(tests[0].title).toBe('first test')\nexpect(tests[1].title).toBe('second test')"
          },
          {
            "title": "parses beforeEach hook",
            "line": 46,
            "source": "const source = `\n    describe('Tests', () => {\n        beforeEach(() => {\n            setup()\n        })\n\n        test('test', () => {})\n    })\n`\n\nconst result = parseTestFile(source)\n\nexpect(result.describes[0].beforeEach).not.toBeNull()\nexpect(result.describes[0].beforeEach.source).toContain('setup()')"
          },
          {
            "title": "parses afterEach hook",
            "line": 64,
            "source": "const source = `\n    describe('Tests', () => {\n        afterEach(() => {\n            cleanup()\n        })\n\n        test('test', () => {})\n    })\n`\n\nconst result = parseTestFile(source)\n\nexpect(result.describes[0].afterEach).not.toBeNull()\nexpect(result.describes[0].afterEach.source).toContain('cleanup()')"
          },
          {
            "title": "parses nested describes",
            "line": 82,
            "source": "const source = `\n    describe('Outer', () => {\n        describe('Inner', () => {\n            test('nested test', () => {})\n        })\n    })\n`\n\nconst result = parseTestFile(source)\n\nexpect(result.describes[0].describes).toHaveLength(1)\nexpect(result.describes[0].describes[0].title).toBe('Inner')"
          },
          {
            "title": "captures line numbers",
            "line": 98,
            "source": "const source = `describe('Test', () => {\n    test('case', () => {})\n})`\n\n        const result = parseTestFile(source)\n\n        expect(result.describes[0].line).toBe(1)\n        expect(result.describes[0].tests[0].line).toBe(2)"
          },
          {
            "title": "extracts test body source",
            "line": 110,
            "source": "const source = `\n    describe('Tests', () => {\n        test('example', () => {\n            const result = add(1, 2)\n            expect(result).toBe(3)\n        })\n    })\n`\n\nconst result = parseTestFile(source)\nconst testSource = result.describes[0].tests[0].source\n\nexpect(testSource).toContain('const result = add(1, 2)')\nexpect(testSource).toContain('expect(result).toBe(3)')"
          },
          {
            "title": "handles identifier as title",
            "line": 128,
            "source": "const source = `\n    describe(ClassName, () => {\n        test('test', () => {})\n    })\n`\n\nconst result = parseTestFile(source)\n\nexpect(result.describes[0].title).toBe('ClassName')"
          },
          {
            "title": "returns empty describes for non-test file",
            "line": 141,
            "source": "const source = `\n    const x = 1\n    export default x\n`\n\nconst result = parseTestFile(source)\n\nexpect(result.describes).toEqual([])"
          }
        ],
        "describes": []
      },
      {
        "title": "getTestsForFile",
        "line": 155,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "returns parsed tests",
            "line": 157,
            "source": "const source = `\n    describe('Test', () => {\n        test('case', () => {})\n    })\n`\n\nconst result = getTestsForFile(source, 'test.js')\n\nexpect(result).not.toBeNull()\nexpect(result.file).toBe('test.js')\nexpect(result.describes).toHaveLength(1)"
          },
          {
            "title": "returns null for empty describes",
            "line": 172,
            "source": "const source = 'const x = 1'\n\nconst result = getTestsForFile(source)\n\nexpect(result).toBeNull()"
          }
        ],
        "describes": []
      }
    ]
  },
  "/doc/renderers/api_renderers.doc.js": {
    "file": "/doc/renderers/api_renderers.test.js",
    "describes": [
      {
        "title": "api_renderers",
        "line": 5,
        "beforeEach": null,
        "afterEach": null,
        "tests": [],
        "describes": [
          {
            "title": "getApiItems",
            "line": 7,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns array for non-single category",
                "line": 9,
                "source": "const api = {methods: [{name: 'foo'}, {name: 'bar'}]}\nconst result = getApiItems(api, {key: 'methods'})\nexpect(result).toEqual([{name: 'foo'}, {name: 'bar'}])"
              },
              {
                "title": "returns empty array if category missing",
                "line": 16,
                "source": "const api = {}\nconst result = getApiItems(api, {key: 'methods'})\nexpect(result).toEqual([])"
              },
              {
                "title": "wraps single item in array for single category",
                "line": 23,
                "source": "const api = {constructor: {name: 'constructor'}}\nconst result = getApiItems(api, {key: 'constructor', single: true})\nexpect(result).toEqual([{name: 'constructor'}])"
              },
              {
                "title": "returns empty array for missing single category",
                "line": 30,
                "source": "const api = {}\nconst result = getApiItems(api, {key: 'init', single: true})\nexpect(result).toEqual([])"
              }
            ],
            "describes": []
          },
          {
            "title": "renderApiMember",
            "line": 39,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates api-member wrapper",
                "line": 41,
                "source": "const el = renderApiMember({name: 'test', source: 'function test() {}'})\nexpect(el.className).toBe('api-member')"
              },
              {
                "title": "displays function signature with params",
                "line": 47,
                "source": "const el = renderApiMember({name: 'greet', params: ['name', 'age'], source: ''})\nconst signature = el.querySelector('.api-member-name')\nexpect(signature.textContent).toBe('greet(name, age)')"
              },
              {
                "title": "displays simple name without params",
                "line": 54,
                "source": "const el = renderApiMember({name: 'count', source: ''})\nconst signature = el.querySelector('.api-member-name')\nexpect(signature.textContent).toBe('count')"
              },
              {
                "title": "displays value for constants",
                "line": 61,
                "source": "const el = renderApiMember({name: 'MAX', value: '100', source: ''})\nconst signature = el.querySelector('.api-member-name')\nexpect(signature.innerHTML).toContain('MAX')\nexpect(signature.innerHTML).toContain('100')"
              },
              {
                "title": "shows line number when file provided",
                "line": 69,
                "source": "const el = renderApiMember({name: 'test', line: 42, source: ''}, 'test.js')\nconst lineEl = el.querySelector('.api-member-line')\nexpect(lineEl.textContent).toBe(':42')"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/doc/renderers/block_renderers.doc.js": {
    "file": "/doc/renderers/block_renderers.test.js",
    "describes": [
      {
        "title": "block_renderers",
        "line": 13,
        "beforeEach": {
          "line": 20,
          "source": "const module = await import('./block_renderers.js')\nrenderText = module.renderText\nrenderDisclaimer = module.renderDisclaimer\nrenderCode = module.renderCode\nrenderSee = module.renderSee"
        },
        "afterEach": null,
        "tests": [],
        "describes": [
          {
            "title": "renderText",
            "line": 29,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates doc-text element",
                "line": 31,
                "source": "const el = renderText({content: 'Hello'})\nexpect(el.className).toBe('doc-text')"
              },
              {
                "title": "sets innerHTML from parsed content",
                "line": 37,
                "source": "const el = renderText({content: 'Hello'})\nexpect(el.innerHTML).toContain('Hello')"
              }
            ],
            "describes": []
          },
          {
            "title": "renderDisclaimer",
            "line": 45,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates doc-disclaimer element",
                "line": 47,
                "source": "const el = renderDisclaimer({content: 'Warning'})\nexpect(el.className).toBe('doc-disclaimer')"
              },
              {
                "title": "sets innerHTML from parsed content",
                "line": 53,
                "source": "const el = renderDisclaimer({content: 'Important note'})\nexpect(el.innerHTML).toContain('Important note')"
              }
            ],
            "describes": []
          },
          {
            "title": "renderCode",
            "line": 61,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates doc-code-block wrapper",
                "line": 63,
                "source": "const el = renderCode({title: 'Test', source: 'code'})\nexpect(el.className).toBe('doc-code-block')"
              },
              {
                "title": "uses extracted source if provided",
                "line": 69,
                "source": "const el = renderCode({title: 'Test', source: 'original'}, 'extracted')\nconst codeEl = el.querySelector('perky-code')\nexpect(codeEl.code).toBe('extracted')"
              }
            ],
            "describes": []
          },
          {
            "title": "renderSee",
            "line": 78,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates doc-see wrapper",
                "line": 80,
                "source": "const el = renderSee({name: 'Logger', pageType: 'doc'})\nexpect(el.className).toBe('doc-see')"
              },
              {
                "title": "creates link with doc-see-link class",
                "line": 86,
                "source": "const el = renderSee({name: 'Logger', pageType: 'doc'})\nconst link = el.querySelector('.doc-see-link')\nexpect(link).toBeTruthy()"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/doc/renderers/test_renderers.doc.js": {
    "file": "/doc/renderers/test_renderers.test.js",
    "describes": [
      {
        "title": "test_renderers",
        "line": 10,
        "beforeEach": null,
        "afterEach": null,
        "tests": [],
        "describes": [
          {
            "title": "createDescribeWrapper",
            "line": 12,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates test-describe class for depth 0",
                "line": 14,
                "source": "const el = createDescribeWrapper({title: 'Suite'}, 'suite', 0)\nexpect(el.className).toBe('test-describe')"
              },
              {
                "title": "creates test-describe-nested class for depth > 0",
                "line": 20,
                "source": "const el = createDescribeWrapper({title: 'Nested'}, 'nested', 1)\nexpect(el.className).toBe('test-describe-nested')"
              },
              {
                "title": "sets id for depth <= 1",
                "line": 26,
                "source": "const el = createDescribeWrapper({title: 'Suite'}, 'my-id', 1)\nexpect(el.id).toBe('my-id')"
              },
              {
                "title": "does not set id for depth > 1",
                "line": 32,
                "source": "const el = createDescribeWrapper({title: 'Deep'}, 'deep-id', 2)\nexpect(el.id).toBe('')"
              }
            ],
            "describes": []
          },
          {
            "title": "addDescribeTocLink",
            "line": 40,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "adds link to tocList",
                "line": 42,
                "source": "const tocList = document.createElement('nav')\naddDescribeTocLink(tocList, 'Test', 'test-id', 0)\nexpect(tocList.children.length).toBe(1)"
              },
              {
                "title": "does nothing if tocList is null",
                "line": 49,
                "source": "addDescribeTocLink(null, 'Test', 'test-id', 0)"
              },
              {
                "title": "does nothing if depth > 1",
                "line": 54,
                "source": "const tocList = document.createElement('nav')\naddDescribeTocLink(tocList, 'Test', 'test-id', 2)\nexpect(tocList.children.length).toBe(0)"
              }
            ],
            "describes": []
          },
          {
            "title": "renderTestHook",
            "line": 63,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates test-hook wrapper",
                "line": 65,
                "source": "const el = renderTestHook('beforeEach', {source: 'setup()'})\nexpect(el.className).toBe('test-hook')"
              },
              {
                "title": "includes hook label",
                "line": 71,
                "source": "const el = renderTestHook('beforeEach', {source: 'setup()'})\nconst label = el.querySelector('.test-hook-label')\nexpect(label.textContent).toBe('beforeEach')"
              }
            ],
            "describes": []
          },
          {
            "title": "renderTest",
            "line": 80,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates test-case wrapper",
                "line": 82,
                "source": "const el = renderTest({title: 'works', source: 'expect(true)'})\nexpect(el.className).toBe('test-case')"
              },
              {
                "title": "includes perky-code element",
                "line": 88,
                "source": "const el = renderTest({title: 'works', source: 'expect(true)'})\nconst codeEl = el.querySelector('perky-code')\nexpect(codeEl).toBeTruthy()"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/doc/utils/dedent.doc.js": {
    "file": "/doc/utils/dedent.test.js",
    "describes": [
      {
        "title": "dedent",
        "line": 5,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "removes common indentation",
            "line": 7,
            "source": "const input = `\n    line 1\n    line 2\n`\nconst result = dedent(input)\nexpect(result).toBe('line 1\\nline 2')"
          },
          {
            "title": "handles mixed indentation",
            "line": 17,
            "source": "const input = `\n    line 1\n        line 2\n    line 3\n`\nconst result = dedent(input)\nexpect(result).toBe('line 1\\n    line 2\\nline 3')"
          },
          {
            "title": "returns empty string for empty input",
            "line": 28,
            "source": "expect(dedent('')).toBe('')\nexpect(dedent('   \\n   ')).toBe('')"
          },
          {
            "title": "handles single line",
            "line": 34,
            "source": "expect(dedent('hello')).toBe('hello')\nexpect(dedent('  hello')).toBe('hello')"
          },
          {
            "title": "preserves relative indentation",
            "line": 40,
            "source": "const input = `\n    function test () {\n        return true\n    }\n`\nconst result = dedent(input)\nexpect(result).toBe('function test () {\\n    return true\\n}')"
          },
          {
            "title": "trimEmptyLines option",
            "line": 51,
            "source": "const input = '\\n\\n  hello\\n\\n'\nexpect(dedent(input, {trimEmptyLines: true})).toBe('hello')\nexpect(dedent(input, {trimEmptyLines: false})).toBe('\\n\\nhello\\n\\n')"
          },
          {
            "title": "preserveFirstLine option",
            "line": 58,
            "source": "const input = 'first line\\n    second line\\n    third line'\nconst result = dedent(input, {preserveFirstLine: true, trimEmptyLines: false})\nexpect(result).toBe('first line\\nsecond line\\nthird line')"
          }
        ],
        "describes": []
      },
      {
        "title": "dedentSource",
        "line": 67,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "preserves first line and dedents rest",
            "line": 69,
            "source": "const input = 'function foo () {\\n        return 1\\n    }'\nconst result = dedentSource(input)\nexpect(result).toBe('function foo () {\\n    return 1\\n}')"
          },
          {
            "title": "handles single line",
            "line": 76,
            "source": "expect(dedentSource('return 1')).toBe('return 1')"
          },
          {
            "title": "handles no indentation",
            "line": 81,
            "source": "const input = 'line 1\\nline 2'\nexpect(dedentSource(input)).toBe('line 1\\nline 2')"
          }
        ],
        "describes": []
      }
    ]
  },
  "/doc/utils/paths.doc.js": {
    "file": "/doc/utils/paths.test.js",
    "describes": [
      {
        "title": "paths",
        "line": 10,
        "beforeEach": {
          "line": 18,
          "source": "const module = await import('./paths.js')\nextractBaseName = module.extractBaseName\nbuildDocUrl = module.buildDocUrl\ndocFileToHtml = module.docFileToHtml\nguideIdToHtml = module.guideIdToHtml\ngetTabUrl = module.getTabUrl"
        },
        "afterEach": null,
        "tests": [],
        "describes": [
          {
            "title": "extractBaseName",
            "line": 28,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "extracts base from doc page",
                "line": 30,
                "source": "expect(extractBaseName('core_logger.html')).toBe('core_logger')"
              },
              {
                "title": "extracts base from api page",
                "line": 35,
                "source": "expect(extractBaseName('core_logger_api.html')).toBe('core_logger')"
              },
              {
                "title": "extracts base from test page",
                "line": 40,
                "source": "expect(extractBaseName('core_logger_test.html')).toBe('core_logger')"
              }
            ],
            "describes": []
          },
          {
            "title": "buildDocUrl",
            "line": 47,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "builds doc url with default category",
                "line": 49,
                "source": "expect(buildDocUrl({name: 'Logger'})).toBe('core_logger.html')"
              },
              {
                "title": "builds api url",
                "line": 54,
                "source": "expect(buildDocUrl({name: 'Logger', pageType: 'api'})).toBe('core_logger_api.html')"
              },
              {
                "title": "builds test url",
                "line": 59,
                "source": "expect(buildDocUrl({name: 'Logger', pageType: 'test'})).toBe('core_logger_test.html')"
              },
              {
                "title": "builds guide url",
                "line": 64,
                "source": "expect(buildDocUrl({name: 'Foreword', pageType: 'guide'})).toBe('guide_foreword.html')"
              },
              {
                "title": "builds url with custom category",
                "line": 69,
                "source": "expect(buildDocUrl({name: 'Application', pageType: 'doc', category: 'application'}))\n.toBe('application_application.html')"
              },
              {
                "title": "builds url with section anchor",
                "line": 75,
                "source": "expect(buildDocUrl({name: 'Logger', pageType: 'doc', section: 'Events'}))\n.toBe('core_logger.html#events')"
              }
            ],
            "describes": []
          },
          {
            "title": "buildDocUrl with registry",
            "line": 83,
            "beforeEach": {
              "line": 85,
              "source": "initRegistry([\n    {title: 'WebGLRenderer', file: '/render/webgl_renderer.doc.js', category: 'render'},\n    {title: 'Object2D', file: '/render/object_2d.doc.js', category: 'render'},\n    {title: 'Vec2', file: '/math/vec2.doc.js', category: 'math'}\n], [\n    {id: 'foreword', title: 'Foreword', file: '/doc/guides/prologue/foreword.guide.js'}\n])"
            },
            "afterEach": null,
            "tests": [
              {
                "title": "uses registry to resolve WebGLRenderer correctly",
                "line": 96,
                "source": "expect(buildDocUrl({name: 'WebGLRenderer'})).toBe('render_webgl_renderer.html')"
              },
              {
                "title": "uses registry to resolve Object2D correctly",
                "line": 101,
                "source": "expect(buildDocUrl({name: 'Object2D'})).toBe('render_object_2d.html')"
              },
              {
                "title": "uses registry to resolve Vec2 correctly",
                "line": 106,
                "source": "expect(buildDocUrl({name: 'Vec2'})).toBe('math_vec2.html')"
              },
              {
                "title": "uses registry for api pages",
                "line": 111,
                "source": "expect(buildDocUrl({name: 'WebGLRenderer', pageType: 'api'})).toBe('render_webgl_renderer_api.html')"
              },
              {
                "title": "uses registry for test pages",
                "line": 116,
                "source": "expect(buildDocUrl({name: 'Object2D', pageType: 'test'})).toBe('render_object_2d_test.html')"
              },
              {
                "title": "uses registry for guides by title",
                "line": 121,
                "source": "expect(buildDocUrl({name: 'Foreword', pageType: 'guide'})).toBe('guide_foreword.html')"
              }
            ],
            "describes": []
          },
          {
            "title": "docFileToHtml",
            "line": 128,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "converts doc file to html",
                "line": 130,
                "source": "expect(docFileToHtml('/core/logger.doc.js')).toBe('core_logger.html')"
              },
              {
                "title": "converts nested doc file",
                "line": 135,
                "source": "expect(docFileToHtml('/input/input_devices/keyboard_device.doc.js'))\n.toBe('input_input_devices_keyboard_device.html')"
              },
              {
                "title": "converts to api html",
                "line": 141,
                "source": "expect(docFileToHtml('/core/logger.doc.js', 'api'))\n.toBe('core_logger_api.html')"
              },
              {
                "title": "converts to test html",
                "line": 147,
                "source": "expect(docFileToHtml('/core/logger.doc.js', 'test'))\n.toBe('core_logger_test.html')"
              }
            ],
            "describes": []
          },
          {
            "title": "guideIdToHtml",
            "line": 155,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "converts guide id to html",
                "line": 157,
                "source": "expect(guideIdToHtml('foreword')).toBe('guide_foreword.html')"
              },
              {
                "title": "converts nested guide id",
                "line": 162,
                "source": "expect(guideIdToHtml('getting_started')).toBe('guide_getting_started.html')"
              }
            ],
            "describes": []
          },
          {
            "title": "getTabUrl",
            "line": 169,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns doc url for doc tab",
                "line": 171,
                "source": "const originalPathname = window.location.pathname\nObject.defineProperty(window, 'location', {\n    value: {pathname: '/doc/core_logger.html'},\n    writable: true\n})\n\nexpect(getTabUrl('doc')).toBe('core_logger.html')\n\nObject.defineProperty(window, 'location', {\n    value: {pathname: originalPathname},\n    writable: true\n})"
              },
              {
                "title": "returns api url for api tab",
                "line": 187,
                "source": "Object.defineProperty(window, 'location', {\n    value: {pathname: '/doc/core_logger.html'},\n    writable: true\n})\n\nexpect(getTabUrl('api')).toBe('core_logger_api.html')"
              },
              {
                "title": "returns test url for test tab",
                "line": 197,
                "source": "Object.defineProperty(window, 'location', {\n    value: {pathname: '/doc/core_logger_api.html'},\n    writable: true\n})\n\nexpect(getTabUrl('test')).toBe('core_logger_test.html')"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/collision/collision_detector.doc.js": {
    "file": "/collision/collision_detector.test.js",
    "describes": [
      {
        "title": "collision_detector",
        "line": 10,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "circle vs box normal is flipped when circle is first shape",
            "line": 314,
            "source": "const circle = createCircleShape(12, 0, 3)\nconst box = createBoxShape(0, 0, 20, 20)\n\nconst circleVsBox = detectCollision(circle, box)\nconst boxVsCircle = detectCollision(box, circle)\n\nexpect(circleVsBox).not.toBeNull()\nexpect(boxVsCircle).not.toBeNull()\n\nexpect(circleVsBox.normal.x).toBe(-boxVsCircle.normal.x)\nexpect(circleVsBox.normal.y).toBe(-boxVsCircle.normal.y)"
          }
        ],
        "describes": [
          {
            "title": "type checking functions",
            "line": 47,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "isBoxVsBox",
                "line": 49,
                "source": "const box1 = createBoxShape(0, 0, 20, 20)\nconst box2 = createBoxShape(10, 10, 30, 30)\nconst circle = createCircleShape(0, 0, 10)\n\nexpect(isBoxVsBox(box1, box2)).toBe(true)\nexpect(isBoxVsBox(box1, circle)).toBe(false)\nexpect(isBoxVsBox(circle, box1)).toBe(false)\nexpect(isBoxVsBox(circle, circle)).toBe(false)"
              },
              {
                "title": "isCircleVsCircle",
                "line": 61,
                "source": "const circle1 = createCircleShape(0, 0, 10)\nconst circle2 = createCircleShape(15, 15, 5)\nconst box = createBoxShape(0, 0, 20, 20)\n\nexpect(isCircleVsCircle(circle1, circle2)).toBe(true)\nexpect(isCircleVsCircle(circle1, box)).toBe(false)\nexpect(isCircleVsCircle(box, circle1)).toBe(false)\nexpect(isCircleVsCircle(box, box)).toBe(false)"
              },
              {
                "title": "isBoxVsCircle",
                "line": 73,
                "source": "const box = createBoxShape(0, 0, 20, 20)\nconst circle = createCircleShape(15, 15, 5)\n\nexpect(isBoxVsCircle(box, circle)).toBe(true)\nexpect(isBoxVsCircle(circle, box)).toBe(false)\nexpect(isBoxVsCircle(box, box)).toBe(false)\nexpect(isBoxVsCircle(circle, circle)).toBe(false)"
              },
              {
                "title": "isCircleVsBox",
                "line": 84,
                "source": "const circle = createCircleShape(15, 15, 5)\nconst box = createBoxShape(0, 0, 20, 20)\n\nexpect(isCircleVsBox(circle, box)).toBe(true)\nexpect(isCircleVsBox(box, circle)).toBe(false)\nexpect(isCircleVsBox(circle, circle)).toBe(false)\nexpect(isCircleVsBox(box, box)).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "detectCollision",
            "line": 97,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "box vs box collision",
                "line": 99,
                "source": "const box1 = createBoxShape(0, 0, 20, 20)\nconst box2 = createBoxShape(5, 0, 20, 20)\n\nconst collision = detectCollision(box1, box2)\n\nexpect(collision).not.toBeNull()\nexpect(collision.depth).toBeGreaterThan(0)\nexpect(collision.normal).toBeDefined()\nexpect(collision.contactPoint).toBeDefined()"
              },
              {
                "title": "box vs box no collision",
                "line": 112,
                "source": "const box1 = createBoxShape(0, 0, 20, 20)\nconst box2 = createBoxShape(50, 50, 20, 20)\n\nconst collision = detectCollision(box1, box2)\n\nexpect(collision).toBeNull()"
              },
              {
                "title": "circle vs circle collision",
                "line": 122,
                "source": "const circle1 = createCircleShape(0, 0, 10)\nconst circle2 = createCircleShape(15, 0, 10)\n\nconst collision = detectCollision(circle1, circle2)\n\nexpect(collision).not.toBeNull()\nexpect(collision.depth).toBeGreaterThan(0)\nexpect(collision.normal).toBeDefined()\nexpect(collision.contactPoint).toBeDefined()"
              },
              {
                "title": "circle vs circle no collision",
                "line": 135,
                "source": "const circle1 = createCircleShape(0, 0, 10)\nconst circle2 = createCircleShape(50, 0, 10)\n\nconst collision = detectCollision(circle1, circle2)\n\nexpect(collision).toBeNull()"
              },
              {
                "title": "box vs circle collision",
                "line": 145,
                "source": "const box = createBoxShape(0, 0, 20, 20)\nconst circle = createCircleShape(15, 0, 10)\n\nconst collision = detectCollision(box, circle)\n\nexpect(collision).not.toBeNull()\nexpect(collision.depth).toBeGreaterThan(0)\nexpect(collision.normal).toBeDefined()\nexpect(collision.contactPoint).toBeDefined()"
              },
              {
                "title": "circle vs box collision with flipped normal",
                "line": 158,
                "source": "const circle = createCircleShape(15, 0, 10)\nconst box = createBoxShape(0, 0, 20, 20)\n\nconst collision = detectCollision(circle, box)\n\nexpect(collision).not.toBeNull()\nexpect(collision.depth).toBeGreaterThan(0)\nexpect(collision.normal).toBeDefined()\nexpect(collision.contactPoint).toBeDefined()"
              },
              {
                "title": "unsupported shape types",
                "line": 171,
                "source": "const unknownShape = {type: 'triangle', x: 0, y: 0}\nconst box = createBoxShape(0, 0, 20, 20)\n\nconst collision = detectCollision(unknownShape, box)\n\nexpect(collision).toBeNull()"
              }
            ],
            "describes": []
          },
          {
            "title": "box vs box collision details",
            "line": 183,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "horizontal overlap smaller than vertical",
                "line": 185,
                "source": "const box1 = createBoxShape(0, 0, 20, 40)\nconst box2 = createBoxShape(15, 0, 20, 40)\n\nconst collision = detectCollision(box1, box2)\n\nexpect(collision).not.toBeNull()\nexpect(collision.normal.x).not.toBe(0)\nexpect(collision.normal.y).toBe(0)\nexpect(collision.depth).toBe(5) // 20/2 + 20/2 - 15 = 5"
              },
              {
                "title": "vertical overlap smaller than horizontal",
                "line": 198,
                "source": "const box1 = createBoxShape(0, 0, 40, 20)\nconst box2 = createBoxShape(0, 15, 40, 20)\n\nconst collision = detectCollision(box1, box2)\n\nexpect(collision).not.toBeNull()\nexpect(collision.normal.x).toBe(0)\nexpect(collision.normal.y).not.toBe(0)\nexpect(collision.depth).toBe(5) // 20/2 + 20/2 - 15 = 5"
              },
              {
                "title": "collision normal direction",
                "line": 211,
                "source": "const box1 = createBoxShape(0, 0, 20, 20)\nconst box2 = createBoxShape(15, 0, 20, 20)\n\nconst collision = detectCollision(box1, box2)\n\nexpect(collision.normal.x).toBe(-1)"
              }
            ],
            "describes": []
          },
          {
            "title": "circle vs circle collision details",
            "line": 223,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "collision depth calculation",
                "line": 225,
                "source": "const circle1 = createCircleShape(0, 0, 10)\nconst circle2 = createCircleShape(15, 0, 10)\n\nconst collision = detectCollision(circle1, circle2)\n\nexpect(collision).not.toBeNull()\nexpect(collision.depth).toBe(5) // (10 + 10) - 15 = 5"
              },
              {
                "title": "collision normal direction",
                "line": 236,
                "source": "const circle1 = createCircleShape(0, 0, 10)\nconst circle2 = createCircleShape(15, 0, 10)\n\nconst collision = detectCollision(circle1, circle2)\n\nexpect(collision.normal.x).toBe(1)\nexpect(collision.normal.y).toBe(0)"
              },
              {
                "title": "touching circles",
                "line": 247,
                "source": "const circle1 = createCircleShape(0, 0, 10)\nconst circle2 = createCircleShape(20, 0, 10)\n\nconst collision = detectCollision(circle1, circle2)\n\nexpect(collision).toBeNull()"
              },
              {
                "title": "identical circles",
                "line": 257,
                "source": "const circle1 = createCircleShape(0, 0, 10)\nconst circle2 = createCircleShape(0, 0, 10)\n\nconst collision = detectCollision(circle1, circle2)\n\nexpect(collision).toBeNull()"
              }
            ],
            "describes": []
          },
          {
            "title": "box vs circle collision details",
            "line": 268,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "circle touching box side",
                "line": 270,
                "source": "const box = createBoxShape(0, 0, 20, 20)\nconst circle = createCircleShape(12, 0, 3)\n\nconst collision = detectCollision(box, circle)\n\nexpect(collision).not.toBeNull()\nexpect(collision.normal.x).toBe(1)\nexpect(collision.normal.y).toBe(0)"
              },
              {
                "title": "circle touching box corner",
                "line": 281,
                "source": "const box = createBoxShape(0, 0, 20, 20)\nconst circle = createCircleShape(12, 12, 4)\n\nconst collision = detectCollision(box, circle)\n\nexpect(collision).not.toBeNull()\nexpect(collision.normal.x).toBeGreaterThan(0)\nexpect(collision.normal.y).toBeGreaterThan(0)"
              },
              {
                "title": "circle completely inside box",
                "line": 292,
                "source": "const box = createBoxShape(0, 0, 100, 100)\nconst circle = createCircleShape(0, 0, 10)\n\nconst collision = detectCollision(box, circle)\n\nexpect(collision).not.toBeNull()\n\nexpect(Math.abs(collision.depth)).toBeGreaterThan(0)"
              },
              {
                "title": "circle far from box",
                "line": 303,
                "source": "const box = createBoxShape(0, 0, 20, 20)\nconst circle = createCircleShape(100, 100, 10)\n\nconst collision = detectCollision(box, circle)\n\nexpect(collision).toBeNull()"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/collision/collision_resolver.doc.js": {
    "file": "/collision/collision_resolver.test.js",
    "describes": [
      {
        "title": "CollisionResolver",
        "line": 4,
        "beforeEach": {
          "line": 7,
          "source": "resolver = new CollisionResolver()"
        },
        "afterEach": null,
        "tests": [],
        "describes": [
          {
            "title": "constructor",
            "line": 11,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "default options",
                "line": 13,
                "source": "expect(resolver.options.separationFactor).toBe(0.5)\nexpect(resolver.options.restitution).toBe(0.2)\nexpect(resolver.options.friction).toBe(0.8)"
              },
              {
                "title": "custom options",
                "line": 19,
                "source": "const customResolver = new CollisionResolver({\n    separationFactor: 0.8,\n    restitution: 0.9,\n    friction: 0.3\n})\n\nexpect(customResolver.options.separationFactor).toBe(0.8)\nexpect(customResolver.options.restitution).toBe(0.9)\nexpect(customResolver.options.friction).toBe(0.3)"
              },
              {
                "title": "partial options override",
                "line": 31,
                "source": "const customResolver = new CollisionResolver({\n    restitution: 0.5\n})\n\nexpect(customResolver.options.separationFactor).toBe(0.5)\nexpect(customResolver.options.restitution).toBe(0.5)\nexpect(customResolver.options.friction).toBe(0.8)"
              }
            ],
            "describes": []
          },
          {
            "title": "separateBodies",
            "line": 42,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "separate two dynamic bodies equally",
                "line": 44,
                "source": "const bodyA = {\n    position: {x: 0, y: 0},\n    userData: {mass: 1}\n}\nconst bodyB = {\n    position: {x: 0, y: 0},\n    userData: {mass: 1}\n}\nconst collision = {\n    normal: {x: 1, y: 0},\n    depth: 10\n}\n\nresolver.separateBodies(bodyA, bodyB, collision)\n\nexpect(bodyA.position.x).toBe(-2.5)\nexpect(bodyA.position.y).toBe(0)\nexpect(bodyB.position.x).toBe(2.5)\nexpect(bodyB.position.y).toBe(0)"
              },
              {
                "title": "separate bodies with different masses",
                "line": 66,
                "source": "const bodyA = {\n    position: {x: 0, y: 0},\n    userData: {mass: 1}\n}\nconst bodyB = {\n    position: {x: 0, y: 0},\n    userData: {mass: 3}\n}\nconst collision = {\n    normal: {x: 1, y: 0},\n    depth: 8\n}\n\nresolver.separateBodies(bodyA, bodyB, collision)\n\nexpect(bodyA.position.x).toBe(-3) // -1 * 4 * 3/4\nexpect(bodyB.position.x).toBe(1)  // 1 * 4 * 1/4"
              },
              {
                "title": "do not move static bodies",
                "line": 86,
                "source": "const bodyA = {\n    position: {x: 0, y: 0},\n    userData: {mass: 1, isStatic: true}\n}\nconst bodyB = {\n    position: {x: 0, y: 0},\n    userData: {mass: 1}\n}\nconst collision = {\n    normal: {x: 1, y: 0},\n    depth: 10\n}\n\nresolver.separateBodies(bodyA, bodyB, collision)\n\nexpect(bodyA.position.x).toBe(0)\nexpect(bodyA.position.y).toBe(0)\nexpect(bodyB.position.x).toBe(2.5) // ratioB = 1/2, separationDistance = 5\nexpect(bodyB.position.y).toBe(0)"
              },
              {
                "title": "bodies without mass use default mass of 1",
                "line": 108,
                "source": "const bodyA = {position: {x: 0, y: 0}}\nconst bodyB = {position: {x: 0, y: 0}}\nconst collision = {\n    normal: {x: 0, y: 1},\n    depth: 6\n}\n\nresolver.separateBodies(bodyA, bodyB, collision)\n\nexpect(bodyA.position.y).toBe(-1.5)\nexpect(bodyB.position.y).toBe(1.5)"
              }
            ],
            "describes": []
          },
          {
            "title": "resolveVelocity",
            "line": 123,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "resolve velocity for colliding bodies",
                "line": 125,
                "source": "const bodyA = {\n    position: {x: 0, y: 0},\n    velocity: {x: 10, y: 0},\n    userData: {mass: 1}\n}\nconst bodyB = {\n    position: {x: 0, y: 0},\n    velocity: {x: -10, y: 0},\n    userData: {mass: 1}\n}\nconst collision = {\n    normal: {x: 1, y: 0}\n}\n\nresolver.resolveVelocity(bodyA, bodyB, collision)\n\nexpect(bodyA.velocity.x).toBeLessThan(10)\nexpect(bodyB.velocity.x).toBeGreaterThan(-10)"
              },
              {
                "title": "do not resolve if bodies are separating",
                "line": 146,
                "source": "const bodyA = {\n    position: {x: 0, y: 0},\n    velocity: {x: -10, y: 0},\n    userData: {mass: 1}\n}\nconst bodyB = {\n    position: {x: 0, y: 0},\n    velocity: {x: 10, y: 0},\n    userData: {mass: 1}\n}\nconst collision = {\n    normal: {x: 1, y: 0}\n}\n\nresolver.resolveVelocity(bodyA, bodyB, collision)\n\nexpect(bodyA.velocity.x).toBe(-10)\nexpect(bodyB.velocity.x).toBe(10)"
              },
              {
                "title": "use custom restitution from body properties",
                "line": 167,
                "source": "const bodyA = {\n    position: {x: 0, y: 0},\n    velocity: {x: 10, y: 0},\n    userData: {mass: 1, restitution: 1.0}\n}\nconst bodyB = {\n    position: {x: 0, y: 0},\n    velocity: {x: 0, y: 0},\n    userData: {mass: 1, restitution: 1.0}\n}\nconst collision = {\n    normal: {x: 1, y: 0}\n}\n\nresolver.resolveVelocity(bodyA, bodyB, collision)\n\nexpect(bodyA.velocity.x).toBeCloseTo(0)\nexpect(bodyB.velocity.x).toBeCloseTo(10)"
              },
              {
                "title": "do not affect static bodies",
                "line": 188,
                "source": "const bodyA = {\n    position: {x: 0, y: 0},\n    velocity: {x: 10, y: 0},\n    userData: {mass: 1}\n}\nconst bodyB = {\n    position: {x: 0, y: 0},\n    velocity: {x: 0, y: 0},\n    userData: {mass: 1, isStatic: true}\n}\nconst collision = {\n    normal: {x: 1, y: 0}\n}\n\nresolver.resolveVelocity(bodyA, bodyB, collision)\n\nexpect(bodyB.velocity.x).toBe(0)\nexpect(bodyB.velocity.y).toBe(0)"
              }
            ],
            "describes": []
          },
          {
            "title": "applyFriction",
            "line": 210,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "apply friction to tangential velocity",
                "line": 212,
                "source": "const bodyA = {\n    position: {x: 0, y: 0},\n    velocity: {x: 0, y: 10},\n    userData: {mass: 1, friction: 0.5}\n}\nconst bodyB = {\n    position: {x: 0, y: 0},\n    velocity: {x: 0, y: 0},\n    userData: {mass: 1, friction: 0.5}\n}\nconst collision = {\n    normal: {x: 1, y: 0}\n}\nconst impulse = {x: 10, y: 0}\n\nresolver.applyFriction(bodyA, bodyB, collision, impulse)\n\nexpect(Math.abs(bodyA.velocity.y)).toBeLessThan(10)\nexpect(Math.abs(bodyB.velocity.y)).toBeGreaterThan(0)"
              },
              {
                "title": "no friction when no tangential velocity",
                "line": 234,
                "source": "const bodyA = {\n    position: {x: 0, y: 0},\n    velocity: {x: 10, y: 0},\n    userData: {mass: 1}\n}\nconst bodyB = {\n    position: {x: 0, y: 0},\n    velocity: {x: 5, y: 0},\n    userData: {mass: 1}\n}\nconst collision = {\n    normal: {x: 1, y: 0}\n}\nconst impulse = {x: 5, y: 0}\n\nconst initialVelA = {...bodyA.velocity}\nconst initialVelB = {...bodyB.velocity}\n\nresolver.applyFriction(bodyA, bodyB, collision, impulse)\n\nexpect(bodyA.velocity.x).toBe(initialVelA.x)\nexpect(bodyA.velocity.y).toBe(initialVelA.y)\nexpect(bodyB.velocity.x).toBe(initialVelB.x)\nexpect(bodyB.velocity.y).toBe(initialVelB.y)"
              }
            ],
            "describes": []
          },
          {
            "title": "resolve",
            "line": 262,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "calls separateBodies and resolveVelocity for bodies with physics",
                "line": 264,
                "source": "const bodyA = {\n    position: {x: 0, y: 0},\n    velocity: {x: 10, y: 0},\n    userData: {mass: 1}\n}\nconst bodyB = {\n    position: {x: 5, y: 0},\n    velocity: {x: -10, y: 0},\n    userData: {mass: 1}\n}\nconst collision = {\n    normal: {x: 1, y: 0},\n    depth: 2\n}\n\nconst initialPosA = {...bodyA.position}\nconst initialVelA = {...bodyA.velocity}\n\nresolver.resolve(bodyA, bodyB, collision)\n\nexpect(bodyA.position.x).not.toBe(initialPosA.x)\n\nexpect(bodyA.velocity.x).not.toBe(initialVelA.x)"
              },
              {
                "title": "only separates bodies without velocity properties",
                "line": 290,
                "source": "const bodyA = {\n    position: {x: 0, y: 0},\n    userData: {mass: 1}\n}\nconst bodyB = {\n    position: {x: 5, y: 0},\n    userData: {mass: 1}\n}\nconst collision = {\n    normal: {x: 1, y: 0},\n    depth: 2\n}\n\nconst initialPosA = {...bodyA.position}\n\nresolver.resolve(bodyA, bodyB, collision)\n\nexpect(bodyA.position.x).not.toBe(initialPosA.x)"
              }
            ],
            "describes": []
          },
          {
            "title": "edge cases",
            "line": 312,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "handles bodies with userData.velocity",
                "line": 314,
                "source": "const bodyA = {\n    position: {x: 0, y: 0},\n    userData: {\n        mass: 1,\n        velocity: {x: 10, y: 0}\n    }\n}\nconst bodyB = {\n    position: {x: 0, y: 0},\n    userData: {\n        mass: 1,\n        velocity: {x: -5, y: 0}\n    }\n}\nconst collision = {\n    normal: {x: 1, y: 0},\n    depth: 2\n}\n\nconst initialVel = bodyA.userData.velocity.x\n\nresolver.resolve(bodyA, bodyB, collision)\n\nexpect(bodyA.userData.velocity.x).not.toBe(initialVel)"
              },
              {
                "title": "handles mixed velocity storage",
                "line": 341,
                "source": "const bodyA = {\n    position: {x: 0, y: 0},\n    velocity: {x: 10, y: 0},\n    userData: {mass: 1}\n}\nconst bodyB = {\n    position: {x: 0, y: 0},\n    userData: {\n        mass: 1,\n        velocity: {x: -5, y: 0}\n    }\n}\nconst collision = {\n    normal: {x: 1, y: 0},\n    depth: 2\n}\n\nresolver.resolve(bodyA, bodyB, collision)\n\nexpect(typeof bodyA.velocity.x).toBe('number')\nexpect(typeof bodyB.userData.velocity.x).toBe('number')"
              },
              {
                "title": "handles zero-length tangent vector in friction",
                "line": 365,
                "source": "const bodyA = {\n    position: {x: 0, y: 0},\n    velocity: {x: 10, y: 0},\n    userData: {mass: 1}\n}\nconst bodyB = {\n    position: {x: 0, y: 0},\n    velocity: {x: 5, y: 0},\n    userData: {mass: 1}\n}\nconst collision = {\n    normal: {x: 1, y: 0}\n}\nconst impulse = {x: 0, y: 0}\n\nconst applyFrictionCall = () => resolver.applyFriction(bodyA, bodyB, collision, impulse)\n\nexpect(applyFrictionCall).not.toThrow()"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/collision/collision_system.doc.js": {
    "file": "/collision/collision_system.test.js",
    "describes": [
      {
        "title": "CollisionSystem",
        "line": 7,
        "beforeEach": {
          "line": 11,
          "source": "collisionSystem = new CollisionSystem()"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor default options",
            "line": 16,
            "source": "expect(collisionSystem.gravity).toEqual({x: 0, y: -800})\nexpect(collisionSystem.bounds).toBeNull()\nexpect(collisionSystem.spatialGrid).toBeNull()\nexpect(collisionSystem.gridSize).toBe(64)\nexpect(collisionSystem.collisionBodies).toEqual([])\nexpect(collisionSystem.staticBodies).toEqual([])\nexpect(collisionSystem.debugEnabled).toBe(false)"
          },
          {
            "title": "constructor custom options",
            "line": 27,
            "source": "const customSystem = new CollisionSystem({\n    gravity: {x: 100, y: -500},\n    bounds: {x: 0, y: 0, width: 800, height: 600},\n    spatialGrid: true,\n    gridSize: 32\n})\n\nexpect(customSystem.gravity).toEqual({x: 100, y: -500})\nexpect(customSystem.bounds).toEqual({x: 0, y: 0, width: 800, height: 600})\nexpect(customSystem.spatialGrid).toBe(true)\nexpect(customSystem.gridSize).toBe(32)"
          },
          {
            "title": "constructor spatial grid setup",
            "line": 42,
            "source": "const systemWithGrid = new CollisionSystem({\n    bounds: {x: 0, y: 0, width: 128, height: 64},\n    spatialGrid: true,\n    gridSize: 32\n})\n\nexpect(systemWithGrid.gridCols).toBe(4) // 128 / 32\nexpect(systemWithGrid.gridRows).toBe(2) // 64 / 32\nexpect(systemWithGrid.grid).toBeDefined()"
          },
          {
            "title": "addBody circle object",
            "line": 55,
            "source": "const circle = {\n    constructor: {name: 'Circle'},\n    userData: {radius: 20}\n}\n\nconst result = collisionSystem.addBody(circle, {\n    velocity: {x: 10, y: 5},\n    mass: 2\n})\n\nexpect(result).toBe(circle)\nexpect(circle.collisionShape).toBeInstanceOf(CircleShape)\nexpect(circle.collisionShape.radius).toBe(20)\nexpect(circle.velocity).toEqual({x: 10, y: 5})\nexpect(circle.mass).toBe(2)\nexpect(circle.isStatic).toBe(false)\nexpect(collisionSystem.collisionBodies).toContain(circle)"
          },
          {
            "title": "addBody rectangle object",
            "line": 76,
            "source": "const rectangle = {\n    constructor: {name: 'Rectangle'},\n    userData: {width: 40, height: 60}\n}\n\ncollisionSystem.addBody(rectangle)\n\nexpect(rectangle.collisionShape).toBeInstanceOf(BoxShape)\nexpect(rectangle.collisionShape.width).toBe(40)\nexpect(rectangle.collisionShape.height).toBe(60)\nexpect(rectangle.velocity).toEqual({x: 0, y: 0})\nexpect(rectangle.restitution).toBe(0.5)"
          },
          {
            "title": "addBody unknown object type uses default box",
            "line": 92,
            "source": "const unknown = {\n    constructor: {name: 'Unknown'},\n    userData: {}\n}\n\ncollisionSystem.addBody(unknown)\n\nexpect(unknown.collisionShape).toBeInstanceOf(BoxShape)\nexpect(unknown.collisionShape.width).toBe(32)\nexpect(unknown.collisionShape.height).toBe(32)"
          },
          {
            "title": "addBody static body",
            "line": 106,
            "source": "const staticBody = {\n    constructor: {name: 'Rectangle'},\n    userData: {width: 100, height: 20}\n}\n\ncollisionSystem.addBody(staticBody, {isStatic: true})\n\nexpect(staticBody.isStatic).toBe(true)\nexpect(collisionSystem.staticBodies).toContain(staticBody)\nexpect(collisionSystem.collisionBodies).not.toContain(staticBody)"
          },
          {
            "title": "removeBody dynamic body",
            "line": 120,
            "source": "const body = {\n    constructor: {name: 'Circle'},\n    userData: {radius: 10}\n}\n\ncollisionSystem.addBody(body)\nexpect(collisionSystem.collisionBodies).toContain(body)\n\ncollisionSystem.removeBody(body)\nexpect(collisionSystem.collisionBodies).not.toContain(body)"
          },
          {
            "title": "removeBody static body",
            "line": 134,
            "source": "const body = {\n    constructor: {name: 'Rectangle'},\n    userData: {width: 20, height: 20}\n}\n\ncollisionSystem.addBody(body, {isStatic: true})\nexpect(collisionSystem.staticBodies).toContain(body)\n\ncollisionSystem.removeBody(body)\nexpect(collisionSystem.staticBodies).not.toContain(body)"
          },
          {
            "title": "removeBody non-existent body",
            "line": 148,
            "source": "const body = {\n    constructor: {name: 'Circle'},\n    userData: {radius: 10}\n}\n\nexpect(() => collisionSystem.removeBody(body)).not.toThrow()"
          },
          {
            "title": "applyGravity",
            "line": 158,
            "source": "const body = {\n    constructor: {name: 'Circle'},\n    userData: {radius: 10},\n    position: {x: 0, y: 0}\n}\n\ncollisionSystem.addBody(body, {velocity: {x: 0, y: 0}})\ncollisionSystem.applyGravity(0.1)\n\nexpect(body.velocity.y).toBe(-80) // -800 * 0.1\nexpect(body.velocity.x).toBe(0)"
          },
          {
            "title": "gravity does not affect static bodies",
            "line": 173,
            "source": "const staticBody = {\n    constructor: {name: 'Rectangle'},\n    userData: {width: 20, height: 20},\n    position: {x: 0, y: 0}\n}\n\ncollisionSystem.addBody(staticBody, {\n    velocity: {x: 0, y: 0},\n    isStatic: true\n})\n\ncollisionSystem.applyGravity(0.1)\n\nexpect(staticBody.velocity.y).toBe(0)"
          },
          {
            "title": "updatePositions",
            "line": 191,
            "source": "const body = {\n    constructor: {name: 'Circle'},\n    userData: {radius: 10},\n    position: {x: 0, y: 0}\n}\n\ncollisionSystem.addBody(body, {velocity: {x: 50, y: 100}})\ncollisionSystem.updatePositions(0.1)\n\nexpect(body.position.x).toBe(5)  // 50 * 0.1\nexpect(body.position.y).toBe(10) // 100 * 0.1"
          },
          {
            "title": "static bodies do not move",
            "line": 206,
            "source": "const staticBody = {\n    constructor: {name: 'Rectangle'},\n    userData: {width: 20, height: 20},\n    position: {x: 100, y: 200}\n}\n\ncollisionSystem.addBody(staticBody, {\n    velocity: {x: 50, y: 100},\n    isStatic: true\n})\n\ncollisionSystem.updatePositions(0.1)\n\nexpect(staticBody.position.x).toBe(100)\nexpect(staticBody.position.y).toBe(200)"
          },
          {
            "title": "debug is disabled by default",
            "line": 225,
            "source": "expect(collisionSystem.debugEnabled).toBe(false)"
          },
          {
            "title": "enableDebug and disableDebug",
            "line": 230,
            "source": "collisionSystem.enableDebug()\nexpect(collisionSystem.debugEnabled).toBe(true)\n\ncollisionSystem.disableDebug()\nexpect(collisionSystem.debugEnabled).toBe(false)"
          },
          {
            "title": "debug method with disabled debug",
            "line": 239,
            "source": "const mockCtx = {\n    save: vi.fn(),\n    restore: vi.fn()\n}\n\nexpect(() => collisionSystem.debug(mockCtx)).not.toThrow()\nexpect(mockCtx.save).not.toHaveBeenCalled()"
          },
          {
            "title": "queryPoint",
            "line": 250,
            "source": "const body = {\n    constructor: {name: 'Circle'},\n    userData: {radius: 20},\n    position: {x: 0, y: 0}\n}\n\ncollisionSystem.addBody(body)\ncollisionSystem.updateShapes()\n\nconst results = collisionSystem.queryPoint(10, 10)\nexpect(results).toContain(body)\n\nconst noResults = collisionSystem.queryPoint(100, 100)\nexpect(noResults).not.toContain(body)"
          },
          {
            "title": "queryAABB",
            "line": 268,
            "source": "const body = {\n    constructor: {name: 'Rectangle'},\n    userData: {width: 40, height: 40},\n    position: {x: 0, y: 0}\n}\n\ncollisionSystem.addBody(body)\ncollisionSystem.updateShapes()\n\nconst bounds = {x: -10, y: -10, width: 20, height: 20}\nconst results = collisionSystem.queryAABB(bounds)\nexpect(results).toContain(body)"
          },
          {
            "title": "setGravity",
            "line": 284,
            "source": "collisionSystem.setGravity(100, -500)\n\nexpect(collisionSystem.gravity.x).toBe(100)\nexpect(collisionSystem.gravity.y).toBe(-500)"
          },
          {
            "title": "checkCollisionPair with dynamic bodies",
            "line": 292,
            "source": "const bodyA = {\n    constructor: {name: 'Circle'},\n    userData: {radius: 10},\n    position: {x: 0, y: 0},\n    isStatic: false\n}\nconst bodyB = {\n    constructor: {name: 'Circle'},\n    userData: {radius: 10},\n    position: {x: 15, y: 0},\n    isStatic: false\n}\n\ncollisionSystem.addBody(bodyA)\ncollisionSystem.addBody(bodyB)\ncollisionSystem.updateShapes()\n\nexpect(() => {\n    collisionSystem.checkCollisionPair(bodyA, bodyB)\n}).not.toThrow()"
          },
          {
            "title": "checkCollisionPair with static bodies does nothing",
            "line": 316,
            "source": "const bodyA = {\n    constructor: {name: 'Rectangle'},\n    userData: {width: 20, height: 20},\n    position: {x: 0, y: 0},\n    isStatic: true\n}\nconst bodyB = {\n    constructor: {name: 'Rectangle'},\n    userData: {width: 20, height: 20},\n    position: {x: 10, y: 0},\n    isStatic: true\n}\n\ncollisionSystem.addBody(bodyA, {isStatic: true})\ncollisionSystem.addBody(bodyB, {isStatic: true})\n\nexpect(() => {\n    collisionSystem.checkCollisionPair(bodyA, bodyB)\n}).not.toThrow()"
          },
          {
            "title": "queryRadius finds bodies within radius",
            "line": 339,
            "source": "const bodyA = createTestBody({x: 0, y: 0})\nconst bodyB = createTestBody({x: 50, y: 0})\nconst bodyC = createTestBody({x: 150, y: 0})\n\ncollisionSystem.addBody(bodyA)\ncollisionSystem.addBody(bodyB)\ncollisionSystem.addBody(bodyC)\n\nconst results = collisionSystem.queryRadius(0, 0, 75)\n\nexpect(results).toContain(bodyA)\nexpect(results).toContain(bodyB)\nexpect(results).not.toContain(bodyC)"
          },
          {
            "title": "pauseBody and resumeBody",
            "line": 356,
            "source": "const body = createTestBody({x: 0, y: 0})\ncollisionSystem.addBody(body, {velocity: {x: 100, y: 50}})\n\ncollisionSystem.pauseBody(body)\n\nexpect(body.paused).toBe(true)\nexpect(body.velocity.x).toBe(0)\nexpect(body.velocity.y).toBe(0)\nexpect(body.pausedVelocity).toEqual({x: 100, y: 50})\n\ncollisionSystem.resumeBody(body)\n\nexpect(body.paused).toBe(false)\nexpect(body.velocity.x).toBe(100)\nexpect(body.velocity.y).toBe(50)"
          },
          {
            "title": "collision callback is called on collision",
            "line": 375,
            "source": "const callback = vi.fn()\ncollisionSystem.setCollisionCallback(callback)\n\nconst bodyA = createTestBody({x: 0, y: 0})\nconst bodyB = createTestBody({x: 10, y: 0})\n\ncollisionSystem.addBody(bodyA, {velocity: {x: 1, y: 0}})\ncollisionSystem.addBody(bodyB, {velocity: {x: -1, y: 0}})\n\ncollisionSystem.detectCollisions()\n\nexpect(callback).toHaveBeenCalled()\nexpect(callback).toHaveBeenCalledWith(\n    expect.objectContaining({collisionShape: expect.any(Object)}),\n    expect.objectContaining({collisionShape: expect.any(Object)}),\n    expect.any(Object)\n)"
          },
          {
            "title": "enableDebugDraw sets debug properties",
            "line": 396,
            "source": "const mockScene = {}\n\nconst result = collisionSystem.enableDebugDraw(mockScene)\n\nexpect(collisionSystem.debugScene).toBe(mockScene)\nexpect(collisionSystem.debugEnabled).toBe(true)\nexpect(result).toBe(collisionSystem)"
          }
        ],
        "describes": [
          {
            "title": "Spatial Grid",
            "line": 407,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "setupSpatialGrid without bounds logs warning",
                "line": 409,
                "source": "const warnSpy = vi.spyOn(console, 'warn').mockImplementation(() => {})\nconst system = new CollisionSystem({spatialGrid: false})\n\nsystem.setupSpatialGrid()\n\nexpect(warnSpy).toHaveBeenCalled()\nexpect(system.grid).toBeUndefined()\nwarnSpy.mockRestore()"
              },
              {
                "title": "setupSpatialGrid creates grid based on bounds and gridSize",
                "line": 421,
                "source": "const system = new CollisionSystem({\n    bounds: {x: 0, y: 0, width: 200, height: 100},\n    gridSize: 50\n})\n\nsystem.setupSpatialGrid()\n\nexpect(system.gridCols).toBe(4)\nexpect(system.gridRows).toBe(2)\nexpect(system.grid.length).toBe(2)\nexpect(system.grid[0].length).toBe(4)"
              },
              {
                "title": "clearGrid empties all cells",
                "line": 436,
                "source": "const system = new CollisionSystem({\n    bounds: {x: 0, y: 0, width: 128, height: 64},\n    spatialGrid: true,\n    gridSize: 64\n})\n\nsystem.grid[0][0].push({id: 1})\nsystem.grid[0][1].push({id: 2})\n\nsystem.clearGrid()\n\nexpect(system.grid[0][0].length).toBe(0)\nexpect(system.grid[0][1].length).toBe(0)"
              },
              {
                "title": "addBodyToGrid places body in correct cells",
                "line": 453,
                "source": "const system = new CollisionSystem({\n    bounds: {x: 0, y: 0, width: 128, height: 128},\n    spatialGrid: true,\n    gridSize: 64\n})\n\nconst body = createTestBody({x: 32, y: 32})\nsystem.addBody(body)\nsystem.updateShapes()\n\nsystem.addBodyToGrid(body)\n\nexpect(system.grid[0][0]).toContain(body)"
              },
              {
                "title": "addBodyToGrid handles body spanning multiple cells",
                "line": 470,
                "source": "const system = new CollisionSystem({\n    bounds: {x: 0, y: 0, width: 128, height: 128},\n    spatialGrid: true,\n    gridSize: 32\n})\n\nconst body = {\n    constructor: {name: 'Rectangle'},\n    userData: {width: 50, height: 50},\n    position: {x: 32, y: 32}\n}\nsystem.addBody(body)\nsystem.updateShapes()\n\nsystem.addBodyToGrid(body)\n\nexpect(system.grid[0][0]).toContain(body)\nexpect(system.grid[0][1]).toContain(body)\nexpect(system.grid[1][0]).toContain(body)\nexpect(system.grid[1][1]).toContain(body)"
              },
              {
                "title": "populateGrid adds all bodies to grid",
                "line": 494,
                "source": "const system = new CollisionSystem({\n    bounds: {x: 0, y: 0, width: 128, height: 128},\n    spatialGrid: true,\n    gridSize: 64\n})\n\nconst bodyA = createTestBody({x: 16, y: 16})\nconst bodyB = createTestBody({x: 80, y: 80})\nsystem.addBody(bodyA)\nsystem.addBody(bodyB)\nsystem.updateShapes()\n\nsystem.populateGrid([bodyA, bodyB])\n\nexpect(system.grid[0][0]).toContain(bodyA)\nexpect(system.grid[1][1]).toContain(bodyB)"
              },
              {
                "title": "checkCellCollisions checks pairs within cell",
                "line": 514,
                "source": "const system = new CollisionSystem({\n    bounds: {x: 0, y: 0, width: 128, height: 128},\n    spatialGrid: true,\n    gridSize: 64\n})\n\nconst callback = vi.fn()\nsystem.setCollisionCallback(callback)\n\nconst bodyA = createTestBody({x: 16, y: 16})\nconst bodyB = createTestBody({x: 20, y: 16})\nsystem.addBody(bodyA)\nsystem.addBody(bodyB)\nsystem.updateShapes()\n\nsystem.checkCellCollisions([bodyA, bodyB])\n\nexpect(callback).toHaveBeenCalled()"
              },
              {
                "title": "checkGridCollisions iterates all cells",
                "line": 536,
                "source": "const system = new CollisionSystem({\n    bounds: {x: 0, y: 0, width: 64, height: 64},\n    spatialGrid: true,\n    gridSize: 32\n})\n\nconst callback = vi.fn()\nsystem.setCollisionCallback(callback)\n\nconst bodyA = createTestBody({x: 16, y: 16})\nconst bodyB = createTestBody({x: 20, y: 16})\nsystem.addBody(bodyA)\nsystem.addBody(bodyB)\nsystem.updateShapes()\n\nsystem.grid[0][0] = [bodyA, bodyB]\n\nsystem.checkGridCollisions()\n\nexpect(callback).toHaveBeenCalled()"
              },
              {
                "title": "detectCollisionsWithGrid uses grid-based detection",
                "line": 560,
                "source": "const system = new CollisionSystem({\n    bounds: {x: 0, y: 0, width: 128, height: 128},\n    spatialGrid: true,\n    gridSize: 64\n})\n\nconst callback = vi.fn()\nsystem.setCollisionCallback(callback)\n\nconst bodyA = createTestBody({x: 16, y: 16})\nconst bodyB = createTestBody({x: 20, y: 16})\nsystem.addBody(bodyA)\nsystem.addBody(bodyB)\nsystem.updateShapes()\n\nsystem.detectCollisionsWithGrid([bodyA, bodyB])\n\nexpect(callback).toHaveBeenCalled()"
              },
              {
                "title": "detectCollisionsBruteForce checks all pairs",
                "line": 582,
                "source": "const callback = vi.fn()\ncollisionSystem.setCollisionCallback(callback)\n\nconst bodyA = createTestBody({x: 0, y: 0})\nconst bodyB = createTestBody({x: 10, y: 0})\ncollisionSystem.addBody(bodyA)\ncollisionSystem.addBody(bodyB)\ncollisionSystem.updateShapes()\n\ncollisionSystem.detectCollisionsBruteForce([bodyA, bodyB])\n\nexpect(callback).toHaveBeenCalled()"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/collision/simple_collision_detector.doc.js": {
    "file": "/collision/simple_collision_detector.test.js",
    "describes": [
      {
        "title": "SimpleCollisionDetector",
        "line": 5,
        "beforeEach": {
          "line": 9,
          "source": "detector = new SimpleCollisionDetector()"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor initializes correctly",
            "line": 14,
            "source": "expect(detector.bodies).toEqual([])\nexpect(detector.callbacks).toBeInstanceOf(Map)\nexpect(detector.enabled).toBe(true)"
          },
          {
            "title": "addBody adds object with default options",
            "line": 21,
            "source": "const object = createMockObject(0, 0, 2)\n\nconst body = detector.addBody(object)\n\nexpect(detector.bodies).toHaveLength(1)\nexpect(body.object).toBe(object)\nexpect(body.type).toBe('default')\nexpect(body.radius).toBe(2)\nexpect(body.enabled).toBe(true)"
          },
          {
            "title": "addBody with custom options",
            "line": 34,
            "source": "const object = createMockObject(0, 0, 1)\n\ndetector.addBody(object, {\n    type: 'player',\n    radius: 5,\n    enabled: false\n})\n\nconst body = detector.bodies[0]\nexpect(body.type).toBe('player')\nexpect(body.radius).toBe(5)\nexpect(body.enabled).toBe(false)"
          },
          {
            "title": "removeBody removes object",
            "line": 50,
            "source": "const object = createMockObject(0, 0, 1)\ndetector.addBody(object)\n\ndetector.removeBody(object)\n\nexpect(detector.bodies).toHaveLength(0)"
          },
          {
            "title": "onCollision sets callback for collision types",
            "line": 60,
            "source": "const callback = vi.fn()\n\ndetector.onCollision('player', 'spore', callback)\n\nexpect(detector.callbacks.get('player-spore')).toBe(callback)"
          },
          {
            "title": "detectCollisions calls callback when objects collide",
            "line": 69,
            "source": "const callback = vi.fn()\n\nconst player = createMockObject(0, 0, 1)\nconst spore = createMockObject(1, 0, 1)\n\ndetector.addBody(player, {type: 'player'})\ndetector.addBody(spore, {type: 'spore'})\ndetector.onCollision('player', 'spore', callback)\n\ndetector.detectCollisions()\n\nexpect(callback).toHaveBeenCalledTimes(1)\nexpect(callback).toHaveBeenCalledWith(\n    player,\n    spore,\n    expect.objectContaining({\n        distance: expect.any(Number),\n        bodyA: expect.any(Object),\n        bodyB: expect.any(Object)\n    })\n)"
          },
          {
            "title": "detectCollisions does not call callback when no collision",
            "line": 94,
            "source": "const callback = vi.fn()\n\nconst player = createMockObject(0, 0, 1)\nconst spore = createMockObject(10, 0, 1)\n\ndetector.addBody(player, {type: 'player'})\ndetector.addBody(spore, {type: 'spore'})\ndetector.onCollision('player', 'spore', callback)\n\ndetector.detectCollisions()\n\nexpect(callback).not.toHaveBeenCalled()"
          },
          {
            "title": "detectCollisions respects enabled state",
            "line": 110,
            "source": "const callback = vi.fn()\n\nconst player = createMockObject(0, 0, 1)\nconst spore = createMockObject(1, 0, 1)\n\ndetector.addBody(player, {type: 'player', enabled: false})\ndetector.addBody(spore, {type: 'spore'})\ndetector.onCollision('player', 'spore', callback)\n\ndetector.detectCollisions()\n\nexpect(callback).not.toHaveBeenCalled()"
          },
          {
            "title": "enable and disable methods",
            "line": 126,
            "source": "const callback = vi.fn()\n\nconst player = createMockObject(0, 0, 1)\nconst spore = createMockObject(1, 0, 1)\n\ndetector.addBody(player, {type: 'player'})\ndetector.addBody(spore, {type: 'spore'})\ndetector.onCollision('player', 'spore', callback)\n\ndetector.disable()\ndetector.detectCollisions()\nexpect(callback).not.toHaveBeenCalled()\n\ndetector.enable()\ndetector.detectCollisions()\nexpect(callback).toHaveBeenCalledTimes(1)"
          },
          {
            "title": "getBodiesOfType filters by type",
            "line": 146,
            "source": "const player = createMockObject(0, 0, 1)\nconst spore1 = createMockObject(5, 0, 1)\nconst spore2 = createMockObject(10, 0, 1)\n\ndetector.addBody(player, {type: 'player'})\ndetector.addBody(spore1, {type: 'spore'})\ndetector.addBody(spore2, {type: 'spore'})\n\nconst spores = detector.getBodiesOfType('spore')\n\nexpect(spores).toHaveLength(2)\nexpect(spores[0].object).toBe(spore1)\nexpect(spores[1].object).toBe(spore2)"
          },
          {
            "title": "getBodiesNear finds objects within radius",
            "line": 163,
            "source": "const obj1 = createMockObject(0, 0, 1)\nconst obj2 = createMockObject(5, 0, 1)\nconst obj3 = createMockObject(15, 0, 1)\n\ndetector.addBody(obj1)\ndetector.addBody(obj2)\ndetector.addBody(obj3)\n\nconst nearBodies = detector.getBodiesNear(0, 0, 10)\n\nexpect(nearBodies).toHaveLength(2)\nexpect(nearBodies.map(b => b.object)).toContain(obj1)\nexpect(nearBodies.map(b => b.object)).toContain(obj2)\nexpect(nearBodies.map(b => b.object)).not.toContain(obj3)"
          },
          {
            "title": "clear removes all bodies and callbacks",
            "line": 181,
            "source": "const object = createMockObject(0, 0, 1)\ndetector.addBody(object)\ndetector.onCollision('type1', 'type2', vi.fn())\n\ndetector.clear()\n\nexpect(detector.bodies).toHaveLength(0)\nexpect(detector.callbacks.size).toBe(0)"
          },
          {
            "title": "checkBodyCollisions checks body at index against subsequent bodies",
            "line": 193,
            "source": "const callback = vi.fn()\n\nconst player = createMockObject(0, 0, 5)\nconst spore1 = createMockObject(3, 0, 5)\nconst spore2 = createMockObject(100, 0, 5)\n\ndetector.addBody(player, {type: 'player'})\ndetector.addBody(spore1, {type: 'spore'})\ndetector.addBody(spore2, {type: 'spore'})\ndetector.onCollision('player', 'spore', callback)\n\ndetector.checkBodyCollisions(0)\n\nexpect(callback).toHaveBeenCalledTimes(1)\nexpect(callback).toHaveBeenCalledWith(player, spore1, expect.any(Object))"
          },
          {
            "title": "checkBodyCollisions skips disabled bodies",
            "line": 212,
            "source": "const callback = vi.fn()\n\nconst player = createMockObject(0, 0, 5)\nconst spore = createMockObject(3, 0, 5)\n\ndetector.addBody(player, {type: 'player'})\ndetector.addBody(spore, {type: 'spore', enabled: false})\ndetector.onCollision('player', 'spore', callback)\n\ndetector.checkBodyCollisions(0)\n\nexpect(callback).not.toHaveBeenCalled()"
          },
          {
            "title": "handleCollision calls callback with collision info",
            "line": 228,
            "source": "const callback = vi.fn()\n\nconst player = createMockObject(0, 0, 5)\nconst spore = createMockObject(3, 0, 5)\n\nconst bodyA = detector.addBody(player, {type: 'player'})\nconst bodyB = detector.addBody(spore, {type: 'spore'})\ndetector.onCollision('player', 'spore', callback)\n\ndetector.handleCollision(bodyA, bodyB)\n\nexpect(callback).toHaveBeenCalledWith(player, spore, expect.objectContaining({\n    distance: 3,\n    bodyA,\n    bodyB\n}))"
          },
          {
            "title": "handleCollision finds callback with reversed key",
            "line": 248,
            "source": "const callback = vi.fn()\n\nconst player = createMockObject(0, 0, 5)\nconst spore = createMockObject(3, 0, 5)\n\nconst bodyA = detector.addBody(player, {type: 'player'})\nconst bodyB = detector.addBody(spore, {type: 'spore'})\ndetector.onCollision('spore', 'player', callback)\n\ndetector.handleCollision(bodyA, bodyB)\n\nexpect(callback).toHaveBeenCalled()"
          },
          {
            "title": "handleCollision does nothing without matching callback",
            "line": 264,
            "source": "const player = createMockObject(0, 0, 5)\nconst spore = createMockObject(3, 0, 5)\n\nconst bodyA = detector.addBody(player, {type: 'player'})\nconst bodyB = detector.addBody(spore, {type: 'spore'})\n\nexpect(() => detector.handleCollision(bodyA, bodyB)).not.toThrow()"
          }
        ],
        "describes": []
      }
    ]
  },
  "/collision/shapes/box_shape.doc.js": {
    "file": "/collision/shapes/box_shape.test.js",
    "describes": [
      {
        "title": "BoxShape",
        "line": 4,
        "beforeEach": {
          "line": 8,
          "source": "boxShape = new BoxShape()"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor with no options",
            "line": 13,
            "source": "expect(boxShape.type).toBe('box')\nexpect(boxShape.width).toBe(32)\nexpect(boxShape.height).toBe(32)\nexpect(boxShape.offset).toEqual({x: 0, y: 0})\nexpect(boxShape.x).toBe(0)\nexpect(boxShape.y).toBe(0)\nexpect(boxShape.body).toBeNull()"
          },
          {
            "title": "constructor with options",
            "line": 24,
            "source": "const options = {\n    width: 100,\n    height: 50,\n    offset: {x: 10, y: 20},\n    x: 30,\n    y: 40\n}\n\nconst shape = new BoxShape(options)\n\nexpect(shape.type).toBe('box')\nexpect(shape.width).toBe(100)\nexpect(shape.height).toBe(50)\nexpect(shape.offset).toEqual({x: 10, y: 20})\nexpect(shape.x).toBe(30)\nexpect(shape.y).toBe(40)"
          },
          {
            "title": "updateFromBody without scale",
            "line": 44,
            "source": "const body = {\n    position: {x: 100, y: 200}\n}\n\nboxShape.offset = {x: 5, y: 10}\nboxShape.updateFromBody(body)\n\nexpect(boxShape.x).toBe(105)\nexpect(boxShape.y).toBe(210)\nexpect(boxShape.scaledWidth).toBe(32)\nexpect(boxShape.scaledHeight).toBe(32)"
          },
          {
            "title": "updateFromBody with scale",
            "line": 59,
            "source": "const body = {\n    position: {x: 100, y: 200},\n    scale: {x: 2, y: 1.5}\n}\n\nboxShape.width = 40\nboxShape.height = 60\nboxShape.updateFromBody(body)\n\nexpect(boxShape.x).toBe(100)\nexpect(boxShape.y).toBe(200)\nexpect(boxShape.scaledWidth).toBe(80)\nexpect(boxShape.scaledHeight).toBe(90)"
          },
          {
            "title": "getBounds without scaling",
            "line": 76,
            "source": "boxShape.x = 100\nboxShape.y = 200\nboxShape.width = 40\nboxShape.height = 60\n\nconst bounds = boxShape.getBounds()\n\nexpect(bounds.left).toBe(80)\nexpect(bounds.right).toBe(120)\nexpect(bounds.top).toBe(170)\nexpect(bounds.bottom).toBe(230)\nexpect(bounds.centerX).toBe(100)\nexpect(bounds.centerY).toBe(200)\nexpect(bounds.width).toBe(40)\nexpect(bounds.height).toBe(60)"
          },
          {
            "title": "getBounds with scaling",
            "line": 95,
            "source": "boxShape.x = 100\nboxShape.y = 200\nboxShape.width = 40\nboxShape.height = 60\nboxShape.scaledWidth = 80\nboxShape.scaledHeight = 120\n\nconst bounds = boxShape.getBounds()\n\nexpect(bounds.left).toBe(60)\nexpect(bounds.right).toBe(140)\nexpect(bounds.top).toBe(140)\nexpect(bounds.bottom).toBe(260)\nexpect(bounds.width).toBe(80)\nexpect(bounds.height).toBe(120)"
          },
          {
            "title": "containsPoint inside",
            "line": 114,
            "source": "boxShape.x = 100\nboxShape.y = 200\nboxShape.width = 40\nboxShape.height = 60\n\nexpect(boxShape.containsPoint(100, 200)).toBe(true)\nexpect(boxShape.containsPoint(90, 180)).toBe(true)\nexpect(boxShape.containsPoint(120, 230)).toBe(true)"
          },
          {
            "title": "containsPoint outside",
            "line": 126,
            "source": "boxShape.x = 100\nboxShape.y = 200\nboxShape.width = 40\nboxShape.height = 60\n\nexpect(boxShape.containsPoint(70, 200)).toBe(false)\nexpect(boxShape.containsPoint(130, 200)).toBe(false)\nexpect(boxShape.containsPoint(100, 160)).toBe(false)\nexpect(boxShape.containsPoint(100, 240)).toBe(false)"
          },
          {
            "title": "containsPoint on edge",
            "line": 139,
            "source": "boxShape.x = 100\nboxShape.y = 200\nboxShape.width = 40\nboxShape.height = 60\n\nexpect(boxShape.containsPoint(80, 200)).toBe(true)\nexpect(boxShape.containsPoint(120, 200)).toBe(true)\nexpect(boxShape.containsPoint(100, 170)).toBe(true)\nexpect(boxShape.containsPoint(100, 230)).toBe(true)"
          },
          {
            "title": "setSize with width and height",
            "line": 152,
            "source": "const result = boxShape.setSize(100, 150)\n\nexpect(boxShape.width).toBe(100)\nexpect(boxShape.height).toBe(150)\nexpect(result).toBe(boxShape)"
          },
          {
            "title": "setSize with only width",
            "line": 161,
            "source": "const result = boxShape.setSize(100)\n\nexpect(boxShape.width).toBe(100)\nexpect(boxShape.height).toBe(100)\nexpect(result).toBe(boxShape)"
          },
          {
            "title": "setOffset",
            "line": 170,
            "source": "const result = boxShape.setOffset(10, 20)\n\nexpect(boxShape.offset).toEqual({x: 10, y: 20})\nexpect(result).toBe(boxShape)"
          },
          {
            "title": "debug method exists",
            "line": 178,
            "source": "expect(typeof boxShape.debug).toBe('function')"
          }
        ],
        "describes": []
      }
    ]
  },
  "/collision/shapes/circle_shape.doc.js": {
    "file": "/collision/shapes/circle_shape.test.js",
    "describes": [
      {
        "title": "CircleShape",
        "line": 4,
        "beforeEach": {
          "line": 8,
          "source": "circleShape = new CircleShape()"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor with no options",
            "line": 13,
            "source": "expect(circleShape.type).toBe('circle')\nexpect(circleShape.radius).toBe(16)\nexpect(circleShape.offset).toEqual({x: 0, y: 0})\nexpect(circleShape.x).toBe(0)\nexpect(circleShape.y).toBe(0)\nexpect(circleShape.body).toBeNull()"
          },
          {
            "title": "constructor with options",
            "line": 23,
            "source": "const options = {\n    radius: 50,\n    offset: {x: 10, y: 20},\n    x: 30,\n    y: 40\n}\n\nconst shape = new CircleShape(options)\n\nexpect(shape.type).toBe('circle')\nexpect(shape.radius).toBe(50)\nexpect(shape.offset).toEqual({x: 10, y: 20})\nexpect(shape.x).toBe(30)\nexpect(shape.y).toBe(40)"
          },
          {
            "title": "updateFromBody without scale",
            "line": 41,
            "source": "const body = {\n    position: {x: 100, y: 200}\n}\n\ncircleShape.offset = {x: 5, y: 10}\ncircleShape.updateFromBody(body)\n\nexpect(circleShape.x).toBe(105)\nexpect(circleShape.y).toBe(210)\nexpect(circleShape.scaledRadius).toBe(16)"
          },
          {
            "title": "updateFromBody with scale",
            "line": 55,
            "source": "const body = {\n    position: {x: 100, y: 200},\n    scale: {x: 2, y: 1.5}\n}\n\ncircleShape.radius = 20\ncircleShape.updateFromBody(body)\n\nexpect(circleShape.x).toBe(100)\nexpect(circleShape.y).toBe(200)\nexpect(circleShape.scaledRadius).toBe(40) // Math.max(2, 1.5) * 20"
          },
          {
            "title": "updateFromBody with scale uses max scale",
            "line": 70,
            "source": "const body = {\n    position: {x: 0, y: 0},\n    scale: {x: 1, y: 3}\n}\n\ncircleShape.radius = 10\ncircleShape.updateFromBody(body)\n\nexpect(circleShape.scaledRadius).toBe(30) // Math.max(1, 3) * 10"
          },
          {
            "title": "getWorldPosition",
            "line": 83,
            "source": "circleShape.x = 150\ncircleShape.y = 250\n\nconst position = circleShape.getWorldPosition()\n\nexpect(position.x).toBe(150)\nexpect(position.y).toBe(250)"
          },
          {
            "title": "getBounds without scaling",
            "line": 94,
            "source": "circleShape.x = 100\ncircleShape.y = 200\ncircleShape.radius = 30\n\nconst bounds = circleShape.getBounds()\n\nexpect(bounds.left).toBe(70)\nexpect(bounds.right).toBe(130)\nexpect(bounds.top).toBe(170)\nexpect(bounds.bottom).toBe(230)\nexpect(bounds.centerX).toBe(100)\nexpect(bounds.centerY).toBe(200)\nexpect(bounds.width).toBe(60)\nexpect(bounds.height).toBe(60)"
          },
          {
            "title": "getBounds with scaling",
            "line": 112,
            "source": "circleShape.x = 100\ncircleShape.y = 200\ncircleShape.radius = 20\ncircleShape.scaledRadius = 40\n\nconst bounds = circleShape.getBounds()\n\nexpect(bounds.left).toBe(60)\nexpect(bounds.right).toBe(140)\nexpect(bounds.top).toBe(160)\nexpect(bounds.bottom).toBe(240)\nexpect(bounds.centerX).toBe(100)\nexpect(bounds.centerY).toBe(200)\nexpect(bounds.width).toBe(80)\nexpect(bounds.height).toBe(80)"
          },
          {
            "title": "containsPoint inside circle",
            "line": 131,
            "source": "circleShape.x = 100\ncircleShape.y = 200\ncircleShape.radius = 30\n\nexpect(circleShape.containsPoint(100, 200)).toBe(true)\nexpect(circleShape.containsPoint(110, 210)).toBe(true)\nexpect(circleShape.containsPoint(90, 190)).toBe(true)"
          },
          {
            "title": "containsPoint outside circle",
            "line": 142,
            "source": "circleShape.x = 100\ncircleShape.y = 200\ncircleShape.radius = 30\n\nexpect(circleShape.containsPoint(140, 200)).toBe(false)\nexpect(circleShape.containsPoint(100, 240)).toBe(false)\nexpect(circleShape.containsPoint(150, 250)).toBe(false)"
          },
          {
            "title": "containsPoint on circle edge",
            "line": 153,
            "source": "circleShape.x = 100\ncircleShape.y = 200\ncircleShape.radius = 30\n\nexpect(circleShape.containsPoint(130, 200)).toBe(true)\nexpect(circleShape.containsPoint(100, 170)).toBe(true)\nexpect(circleShape.containsPoint(70, 200)).toBe(true)\nexpect(circleShape.containsPoint(100, 230)).toBe(true)"
          },
          {
            "title": "containsPoint with scaled radius",
            "line": 165,
            "source": "circleShape.x = 100\ncircleShape.y = 200\ncircleShape.radius = 20\ncircleShape.scaledRadius = 40\n\nexpect(circleShape.containsPoint(100, 200)).toBe(true)\nexpect(circleShape.containsPoint(140, 200)).toBe(true)\nexpect(circleShape.containsPoint(150, 200)).toBe(false)"
          },
          {
            "title": "containsPoint uses exact distance calculation",
            "line": 177,
            "source": "circleShape.x = 0\ncircleShape.y = 0\ncircleShape.radius = 5\n\nexpect(circleShape.containsPoint(3, 4)).toBe(true) // distance = 5, exactly on edge\nexpect(circleShape.containsPoint(4, 4)).toBe(false) // distance > 5"
          },
          {
            "title": "setRadius",
            "line": 187,
            "source": "const result = circleShape.setRadius(50)\n\nexpect(circleShape.radius).toBe(50)\nexpect(result).toBe(circleShape)"
          },
          {
            "title": "setOffset",
            "line": 195,
            "source": "const result = circleShape.setOffset(15, 25)\n\nexpect(circleShape.offset).toEqual({x: 15, y: 25})\nexpect(result).toBe(circleShape)"
          },
          {
            "title": "debug method exists",
            "line": 203,
            "source": "expect(typeof circleShape.debug).toBe('function')"
          }
        ],
        "describes": []
      }
    ]
  },
  "/io/binary_reader.doc.js": {
    "file": "/io/binary_reader.test.js",
    "describes": [
      {
        "title": "BinaryReader",
        "line": 4,
        "beforeEach": null,
        "afterEach": null,
        "tests": [],
        "describes": [
          {
            "title": "constructor",
            "line": 11,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "from ArrayBuffer",
                "line": 13,
                "source": "const buffer = new ArrayBuffer(4)\nconst reader = new BinaryReader(buffer)\nexpect(reader.length).toBe(4)\nexpect(reader.offset).toBe(0)"
              },
              {
                "title": "from Uint8Array",
                "line": 20,
                "source": "const array = new Uint8Array([1, 2, 3, 4])\nconst reader = new BinaryReader(array)\nexpect(reader.length).toBe(4)"
              },
              {
                "title": "from DataView",
                "line": 26,
                "source": "const buffer = new ArrayBuffer(8)\nconst view = new DataView(buffer, 2, 4)\nconst reader = new BinaryReader(view)\nexpect(reader.length).toBe(4)"
              }
            ],
            "describes": []
          },
          {
            "title": "length and remaining",
            "line": 36,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "length",
                "line": 38,
                "source": "const reader = createReader([1, 2, 3, 4, 5])\nexpect(reader.length).toBe(5)"
              },
              {
                "title": "remaining",
                "line": 43,
                "source": "const reader = createReader([1, 2, 3, 4, 5])\nexpect(reader.remaining).toBe(5)\nreader.skip(2)\nexpect(reader.remaining).toBe(3)"
              }
            ],
            "describes": []
          },
          {
            "title": "seek and skip",
            "line": 53,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "seek",
                "line": 55,
                "source": "const reader = createReader([1, 2, 3, 4])\nreader.seek(2)\nexpect(reader.offset).toBe(2)"
              },
              {
                "title": "skip",
                "line": 61,
                "source": "const reader = createReader([1, 2, 3, 4])\nreader.skip(3)\nexpect(reader.offset).toBe(3)"
              }
            ],
            "describes": []
          },
          {
            "title": "integer reading",
            "line": 70,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "readUint8",
                "line": 72,
                "source": "const reader = createReader([0xFF, 0x00, 0x7F])\nexpect(reader.readUint8()).toBe(255)\nexpect(reader.readUint8()).toBe(0)\nexpect(reader.readUint8()).toBe(127)"
              },
              {
                "title": "readInt8",
                "line": 79,
                "source": "const reader = createReader([0xFF, 0x00, 0x7F])\nexpect(reader.readInt8()).toBe(-1)\nexpect(reader.readInt8()).toBe(0)\nexpect(reader.readInt8()).toBe(127)"
              },
              {
                "title": "readUint16 big endian",
                "line": 86,
                "source": "const reader = createReader([0x01, 0x02])\nexpect(reader.readUint16()).toBe(0x0102)"
              },
              {
                "title": "readUint16 little endian",
                "line": 91,
                "source": "const reader = createReader([0x01, 0x02])\nexpect(reader.readUint16(true)).toBe(0x0201)"
              },
              {
                "title": "readInt16",
                "line": 96,
                "source": "const reader = createReader([0xFF, 0xFE])\nexpect(reader.readInt16()).toBe(-2)"
              },
              {
                "title": "readUint32 big endian",
                "line": 101,
                "source": "const reader = createReader([0x00, 0x00, 0x01, 0x00])\nexpect(reader.readUint32()).toBe(256)"
              },
              {
                "title": "readUint32 little endian",
                "line": 106,
                "source": "const reader = createReader([0x00, 0x01, 0x00, 0x00])\nexpect(reader.readUint32(true)).toBe(256)"
              },
              {
                "title": "readInt32",
                "line": 111,
                "source": "const reader = createReader([0xFF, 0xFF, 0xFF, 0xFF])\nexpect(reader.readInt32()).toBe(-1)"
              }
            ],
            "describes": []
          },
          {
            "title": "float reading",
            "line": 119,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "readFloat32",
                "line": 121,
                "source": "const buffer = new ArrayBuffer(4)\nconst view = new DataView(buffer)\nview.setFloat32(0, 3.14, false)\nconst reader = new BinaryReader(buffer)\nexpect(reader.readFloat32()).toBeCloseTo(3.14, 2)"
              },
              {
                "title": "readFloat64",
                "line": 129,
                "source": "const buffer = new ArrayBuffer(8)\nconst view = new DataView(buffer)\nview.setFloat64(0, 3.141592653589793, false)\nconst reader = new BinaryReader(buffer)\nexpect(reader.readFloat64()).toBeCloseTo(3.141592653589793, 10)"
              }
            ],
            "describes": []
          },
          {
            "title": "byte and string reading",
            "line": 140,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "readBytes",
                "line": 142,
                "source": "const reader = createReader([1, 2, 3, 4, 5])\nconst bytes = reader.readBytes(3)\nexpect(bytes).toEqual(new Uint8Array([1, 2, 3]))\nexpect(reader.offset).toBe(3)"
              },
              {
                "title": "readString",
                "line": 149,
                "source": "const reader = createReader([72, 101, 108, 108, 111])\nexpect(reader.readString(5)).toBe('Hello')"
              },
              {
                "title": "readPascalString",
                "line": 154,
                "source": "const reader = createReader([3, 65, 66, 67])\nexpect(reader.readPascalString()).toBe('ABC')"
              },
              {
                "title": "readPascalString empty",
                "line": 159,
                "source": "const reader = createReader([0])\nexpect(reader.readPascalString()).toBe('')"
              },
              {
                "title": "readPascalString with padding",
                "line": 164,
                "source": "const reader = createReader([3, 65, 66, 67, 0, 0, 99])\nexpect(reader.readPascalString(4)).toBe('ABC')\nexpect(reader.offset).toBe(4)"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/io/canvas.doc.js": {
    "file": "/io/canvas.test.js",
    "describes": [
      {
        "title": "calculateResizeDimensions",
        "line": 11,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "returns target dimensions when both provided",
            "line": 13,
            "source": "const result = calculateResizeDimensions(100, 200, 50, 100)\nexpect(result).toEqual({width: 50, height: 100})"
          },
          {
            "title": "scales by width when only width provided",
            "line": 18,
            "source": "const result = calculateResizeDimensions(100, 200, 50, undefined)\nexpect(result).toEqual({width: 50, height: 100})"
          },
          {
            "title": "scales by height when only height provided",
            "line": 23,
            "source": "const result = calculateResizeDimensions(100, 200, undefined, 100)\nexpect(result).toEqual({width: 50, height: 100})"
          },
          {
            "title": "returns source dimensions when no target provided",
            "line": 28,
            "source": "const result = calculateResizeDimensions(100, 200, undefined, undefined)\nexpect(result).toEqual({width: 100, height: 200})"
          },
          {
            "title": "handles non-proportional scaling",
            "line": 33,
            "source": "const result = calculateResizeDimensions(100, 100, 200, 50)\nexpect(result).toEqual({width: 200, height: 50})"
          },
          {
            "title": "rounds scaled dimensions",
            "line": 38,
            "source": "const result = calculateResizeDimensions(100, 100, 33, undefined)\nexpect(result.width).toBe(33)\nexpect(result.height).toBe(33)"
          }
        ],
        "describes": []
      },
      {
        "title": "createCanvas",
        "line": 47,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "creates canvas with specified dimensions",
            "line": 49,
            "source": "const canvas = await createCanvas(100, 200)\nexpect(canvas.width).toBe(100)\nexpect(canvas.height).toBe(200)"
          },
          {
            "title": "canvas has 2d context",
            "line": 55,
            "source": "const canvas = await createCanvas(50, 50)\nconst ctx = canvas.getContext('2d')\nexpect(ctx).toBeDefined()"
          }
        ],
        "describes": []
      },
      {
        "title": "putPixels",
        "line": 64,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "puts pixel data on canvas context",
            "line": 66,
            "source": "const canvas = await createCanvas(2, 2)\nconst ctx = canvas.getContext('2d')\n\nconst pixels = new Uint8Array([\n    255, 0, 0, 255,\n    0, 255, 0, 255,\n    0, 0, 255, 255,\n    255, 255, 255, 255\n])\n\nputPixels(ctx, {pixels, width: 2, height: 2})\n\nconst imageData = ctx.getImageData(0, 0, 2, 2)\nexpect(imageData.data[0]).toBe(255)\nexpect(imageData.data[1]).toBe(0)\nexpect(imageData.data[2]).toBe(0)\nexpect(imageData.data[3]).toBe(255)"
          },
          {
            "title": "puts pixels at specified offset",
            "line": 86,
            "source": "const canvas = await createCanvas(4, 4)\nconst ctx = canvas.getContext('2d')\n\nconst pixels = new Uint8Array([255, 0, 0, 255])\n\nputPixels(ctx, {pixels, width: 1, height: 1, x: 2, y: 2})\n\nconst imageData = ctx.getImageData(2, 2, 1, 1)\nexpect(imageData.data[0]).toBe(255)"
          }
        ],
        "describes": []
      },
      {
        "title": "resizeCanvas",
        "line": 101,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "resizes canvas to target dimensions",
            "line": 103,
            "source": "const source = await createCanvas(100, 100)\nconst resized = await resizeCanvas(source, 50, 50)\nexpect(resized.width).toBe(50)\nexpect(resized.height).toBe(50)"
          },
          {
            "title": "uses smooth interpolation by default",
            "line": 110,
            "source": "const source = await createCanvas(100, 100)\nconst resized = await resizeCanvas(source, 50, 50)\nconst ctx = resized.getContext('2d')\nexpect(ctx.imageSmoothingEnabled).toBe(true)"
          },
          {
            "title": "disables smoothing with nearest flag",
            "line": 117,
            "source": "const source = await createCanvas(100, 100)\nconst resized = await resizeCanvas(source, 50, 50, true)\nconst ctx = resized.getContext('2d')\nexpect(ctx.imageSmoothingEnabled).toBe(false)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/io/manifest_patcher.doc.js": {
    "file": "/io/manifest_patcher.test.js",
    "describes": [
      {
        "title": "applyOverrides",
        "line": 14,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "injects source into matching assets",
            "line": 16,
            "source": "const manifestData = {\n    config: {name: 'Test'},\n    assets: {\n        redAnimator: {type: 'animator', url: './red.json'},\n        redSpritesheet: {type: 'spritesheet', url: './red_sheet.json'}\n    }\n}\n\nconst overrides = [\n    {id: 'redAnimator', source: {spritesheet: 'redSpritesheet', animations: {}}},\n    {id: 'redSpritesheet', source: {data: {frames: []}, images: []}}\n]\n\nconst result = applyOverrides(manifestData, overrides)\n\nexpect(result.assets.redAnimator.source).toEqual({spritesheet: 'redSpritesheet', animations: {}})\nexpect(result.assets.redSpritesheet.source).toEqual({data: {frames: []}, images: []})"
          },
          {
            "title": "preserves existing asset properties",
            "line": 37,
            "source": "const manifestData = {\n    assets: {\n        redAnimator: {type: 'animator', url: './red.json', config: {foo: true}}\n    }\n}\n\nconst overrides = [{id: 'redAnimator', source: {animations: {}}}]\nconst result = applyOverrides(manifestData, overrides)\n\nexpect(result.assets.redAnimator.type).toBe('animator')\nexpect(result.assets.redAnimator.url).toBe('./red.json')\nexpect(result.assets.redAnimator.config).toEqual({foo: true})\nexpect(result.assets.redAnimator.source).toEqual({animations: {}})"
          },
          {
            "title": "does not modify the original manifest data",
            "line": 54,
            "source": "const manifestData = {\n    config: {name: 'Test'},\n    assets: {\n        redAnimator: {type: 'animator', url: './red.json'}\n    }\n}\n\nconst overrides = [{id: 'redAnimator', source: {animations: {}}}]\napplyOverrides(manifestData, overrides)\n\nexpect(manifestData.assets.redAnimator.source).toBeUndefined()"
          },
          {
            "title": "ignores overrides for non-existing assets",
            "line": 69,
            "source": "const manifestData = {\n    assets: {\n        redAnimator: {type: 'animator', url: './red.json'}\n    }\n}\n\nconst overrides = [\n    {id: 'blueAnimator', source: {animations: {}}}\n]\n\nconst result = applyOverrides(manifestData, overrides)\n\nexpect(result.assets.blueAnimator).toBeUndefined()\nexpect(result.assets.redAnimator.source).toBeUndefined()"
          },
          {
            "title": "preserves config and other top-level manifest fields",
            "line": 87,
            "source": "const manifestData = {\n    config: {name: 'Test', audio: {volume: 1}},\n    assets: {\n        redAnimator: {type: 'animator', url: './red.json'}\n    }\n}\n\nconst overrides = [{id: 'redAnimator', source: {animations: {}}}]\nconst result = applyOverrides(manifestData, overrides)\n\nexpect(result.config).toEqual({name: 'Test', audio: {volume: 1}})"
          },
          {
            "title": "handles empty overrides",
            "line": 102,
            "source": "const manifestData = {\n    assets: {redAnimator: {type: 'animator', url: './red.json'}}\n}\n\nconst result = applyOverrides(manifestData, [])\n\nexpect(result.assets.redAnimator).toEqual({type: 'animator', url: './red.json'})"
          }
        ],
        "describes": []
      },
      {
        "title": "loadStudioOverrides",
        "line": 126,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "returns empty array when no resources",
            "line": 128,
            "source": "PerkyStore.prototype.list.mockResolvedValue([])\n\nconst result = await loadStudioOverrides()\n\nexpect(result).toEqual([])"
          },
          {
            "title": "loads animator config from store",
            "line": 137,
            "source": "const animatorConfig = {spritesheet: 'redSpritesheet', animations: {idle: {}}}\n\nPerkyStore.prototype.list.mockResolvedValue([{id: 'redAnimator'}])\nPerkyStore.prototype.get.mockResolvedValue({\n    id: 'redAnimator',\n    files: [\n        {name: 'redAnimator.json', blob: createBlob(animatorConfig)}\n    ]\n})\n\nconst result = await loadStudioOverrides()\n\nexpect(result.length).toBeGreaterThanOrEqual(1)\nexpect(result[0]).toEqual({id: 'redAnimator', source: animatorConfig})"
          },
          {
            "title": "skips resource when store.get returns null",
            "line": 155,
            "source": "PerkyStore.prototype.list.mockResolvedValue([{id: 'missingAnimator'}])\nPerkyStore.prototype.get.mockResolvedValue(null)\n\nconst result = await loadStudioOverrides()\n\nexpect(result).toEqual([])"
          },
          {
            "title": "skips resource when no Animator.json file found",
            "line": 165,
            "source": "PerkyStore.prototype.list.mockResolvedValue([{id: 'noConfig'}])\nPerkyStore.prototype.get.mockResolvedValue({\n    id: 'noConfig',\n    files: [{name: 'other.json', blob: createBlob({})}]\n})\n\nconst result = await loadStudioOverrides()\n\nexpect(result).toEqual([])"
          },
          {
            "title": "includes spritesheet override when spritesheet config exists",
            "line": 178,
            "source": "const animatorConfig = {spritesheet: 'heroSpritesheet', animations: {run: {}}}\nconst spritesheetData = {frames: {frame0: {}}, meta: {}}\n\nglobalThis.createImageBitmap = vi.fn().mockResolvedValue({width: 64, height: 64})\n\nPerkyStore.prototype.list.mockResolvedValue([{id: 'heroAnimator'}])\nPerkyStore.prototype.get.mockResolvedValue({\n    id: 'heroAnimator',\n    files: [\n        {name: 'heroAnimator.json', blob: createBlob(animatorConfig)},\n        {name: 'heroSpritesheet.json', blob: createBlob(spritesheetData)},\n        {name: 'hero_0.png', blob: createPngBlob()}\n    ]\n})\n\nconst result = await loadStudioOverrides()\n\nexpect(result.length).toBe(2)\nexpect(result[0]).toEqual({id: 'heroAnimator', source: animatorConfig})\nexpect(result[1].id).toBe('heroSpritesheet')\nexpect(result[1].source.data).toEqual(spritesheetData)\nexpect(result[1].source.images).toHaveLength(1)"
          },
          {
            "title": "skips spritesheet when no spritesheet name in config",
            "line": 204,
            "source": "const animatorConfig = {animations: {idle: {}}}\n\nPerkyStore.prototype.list.mockResolvedValue([{id: 'simpleAnimator'}])\nPerkyStore.prototype.get.mockResolvedValue({\n    id: 'simpleAnimator',\n    files: [\n        {name: 'simpleAnimator.json', blob: createBlob(animatorConfig)}\n    ]\n})\n\nconst result = await loadStudioOverrides()\n\nexpect(result).toEqual([{id: 'simpleAnimator', source: animatorConfig}])"
          }
        ],
        "describes": []
      }
    ]
  },
  "/io/pack.doc.js": {
    "file": "/io/pack.test.js",
    "describes": [
      {
        "title": "pack",
        "line": 24,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "pack single text file",
            "line": 26,
            "source": "const files = [\n    {name: 'test.txt', blob: new Blob(['Hello World'], {type: 'text/plain'})}\n]\n\nconst packed = await pack(files)\n\nexpect(packed).toBeInstanceOf(Blob)\nexpect(packed.size).toBeGreaterThan(0)"
          },
          {
            "title": "pack multiple files",
            "line": 38,
            "source": "const files = [\n    {name: 'a.txt', blob: new Blob(['AAA'], {type: 'text/plain'})},\n    {name: 'b.json', blob: new Blob(['{\"x\":1}'], {type: 'application/json'})}\n]\n\nconst packed = await pack(files)\n\nexpect(packed).toBeInstanceOf(Blob)"
          },
          {
            "title": "pack empty list",
            "line": 50,
            "source": "const packed = await pack([])\n\nexpect(packed).toBeInstanceOf(Blob)"
          }
        ],
        "describes": []
      },
      {
        "title": "unpack",
        "line": 59,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "unpack single file",
            "line": 61,
            "source": "const original = [{name: 'test.txt', blob: new Blob(['Hello'], {type: 'text/plain'})}]\nconst packed = await pack(original)\nconst unpacked = await unpack(packed)\n\nexpect(unpacked).toHaveLength(1)\nexpect(unpacked[0].name).toBe('test.txt')\nexpect(unpacked[0].blob.type).toBe('text/plain')\n\nconst text = await blobToText(unpacked[0].blob)\nexpect(text).toBe('Hello')"
          },
          {
            "title": "unpack multiple files",
            "line": 75,
            "source": "const original = [\n    {name: 'a.txt', blob: new Blob(['AAA'], {type: 'text/plain'})},\n    {name: 'b.json', blob: new Blob(['{\"x\":1}'], {type: 'application/json'})},\n    {name: 'c.bin', blob: new Blob([new Uint8Array([1, 2, 3])], {type: 'application/octet-stream'})}\n]\n\nconst packed = await pack(original)\nconst unpacked = await unpack(packed)\n\nexpect(unpacked).toHaveLength(3)\n\nexpect(unpacked[0].name).toBe('a.txt')\nexpect(await blobToText(unpacked[0].blob)).toBe('AAA')\n\nexpect(unpacked[1].name).toBe('b.json')\nexpect(await blobToText(unpacked[1].blob)).toBe('{\"x\":1}')\n\nexpect(unpacked[2].name).toBe('c.bin')\nconst bytes = new Uint8Array(await blobToArrayBuffer(unpacked[2].blob))\nexpect(Array.from(bytes)).toEqual([1, 2, 3])"
          },
          {
            "title": "unpack empty pack",
            "line": 99,
            "source": "const packed = await pack([])\nconst unpacked = await unpack(packed)\n\nexpect(unpacked).toEqual([])"
          },
          {
            "title": "preserves file types",
            "line": 107,
            "source": "const original = [\n    {name: 'image.png', blob: new Blob([new Uint8Array([0x89, 0x50, 0x4E, 0x47])], {type: 'image/png'})}\n]\n\nconst packed = await pack(original)\nconst unpacked = await unpack(packed)\n\nexpect(unpacked[0].blob.type).toBe('image/png')"
          }
        ],
        "describes": []
      }
    ]
  },
  "/io/perky_store.doc.js": {
    "file": "/io/perky_store.test.js",
    "describes": [
      {
        "title": "open",
        "line": 158,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "opens database",
            "line": 160,
            "source": "const db = await store.open()\nexpect(db).not.toBeNull()"
          },
          {
            "title": "returns same database on subsequent calls",
            "line": 166,
            "source": "const db1 = await store.open()\nconst db2 = await store.open()\nexpect(db1).toBe(db2)"
          }
        ],
        "describes": []
      },
      {
        "title": "list",
        "line": 175,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "returns empty array initially",
            "line": 177,
            "source": "const items = await store.list()\nexpect(items).toEqual([])"
          },
          {
            "title": "returns saved items",
            "line": 183,
            "source": "await store.save('testAnimator', {\n    type: 'animator',\n    name: 'test',\n    files: [{name: 'test.json', blob: new Blob(['{}'], {type: 'application/json'})}]\n})\n\nconst items = await store.list()\n\nexpect(items).toHaveLength(1)\nexpect(items[0].id).toBe('testAnimator')\nexpect(items[0].type).toBe('animator')\nexpect(items[0].name).toBe('test')"
          },
          {
            "title": "filters by type",
            "line": 199,
            "source": "await store.save('redAnimator', {\n    type: 'animator',\n    name: 'red',\n    files: [{name: 'red.json', blob: new Blob(['{}'], {type: 'application/json'})}]\n})\n\nawait store.save('blueSpritesheet', {\n    type: 'spritesheet',\n    name: 'blue',\n    files: [{name: 'blue.json', blob: new Blob(['{}'], {type: 'application/json'})}]\n})\n\nconst animators = await store.list('animator')\nexpect(animators).toHaveLength(1)\nexpect(animators[0].type).toBe('animator')\n\nconst spritesheets = await store.list('spritesheet')\nexpect(spritesheets).toHaveLength(1)\nexpect(spritesheets[0].type).toBe('spritesheet')"
          }
        ],
        "describes": []
      },
      {
        "title": "save",
        "line": 224,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "saves resource with type and files",
            "line": 226,
            "source": "const result = await store.save('blueAnimator', {\n    type: 'animator',\n    name: 'blue',\n    files: [\n        {name: 'blue.json', blob: new Blob(['{}'], {type: 'application/json'})},\n        {name: 'blue.png', blob: new Blob(['png'], {type: 'image/png'})}\n    ]\n})\n\nexpect(result.id).toBe('blueAnimator')\nexpect(result.type).toBe('animator')\nexpect(result.name).toBe('blue')"
          },
          {
            "title": "requires type",
            "line": 242,
            "source": "await expect(store.save('test', {\n    name: 'test',\n    files: []\n})).rejects.toThrow('Resource type is required')"
          },
          {
            "title": "updates existing resource",
            "line": 250,
            "source": "await store.save('blueAnimator', {\n    type: 'animator',\n    name: 'blue',\n    files: [{name: 'v1.json', blob: new Blob(['v1'], {type: 'application/json'})}]\n})\n\nawait store.save('blueAnimator', {\n    type: 'animator',\n    name: 'blue',\n    files: [{name: 'v2.json', blob: new Blob(['v2'], {type: 'application/json'})}]\n})\n\nconst items = await store.list()\nexpect(items).toHaveLength(1)"
          }
        ],
        "describes": []
      },
      {
        "title": "get",
        "line": 270,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "returns null for non-existent resource",
            "line": 272,
            "source": "const result = await store.get('nonExistent')\nexpect(result).toBeNull()"
          },
          {
            "title": "returns saved resource with files",
            "line": 278,
            "source": "await store.save('redAnimator', {\n    type: 'animator',\n    name: 'red',\n    files: [\n        {name: 'red.json', blob: new Blob(['{\"fps\":10}'], {type: 'application/json'})},\n        {name: 'red.png', blob: new Blob(['image'], {type: 'image/png'})}\n    ]\n})\n\nconst result = await store.get('redAnimator')\n\nexpect(result.id).toBe('redAnimator')\nexpect(result.type).toBe('animator')\nexpect(result.name).toBe('red')\nexpect(result.files).toHaveLength(2)\nexpect(result.files.find(f => f.name === 'red.json')).toBeDefined()\nexpect(result.files.find(f => f.name === 'red.png')).toBeDefined()"
          },
          {
            "title": "excludes meta.json from files",
            "line": 299,
            "source": "await store.save('testResource', {\n    type: 'test',\n    name: 'test',\n    files: [{name: 'data.json', blob: new Blob(['{}'], {type: 'application/json'})}]\n})\n\nconst result = await store.get('testResource')\n\nconst metaFile = result.files.find(f => f.name === 'meta.json')\nexpect(metaFile).toBeUndefined()"
          }
        ],
        "describes": []
      },
      {
        "title": "export",
        "line": 332,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "creates download link",
            "line": 334,
            "source": "await store.save('exportResource', {\n    type: 'animator',\n    name: 'export',\n    files: [{name: 'export.json', blob: new Blob(['{}'], {type: 'application/json'})}]\n})\n\nconst mockAnchor = {click: vi.fn(), href: '', download: ''}\nconst originalCreateElement = document.createElement.bind(document)\nvi.spyOn(document, 'createElement').mockImplementation((tag) => {\n    if (tag === 'a') {\n        return mockAnchor\n    }\n    return originalCreateElement(tag)\n})\n\nconst originalCreateObjectURL = URL.createObjectURL\nconst originalRevokeObjectURL = URL.revokeObjectURL\nURL.createObjectURL = vi.fn(() => 'blob:test')\nURL.revokeObjectURL = vi.fn()\n\nawait store.export('exportResource')\n\nexpect(mockAnchor.click).toHaveBeenCalled()\nexpect(mockAnchor.download).toBe('export.perky')\nexpect(URL.revokeObjectURL).toHaveBeenCalled()\n\ndocument.createElement.mockRestore()\nURL.createObjectURL = originalCreateObjectURL\nURL.revokeObjectURL = originalRevokeObjectURL"
          },
          {
            "title": "rejects for non-existent resource",
            "line": 367,
            "source": "await expect(store.export('nonExistent')).rejects.toThrow('Resource not found')"
          }
        ],
        "describes": []
      },
      {
        "title": "import",
        "line": 374,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "imports .perky file with meta.json",
            "line": 376,
            "source": "const files = [\n    {name: 'meta.json', type: 'application/json', content: '{\"type\":\"animator\",\"name\":\"blue\"}'},\n    {name: 'blue.json', type: 'application/json', content: '{}'},\n    {name: 'blue.png', type: 'image/png', content: 'png data'}\n]\nconst perkyBlob = new Blob([JSON.stringify(files)], {type: 'application/octet-stream'})\n\nconst result = await store.import(perkyBlob)\n\nexpect(result.id).toBe('blueAnimator')\nexpect(result.type).toBe('animator')\nexpect(result.name).toBe('blue')"
          },
          {
            "title": "rejects file without meta.json",
            "line": 392,
            "source": "const files = [\n    {name: 'data.json', type: 'application/json', content: '{}'}\n]\nconst perkyBlob = new Blob([JSON.stringify(files)], {type: 'application/octet-stream'})\n\nawait expect(store.import(perkyBlob)).rejects.toThrow('Invalid .perky file: missing meta.json')"
          },
          {
            "title": "rejects meta.json without type",
            "line": 402,
            "source": "const files = [\n    {name: 'meta.json', type: 'application/json', content: '{\"name\":\"test\"}'}\n]\nconst perkyBlob = new Blob([JSON.stringify(files)], {type: 'application/octet-stream'})\n\nawait expect(store.import(perkyBlob)).rejects.toThrow('Invalid .perky file: meta.json must have type and name')"
          }
        ],
        "describes": []
      }
    ]
  },
  "/io/psd.doc.js": {
    "file": "/io/psd.test.js",
    "describes": [
      {
        "title": "parsePsd",
        "line": 72,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "parses minimal valid PSD",
            "line": 74,
            "source": "const buffer = createMinimalPsd()\nconst result = parsePsd(buffer)\n\nexpect(result.width).toBe(100)\nexpect(result.height).toBe(100)\nexpect(result.depth).toBe(8)\nexpect(result.colorMode).toBe('RGB')"
          },
          {
            "title": "parses PSD dimensions",
            "line": 84,
            "source": "const buffer = createMinimalPsd({width: 200, height: 150})\nconst result = parsePsd(buffer)\n\nexpect(result.width).toBe(200)\nexpect(result.height).toBe(150)"
          },
          {
            "title": "parses grayscale color mode",
            "line": 92,
            "source": "const buffer = createMinimalPsd({colorMode: 1})\nconst result = parsePsd(buffer)\n\nexpect(result.colorMode).toBe('Grayscale')"
          },
          {
            "title": "parses CMYK color mode",
            "line": 99,
            "source": "const buffer = createMinimalPsd({colorMode: 4})\nconst result = parsePsd(buffer)\n\nexpect(result.colorMode).toBe('CMYK')"
          },
          {
            "title": "throws on invalid signature",
            "line": 106,
            "source": "const buffer = new ArrayBuffer(26)\nconst view = new DataView(buffer)\nview.setUint8(0, 'X'.charCodeAt(0))\n\nexpect(() => parsePsd(buffer)).toThrow('Invalid PSD signature')"
          },
          {
            "title": "throws on unsupported version",
            "line": 114,
            "source": "const parts = []\nparts.push(stringToBytes('8BPS'))\nparts.push(uint16ToBytes(99))\nparts.push(new Uint8Array(20))\n\nexpect(() => parsePsd(concatBuffers(parts))).toThrow('Unsupported PSD version')"
          },
          {
            "title": "returns empty layers for minimal PSD",
            "line": 123,
            "source": "const buffer = createMinimalPsd()\nconst result = parsePsd(buffer)\n\nexpect(result.layers).toEqual([])"
          },
          {
            "title": "returns empty tree for minimal PSD",
            "line": 130,
            "source": "const buffer = createMinimalPsd()\nconst result = parsePsd(buffer)\n\nexpect(result.tree).toEqual([])"
          },
          {
            "title": "returns empty animations for minimal PSD",
            "line": 137,
            "source": "const buffer = createMinimalPsd()\nconst result = parsePsd(buffer)\n\nexpect(result.animations).toEqual({})"
          },
          {
            "title": "returns default sRGB color profile",
            "line": 144,
            "source": "const buffer = createMinimalPsd()\nconst result = parsePsd(buffer)\n\nexpect(result.colorProfile.name).toBe('sRGB')\nexpect(result.colorProfile.isP3).toBe(false)"
          }
        ],
        "describes": []
      },
      {
        "title": "layerToRGBA",
        "line": 155,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "returns null for empty layer",
            "line": 157,
            "source": "const layer = {\n    channelData: {},\n    width: 0,\n    height: 0,\n    left: 0,\n    top: 0\n}\n\nconst result = layerToRGBA(layer, 100, 100)\nexpect(result).toBeNull()"
          },
          {
            "title": "converts layer to RGBA with trim option",
            "line": 170,
            "source": "const layer = {\n    channelData: {\n        0: new Uint8Array([255, 0]),\n        1: new Uint8Array([0, 255]),\n        2: new Uint8Array([0, 0]),\n        [-1]: new Uint8Array([255, 255])\n    },\n    width: 2,\n    height: 1,\n    left: 10,\n    top: 20\n}\n\nconst result = layerToRGBA(layer, 100, 100, {trim: true})\n\nexpect(result.width).toBe(2)\nexpect(result.height).toBe(1)\nexpect(result.left).toBe(10)\nexpect(result.top).toBe(20)\nexpect(result.pixels[0]).toBe(255)\nexpect(result.pixels[1]).toBe(0)\nexpect(result.pixels[2]).toBe(0)\nexpect(result.pixels[3]).toBe(255)"
          },
          {
            "title": "converts layer to full canvas RGBA",
            "line": 196,
            "source": "const layer = {\n    channelData: {\n        0: new Uint8Array([255]),\n        1: new Uint8Array([128]),\n        2: new Uint8Array([64]),\n        [-1]: new Uint8Array([255])\n    },\n    width: 1,\n    height: 1,\n    left: 0,\n    top: 0\n}\n\nconst result = layerToRGBA(layer, 2, 2)\n\nexpect(result.width).toBe(2)\nexpect(result.height).toBe(2)\nexpect(result.pixels[0]).toBe(255)\nexpect(result.pixels[1]).toBe(128)\nexpect(result.pixels[2]).toBe(64)\nexpect(result.pixels[3]).toBe(255)"
          },
          {
            "title": "handles missing alpha channel",
            "line": 220,
            "source": "const layer = {\n    channelData: {\n        0: new Uint8Array([255]),\n        1: new Uint8Array([0]),\n        2: new Uint8Array([0])\n    },\n    width: 1,\n    height: 1,\n    left: 0,\n    top: 0\n}\n\nconst result = layerToRGBA(layer, 1, 1)\nexpect(result.pixels[3]).toBe(255)"
          },
          {
            "title": "handles layer positioned outside canvas bounds",
            "line": 237,
            "source": "const layer = {\n    channelData: {\n        0: new Uint8Array([255]),\n        1: new Uint8Array([0]),\n        2: new Uint8Array([0]),\n        [-1]: new Uint8Array([255])\n    },\n    width: 1,\n    height: 1,\n    left: -10,\n    top: -10\n}\n\nconst result = layerToRGBA(layer, 10, 10)\nexpect(result).not.toBeNull()\nexpect(result.width).toBe(10)\nexpect(result.height).toBe(10)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/io/psd_converter.doc.js": {
    "file": "/io/psd_converter.test.js",
    "describes": [
      {
        "title": "PsdConverter",
        "line": 35,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "creates instance",
            "line": 37,
            "source": "const converter = new PsdConverter()\nexpect(converter).toBeInstanceOf(PsdConverter)"
          },
          {
            "title": "has notifier methods",
            "line": 43,
            "source": "const converter = new PsdConverter()\nexpect(typeof converter.on).toBe('function')\nexpect(typeof converter.emit).toBe('function')\nexpect(typeof converter.off).toBe('function')"
          },
          {
            "title": "parse returns psd data",
            "line": 51,
            "source": "const converter = new PsdConverter()\nconst buffer = new ArrayBuffer(8)\n\nconst result = converter.parse(buffer)\n\nexpect(result).toBeDefined()\nexpect(result.width).toBe(64)\nexpect(result.height).toBe(64)"
          },
          {
            "title": "getAnimationGroups returns groups from tree",
            "line": 63,
            "source": "const {findAnimationGroups} = await import('./spritesheet.js')\nfindAnimationGroups.mockReturnValue([\n    {name: 'anim - idle'},\n    {name: 'anim - walk'}\n])\n\nconst converter = new PsdConverter()\nconst psd = {tree: []}\n\nconst groups = converter.getAnimationGroups(psd)\n\nexpect(groups).toHaveLength(2)\nexpect(findAnimationGroups).toHaveBeenCalledWith(psd.tree)"
          },
          {
            "title": "getAnimationInfo returns animation metadata",
            "line": 80,
            "source": "const {findAnimationGroups, parseAnimationName, countFrames} = await import('./spritesheet.js')\nfindAnimationGroups.mockReturnValue([\n    {name: 'anim - idle'},\n    {name: 'anim - walk'}\n])\nparseAnimationName.mockImplementation((name) => name.replace('anim - ', ''))\ncountFrames.mockReturnValue(4)\n\nconst converter = new PsdConverter()\nconst psd = {tree: []}\n\nconst info = converter.getAnimationInfo(psd)\n\nexpect(info).toHaveLength(2)\nexpect(info[0]).toEqual({name: 'idle', frameCount: 4})\nexpect(info[1]).toEqual({name: 'walk', frameCount: 4})"
          },
          {
            "title": "buildAnimatorConfig generates correct structure",
            "line": 100,
            "source": "const converter = new PsdConverter()\nconst animations = {\n    idle: ['idle/1', 'idle/2'],\n    walk: ['walk/1', 'walk/2', 'walk/3']\n}\n\nconst config = converter.buildAnimatorConfig('testSpritesheet', animations)\n\nexpect(config.spritesheet).toBe('testSpritesheet')\nexpect(config.anchor).toEqual({x: 0.5, y: 0.5})\nexpect(config.animations.idle.fps).toBe(10)\nexpect(config.animations.idle.loop).toBe(true)\nexpect(config.animations.idle.frames).toHaveLength(2)\nexpect(config.animations.idle.frames[0].source).toBe('testSpritesheet:idle/1')\nexpect(config.animations.walk.frames).toHaveLength(3)"
          },
          {
            "title": "emits progress events during convert",
            "line": 119,
            "source": "const {findAnimationGroups} = await import('./spritesheet.js')\nfindAnimationGroups.mockReturnValue([])\n\nconst converter = new PsdConverter()\nconst progressEvents = []\nconverter.on('progress', (e) => progressEvents.push(e))\n\nconst psd = {width: 64, height: 64, tree: [], filename: 'test'}\nawait converter.convert(psd)\n\nexpect(progressEvents.length).toBeGreaterThan(0)\nexpect(progressEvents[progressEvents.length - 1]).toEqual({stage: 'complete', percent: 100})"
          },
          {
            "title": "convert returns result with expected properties",
            "line": 135,
            "source": "const {findAnimationGroups} = await import('./spritesheet.js')\nfindAnimationGroups.mockReturnValue([])\n\nconst converter = new PsdConverter()\nconst psd = {width: 64, height: 64, tree: [], filename: 'test'}\n\nconst result = await converter.convert(psd, {name: 'mySprite'})\n\nexpect(result.name).toBe('mySprite')\nexpect(result.spritesheetName).toBe('mySpriteSpritesheet')\nexpect(result.atlases).toBeDefined()\nexpect(result.spritesheetJson).toBeDefined()\nexpect(result.animatorConfig).toBeDefined()"
          },
          {
            "title": "convert uses smooth resize by default",
            "line": 152,
            "source": "const {findAnimationGroups, resizeFrames} = await import('./spritesheet.js')\nfindAnimationGroups.mockReturnValue([])\nresizeFrames.mockClear()\n\nconst converter = new PsdConverter()\nconst psd = {width: 64, height: 64, tree: [], filename: 'test'}\n\nawait converter.convert(psd, {name: 'test', targetWidth: 32})\n\nexpect(resizeFrames).toHaveBeenCalledWith(\n    expect.anything(),\n    expect.objectContaining({nearest: false})\n)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/io/spritesheet.doc.js": {
    "file": "/io/spritesheet.test.js",
    "describes": [
      {
        "title": "constants",
        "line": 19,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "MAX_ATLAS_SIZE",
            "line": 21,
            "source": "expect(MAX_ATLAS_SIZE).toBe(4096)"
          },
          {
            "title": "PADDING",
            "line": 25,
            "source": "expect(PADDING).toBe(1)"
          }
        ],
        "describes": []
      },
      {
        "title": "isAnimationGroup",
        "line": 32,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "matches anim - prefix",
            "line": 34,
            "source": "expect(isAnimationGroup('anim - walk')).toBe(true)"
          },
          {
            "title": "matches anim prefix with space",
            "line": 38,
            "source": "expect(isAnimationGroup('anim walk')).toBe(true)"
          },
          {
            "title": "case insensitive",
            "line": 42,
            "source": "expect(isAnimationGroup('ANIM - run')).toBe(true)\nexpect(isAnimationGroup('Anim - jump')).toBe(true)"
          },
          {
            "title": "rejects non-animation groups",
            "line": 47,
            "source": "expect(isAnimationGroup('background')).toBe(false)\nexpect(isAnimationGroup('animation')).toBe(false)\nexpect(isAnimationGroup('my anim')).toBe(false)"
          }
        ],
        "describes": []
      },
      {
        "title": "findAnimationGroups",
        "line": 56,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "finds animation groups at root",
            "line": 58,
            "source": "const tree = [\n    {type: 'group', name: 'anim - walk', children: []},\n    {type: 'layer', name: 'background'}\n]\n\nconst groups = findAnimationGroups(tree)\nexpect(groups).toHaveLength(1)\nexpect(groups[0].name).toBe('anim - walk')"
          },
          {
            "title": "finds nested animation groups",
            "line": 69,
            "source": "const tree = [\n    {\n        type: 'group',\n        name: 'sprites',\n        children: [\n            {type: 'group', name: 'anim - idle', children: []}\n        ]\n    }\n]\n\nconst groups = findAnimationGroups(tree)\nexpect(groups).toHaveLength(1)\nexpect(groups[0].name).toBe('anim - idle')"
          },
          {
            "title": "does not recurse into animation groups",
            "line": 85,
            "source": "const tree = [\n    {\n        type: 'group',\n        name: 'anim - outer',\n        children: [\n            {type: 'group', name: 'anim - inner', children: []}\n        ]\n    }\n]\n\nconst groups = findAnimationGroups(tree)\nexpect(groups).toHaveLength(1)\nexpect(groups[0].name).toBe('anim - outer')"
          },
          {
            "title": "returns empty array when no animation groups",
            "line": 101,
            "source": "const tree = [\n    {type: 'group', name: 'misc', children: []},\n    {type: 'layer', name: 'bg'}\n]\n\nconst groups = findAnimationGroups(tree)\nexpect(groups).toHaveLength(0)"
          }
        ],
        "describes": []
      },
      {
        "title": "parseAnimationName",
        "line": 114,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "extracts name from anim - prefix",
            "line": 116,
            "source": "expect(parseAnimationName('anim - walk')).toBe('walk')"
          },
          {
            "title": "converts to camelCase",
            "line": 120,
            "source": "expect(parseAnimationName('anim - walk cycle')).toBe('walkCycle')"
          },
          {
            "title": "handles uppercase",
            "line": 124,
            "source": "expect(parseAnimationName('ANIM - JUMP')).toBe('jump')"
          },
          {
            "title": "returns original if no match",
            "line": 128,
            "source": "expect(parseAnimationName('other')).toBe('other')"
          }
        ],
        "describes": []
      },
      {
        "title": "parseFrameNumber",
        "line": 135,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "extracts leading number",
            "line": 137,
            "source": "expect(parseFrameNumber('01')).toBe('01')\nexpect(parseFrameNumber('1 frame')).toBe('1')\nexpect(parseFrameNumber('123_test')).toBe('123')"
          },
          {
            "title": "returns null for non-numeric",
            "line": 143,
            "source": "expect(parseFrameNumber('frame')).toBeNull()\nexpect(parseFrameNumber('_1')).toBeNull()"
          }
        ],
        "describes": []
      },
      {
        "title": "countFrames",
        "line": 151,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "counts layers with frame numbers",
            "line": 153,
            "source": "const group = {\n    children: [\n        {type: 'layer', name: '01'},\n        {type: 'layer', name: '02'},\n        {type: 'layer', name: '03'}\n    ]\n}\n\nexpect(countFrames(group)).toBe(3)"
          },
          {
            "title": "ignores non-layer children",
            "line": 165,
            "source": "const group = {\n    children: [\n        {type: 'layer', name: '01'},\n        {type: 'group', name: '02', children: []}\n    ]\n}\n\nexpect(countFrames(group)).toBe(1)"
          },
          {
            "title": "ignores layers without frame numbers",
            "line": 176,
            "source": "const group = {\n    children: [\n        {type: 'layer', name: '01'},\n        {type: 'layer', name: 'ref'}\n    ]\n}\n\nexpect(countFrames(group)).toBe(1)"
          }
        ],
        "describes": []
      },
      {
        "title": "extractFramesFromGroup",
        "line": 190,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "extracts frames sorted by number",
            "line": 192,
            "source": "const group = {\n    name: 'anim - walk',\n    children: [\n        {\n            type: 'layer',\n            name: '02',\n            layer: {\n                channelData: {0: new Uint8Array([255]), 1: new Uint8Array([0]), 2: new Uint8Array([0])},\n                width: 1,\n                height: 1,\n                left: 0,\n                top: 0\n            }\n        },\n        {\n            type: 'layer',\n            name: '01',\n            layer: {\n                channelData: {0: new Uint8Array([0]), 1: new Uint8Array([255]), 2: new Uint8Array([0])},\n                width: 1,\n                height: 1,\n                left: 0,\n                top: 0\n            }\n        }\n    ]\n}\n\nconst frames = extractFramesFromGroup(group, 10, 10)\n\nexpect(frames).toHaveLength(2)\nexpect(frames[0].frameNumber).toBe(1)\nexpect(frames[1].frameNumber).toBe(2)"
          },
          {
            "title": "skips layers without frame numbers",
            "line": 228,
            "source": "const group = {\n    name: 'anim - idle',\n    children: [\n        {\n            type: 'layer',\n            name: '01',\n            layer: {\n                channelData: {0: new Uint8Array([255]), 1: new Uint8Array([0]), 2: new Uint8Array([0])},\n                width: 1,\n                height: 1,\n                left: 0,\n                top: 0\n            }\n        },\n        {\n            type: 'layer',\n            name: 'reference',\n            layer: {\n                channelData: {},\n                width: 1,\n                height: 1,\n                left: 0,\n                top: 0\n            }\n        }\n    ]\n}\n\nconst frames = extractFramesFromGroup(group, 10, 10)\nexpect(frames).toHaveLength(1)"
          },
          {
            "title": "generates correct filenames",
            "line": 261,
            "source": "const group = {\n    name: 'anim - run',\n    children: [\n        {\n            type: 'layer',\n            name: '01',\n            layer: {\n                channelData: {0: new Uint8Array([255]), 1: new Uint8Array([0]), 2: new Uint8Array([0])},\n                width: 1,\n                height: 1,\n                left: 0,\n                top: 0\n            }\n        }\n    ]\n}\n\nconst frames = extractFramesFromGroup(group, 10, 10)\nexpect(frames[0].filename).toBe('run/1')\nexpect(frames[0].animName).toBe('run')"
          }
        ],
        "describes": []
      },
      {
        "title": "packFramesIntoAtlases",
        "line": 287,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "packs frames into single atlas",
            "line": 289,
            "source": "const frames = [\n    {filename: 'test/1', width: 32, height: 32, pixels: new Uint8Array(32 * 32 * 4)},\n    {filename: 'test/2', width: 32, height: 32, pixels: new Uint8Array(32 * 32 * 4)}\n]\n\nconst atlases = packFramesIntoAtlases(frames, 128, 0)\n\nexpect(atlases).toHaveLength(1)\nexpect(atlases[0].frames).toHaveLength(2)"
          },
          {
            "title": "creates new atlas when full",
            "line": 301,
            "source": "const frames = [\n    {filename: 'a', width: 64, height: 64, pixels: new Uint8Array(64 * 64 * 4)},\n    {filename: 'b', width: 64, height: 64, pixels: new Uint8Array(64 * 64 * 4)}\n]\n\nconst atlases = packFramesIntoAtlases(frames, 64, 0)\n\nexpect(atlases).toHaveLength(2)"
          },
          {
            "title": "assigns x, y coordinates to frames",
            "line": 312,
            "source": "const frames = [\n    {filename: 'test/1', width: 32, height: 32, pixels: new Uint8Array(32 * 32 * 4)}\n]\n\nconst atlases = packFramesIntoAtlases(frames, 128, 0)\n\nexpect(atlases[0].frames[0].x).toBeDefined()\nexpect(atlases[0].frames[0].y).toBeDefined()"
          },
          {
            "title": "assigns atlasIndex to frames",
            "line": 323,
            "source": "const frames = [\n    {filename: 'test/1', width: 32, height: 32, pixels: new Uint8Array(32 * 32 * 4)}\n]\n\nconst atlases = packFramesIntoAtlases(frames, 128, 0)\n\nexpect(atlases[0].frames[0].atlasIndex).toBe(0)"
          }
        ],
        "describes": []
      },
      {
        "title": "resizeFrame",
        "line": 336,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "resizes frame to target dimensions",
            "line": 338,
            "source": "const pixels = new Uint8Array(4 * 4 * 4)\npixels.fill(255)\n\nconst result = await resizeFrame({pixels, width: 4, height: 4}, 2, 2, false)\n\nexpect(result.width).toBe(2)\nexpect(result.height).toBe(2)\nexpect(result.pixels).toBeInstanceOf(Uint8Array)\nexpect(result.pixels.length).toBe(2 * 2 * 4)"
          },
          {
            "title": "uses nearest neighbor when specified",
            "line": 350,
            "source": "const pixels = new Uint8Array(4 * 4 * 4)\npixels.fill(255)\n\nconst result = await resizeFrame({pixels, width: 4, height: 4}, 8, 8, true)\n\nexpect(result.width).toBe(8)\nexpect(result.height).toBe(8)"
          }
        ],
        "describes": []
      },
      {
        "title": "resizeFrames",
        "line": 363,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "returns original frames when no resize needed",
            "line": 365,
            "source": "const frames = [\n    {filename: 'test/1', width: 10, height: 10, pixels: new Uint8Array(10 * 10 * 4)}\n]\n\nconst result = await resizeFrames(frames, {\n    psdWidth: 100,\n    psdHeight: 100,\n    targetWidth: 100,\n    targetHeight: 100\n})\n\nexpect(result).toBe(frames)"
          },
          {
            "title": "resizes all frames when dimensions differ",
            "line": 380,
            "source": "const pixels = new Uint8Array(10 * 10 * 4)\npixels.fill(255)\n\nconst frames = [\n    {filename: 'test/1', width: 10, height: 10, pixels},\n    {filename: 'test/2', width: 10, height: 10, pixels}\n]\n\nconst result = await resizeFrames(frames, {\n    psdWidth: 100,\n    psdHeight: 100,\n    targetWidth: 50,\n    targetHeight: 50\n})\n\nexpect(result).toHaveLength(2)\nexpect(result[0].width).toBe(50)\nexpect(result[0].height).toBe(50)\nexpect(result[0].filename).toBe('test/1')"
          },
          {
            "title": "preserves frame metadata after resize",
            "line": 402,
            "source": "const pixels = new Uint8Array(4 * 4 * 4)\n\nconst frames = [\n    {filename: 'walk/1', width: 4, height: 4, pixels, animName: 'walk', frameNumber: 1}\n]\n\nconst result = await resizeFrames(frames, {\n    psdWidth: 100,\n    psdHeight: 100,\n    targetWidth: 50,\n    targetHeight: 50\n})\n\nexpect(result[0].animName).toBe('walk')\nexpect(result[0].frameNumber).toBe(1)"
          }
        ],
        "describes": []
      },
      {
        "title": "compositeAtlas",
        "line": 423,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "creates canvas with specified dimensions",
            "line": 425,
            "source": "const canvas = await compositeAtlas([], 128, 256)\n\nexpect(canvas.width).toBe(128)\nexpect(canvas.height).toBe(256)"
          },
          {
            "title": "composites frames onto canvas",
            "line": 432,
            "source": "const pixels = new Uint8Array([255, 0, 0, 255])\n\nconst frames = [\n    {pixels, width: 1, height: 1, x: 0, y: 0}\n]\n\nconst canvas = await compositeAtlas(frames, 4, 4)\nconst ctx = canvas.getContext('2d')\nconst imageData = ctx.getImageData(0, 0, 1, 1)\n\nexpect(imageData.data[0]).toBe(255)\nexpect(imageData.data[1]).toBe(0)\nexpect(imageData.data[2]).toBe(0)\nexpect(imageData.data[3]).toBe(255)"
          },
          {
            "title": "places frames at correct positions",
            "line": 449,
            "source": "const redPixel = new Uint8Array([255, 0, 0, 255])\nconst greenPixel = new Uint8Array([0, 255, 0, 255])\n\nconst frames = [\n    {pixels: redPixel, width: 1, height: 1, x: 0, y: 0},\n    {pixels: greenPixel, width: 1, height: 1, x: 2, y: 2}\n]\n\nconst canvas = await compositeAtlas(frames, 4, 4)\nconst ctx = canvas.getContext('2d')\n\nconst redData = ctx.getImageData(0, 0, 1, 1)\nexpect(redData.data[0]).toBe(255)\nexpect(redData.data[1]).toBe(0)\n\nconst greenData = ctx.getImageData(2, 2, 1, 1)\nexpect(greenData.data[0]).toBe(0)\nexpect(greenData.data[1]).toBe(255)"
          }
        ],
        "describes": []
      },
      {
        "title": "nextPowerOfTwo",
        "line": 473,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "returns next power of two",
            "line": 475,
            "source": "expect(nextPowerOfTwo(1)).toBe(16)\nexpect(nextPowerOfTwo(17)).toBe(32)\nexpect(nextPowerOfTwo(33)).toBe(64)\nexpect(nextPowerOfTwo(65)).toBe(128)\nexpect(nextPowerOfTwo(129)).toBe(256)\nexpect(nextPowerOfTwo(257)).toBe(512)\nexpect(nextPowerOfTwo(513)).toBe(1024)\nexpect(nextPowerOfTwo(1025)).toBe(2048)\nexpect(nextPowerOfTwo(2049)).toBe(4096)"
          },
          {
            "title": "returns same if already power of two",
            "line": 487,
            "source": "expect(nextPowerOfTwo(16)).toBe(16)\nexpect(nextPowerOfTwo(32)).toBe(32)\nexpect(nextPowerOfTwo(64)).toBe(64)"
          },
          {
            "title": "caps at 4096",
            "line": 493,
            "source": "expect(nextPowerOfTwo(5000)).toBe(4096)"
          }
        ],
        "describes": []
      },
      {
        "title": "buildJsonData",
        "line": 500,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "builds JSON structure",
            "line": 502,
            "source": "const atlases = [\n    {\n        frames: [\n            {filename: 'walk/1', x: 0, y: 0, width: 32, height: 32}\n        ],\n        finalHeight: 64\n    }\n]\nconst animations = {walk: ['walk/1']}\n\nconst json = buildJsonData(atlases, animations, 'sprite')\n\nexpect(json.frames).toHaveLength(1)\nexpect(json.animations).toBe(animations)\nexpect(json.meta.app).toBe('perky-spritesheet')\nexpect(json.meta.images).toHaveLength(1)"
          },
          {
            "title": "uses custom app name",
            "line": 521,
            "source": "const atlases = [{frames: [], finalHeight: 64}]\n\nconst json = buildJsonData(atlases, {}, 'sprite', 'custom-app')\n\nexpect(json.meta.app).toBe('custom-app')"
          },
          {
            "title": "generates numbered filenames for multiple atlases",
            "line": 529,
            "source": "const atlases = [\n    {frames: [], finalHeight: 64},\n    {frames: [], finalHeight: 64}\n]\n\nconst json = buildJsonData(atlases, {}, 'sprite')\n\nexpect(json.meta.images[0].filename).toBe('sprite_0.png')\nexpect(json.meta.images[1].filename).toBe('sprite_1.png')"
          },
          {
            "title": "generates single filename for one atlas",
            "line": 541,
            "source": "const atlases = [{frames: [], finalHeight: 64}]\n\nconst json = buildJsonData(atlases, {}, 'sprite')\n\nexpect(json.meta.images[0].filename).toBe('sprite.png')"
          },
          {
            "title": "includes frame data with correct structure",
            "line": 549,
            "source": "const atlases = [\n    {\n        frames: [\n            {filename: 'idle/1', x: 10, y: 20, width: 32, height: 48}\n        ],\n        finalHeight: 128\n    }\n]\n\nconst json = buildJsonData(atlases, {}, 'test')\n\nexpect(json.frames[0]).toEqual({\n    filename: 'idle/1',\n    frame: {x: 10, y: 20, w: 32, h: 48},\n    sourceSize: {w: 32, h: 48},\n    atlas: 0\n})"
          }
        ],
        "describes": []
      }
    ]
  },
  "/service/service_client.doc.js": {
    "file": "/service/service_client.test.js",
    "describes": [
      {
        "title": "ServiceClient",
        "line": 7,
        "beforeEach": {
          "line": 12,
          "source": "transport = ServiceTransport.local()\nclient = new ServiceClient({transport})"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor with transport",
            "line": 18,
            "source": "expect(client.transport).toBe(transport)\nexpect(client.pendingRequests).toBeInstanceOf(Map)\nexpect(client.pendingRequests.size).toBe(0)"
          },
          {
            "title": "constructor with target",
            "line": 25,
            "source": "const target = {\n    postMessage: vi.fn(),\n    onmessage: null\n}\n\nconst clientWithTarget = new ServiceClient({target})\n\nexpect(clientWithTarget.transport).toBeInstanceOf(ServiceTransport)\nexpect(clientWithTarget.pendingRequests).toBeInstanceOf(Map)"
          },
          {
            "title": "constructor with no parameters uses auto transport",
            "line": 38,
            "source": "const clientAuto = new ServiceClient()\n\nexpect(clientAuto.transport).toBeInstanceOf(ServiceTransport)\nexpect(clientAuto.pendingRequests).toBeInstanceOf(Map)"
          },
          {
            "title": "request creates and sends service request",
            "line": 46,
            "source": "const transportSpy = vi.spyOn(transport, 'send')\n\nconst requestPromise = client.request('testAction', {param1: 'value1'})\n\nexpect(transportSpy).toHaveBeenCalledWith({\n    type: 'service-request',\n    request: expect.objectContaining({\n        action: 'testAction',\n        params: {param1: 'value1'},\n        id: expect.any(String),\n        timestamp: expect.any(Number)\n    })\n})\n\nexpect(client.pendingRequests.size).toBe(1)\n\nconst requestCall = transportSpy.mock.calls[0][0]\nconst requestId = requestCall.request.id\n\ntransportSpy.mockRestore()\n\nclient.handleMessage({\n    type: 'service-response',\n    response: {\n        requestId,\n        success: true,\n        data: {result: 'success'}\n    }\n})\n\nconst result = await requestPromise\nexpect(result).toEqual({result: 'success'})"
          },
          {
            "title": "request with default parameters",
            "line": 82,
            "source": "const transportSpy = vi.spyOn(transport, 'send')\n\nconst requestPromise = client.request('testAction')\n\nexpect(transportSpy).toHaveBeenCalledWith({\n    type: 'service-request',\n    request: expect.objectContaining({\n        action: 'testAction',\n        params: {},\n        id: expect.any(String),\n        timestamp: expect.any(Number)\n    })\n})\n\nconst requestCall = transportSpy.mock.calls[0][0]\nconst requestId = requestCall.request.id\n\ntransportSpy.mockRestore()\n\nclient.handleMessage({\n    type: 'service-response',\n    response: {\n        requestId,\n        success: true,\n        data: null\n    }\n})\n\nconst result = await requestPromise\nexpect(result).toBeNull()"
          },
          {
            "title": "request timeout",
            "line": 116,
            "source": "const requestPromise = client.request('testAction', {}, 100)\n\nawait expect(requestPromise).rejects.toThrow(\"Request timeout for action 'testAction'\")\nexpect(client.pendingRequests.size).toBe(0)"
          },
          {
            "title": "request success response",
            "line": 124,
            "source": "const requestPromise = client.request('testAction')\n\nconst pendingRequest = Array.from(client.pendingRequests.keys())[0]\n\nclient.handleMessage({\n    type: 'service-response',\n    response: {\n        requestId: pendingRequest,\n        success: true,\n        data: {result: 'success', value: 42}\n    }\n})\n\nconst result = await requestPromise\nexpect(result).toEqual({result: 'success', value: 42})\nexpect(client.pendingRequests.size).toBe(0)"
          },
          {
            "title": "request error response",
            "line": 144,
            "source": "const requestPromise = client.request('testAction')\n\nconst pendingRequest = Array.from(client.pendingRequests.keys())[0]\n\nclient.handleMessage({\n    type: 'service-response',\n    response: {\n        requestId: pendingRequest,\n        success: false,\n        error: 'Something went wrong'\n    }\n})\n\nawait expect(requestPromise).rejects.toThrow('Something went wrong')\nexpect(client.pendingRequests.size).toBe(0)"
          },
          {
            "title": "handleMessage ignores non-service-response messages",
            "line": 163,
            "source": "client.request('testAction')\n\nclient.handleMessage({type: 'other-message'})\nclient.handleMessage({type: 'service-request'})\n\nexpect(client.pendingRequests.size).toBe(1)"
          },
          {
            "title": "handleMessage ignores unknown request ids",
            "line": 173,
            "source": "client.request('testAction')\n\nclient.handleMessage({\n    type: 'service-response',\n    response: {\n        requestId: 'unknown-id',\n        success: true,\n        data: null\n    }\n})\n\nexpect(client.pendingRequests.size).toBe(1)"
          },
          {
            "title": "multiple concurrent requests",
            "line": 189,
            "source": "const request1 = client.request('action1', {input: 1})\nconst request2 = client.request('action2', {input: 2})\nconst request3 = client.request('action3', {input: 3})\n\nexpect(client.pendingRequests.size).toBe(3)\n\nconst requestIds = Array.from(client.pendingRequests.keys())\n\nclient.handleMessage({\n    type: 'service-response',\n    response: {\n        requestId: requestIds[1],\n        success: true,\n        data: {output: 2}\n    }\n})\n\nclient.handleMessage({\n    type: 'service-response',\n    response: {\n        requestId: requestIds[0],\n        success: true,\n        data: {output: 1}\n    }\n})\n\nclient.handleMessage({\n    type: 'service-response',\n    response: {\n        requestId: requestIds[2],\n        success: false,\n        error: 'Error in action3'\n    }\n})\n\nconst [result1, result2] = await Promise.allSettled([request1, request2])\n\nexpect(result1.status).toBe('fulfilled')\nexpect(result1.value).toEqual({output: 1})\n\nexpect(result2.status).toBe('fulfilled')\nexpect(result2.value).toEqual({output: 2})\n\nawait expect(request3).rejects.toThrow('Error in action3')\nexpect(client.pendingRequests.size).toBe(0)"
          },
          {
            "title": "full client-host integration",
            "line": 238,
            "source": "const [transportA, transportB] = ServiceTransport.pair()\nconst clientA = new ServiceClient({transport: transportA})\nconst hostB = new ServiceHost({transport: transportB})\n\nhostB.register('echo', (req, res) => {\n    res.send({echo: req.params.message, timestamp: req.timestamp})\n})\n\nhostB.register('calculate', (req, res) => {\n    const {a, b, operation} = req.params\n    if (operation === 'add') {\n        res.send({result: a + b})\n    } else {\n        res.error('Unsupported operation')\n    }\n})\n\nconst echoResult = await clientA.request('echo', {message: 'hello world'})\nexpect(echoResult.echo).toBe('hello world')\nexpect(echoResult.timestamp).toBeDefined()\n\nconst calcResult = await clientA.request('calculate', {a: 5, b: 3, operation: 'add'})\nexpect(calcResult).toEqual({result: 8})\n\nawait expect(\n    clientA.request('calculate', {a: 5, b: 3, operation: 'multiply'})\n).rejects.toThrow('Unsupported operation')\n\nawait expect(\n    clientA.request('unknownAction')\n).rejects.toThrow(\"Action 'unknownAction' not found\")"
          },
          {
            "title": "timeout cleanup with custom timeout",
            "line": 273,
            "source": "const shortTimeoutPromise = client.request('testAction', {}, 50)\n\nexpect(client.pendingRequests.size).toBe(1)\n\nawait expect(shortTimeoutPromise).rejects.toThrow(\"Request timeout for action 'testAction'\")\nexpect(client.pendingRequests.size).toBe(0)"
          },
          {
            "title": "request id uniqueness",
            "line": 283,
            "source": "const transportSpy = vi.spyOn(transport, 'send')\n\nclient.request('action1')\nclient.request('action2')\nclient.request('action3')\n\nconst calls = transportSpy.mock.calls\nconst ids = calls.map(call => call[0].request.id)\n\nexpect(new Set(ids).size).toBe(3)\n\ntransportSpy.mockRestore()"
          },
          {
            "title": "inherits from PerkyModule and has Notifier methods",
            "line": 299,
            "source": "expect(typeof client.on).toBe('function')\nexpect(typeof client.emit).toBe('function')\nexpect(typeof client.off).toBe('function')\nexpect(typeof client.start).toBe('function')\nexpect(typeof client.dispose).toBe('function')"
          },
          {
            "title": "has $category defined",
            "line": 308,
            "source": "expect(ServiceClient.$category).toBe('serviceClient')"
          },
          {
            "title": "emitToHost sends service-event message",
            "line": 313,
            "source": "const transportSpy = vi.spyOn(transport, 'send')\n\nclient.emitToHost('userAction', 'click', {x: 100, y: 200})\n\nexpect(transportSpy).toHaveBeenCalledWith({\n    type: 'service-event',\n    eventName: 'userAction',\n    args: ['click', {x: 100, y: 200}],\n    direction: 'client-to-host'\n})\n\ntransportSpy.mockRestore()"
          },
          {
            "title": "handleEvent from host triggers local event with prefix",
            "line": 329,
            "source": "const eventHandler = vi.fn()\nclient.on('host:statusUpdate', eventHandler)\n\nconst message = {\n    type: 'service-event',\n    eventName: 'statusUpdate',\n    args: ['connected', 'ready'],\n    direction: 'host-to-client'\n}\n\nclient.handleMessage(message)\n\nexpect(eventHandler).toHaveBeenCalledWith('connected', 'ready')"
          },
          {
            "title": "handleEvent ignores wrong direction",
            "line": 346,
            "source": "const eventHandler = vi.fn()\nclient.on('host:statusUpdate', eventHandler)\n\nconst message = {\n    type: 'service-event',\n    eventName: 'statusUpdate',\n    args: ['connected', 'ready'],\n    direction: 'client-to-host'\n}\n\nclient.handleMessage(message)\n\nexpect(eventHandler).not.toHaveBeenCalled()"
          },
          {
            "title": "full event communication with host",
            "line": 363,
            "source": "const [transportA, transportB] = ServiceTransport.pair()\nconst clientA = new ServiceClient({transport: transportA})\nconst hostB = new ServiceHost({transport: transportB})\n\nconst clientEventHandler = vi.fn()\nconst hostEventHandler = vi.fn()\n\nclientA.on('host:notification', clientEventHandler)\nhostB.on('client:userInput', hostEventHandler)\n\nclientA.emitToHost('userInput', 'keypress', 'Enter')\nhostB.emitToClient('notification', 'Process completed', 'success')\n\nexpect(hostEventHandler).toHaveBeenCalledWith('keypress', 'Enter')\nexpect(clientEventHandler).toHaveBeenCalledWith('Process completed', 'success')"
          },
          {
            "title": "fromService creates client and host with paired transport",
            "line": 382,
            "source": "class TestService extends ServiceHost {\n    static serviceMethods = ['test']\n\n    test (req, res) {\n        res.send({message: 'direct service'})\n    }\n}\n\nconst clientA = await ServiceClient.fromService(TestService, {config: 'test'})\n\nexpect(clientA).toBeInstanceOf(ServiceClient)\nexpect(clientA.serviceHost).toBeInstanceOf(TestService)\n\nconst result = await clientA.request('test')\nexpect(result.message).toBe('direct service')"
          },
          {
            "title": "fromPath imports and creates service",
            "line": 401,
            "source": "class MockService extends ServiceHost {\n    static serviceMethods = ['mock']\n\n    mock (req, res) {  \n        res.send({type: 'mocked'})\n    }\n}\n\nvi.doMock('./mock-service.js', () => ({\n    default: MockService\n}))\n\nconst clientA = await ServiceClient.fromPath('./mock-service.js')\n\nexpect(clientA).toBeInstanceOf(ServiceClient)\nexpect(clientA.serviceHost).toBeInstanceOf(MockService)\n\nconst result = await clientA.request('mock')\nexpect(result.type).toBe('mocked')\n\nvi.doUnmock('./mock-service.js')"
          },
          {
            "title": "fromPath handles module without default export",
            "line": 426,
            "source": "class TestService extends ServiceHost {\n    static serviceMethods = ['test']\n\n    test (req, res) {  \n        res.send({exported: 'named'})\n    }\n}\n\nvi.doMock('./named-export-service.js', () => ({\n    default: undefined,\n    TestService\n}))\n\nconst clientA = await ServiceClient.fromPath('./named-export-service.js')\n\nconst result = await clientA.request('test')\nexpect(result.exported).toBe('named')\n\nvi.doUnmock('./named-export-service.js')"
          },
          {
            "title": "from() with worker option",
            "line": 449,
            "source": "const mockWorker = {\n    postMessage: vi.fn(),\n    onmessage: null\n}\n\nglobal.Worker = vi.fn().mockReturnValue(mockWorker)\nglobal.URL = vi.fn().mockReturnValue('mocked-url')\n\nconst clientA = ServiceClient.from({\n    worker: './test-service.js',\n    config: {precision: 'high'}\n})\n\nexpect(clientA).toBeInstanceOf(ServiceClient)\nexpect(global.Worker).toHaveBeenCalled()\nexpect(mockWorker.postMessage).toHaveBeenCalledWith({\n    type: 'init-service',\n    servicePath: './test-service.js',\n    config: {precision: 'high'}\n})\n\nglobal.Worker.mockRestore()\nglobal.URL.mockRestore()"
          },
          {
            "title": "from() with service option",
            "line": 476,
            "source": "class TestService extends ServiceHost {\n    static serviceMethods = ['test']\n    test (req, res) {  \n        res.send({type: 'unified'})\n    }\n}\n\nconst clientA = await ServiceClient.from({\n    service: TestService,\n    config: {mode: 'test'}\n})\n\nexpect(clientA).toBeInstanceOf(ServiceClient)\nexpect(clientA.serviceHost).toBeInstanceOf(TestService)\n\nconst result = await clientA.request('test')\nexpect(result.type).toBe('unified')"
          },
          {
            "title": "from() with path option",
            "line": 497,
            "source": "class PathService extends ServiceHost {\n    static serviceMethods = ['pathTest']\n    pathTest (req, res) {  \n        res.send({loaded: 'dynamically'})\n    }\n}\n\nvi.doMock('./dynamic-service.js', () => ({\n    default: PathService\n}))\n\nconst clientA = await ServiceClient.from({\n    path: './dynamic-service.js',\n    config: {dynamic: true}\n})\n\nconst result = await clientA.request('pathTest')\nexpect(result.loaded).toBe('dynamically')\n\nvi.doUnmock('./dynamic-service.js')"
          },
          {
            "title": "from() throws error with no options",
            "line": 521,
            "source": "expect(() => ServiceClient.from({})).toThrow(\n    'ServiceClient.from() requires one of: worker, service, or path'\n)"
          },
          {
            "title": "from() throws error with multiple options",
            "line": 528,
            "source": "class TestService extends ServiceHost { }\n\nexpect(() => ServiceClient.from({\n    worker: './worker.js',\n    service: TestService\n})).toThrow(\n    'ServiceClient.from() requires exactly one option: worker, service, or path'\n)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/service/service_host.doc.js": {
    "file": "/service/service_host.test.js",
    "describes": [
      {
        "title": "ServiceHost",
        "line": 8,
        "beforeEach": {
          "line": 13,
          "source": "transport = ServiceTransport.local()\nhost = new ServiceHost({transport})"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor with transport",
            "line": 19,
            "source": "expect(host.transport).toBe(transport)\nexpect(host.actions).toBeInstanceOf(Map)\nexpect(host.actions.size).toBe(0)"
          },
          {
            "title": "constructor with target",
            "line": 26,
            "source": "const target = {\n    postMessage: vi.fn(),\n    onmessage: null\n}\n\nconst hostWithTarget = new ServiceHost({target})\n\nexpect(hostWithTarget.transport).toBeInstanceOf(ServiceTransport)\nexpect(hostWithTarget.actions).toBeInstanceOf(Map)"
          },
          {
            "title": "constructor with no parameters uses auto transport",
            "line": 39,
            "source": "const hostAuto = new ServiceHost()\n\nexpect(hostAuto.transport).toBeInstanceOf(ServiceTransport)\nexpect(hostAuto.actions).toBeInstanceOf(Map)"
          },
          {
            "title": "register action",
            "line": 47,
            "source": "const handler = vi.fn()\n\nconst result = host.register('testAction', handler)\n\nexpect(result).toBe(host)\nexpect(host.actions.get('testAction')).toBe(handler)"
          },
          {
            "title": "unregister action",
            "line": 57,
            "source": "const handler = vi.fn()\n\nhost.register('testAction', handler)\nexpect(host.actions.has('testAction')).toBe(true)\n\nconst result = host.unregister('testAction')\n\nexpect(result).toBe(host)\nexpect(host.actions.has('testAction')).toBe(false)"
          },
          {
            "title": "handleMessage ignores non-service-request messages",
            "line": 70,
            "source": "const handler = vi.fn()\nhost.register('testAction', handler)\n\nhost.handleMessage({type: 'other-message'})\nhost.handleMessage({type: 'service-response'})\n\nexpect(handler).not.toHaveBeenCalled()"
          },
          {
            "title": "handleMessage with valid service request",
            "line": 81,
            "source": "const handler = vi.fn()\nconst sendSpy = vi.spyOn(host, 'sendResponse')\n\nhost.register('testAction', handler)\n\nconst request = new ServiceRequest('testAction', {param1: 'value1'})\nconst message = {\n    type: 'service-request',\n    request: request.export()\n}\n\nhost.handleMessage(message)\n\nexpect(handler).toHaveBeenCalledWith(\n    {\n        id: request.id,\n        action: 'testAction',\n        params: {param1: 'value1'},\n        timestamp: request.timestamp\n    },\n    expect.objectContaining({\n        send: expect.any(Function),\n        error: expect.any(Function)\n    })\n)\n\nsendSpy.mockRestore()"
          },
          {
            "title": "handleMessage with unknown action",
            "line": 112,
            "source": "const sendSpy = vi.spyOn(host, 'sendResponse')\n\nconst request = new ServiceRequest('unknownAction')\nconst message = {\n    type: 'service-request',\n    request: request.export()\n}\n\nhost.handleMessage(message)\n\nexpect(sendSpy).toHaveBeenCalledWith(\n    expect.objectContaining({\n        requestId: request.id,\n        success: false,\n        error: \"Action 'unknownAction' not found\"\n    })\n)\n\nsendSpy.mockRestore()"
          },
          {
            "title": "action handler success response",
            "line": 135,
            "source": "const sendSpy = vi.spyOn(host, 'sendResponse')\n\nhost.register('testAction', (req, res) => {\n    res.send({result: 'success', data: req.params.input})\n})\n\nconst request = new ServiceRequest('testAction', {input: 'test data'})\nconst message = {\n    type: 'service-request',\n    request: request.export()\n}\n\nhost.handleMessage(message)\n\nexpect(sendSpy).toHaveBeenCalledWith(\n    expect.objectContaining({\n        requestId: request.id,\n        success: true,\n        data: {result: 'success', data: 'test data'}\n    })\n)\n\nsendSpy.mockRestore()"
          },
          {
            "title": "action handler error response",
            "line": 162,
            "source": "const sendSpy = vi.spyOn(host, 'sendResponse')\n\nhost.register('testAction', (req, res) => {\n    res.error('Something went wrong')\n})\n\nconst request = new ServiceRequest('testAction')\nconst message = {\n    type: 'service-request',\n    request: request.export()\n}\n\nhost.handleMessage(message)\n\nexpect(sendSpy).toHaveBeenCalledWith(\n    expect.objectContaining({\n        requestId: request.id,\n        success: false,\n        error: 'Something went wrong'\n    })\n)\n\nsendSpy.mockRestore()"
          },
          {
            "title": "action handler exception handling",
            "line": 189,
            "source": "const sendSpy = vi.spyOn(host, 'sendResponse')\n\nhost.register('testAction', () => {\n    throw new Error('Handler crashed')\n})\n\nconst request = new ServiceRequest('testAction')\nconst message = {\n    type: 'service-request',\n    request: request.export()\n}\n\nhost.handleMessage(message)\n\nexpect(sendSpy).toHaveBeenCalledWith(\n    expect.objectContaining({\n        requestId: request.id,\n        success: false,\n        error: 'Handler crashed'\n    })\n)\n\nsendSpy.mockRestore()"
          },
          {
            "title": "sendResponse",
            "line": 216,
            "source": "const transportSpy = vi.spyOn(transport, 'send')\nconst response = new ServiceResponse('test-request-id')\nresponse.send({result: 'test'})\n\nhost.sendResponse(response)\n\nexpect(transportSpy).toHaveBeenCalledWith({\n    type: 'service-response',\n    response: response.export()\n})\n\ntransportSpy.mockRestore()"
          },
          {
            "title": "full request-response cycle",
            "line": 232,
            "source": "const [transportA, transportB] = ServiceTransport.pair()\nconst hostA = new ServiceHost({transport: transportA})\n\nhostA.register('echo', (req, res) => {\n    res.send({echo: req.params.message})\n})\n\nconst responseHandler = vi.fn()\ntransportB.onMessage(responseHandler)\n\nconst request = new ServiceRequest('echo', {message: 'hello world'})\nconst message = {\n    type: 'service-request',\n    request: request.export()\n}\n\ntransportB.send(message)\n\nexpect(responseHandler).toHaveBeenCalledWith({\n    type: 'service-response',\n    response: expect.objectContaining({\n        requestId: request.id,\n        success: true,\n        data: {echo: 'hello world'}\n    })\n})"
          },
          {
            "title": "multiple action registrations",
            "line": 262,
            "source": "const handler1 = vi.fn((req, res) => res.send('result1'))\nconst handler2 = vi.fn((req, res) => res.send('result2'))\n\nhost.register('action1', handler1)\nhost.register('action2', handler2)\n\nexpect(host.actions.size).toBe(2)\nexpect(host.actions.get('action1')).toBe(handler1)\nexpect(host.actions.get('action2')).toBe(handler2)"
          },
          {
            "title": "overwrite action registration",
            "line": 275,
            "source": "const handler1 = vi.fn()\nconst handler2 = vi.fn()\n\nhost.register('testAction', handler1)\nhost.register('testAction', handler2)\n\nexpect(host.actions.size).toBe(1)\nexpect(host.actions.get('testAction')).toBe(handler2)"
          },
          {
            "title": "inherits from PerkyModule and has Notifier methods",
            "line": 287,
            "source": "expect(typeof host.on).toBe('function')\nexpect(typeof host.emit).toBe('function')\nexpect(typeof host.off).toBe('function')\nexpect(typeof host.start).toBe('function')\nexpect(typeof host.dispose).toBe('function')"
          },
          {
            "title": "has $category defined",
            "line": 296,
            "source": "expect(ServiceHost.$category).toBe('serviceHost')"
          },
          {
            "title": "emitToClient sends service-event message",
            "line": 301,
            "source": "const transportSpy = vi.spyOn(transport, 'send')\n\nhost.emitToClient('testEvent', 'arg1', 'arg2', 42)\n\nexpect(transportSpy).toHaveBeenCalledWith({\n    type: 'service-event',\n    eventName: 'testEvent',\n    args: ['arg1', 'arg2', 42],\n    direction: 'host-to-client'\n})\n\ntransportSpy.mockRestore()"
          },
          {
            "title": "handleEvent from client triggers local event with prefix",
            "line": 317,
            "source": "const eventHandler = vi.fn()\nhost.on('client:testEvent', eventHandler)\n\nconst message = {\n    type: 'service-event',\n    eventName: 'testEvent',\n    args: ['hello', 'world'],\n    direction: 'client-to-host'\n}\n\nhost.handleMessage(message)\n\nexpect(eventHandler).toHaveBeenCalledWith('hello', 'world')"
          },
          {
            "title": "handleEvent ignores wrong direction",
            "line": 334,
            "source": "const eventHandler = vi.fn()\nhost.on('client:testEvent', eventHandler)\n\nconst message = {\n    type: 'service-event',\n    eventName: 'testEvent',\n    args: ['hello', 'world'],\n    direction: 'host-to-client'\n}\n\nhost.handleMessage(message)\n\nexpect(eventHandler).not.toHaveBeenCalled()"
          },
          {
            "title": "event communication with client",
            "line": 351,
            "source": "const [transportA, transportB] = ServiceTransport.pair()\nconst hostA = new ServiceHost({transport: transportA})\n\nconst clientEventHandler = vi.fn()\ntransportB.onMessage((message) => {\n    if (message.type === 'service-event' && message.direction === 'host-to-client') {\n        clientEventHandler(message.eventName, ...message.args)\n    }\n})\n\nhostA.emitToClient('dataUpdate', {id: 1, name: 'test'})\n\nexpect(clientEventHandler).toHaveBeenCalledWith('dataUpdate', {id: 1, name: 'test'})"
          },
          {
            "title": "registerMethod registers method by name",
            "line": 368,
            "source": "const [transportA] = ServiceTransport.pair()\nnew ServiceHost({transport: transportA})\n\nhost.testMethod = vi.fn()\nhost.registerMethod('testMethod')\n\nexpect(host.actions.has('testMethod')).toBe(true)\nexpect(typeof host.actions.get('testMethod')).toBe('function')"
          },
          {
            "title": "registerMethod throws error for non-existent method",
            "line": 380,
            "source": "const [transportA] = ServiceTransport.pair()\nnew ServiceHost({transport: transportA})\n\nexpect(() => {\n    host.registerMethod('nonExistentMethod')\n}).toThrow(\"Method 'nonExistentMethod' not found on service\")"
          },
          {
            "title": "registerMethod with method call",
            "line": 390,
            "source": "const [transportA, transportB] = ServiceTransport.pair()\nconst hostA = new ServiceHost({transport: transportA})\n\nhostA.echo = (req, res) => {\n    res.send({message: req.params.text})\n}\n\nhostA.registerMethod('echo')\n\nconst request = new ServiceRequest('echo', {text: 'hello'})\nconst responseHandler = vi.fn()\ntransportB.onMessage(responseHandler)\n\ntransportB.send({\n    type: 'service-request',\n    request: request.export()\n})\n\nexpect(responseHandler).toHaveBeenCalledWith({\n    type: 'service-response',\n    response: expect.objectContaining({\n        requestId: request.id,\n        success: true,\n        data: {message: 'hello'}\n    })\n})"
          },
          {
            "title": "auto-registers methods from static serviceMethods",
            "line": 420,
            "source": "class TestService extends ServiceHost {\n    static serviceMethods = ['methodA', 'methodB']\n\n    methodA () {\n        return this\n    }\n    methodB () {\n        return this\n    }\n}\n\nconst [transportA] = ServiceTransport.pair()\nconst service = new TestService({transport: transportA})\n\nexpect(service.actions.has('methodA')).toBe(true)\nexpect(service.actions.has('methodB')).toBe(true)\nexpect(service.actions.size).toBe(2)"
          },
          {
            "title": "ignores invalid serviceMethods",
            "line": 441,
            "source": "class TestService extends ServiceHost {\n    static serviceMethods = 'not an array'\n}\n\nconst [transportA] = ServiceTransport.pair()\n\nexpect(() => {\n    new TestService({transport: transportA})\n}).not.toThrow()"
          },
          {
            "title": "serviceMethods works with inheritance",
            "line": 454,
            "source": "class BaseService extends ServiceHost {\n    static serviceMethods = ['baseMethod']\n\n    baseMethod () {\n        return this\n    }\n}\n\nclass ChildService extends BaseService {\n    static serviceMethods = ['childMethod']\n\n    childMethod () {\n        return this\n    }\n}\n\nconst [transportA] = ServiceTransport.pair()\nconst childService = new ChildService({transport: transportA})\n\nexpect(childService.actions.has('childMethod')).toBe(true)\nexpect(childService.actions.has('baseMethod')).toBe(false)\nexpect(childService.actions.size).toBe(1)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/service/service_request.doc.js": {
    "file": "/service/service_request.test.js",
    "describes": [
      {
        "title": "ServiceRequest",
        "line": 4,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "constructor",
            "line": 6,
            "source": "const request = new ServiceRequest('testAction', {param1: 'value1'})\n\nexpect(request.action).toBe('testAction')\nexpect(request.params).toEqual({param1: 'value1'})\nexpect(request.id).toBeDefined()\nexpect(typeof request.id).toBe('string')\nexpect(request.timestamp).toBeDefined()\nexpect(typeof request.timestamp).toBe('number')"
          },
          {
            "title": "constructor with no params",
            "line": 18,
            "source": "const request = new ServiceRequest('testAction')\n\nexpect(request.action).toBe('testAction')\nexpect(request.params).toEqual({})\nexpect(request.id).toBeDefined()\nexpect(request.timestamp).toBeDefined()"
          },
          {
            "title": "unique ids",
            "line": 28,
            "source": "const request1 = new ServiceRequest('action1')\nconst request2 = new ServiceRequest('action2')\n\nexpect(request1.id).not.toBe(request2.id)"
          },
          {
            "title": "export",
            "line": 36,
            "source": "const request = new ServiceRequest('testAction', {param1: 'value1'})\nconst json = request.export()\n\nexpect(json).toEqual({\n    id: request.id,\n    action: 'testAction',\n    params: {param1: 'value1'},\n    timestamp: request.timestamp\n})"
          },
          {
            "title": "import",
            "line": 49,
            "source": "const data = {\n    id: 'test-id',\n    action: 'testAction',\n    params: {param1: 'value1'},\n    timestamp: 1234567890\n}\n\nconst request = ServiceRequest.import(data)\n\nexpect(request.id).toBe('test-id')\nexpect(request.action).toBe('testAction')\nexpect(request.params).toEqual({param1: 'value1'})\nexpect(request.timestamp).toBe(1234567890)"
          },
          {
            "title": "import creates new instance",
            "line": 66,
            "source": "const data = {\n    id: 'test-id',\n    action: 'testAction',\n    params: {},\n    timestamp: 1234567890\n}\n\nconst request = ServiceRequest.import(data)\n\nexpect(request).toBeInstanceOf(ServiceRequest)"
          },
          {
            "title": "export and import roundtrip",
            "line": 80,
            "source": "const originalRequest = new ServiceRequest('testAction', {param1: 'value1'})\nconst json = originalRequest.export()\nconst restoredRequest = ServiceRequest.import(json)\n\nexpect(restoredRequest.id).toBe(originalRequest.id)\nexpect(restoredRequest.action).toBe(originalRequest.action)\nexpect(restoredRequest.params).toEqual(originalRequest.params)\nexpect(restoredRequest.timestamp).toBe(originalRequest.timestamp)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/service/service_response.doc.js": {
    "file": "/service/service_response.test.js",
    "describes": [
      {
        "title": "ServiceResponse",
        "line": 4,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "constructor",
            "line": 6,
            "source": "const response = new ServiceResponse('test-request-id')\n\nexpect(response.requestId).toBe('test-request-id')\nexpect(response.success).toBe(true)\nexpect(response.data).toBeNull()\nexpect(response.error).toBeNull()"
          },
          {
            "title": "send with data",
            "line": 16,
            "source": "const response = new ServiceResponse('test-request-id')\nconst testData = {result: 'success', value: 42}\n\nconst returnValue = response.send(testData)\n\nexpect(response.success).toBe(true)\nexpect(response.data).toBe(testData)\nexpect(response.error).toBeNull()\nexpect(returnValue).toBe(response)"
          },
          {
            "title": "send with null data",
            "line": 29,
            "source": "const response = new ServiceResponse('test-request-id')\n\nresponse.send(null)\n\nexpect(response.success).toBe(true)\nexpect(response.data).toBeNull()\nexpect(response.error).toBeNull()"
          },
          {
            "title": "send with undefined data",
            "line": 40,
            "source": "const response = new ServiceResponse('test-request-id')\n\nresponse.send(undefined)\n\nexpect(response.success).toBe(true)\nexpect(response.data).toBeUndefined()\nexpect(response.error).toBeNull()"
          },
          {
            "title": "fail with error message",
            "line": 51,
            "source": "const response = new ServiceResponse('test-request-id')\nconst errorMessage = 'Something went wrong'\n\nconst returnValue = response.fail(errorMessage)\n\nexpect(response.success).toBe(false)\nexpect(response.data).toBeNull()\nexpect(response.error).toBe(errorMessage)\nexpect(returnValue).toBe(response)"
          },
          {
            "title": "fail with error object",
            "line": 64,
            "source": "const response = new ServiceResponse('test-request-id')\nconst error = new Error('Test error')\n\nresponse.fail(error)\n\nexpect(response.success).toBe(false)\nexpect(response.data).toBeNull()\nexpect(response.error).toBe(error)"
          },
          {
            "title": "export success response",
            "line": 76,
            "source": "const response = new ServiceResponse('test-request-id')\nconst testData = {result: 'success'}\n\nresponse.send(testData)\nconst json = response.export()\n\nexpect(json).toEqual({\n    requestId: 'test-request-id',\n    success: true,\n    data: testData,\n    error: null\n})"
          },
          {
            "title": "export error response",
            "line": 92,
            "source": "const response = new ServiceResponse('test-request-id')\nconst errorMessage = 'Test error'\n\nresponse.fail(errorMessage)\nconst json = response.export()\n\nexpect(json).toEqual({\n    requestId: 'test-request-id',\n    success: false,\n    data: null,\n    error: errorMessage\n})"
          },
          {
            "title": "export default response",
            "line": 108,
            "source": "const response = new ServiceResponse('test-request-id')\nconst json = response.export()\n\nexpect(json).toEqual({\n    requestId: 'test-request-id',\n    success: true,\n    data: null,\n    error: null\n})"
          },
          {
            "title": "overwrite success with fail",
            "line": 121,
            "source": "const response = new ServiceResponse('test-request-id')\n\nresponse.send({result: 'success'})\nexpect(response.success).toBe(true)\n\nresponse.fail('Error occurred')\nexpect(response.success).toBe(false)\nexpect(response.data).toEqual({result: 'success'})\nexpect(response.error).toBe('Error occurred')"
          },
          {
            "title": "overwrite fail with send",
            "line": 134,
            "source": "const response = new ServiceResponse('test-request-id')\n\nresponse.fail('Error occurred')\nexpect(response.success).toBe(false)\n\nresponse.send({result: 'success'})\nexpect(response.success).toBe(true)\nexpect(response.data).toEqual({result: 'success'})\nexpect(response.error).toBe('Error occurred')"
          }
        ],
        "describes": []
      }
    ]
  },
  "/service/service_transport.doc.js": {
    "file": "/service/service_transport.test.js",
    "describes": [
      {
        "title": "ServiceTransport",
        "line": 5,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "constructor",
            "line": 7,
            "source": "const sendFn = vi.fn()\nconst receiveFn = vi.fn()\n\nconst transport = new ServiceTransport({\n    send: sendFn,\n    receive: receiveFn\n})\n\nexpect(transport.sendFn).toBe(sendFn)\nexpect(transport.messageHandlers).toBeInstanceOf(Set)\nexpect(transport.messageHandlers.size).toBe(0)\nexpect(receiveFn).toHaveBeenCalledWith(expect.any(Function))"
          },
          {
            "title": "send",
            "line": 23,
            "source": "const sendFn = vi.fn()\nconst transport = new ServiceTransport({send: sendFn})\nconst message = {type: 'test', data: 'hello'}\n\ntransport.send(message)\n\nexpect(sendFn).toHaveBeenCalledWith(message)"
          },
          {
            "title": "onMessage and offMessage",
            "line": 34,
            "source": "const transport = new ServiceTransport({send: vi.fn()})\nconst handler1 = vi.fn()\nconst handler2 = vi.fn()\n\ntransport.onMessage(handler1)\ntransport.onMessage(handler2)\n\nexpect(transport.messageHandlers.has(handler1)).toBe(true)\nexpect(transport.messageHandlers.has(handler2)).toBe(true)\nexpect(transport.messageHandlers.size).toBe(2)\n\ntransport.offMessage(handler1)\nexpect(transport.messageHandlers.has(handler1)).toBe(false)\nexpect(transport.messageHandlers.has(handler2)).toBe(true)\nexpect(transport.messageHandlers.size).toBe(1)"
          },
          {
            "title": "handleMessage",
            "line": 53,
            "source": "const transport = new ServiceTransport({send: vi.fn()})\nconst handler1 = vi.fn()\nconst handler2 = vi.fn()\nconst message = {type: 'test', data: 'hello'}\n\ntransport.onMessage(handler1)\ntransport.onMessage(handler2)\n\ntransport.handleMessage(message)\n\nexpect(handler1).toHaveBeenCalledWith(message)\nexpect(handler2).toHaveBeenCalledWith(message)"
          },
          {
            "title": "create static method",
            "line": 69,
            "source": "const config = {\n    send: vi.fn(),\n    receive: vi.fn()\n}\n\nconst transport = ServiceTransport.create(config)\n\nexpect(transport).toBeInstanceOf(ServiceTransport)\nexpect(transport.sendFn).toBe(config.send)"
          },
          {
            "title": "auto with postMessage target",
            "line": 82,
            "source": "const target = {\n    postMessage: vi.fn(),\n    onmessage: null\n}\n\nconst transport = ServiceTransport.auto(target)\n\nexpect(transport).toBeInstanceOf(ServiceTransport)\n\nconst message = {type: 'test'}\ntransport.send(message)\nexpect(target.postMessage).toHaveBeenCalledWith(message)"
          },
          {
            "title": "auto with self available",
            "line": 98,
            "source": "const originalSelf = globalThis.self\nglobalThis.self = {\n    postMessage: vi.fn(),\n    onmessage: null\n}\n\nconst transport = ServiceTransport.auto()\n\nexpect(transport).toBeInstanceOf(ServiceTransport)\n\nconst message = {type: 'test'}\ntransport.send(message)\nexpect(globalThis.self.postMessage).toHaveBeenCalledWith(message)\n\nglobalThis.self = originalSelf"
          },
          {
            "title": "auto fallback to local",
            "line": 117,
            "source": "const originalSelf = globalThis.self\ndelete globalThis.self\n\nconst transport = ServiceTransport.auto()\n\nexpect(transport).toBeInstanceOf(ServiceTransport)\n\nglobalThis.self = originalSelf"
          },
          {
            "title": "worker static method",
            "line": 129,
            "source": "const worker = {\n    postMessage: vi.fn(),\n    onmessage: null\n}\n\nconst transport = ServiceTransport.worker(worker)\n\nexpect(transport).toBeInstanceOf(ServiceTransport)\n\nconst message = {type: 'test'}\ntransport.send(message)\nexpect(worker.postMessage).toHaveBeenCalledWith(message)"
          },
          {
            "title": "main static method",
            "line": 145,
            "source": "const originalSelf = globalThis.self\nglobalThis.self = {\n    postMessage: vi.fn(),\n    onmessage: null\n}\n\nconst transport = ServiceTransport.main()\n\nexpect(transport).toBeInstanceOf(ServiceTransport)\n\nconst message = {type: 'test'}\ntransport.send(message)\nexpect(globalThis.self.postMessage).toHaveBeenCalledWith(message)\n\nglobalThis.self = originalSelf"
          },
          {
            "title": "local static method",
            "line": 164,
            "source": "const transport = ServiceTransport.local()\n\nexpect(transport).toBeInstanceOf(ServiceTransport)\n\nconst handler = vi.fn()\ntransport.onMessage(handler)\n\nconst message = {type: 'test', data: 'hello'}\ntransport.send(message)\n\nexpect(handler).toHaveBeenCalledWith(message)"
          },
          {
            "title": "channel static method",
            "line": 179,
            "source": "const port = {\n    postMessage: vi.fn(),\n    onmessage: null\n}\n\nconst transport = ServiceTransport.channel(port)\n\nexpect(transport).toBeInstanceOf(ServiceTransport)\n\nconst message = {type: 'test'}\ntransport.send(message)\nexpect(port.postMessage).toHaveBeenCalledWith(message)"
          },
          {
            "title": "pair static method",
            "line": 195,
            "source": "const [transportA, transportB] = ServiceTransport.pair()\n\nexpect(transportA).toBeInstanceOf(ServiceTransport)\nexpect(transportB).toBeInstanceOf(ServiceTransport)\nexpect(transportA).not.toBe(transportB)\n\nconst handlerA = vi.fn()\nconst handlerB = vi.fn()\n\ntransportA.onMessage(handlerA)\ntransportB.onMessage(handlerB)\n\nconst messageToB = {type: 'test', data: 'hello B'}\nconst messageToA = {type: 'test', data: 'hello A'}\n\ntransportA.send(messageToB)\ntransportB.send(messageToA)\n\nexpect(handlerA).toHaveBeenCalledWith(messageToA)\nexpect(handlerB).toHaveBeenCalledWith(messageToB)\nexpect(handlerA).not.toHaveBeenCalledWith(messageToB)\nexpect(handlerB).not.toHaveBeenCalledWith(messageToA)"
          },
          {
            "title": "pair bidirectional communication",
            "line": 221,
            "source": "const [transportA, transportB] = ServiceTransport.pair()\n\nconst messagesA = []\nconst messagesB = []\n\ntransportA.onMessage((msg) => messagesA.push(msg))\ntransportB.onMessage((msg) => messagesB.push(msg))\n\ntransportA.send({from: 'A', id: 1})\ntransportB.send({from: 'B', id: 1})\ntransportA.send({from: 'A', id: 2})\ntransportB.send({from: 'B', id: 2})\n\nexpect(messagesA).toEqual([\n    {from: 'B', id: 1},\n    {from: 'B', id: 2}\n])\nexpect(messagesB).toEqual([\n    {from: 'A', id: 1},\n    {from: 'A', id: 2}\n])"
          },
          {
            "title": "receive function integration",
            "line": 246,
            "source": "let messageHandler\nconst receiveFn = vi.fn((handler) => {\n    messageHandler = handler\n})\n\nconst transport = new ServiceTransport({\n    send: vi.fn(),\n    receive: receiveFn\n})\n\nconst handler = vi.fn()\ntransport.onMessage(handler)\n\nconst message = {type: 'test', data: 'hello'}\nmessageHandler(message)\n\nexpect(handler).toHaveBeenCalledWith(message)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/service/service_worker.doc.js": {
    "file": "/service/service_worker.test.js",
    "describes": [
      {
        "title": "ServiceClient.fromWorker",
        "line": 5,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "fromWorker creates client with worker",
            "line": 7,
            "source": "const mockWorker = {\n    postMessage: vi.fn(),\n    addEventListener: vi.fn(),\n    removeEventListener: vi.fn(),\n    terminate: vi.fn()\n}\n\nglobal.Worker = vi.fn(() => mockWorker)\n\nconst client = ServiceClient.fromWorker('./test-service.js')\n\nexpect(global.Worker).toHaveBeenCalledWith(expect.any(URL), {type: 'module'})\nexpect(global.Worker.mock.calls[0][0].href).toContain('service_worker.js')\nexpect(mockWorker.postMessage).toHaveBeenCalledWith({\n    type: 'init-service',\n    servicePath: './test-service.js',\n    config: {}\n})\nexpect(client).toBeInstanceOf(ServiceClient)"
          },
          {
            "title": "fromWorker with config",
            "line": 30,
            "source": "const mockWorker = {\n    postMessage: vi.fn(),\n    addEventListener: vi.fn(),\n    removeEventListener: vi.fn(),\n    terminate: vi.fn()\n}\n\nglobal.Worker = vi.fn(() => mockWorker)\n\nconst config = {setting1: 'value1', setting2: 42}\nServiceClient.fromWorker('./test-service.js', config)\n\nexpect(mockWorker.postMessage).toHaveBeenCalledWith({\n    type: 'init-service',\n    servicePath: './test-service.js',\n    config\n})"
          },
          {
            "title": "service worker message handling",
            "line": 51,
            "source": "const mockSelf = {\n    addEventListener: vi.fn(),\n    console: {error: vi.fn()}\n}\n\nglobal.self = mockSelf\nglobal.console = mockSelf.console\n\nawait import('./service_worker.js')\n\nexpect(mockSelf.addEventListener).toHaveBeenCalledWith('message', expect.any(Function))"
          }
        ],
        "describes": []
      }
    ]
  },
  "/studio/hub_view.doc.js": {
    "file": "/studio/hub_view.test.js",
    "describes": [
      {
        "title": "HubView",
        "line": 33,
        "beforeEach": {
          "line": 38,
          "source": "container = document.createElement('div')\ndocument.body.appendChild(container)\n\nview = document.createElement('hub-view')\ncontainer.appendChild(view)\n\nawait flushPromises()"
        },
        "afterEach": {
          "line": 49,
          "source": "container.remove()"
        },
        "tests": [
          {
            "title": "dispatches navigate event on card click",
            "line": 199,
            "source": "const mockTextureSystem = {\n    getSpritesheet: vi.fn(() => null)\n}\n\nview.setContext({\n    manifest: {},\n    animators: {\n        player: {animations: {}}\n    },\n    textureSystem: mockTextureSystem\n})\n\nawait flushPromises()\n\nconst handler = vi.fn()\nview.addEventListener('navigate', handler)\n\nconst originalLocation = window.location\ndelete window.location\nwindow.location = {href: ''}\n\nconst card = view.shadowRoot.querySelector('.animator-card')\ncard.click()\n\nexpect(handler).toHaveBeenCalled()\nexpect(handler.mock.calls[0][0].detail.name).toBe('player')\n\nwindow.location = originalLocation"
          }
        ],
        "describes": [
          {
            "title": "initialization",
            "line": 54,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "extends HTMLElement",
                "line": 56,
                "source": "expect(view).toBeInstanceOf(HTMLElement)"
              },
              {
                "title": "has shadow DOM",
                "line": 61,
                "source": "expect(view.shadowRoot).not.toBeNull()"
              },
              {
                "title": "contains app-layout",
                "line": 66,
                "source": "const appLayout = view.shadowRoot.querySelector('app-layout')\nexpect(appLayout).not.toBeNull()"
              }
            ],
            "describes": []
          },
          {
            "title": "setContext",
            "line": 74,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "sets context without error",
                "line": 76,
                "source": "const mockTextureSystem = {\n    getSpritesheet: vi.fn(() => null)\n}\n\nexpect(() => {\n    view.setContext({\n        manifest: {},\n        animators: {},\n        textureSystem: mockTextureSystem\n    })\n}).not.toThrow()"
              },
              {
                "title": "renders animator cards plus create card",
                "line": 91,
                "source": "const mockTextureSystem = {\n    getSpritesheet: vi.fn(() => null)\n}\n\nview.setContext({\n    manifest: {},\n    animators: {\n        player: {animations: {idle: {}}},\n        enemy: {animations: {walk: {}}}\n    },\n    textureSystem: mockTextureSystem\n})\n\nawait flushPromises()\n\nconst cards = view.shadowRoot.querySelectorAll('.animator-card')\nexpect(cards.length).toBe(3)\n\nconst createCard = view.shadowRoot.querySelector('.create-card')\nexpect(createCard).not.toBeNull()"
              },
              {
                "title": "shows create card when no animators",
                "line": 115,
                "source": "const mockTextureSystem = {\n    getSpritesheet: vi.fn(() => null)\n}\n\nview.setContext({\n    manifest: {},\n    animators: {},\n    textureSystem: mockTextureSystem\n})\n\nawait flushPromises()\n\nconst createCard = view.shadowRoot.querySelector('.create-card')\nexpect(createCard).not.toBeNull()"
              }
            ],
            "describes": []
          },
          {
            "title": "animator cards",
            "line": 135,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "displays animator name",
                "line": 137,
                "source": "const mockTextureSystem = {\n    getSpritesheet: vi.fn(() => null)\n}\n\nview.setContext({\n    manifest: {},\n    animators: {\n        player: {animations: {idle: {}}}\n    },\n    textureSystem: mockTextureSystem\n})\n\nawait flushPromises()\n\nconst title = view.shadowRoot.querySelector('.card-title')\nexpect(title.textContent).toBe('player')"
              },
              {
                "title": "displays animation count",
                "line": 157,
                "source": "const mockTextureSystem = {\n    getSpritesheet: vi.fn(() => null)\n}\n\nview.setContext({\n    manifest: {},\n    animators: {\n        player: {animations: {idle: {}, walk: {}, run: {}}}\n    },\n    textureSystem: mockTextureSystem\n})\n\nawait flushPromises()\n\nconst meta = view.shadowRoot.querySelector('.card-meta')\nexpect(meta.textContent).toBe('3 animations')"
              },
              {
                "title": "displays singular animation count",
                "line": 177,
                "source": "const mockTextureSystem = {\n    getSpritesheet: vi.fn(() => null)\n}\n\nview.setContext({\n    manifest: {},\n    animators: {\n        player: {animations: {idle: {}}}\n    },\n    textureSystem: mockTextureSystem\n})\n\nawait flushPromises()\n\nconst meta = view.shadowRoot.querySelector('.card-meta')\nexpect(meta.textContent).toBe('1 animation')"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/studio/launcher.doc.js": {
    "file": "/studio/launcher.test.js",
    "describes": [
      {
        "title": "loadManifest",
        "line": 18,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "returns a manifest",
            "line": 20,
            "source": "const manifestData = {assets: {}}\n\nconst result = await loadManifest(manifestData)\n\nexpect(result).toBeDefined()\nexpect(typeof result.getAsset).toBe('function')"
          },
          {
            "title": "rewrites asset urls with basePath",
            "line": 30,
            "source": "const manifestData = {\n    assets: {\n        sprite: {type: 'image', url: './sprite.png'}\n    }\n}\n\nconst result = await loadManifest(manifestData, '/game/')\n\nconst asset = result.getAsset('sprite')\nexpect(asset.url).toBe('/game/sprite.png')"
          },
          {
            "title": "preserves urls when no basePath",
            "line": 44,
            "source": "const manifestData = {\n    assets: {\n        sprite: {type: 'image', url: './sprite.png'}\n    }\n}\n\nconst result = await loadManifest(manifestData)\n\nconst asset = result.getAsset('sprite')\nexpect(asset.url).toBe('./sprite.png')"
          }
        ],
        "describes": []
      },
      {
        "title": "buildTextureSystem",
        "line": 60,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "returns a texture system",
            "line": 62,
            "source": "const manifest = {\n    getAssetsByType: vi.fn(() => [])\n}\n\nconst result = buildTextureSystem(manifest)\n\nexpect(result).toBeDefined()\nexpect(typeof result.getSpritesheet).toBe('function')"
          },
          {
            "title": "registers spritesheets from manifest",
            "line": 74,
            "source": "const manifest = {\n    getAssetsByType: vi.fn((type) => {\n        if (type === 'spritesheet') {\n            return [{id: 'sprites', source: {frames: {}}}]\n        }\n        return []\n    })\n}\n\nconst result = buildTextureSystem(manifest)\n\nexpect(manifest.getAssetsByType).toHaveBeenCalledWith('spritesheet')\nexpect(result.getSpritesheet('sprites')).toBeDefined()"
          }
        ],
        "describes": []
      },
      {
        "title": "collectAnimators",
        "line": 93,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "returns empty object when no animators",
            "line": 95,
            "source": "const manifest = {\n    getAssetsByType: vi.fn(() => [])\n}\n\nconst result = collectAnimators(manifest)\n\nexpect(result).toEqual({})"
          },
          {
            "title": "collects animators from manifest",
            "line": 106,
            "source": "const animatorSource = {animations: {idle: {}}}\nconst manifest = {\n    getAssetsByType: vi.fn(() => [\n        {id: 'player', source: animatorSource}\n    ])\n}\n\nconst result = collectAnimators(manifest)\n\nexpect(result).toEqual({player: animatorSource})"
          },
          {
            "title": "skips animators without source",
            "line": 120,
            "source": "const manifest = {\n    getAssetsByType: vi.fn(() => [\n        {id: 'player', source: null}\n    ])\n}\n\nconst result = collectAnimators(manifest)\n\nexpect(result).toEqual({})"
          }
        ],
        "describes": []
      },
      {
        "title": "getStudioConfig",
        "line": 135,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "returns config for tool",
            "line": 137,
            "source": "const config = {unitsInView: {width: 10}}\nconst manifest = {\n    getConfig: vi.fn(() => config)\n}\n\nconst result = getStudioConfig(manifest, 'animator')\n\nexpect(manifest.getConfig).toHaveBeenCalledWith('studio.animator')\nexpect(result).toBe(config)"
          },
          {
            "title": "returns empty object when no config",
            "line": 150,
            "source": "const manifest = {\n    getConfig: vi.fn(() => null)\n}\n\nconst result = getStudioConfig(manifest, 'animator')\n\nexpect(result).toEqual({})"
          }
        ],
        "describes": []
      },
      {
        "title": "getBackgroundImage",
        "line": 163,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "returns null when no background configured",
            "line": 165,
            "source": "const manifest = {\n    getAsset: vi.fn()\n}\n\nconst result = getBackgroundImage(manifest, {})\n\nexpect(result).toBeNull()"
          },
          {
            "title": "returns background image source",
            "line": 176,
            "source": "const image = new Image()\nconst manifest = {\n    getAsset: vi.fn(() => ({source: image}))\n}\n\nconst result = getBackgroundImage(manifest, {background: 'bg'})\n\nexpect(manifest.getAsset).toHaveBeenCalledWith('bg')\nexpect(result).toBe(image)"
          },
          {
            "title": "returns null when asset not found",
            "line": 189,
            "source": "const manifest = {\n    getAsset: vi.fn(() => null)\n}\n\nconst result = getBackgroundImage(manifest, {background: 'missing'})\n\nexpect(result).toBeNull()"
          }
        ],
        "describes": []
      }
    ]
  },
  "/studio/animator/animator_helpers.doc.js": {
    "file": "/studio/animator/animator_helpers.test.js",
    "describes": [
      {
        "title": "animator_helpers",
        "line": 10,
        "beforeEach": null,
        "afterEach": null,
        "tests": [],
        "describes": [
          {
            "title": "inferSpritesheetName",
            "line": 12,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns null for empty config",
                "line": 14,
                "source": "expect(inferSpritesheetName(null)).toBeNull()\nexpect(inferSpritesheetName({})).toBeNull()\nexpect(inferSpritesheetName({animations: null})).toBeNull()"
              },
              {
                "title": "extracts name from animation source",
                "line": 21,
                "source": "const config = {\n    animations: {\n        idle: {source: 'player:idle'}\n    }\n}\nexpect(inferSpritesheetName(config)).toBe('player')"
              },
              {
                "title": "extracts name from frame source",
                "line": 31,
                "source": "const config = {\n    animations: {\n        walk: {\n            frames: [\n                {source: 'enemy:walk_0'}\n            ]\n        }\n    }\n}\nexpect(inferSpritesheetName(config)).toBe('enemy')"
              },
              {
                "title": "returns null when no source found",
                "line": 45,
                "source": "const config = {\n    animations: {\n        idle: {fps: 10}\n    }\n}\nexpect(inferSpritesheetName(config)).toBeNull()"
              }
            ],
            "describes": []
          },
          {
            "title": "collectEventSuggestions",
            "line": 57,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns empty array for animator with no events",
                "line": 59,
                "source": "const animator = {\n    children: [\n        {frames: [{}, {}]}\n    ]\n}\nexpect(collectEventSuggestions(animator, [])).toEqual([])"
              },
              {
                "title": "collects events from all animations",
                "line": 69,
                "source": "const animator = {\n    children: [\n        {frames: [{events: ['footstep']}, {events: ['jump']}]},\n        {frames: [{events: ['land']}]}\n    ]\n}\nconst result = collectEventSuggestions(animator, [])\nexpect(result).toContain('footstep')\nexpect(result).toContain('jump')\nexpect(result).toContain('land')"
              },
              {
                "title": "excludes specified events",
                "line": 83,
                "source": "const animator = {\n    children: [\n        {frames: [{events: ['footstep', 'jump', 'land']}]}\n    ]\n}\nconst result = collectEventSuggestions(animator, ['jump'])\nexpect(result).toContain('footstep')\nexpect(result).toContain('land')\nexpect(result).not.toContain('jump')"
              },
              {
                "title": "limits results to 6 suggestions",
                "line": 96,
                "source": "const animator = {\n    children: [\n        {frames: [{events: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']}]}\n    ]\n}\nconst result = collectEventSuggestions(animator, [])\nexpect(result.length).toBe(6)"
              },
              {
                "title": "deduplicates events",
                "line": 107,
                "source": "const animator = {\n    children: [\n        {frames: [{events: ['footstep']}, {events: ['footstep']}]},\n        {frames: [{events: ['footstep']}]}\n    ]\n}\nconst result = collectEventSuggestions(animator, [])\nexpect(result).toEqual(['footstep'])"
              }
            ],
            "describes": []
          },
          {
            "title": "buildAnimationConfig",
            "line": 121,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "includes fps and loop",
                "line": 123,
                "source": "const anim = {\n    fps: 12,\n    loop: true,\n    playbackMode: 'forward',\n    frames: []\n}\nconst config = buildAnimationConfig(anim, null)\nexpect(config.fps).toBe(12)\nexpect(config.loop).toBe(true)"
              },
              {
                "title": "includes playbackMode when not forward",
                "line": 136,
                "source": "const anim = {\n    fps: 10,\n    loop: false,\n    playbackMode: 'pingpong',\n    frames: []\n}\nconst config = buildAnimationConfig(anim, null)\nexpect(config.playbackMode).toBe('pingpong')"
              },
              {
                "title": "excludes playbackMode when forward",
                "line": 148,
                "source": "const anim = {\n    fps: 10,\n    loop: true,\n    playbackMode: 'forward',\n    frames: []\n}\nconst config = buildAnimationConfig(anim, null)\nexpect(config.playbackMode).toBeUndefined()"
              },
              {
                "title": "includes motion when enabled",
                "line": 160,
                "source": "const anim = {\n    fps: 10,\n    loop: true,\n    playbackMode: 'forward',\n    motion: {\n        enabled: true,\n        mode: 'topdown',\n        direction: 'n'\n    },\n    frames: []\n}\nconst config = buildAnimationConfig(anim, null)\nexpect(config.motion).toEqual({\n    mode: 'topdown',\n    direction: 'n'\n})"
              },
              {
                "title": "excludes motion when disabled",
                "line": 180,
                "source": "const anim = {\n    fps: 10,\n    loop: true,\n    playbackMode: 'forward',\n    motion: {enabled: false},\n    frames: []\n}\nconst config = buildAnimationConfig(anim, null)\nexpect(config.motion).toBeUndefined()"
              },
              {
                "title": "builds frame config with source",
                "line": 193,
                "source": "const anim = {\n    fps: 10,\n    loop: true,\n    playbackMode: 'forward',\n    frames: [\n        {source: 'player:idle_0'},\n        {source: 'player:idle_1'}\n    ]\n}\nconst config = buildAnimationConfig(anim, null)\nexpect(config.frames).toEqual([\n    {source: 'player:idle_0'},\n    {source: 'player:idle_1'}\n])"
              },
              {
                "title": "builds frame source from name and spritesheet",
                "line": 211,
                "source": "const anim = {\n    fps: 10,\n    loop: true,\n    playbackMode: 'forward',\n    frames: [\n        {name: 'idle_0'},\n        {name: 'idle_1'}\n    ]\n}\nconst config = buildAnimationConfig(anim, 'player')\nexpect(config.frames).toEqual([\n    {source: 'player:idle_0'},\n    {source: 'player:idle_1'}\n])"
              },
              {
                "title": "includes frame duration when not 1",
                "line": 229,
                "source": "const anim = {\n    fps: 10,\n    loop: true,\n    playbackMode: 'forward',\n    frames: [\n        {source: 'player:idle_0', duration: 2},\n        {source: 'player:idle_1', duration: 1}\n    ]\n}\nconst config = buildAnimationConfig(anim, null)\nexpect(config.frames[0].duration).toBe(2)\nexpect(config.frames[1].duration).toBeUndefined()"
              },
              {
                "title": "includes frame events when present",
                "line": 245,
                "source": "const anim = {\n    fps: 10,\n    loop: true,\n    playbackMode: 'forward',\n    frames: [\n        {source: 'player:attack_0', events: ['swing']},\n        {source: 'player:attack_1'}\n    ]\n}\nconst config = buildAnimationConfig(anim, null)\nexpect(config.frames[0].events).toEqual(['swing'])\nexpect(config.frames[1].events).toBeUndefined()"
              }
            ],
            "describes": []
          },
          {
            "title": "buildFramePreview",
            "line": 263,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates frame-editor-preview element",
                "line": 265,
                "source": "const frame = {name: 'idle_0'}\nconst preview = buildFramePreview(frame)\nexpect(preview.className).toBe('frame-editor-preview')"
              },
              {
                "title": "creates canvas element",
                "line": 272,
                "source": "const frame = {name: 'idle_0'}\nconst preview = buildFramePreview(frame)\nconst canvas = preview.querySelector('canvas')\nexpect(canvas).not.toBeNull()\nexpect(canvas.width).toBe(120)\nexpect(canvas.height).toBe(120)"
              },
              {
                "title": "displays frame name",
                "line": 282,
                "source": "const frame = {name: 'walk_3'}\nconst preview = buildFramePreview(frame)\nconst nameEl = preview.querySelector('.frame-editor-name')\nexpect(nameEl.textContent).toBe('walk_3')"
              },
              {
                "title": "displays \"Unnamed frame\" when no name",
                "line": 290,
                "source": "const frame = {}\nconst preview = buildFramePreview(frame)\nconst nameEl = preview.querySelector('.frame-editor-name')\nexpect(nameEl.textContent).toBe('Unnamed frame')"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/studio/animator/launcher.doc.js": {
    "file": "/studio/animator/launcher.test.js",
    "describes": [
      {
        "title": "launchAnimatorStudio",
        "line": 66,
        "beforeEach": {
          "line": 71,
          "source": "container = document.createElement('div')\n\nif (!customElements.get('animator-view')) {\n    customElements.define('animator-view', class extends HTMLElement {\n        setContext () {}\n    })\n}\n\nconst module = await import('./launcher.js')\nlaunchAnimatorStudio = module.launchAnimatorStudio"
        },
        "afterEach": {
          "line": 84,
          "source": "vi.clearAllMocks()"
        },
        "tests": [
          {
            "title": "clears container before rendering",
            "line": 89,
            "source": "container.innerHTML = '<div>old content</div>'\n\nawait launchAnimatorStudio({assets: {}}, container)\n\nexpect(container.innerHTML).not.toContain('old content')"
          },
          {
            "title": "creates animator-view element when animator exists",
            "line": 98,
            "source": "const manifestData = {\n    assets: {\n        player: {\n            type: 'animator',\n            animations: {idle: {frames: []}}\n        }\n    }\n}\n\nawait launchAnimatorStudio(manifestData, container)\n\nconst animatorView = container.querySelector('animator-view')\nexpect(animatorView).not.toBeNull()"
          },
          {
            "title": "appends animator-view to container when animator exists",
            "line": 115,
            "source": "const manifestData = {\n    assets: {\n        player: {\n            type: 'animator',\n            animations: {idle: {frames: []}}\n        }\n    }\n}\n\nawait launchAnimatorStudio(manifestData, container)\n\nexpect(container.children).toHaveLength(1)\nexpect(container.children[0].tagName.toLowerCase()).toBe('animator-view')"
          },
          {
            "title": "works with basePath option",
            "line": 132,
            "source": "const manifestData = {\n    assets: {\n        player: {\n            type: 'animator',\n            url: './player.json',\n            animations: {idle: {frames: []}}\n        }\n    }\n}\n\nawait launchAnimatorStudio(manifestData, container, {basePath: '/assets/'})\n\nconst animatorView = container.querySelector('animator-view')\nexpect(animatorView).not.toBeNull()"
          },
          {
            "title": "shows error message with empty manifest",
            "line": 150,
            "source": "await launchAnimatorStudio({}, container)\n\nexpect(container.innerHTML).toContain('No animator found')"
          }
        ],
        "describes": []
      }
    ]
  },
  "/studio/animator/animator_preview.doc.js": {
    "file": "/studio/animator/animator_preview.test.js",
    "describes": [
      {
        "title": "AnimatorPreview",
        "line": 5,
        "beforeEach": {
          "line": 11,
          "source": "canvas = document.createElement('canvas')\ncanvas.width = 400\ncanvas.height = 300\ndocument.body.appendChild(canvas)\n\nmockAnimation = {\n    currentFrame: {region: {x: 0, y: 0, width: 32, height: 32, image: new Image()}},\n    currentIndex: 0,\n    completed: false,\n    play: vi.fn(),\n    pause: vi.fn(),\n    stop: vi.fn(),\n    update: vi.fn(),\n    seekToFrame: vi.fn()\n}\n\npreview = new AnimatorPreview({canvas})"
        },
        "afterEach": {
          "line": 32,
          "source": "preview?.dispose()\ncanvas.remove()"
        },
        "tests": [
          {
            "title": "setUnitsInView updates units in view",
            "line": 66,
            "source": "preview.setUnitsInView({width: 12, height: 10})\nexpect(preview).toBeInstanceOf(AnimatorPreview)"
          },
          {
            "title": "setMotion sets motion configuration",
            "line": 88,
            "source": "preview.setMotion({mode: 'walk', speed: 1.5, direction: 'e'})\nexpect(preview).toBeInstanceOf(AnimatorPreview)"
          },
          {
            "title": "resize resizes canvas and renderer",
            "line": 143,
            "source": "preview.resize(800, 600)\nexpect(canvas.width).toBe(800)\nexpect(canvas.height).toBe(600)"
          },
          {
            "title": "render renders scene",
            "line": 231,
            "source": "preview.render()\nexpect(preview).toBeInstanceOf(AnimatorPreview)"
          },
          {
            "title": "dispose stops playback and cleans up",
            "line": 237,
            "source": "preview.setAnimation(mockAnimation)\npreview.play()\npreview.dispose()\npreview = null\nexpect(mockAnimation.stop).toHaveBeenCalled()"
          }
        ],
        "describes": [
          {
            "title": "constructor",
            "line": 38,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates instance with canvas",
                "line": 40,
                "source": "expect(preview).toBeInstanceOf(AnimatorPreview)"
              },
              {
                "title": "accepts unitsInView option",
                "line": 45,
                "source": "const customPreview = new AnimatorPreview({\n    canvas,\n    unitsInView: {width: 10, height: 8}\n})\nexpect(customPreview).toBeInstanceOf(AnimatorPreview)\ncustomPreview.dispose()"
              },
              {
                "title": "accepts callback options",
                "line": 55,
                "source": "const onFrame = vi.fn()\nconst onComplete = vi.fn()\nconst customPreview = new AnimatorPreview({canvas, onFrame, onComplete})\nexpect(customPreview).toBeInstanceOf(AnimatorPreview)\ncustomPreview.dispose()"
              }
            ],
            "describes": []
          },
          {
            "title": "setSize",
            "line": 72,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "updates sprite size",
                "line": 74,
                "source": "preview.setSize({width: 2, height: 2})\nexpect(preview).toBeInstanceOf(AnimatorPreview)"
              },
              {
                "title": "handles null value",
                "line": 80,
                "source": "preview.setSize(null)\nexpect(preview).toBeInstanceOf(AnimatorPreview)"
              }
            ],
            "describes": []
          },
          {
            "title": "setBackgroundRegion",
            "line": 94,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "hides background when null",
                "line": 96,
                "source": "preview.setBackgroundRegion(null)\nexpect(preview).toBeInstanceOf(AnimatorPreview)"
              },
              {
                "title": "shows background when region provided",
                "line": 102,
                "source": "const region = {x: 0, y: 0, width: 100, height: 100}\npreview.setBackgroundRegion(region)\nexpect(preview).toBeInstanceOf(AnimatorPreview)"
              }
            ],
            "describes": []
          },
          {
            "title": "setAnimation",
            "line": 111,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "sets animation",
                "line": 113,
                "source": "preview.setAnimation(mockAnimation)\nexpect(preview.animation).toBe(mockAnimation)"
              },
              {
                "title": "handles null animation",
                "line": 119,
                "source": "preview.setAnimation(null)\nexpect(preview.animation).toBeNull()"
              }
            ],
            "describes": []
          },
          {
            "title": "setAnchor",
            "line": 127,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "sets anchor point",
                "line": 129,
                "source": "preview.setAnchor({x: 0.5, y: 1})\nexpect(preview).toBeInstanceOf(AnimatorPreview)"
              },
              {
                "title": "handles null anchor",
                "line": 135,
                "source": "preview.setAnchor(null)\nexpect(preview).toBeInstanceOf(AnimatorPreview)"
              }
            ],
            "describes": []
          },
          {
            "title": "playback controls",
            "line": 150,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "play does nothing without animation",
                "line": 152,
                "source": "preview.play()\nexpect(preview.isPlaying).toBe(false)"
              },
              {
                "title": "play starts animation playback",
                "line": 158,
                "source": "preview.setAnimation(mockAnimation)\npreview.play()\nexpect(preview.isPlaying).toBe(true)\nexpect(mockAnimation.play).toHaveBeenCalled()"
              },
              {
                "title": "pause stops playback",
                "line": 166,
                "source": "preview.setAnimation(mockAnimation)\npreview.play()\npreview.pause()\nexpect(preview.isPlaying).toBe(false)\nexpect(mockAnimation.pause).toHaveBeenCalled()"
              },
              {
                "title": "stop resets animation",
                "line": 175,
                "source": "preview.setAnimation(mockAnimation)\npreview.play()\npreview.stop()\nexpect(preview.isPlaying).toBe(false)\nexpect(mockAnimation.stop).toHaveBeenCalled()"
              }
            ],
            "describes": []
          },
          {
            "title": "seekToFrame",
            "line": 186,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "does nothing without animation",
                "line": 188,
                "source": "preview.seekToFrame(5)\nexpect(preview).toBeInstanceOf(AnimatorPreview)"
              },
              {
                "title": "seeks to frame index",
                "line": 194,
                "source": "preview.setAnimation(mockAnimation)\npreview.seekToFrame(3)\nexpect(mockAnimation.seekToFrame).toHaveBeenCalledWith(3)"
              }
            ],
            "describes": []
          },
          {
            "title": "getters",
            "line": 203,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "isPlaying returns playback state",
                "line": 205,
                "source": "expect(preview.isPlaying).toBe(false)"
              },
              {
                "title": "animation returns current animation",
                "line": 210,
                "source": "expect(preview.animation).toBeNull()\npreview.setAnimation(mockAnimation)\nexpect(preview.animation).toBe(mockAnimation)"
              },
              {
                "title": "sprite returns animator sprite",
                "line": 217,
                "source": "expect(preview.sprite).toBeDefined()"
              },
              {
                "title": "currentIndex returns animation index",
                "line": 222,
                "source": "expect(preview.currentIndex).toBe(0)\npreview.setAnimation(mockAnimation)\nexpect(preview.currentIndex).toBe(0)"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/studio/animator/animator_view.doc.js": {
    "file": "/studio/animator/animator_view.test.js",
    "describes": [
      {
        "title": "AnimatorView",
        "line": 5,
        "beforeEach": {
          "line": 10,
          "source": "container = document.createElement('div')\ndocument.body.appendChild(container)\n\nview = document.createElement('animator-view')\ncontainer.appendChild(view)"
        },
        "afterEach": {
          "line": 19,
          "source": "container.remove()"
        },
        "tests": [
          {
            "title": "back button navigates to index.html",
            "line": 109,
            "source": "const mockTextureSystem = {\n    getSpritesheet: vi.fn(() => null)\n}\n\nview.setContext({\n    textureSystem: mockTextureSystem,\n    animatorConfig: {animations: {}},\n    animatorName: 'test'\n})\n\nconst originalLocation = window.location\ndelete window.location\nwindow.location = {href: ''}\n\nconst backBtn = view.shadowRoot.querySelector('.toolbar-btn')\nbackBtn?.click()\n\nexpect(window.location.href).toBe('index.html')\n\nwindow.location = originalLocation"
          }
        ],
        "describes": [
          {
            "title": "initialization",
            "line": 24,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "extends HTMLElement",
                "line": 26,
                "source": "expect(view).toBeInstanceOf(HTMLElement)"
              },
              {
                "title": "has shadow DOM",
                "line": 31,
                "source": "expect(view.shadowRoot).not.toBeNull()"
              }
            ],
            "describes": []
          },
          {
            "title": "setContext",
            "line": 38,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "sets context without error",
                "line": 40,
                "source": "const mockTextureSystem = {\n    getSpritesheet: vi.fn(() => null)\n}\n\nexpect(() => {\n    view.setContext({\n        textureSystem: mockTextureSystem,\n        animatorConfig: null,\n        animatorName: null\n    })\n}).not.toThrow()"
              },
              {
                "title": "handles animator configuration",
                "line": 55,
                "source": "const mockTextureSystem = {\n    getSpritesheet: vi.fn(() => null)\n}\n\nconst mockAnimatorConfig = {\n    animations: {},\n    anchor: {x: 0.5, y: 0.5}\n}\n\nexpect(() => {\n    view.setContext({\n        textureSystem: mockTextureSystem,\n        animatorConfig: mockAnimatorConfig,\n        animatorName: 'player'\n    })\n}).not.toThrow()"
              },
              {
                "title": "accepts background image",
                "line": 75,
                "source": "const mockTextureSystem = {\n    getSpritesheet: vi.fn(() => null)\n}\n\nconst mockImage = new Image()\n\nexpect(() => {\n    view.setContext({\n        textureSystem: mockTextureSystem,\n        animatorConfig: null,\n        backgroundImage: mockImage\n    })\n}).not.toThrow()"
              },
              {
                "title": "accepts studio config",
                "line": 92,
                "source": "const mockTextureSystem = {\n    getSpritesheet: vi.fn(() => null)\n}\n\nexpect(() => {\n    view.setContext({\n        textureSystem: mockTextureSystem,\n        animatorConfig: null,\n        studioConfig: {unitsInView: {width: 10, height: 8}}\n    })\n}).not.toThrow()"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/studio/animator/components/anchor_editor.doc.js": {
    "file": "/studio/animator/components/anchor_editor.test.js",
    "describes": [
      {
        "title": "anchor_editor",
        "line": 11,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "buildAnchorPreview creates wrapper with canvas and handle",
            "line": 80,
            "source": "const anchor = {x: 0.5, y: 0.5}\nconst {wrapper, canvas, handle} = buildAnchorPreview(null, anchor, () => {})\n\nexpect(wrapper.className).toBe('anchor-preview-wrapper')\nexpect(canvas.className).toBe('anchor-preview-canvas')\nexpect(handle.className).toBe('anchor-handle')"
          }
        ],
        "describes": [
          {
            "title": "getFirstFrameData",
            "line": 13,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns null for null spritesheet",
                "line": 15,
                "source": "expect(getFirstFrameData(null)).toBeNull()"
              },
              {
                "title": "returns null for spritesheet with no frames",
                "line": 20,
                "source": "const spritesheet = {\n    getFrames: () => []\n}\nexpect(getFirstFrameData(spritesheet)).toBeNull()"
              },
              {
                "title": "returns first frame data",
                "line": 28,
                "source": "const mockImage = new Image()\nconst mockRegion = {x: 0, y: 0, width: 32, height: 32}\nconst spritesheet = {\n    getFrames: () => [{image: mockImage, region: mockRegion}]\n}\n\nconst result = getFirstFrameData(spritesheet)\n\nexpect(result.image).toBe(mockImage)\nexpect(result.region).toBe(mockRegion)"
              }
            ],
            "describes": []
          },
          {
            "title": "buildAnchorInputs",
            "line": 44,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates row with two number inputs",
                "line": 46,
                "source": "const anchor = {x: 0.5, y: 0.5}\nconst {row, xInput, yInput} = buildAnchorInputs(anchor, () => {})\n\nexpect(row.className).toContain('anchor-inputs')\nexpect(xInput).not.toBeNull()\nexpect(yInput).not.toBeNull()"
              },
              {
                "title": "calls onChange when X input changes",
                "line": 56,
                "source": "const anchor = {x: 0.5, y: 0.5}\nconst onChange = vi.fn()\nconst {xInput} = buildAnchorInputs(anchor, onChange)\n\nxInput.dispatchEvent(new CustomEvent('change', {detail: {value: 0.3}}))\n\nexpect(onChange).toHaveBeenCalledWith('x', 0.3)"
              },
              {
                "title": "calls onChange when Y input changes",
                "line": 67,
                "source": "const anchor = {x: 0.5, y: 0.5}\nconst onChange = vi.fn()\nconst {yInput} = buildAnchorInputs(anchor, onChange)\n\nyInput.dispatchEvent(new CustomEvent('change', {detail: {value: 0.7}}))\n\nexpect(onChange).toHaveBeenCalledWith('y', 0.7)"
              }
            ],
            "describes": []
          },
          {
            "title": "buildAnchorEditor",
            "line": 90,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates container with settings class",
                "line": 92,
                "source": "const anchor = {x: 0.5, y: 0.5}\nconst {container} = buildAnchorEditor(null, anchor, () => {})\n\nexpect(container.className).toBe('spritesheet-settings')"
              },
              {
                "title": "includes anchor section with label",
                "line": 100,
                "source": "const anchor = {x: 0.5, y: 0.5}\nconst {container} = buildAnchorEditor(null, anchor, () => {})\n\nconst label = container.querySelector('.settings-label')\nexpect(label.textContent).toBe('Anchor')"
              },
              {
                "title": "returns syncInputs function",
                "line": 109,
                "source": "const anchor = {x: 0.5, y: 0.5}\nconst editor = buildAnchorEditor(null, anchor, () => {})\n\nexpect(typeof editor.syncInputs).toBe('function')"
              },
              {
                "title": "returns updatePreview function",
                "line": 117,
                "source": "const anchor = {x: 0.5, y: 0.5}\nconst editor = buildAnchorEditor(null, anchor, () => {})\n\nexpect(typeof editor.updatePreview).toBe('function')"
              }
            ],
            "describes": []
          },
          {
            "title": "renderAnchorPreview",
            "line": 127,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "clears canvas when no frame data",
                "line": 129,
                "source": "const canvas = document.createElement('canvas')\ncanvas.width = 100\ncanvas.height = 100\nconst handle = document.createElement('div')\nconst anchor = {x: 0.5, y: 0.5}\n\nrenderAnchorPreview(canvas, handle, anchor, null)\n\nconst ctx = canvas.getContext('2d')\nconst imageData = ctx.getImageData(0, 0, 100, 100)\nconst isEmpty = imageData.data.every(v => v === 0)\nexpect(isEmpty).toBe(true)"
              },
              {
                "title": "positions handle based on anchor when frame data provided",
                "line": 145,
                "source": "const canvas = document.createElement('canvas')\ncanvas.width = 100\ncanvas.height = 100\nconst handle = document.createElement('div')\nconst anchor = {x: 0.5, y: 0.5}\n\nconst mockImage = document.createElement('canvas')\nmockImage.width = 32\nmockImage.height = 32\nconst frameData = {\n    image: mockImage,\n    region: {x: 0, y: 0, width: 32, height: 32}\n}\n\nrenderAnchorPreview(canvas, handle, anchor, frameData)\n\nexpect(handle.style.left).toBeTruthy()\nexpect(handle.style.top).toBeTruthy()"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/studio/animator/components/animation_settings.doc.js": {
    "file": "/studio/animator/components/animation_settings.test.js",
    "describes": [
      {
        "title": "animation_settings",
        "line": 9,
        "beforeEach": null,
        "afterEach": null,
        "tests": [],
        "describes": [
          {
            "title": "rebuildDirectionPad",
            "line": 25,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates 9 direction buttons",
                "line": 27,
                "source": "const pad = document.createElement('div')\nconst animation = {motion: {mode: 'sidescroller', direction: 'e'}}\n\nrebuildDirectionPad(pad, animation, {})\n\nexpect(pad.children.length).toBe(9)"
              },
              {
                "title": "marks current direction as active",
                "line": 37,
                "source": "const pad = document.createElement('div')\nconst animation = {motion: {mode: 'sidescroller', direction: 'n'}}\n\nrebuildDirectionPad(pad, animation, {})\n\nconst activeBtn = pad.querySelector('.direction-btn.active')\nexpect(activeBtn).not.toBeNull()\nexpect(activeBtn.textContent).toBe('')"
              },
              {
                "title": "shows 4 directions for sidescroller mode",
                "line": 49,
                "source": "const pad = document.createElement('div')\nconst animation = {motion: {mode: 'sidescroller', direction: 'e'}}\n\nrebuildDirectionPad(pad, animation, {})\n\nconst visibleBtns = Array.from(pad.querySelectorAll('.direction-btn'))\n    .filter(btn => btn.style.visibility !== 'hidden' && !btn.classList.contains('center'))\nexpect(visibleBtns.length).toBe(4)"
              },
              {
                "title": "shows 8 directions for topdown mode",
                "line": 61,
                "source": "const pad = document.createElement('div')\nconst animation = {motion: {mode: 'topdown', direction: 'e'}}\n\nrebuildDirectionPad(pad, animation, {})\n\nconst visibleBtns = Array.from(pad.querySelectorAll('.direction-btn'))\n    .filter(btn => btn.style.visibility !== 'hidden' && !btn.classList.contains('center'))\nexpect(visibleBtns.length).toBe(8)"
              },
              {
                "title": "calls onMotionChange when direction clicked",
                "line": 73,
                "source": "const pad = document.createElement('div')\nconst animation = {motion: {mode: 'sidescroller', direction: 'e'}}\nconst onMotionChange = vi.fn()\n\nrebuildDirectionPad(pad, animation, {onMotionChange})\n\nconst northBtn = Array.from(pad.querySelectorAll('.direction-btn'))\n    .find(btn => btn.textContent === '')\nnorthBtn?.click()\n\nexpect(animation.motion.direction).toBe('n')\nexpect(onMotionChange).toHaveBeenCalled()"
              }
            ],
            "describes": []
          },
          {
            "title": "buildAnimationSettingsContent",
            "line": 91,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "adds motion section to container",
                "line": 93,
                "source": "const container = document.createElement('div')\nconst animation = {\n    motion: {enabled: false},\n    frames: []\n}\n\nbuildAnimationSettingsContent(container, animation, {})\n\nconst motionSection = container.querySelector('[data-setting=\"motion\"]')\nexpect(motionSection).not.toBeNull()"
              },
              {
                "title": "does nothing when animation is null",
                "line": 107,
                "source": "const container = document.createElement('div')\n\nbuildAnimationSettingsContent(container, null, {})\n\nexpect(container.children.length).toBe(0)"
              },
              {
                "title": "shows motion options when motion enabled",
                "line": 116,
                "source": "const container = document.createElement('div')\nconst animation = {\n    motion: {enabled: true, mode: 'sidescroller'},\n    frames: []\n}\n\nbuildAnimationSettingsContent(container, animation, {})\n\nconst motionOptions = container.querySelector('.motion-options')\nexpect(motionOptions.style.display).not.toBe('none')"
              },
              {
                "title": "hides motion options when motion disabled",
                "line": 130,
                "source": "const container = document.createElement('div')\nconst animation = {\n    motion: {enabled: false},\n    frames: []\n}\n\nbuildAnimationSettingsContent(container, animation, {})\n\nconst motionOptions = container.querySelector('.motion-options')\nexpect(motionOptions.style.display).toBe('none')"
              }
            ],
            "describes": []
          },
          {
            "title": "buildAnimationSettings",
            "line": 146,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates animation-settings container",
                "line": 148,
                "source": "const animator = createMockAnimator([{id: 'idle'}])\nconst animation = animator.children[0]\n\nconst {container} = buildAnimationSettings(animator, animation, {})\n\nexpect(container.className).toBe('animation-settings')"
              },
              {
                "title": "returns nameInput",
                "line": 158,
                "source": "const animator = createMockAnimator([{id: 'idle'}])\nconst animation = animator.children[0]\n\nconst {nameInput} = buildAnimationSettings(animator, animation, {})\n\nexpect(nameInput).not.toBeNull()\nexpect(nameInput.value).toBe('idle')"
              },
              {
                "title": "returns rebuild function",
                "line": 169,
                "source": "const animator = createMockAnimator([{id: 'idle'}])\nconst animation = animator.children[0]\n\nconst settings = buildAnimationSettings(animator, animation, {})\n\nexpect(typeof settings.rebuild).toBe('function')"
              },
              {
                "title": "rebuild replaces motion section",
                "line": 179,
                "source": "const animator = createMockAnimator([\n    {id: 'idle', motion: {enabled: false}},\n    {id: 'walk', motion: {enabled: true, mode: 'sidescroller'}}\n])\n\nconst {container, rebuild} = buildAnimationSettings(animator, animator.children[0], {})\n\nrebuild(animator.children[1])\n\nconst motionOptions = container.querySelector('.motion-options')\nexpect(motionOptions.style.display).not.toBe('none')"
              },
              {
                "title": "shows delete button",
                "line": 194,
                "source": "const animator = createMockAnimator([{id: 'idle'}])\nconst animation = animator.children[0]\n\nconst {container} = buildAnimationSettings(animator, animation, {})\n\nconst deleteBtn = container.querySelector('.settings-delete-btn')\nexpect(deleteBtn).not.toBeNull()\nexpect(deleteBtn.textContent).toBe('Delete Animation')"
              },
              {
                "title": "first click shows confirm state",
                "line": 206,
                "source": "const animator = createMockAnimator([{id: 'idle'}, {id: 'walk'}])\nconst animation = animator.children[0]\n\nconst {container} = buildAnimationSettings(animator, animation, {})\n\nconst deleteBtn = container.querySelector('.settings-delete-btn')\ndeleteBtn.click()\n\nexpect(deleteBtn.textContent).toBe('Confirm?')\nexpect(deleteBtn.classList.contains('confirming')).toBe(true)"
              },
              {
                "title": "second click calls onDelete",
                "line": 220,
                "source": "const animator = createMockAnimator([{id: 'idle'}, {id: 'walk'}])\nconst animation = animator.children[0]\nconst onDelete = vi.fn()\n\nconst {container} = buildAnimationSettings(animator, animation, {onDelete})\n\nconst deleteBtn = container.querySelector('.settings-delete-btn')\ndeleteBtn.click()\ndeleteBtn.click()\n\nexpect(onDelete).toHaveBeenCalledOnce()"
              },
              {
                "title": "confirm resets after timeout",
                "line": 235,
                "source": "vi.useFakeTimers()\nconst animator = createMockAnimator([{id: 'idle'}, {id: 'walk'}])\nconst animation = animator.children[0]\n\nconst {container} = buildAnimationSettings(animator, animation, {})\n\nconst deleteBtn = container.querySelector('.settings-delete-btn')\ndeleteBtn.click()\n\nexpect(deleteBtn.textContent).toBe('Confirm?')\n\nvi.advanceTimersByTime(3000)\n\nexpect(deleteBtn.textContent).toBe('Delete Animation')\nexpect(deleteBtn.classList.contains('confirming')).toBe(false)\nvi.useRealTimers()"
              },
              {
                "title": "rebuild preserves delete button",
                "line": 255,
                "source": "const animator = createMockAnimator([\n    {id: 'idle', motion: {enabled: false}},\n    {id: 'walk', motion: {enabled: true, mode: 'sidescroller'}}\n])\n\nconst {container, rebuild} = buildAnimationSettings(animator, animator.children[0], {})\n\nrebuild(animator.children[1])\n\nconst deleteBtn = container.querySelector('.settings-delete-btn')\nexpect(deleteBtn).not.toBeNull()"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/studio/animator/components/frame_editor.doc.js": {
    "file": "/studio/animator/components/frame_editor.test.js",
    "describes": [
      {
        "title": "frame_editor",
        "line": 9,
        "beforeEach": null,
        "afterEach": null,
        "tests": [],
        "describes": [
          {
            "title": "buildFrameEditor",
            "line": 11,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates frame-editor container",
                "line": 13,
                "source": "const frame = {name: 'idle_0'}\nconst editor = buildFrameEditor(frame, {})\nexpect(editor.className).toBe('frame-editor')"
              },
              {
                "title": "includes frame preview",
                "line": 20,
                "source": "const frame = {name: 'idle_0'}\nconst editor = buildFrameEditor(frame, {})\nconst preview = editor.querySelector('.frame-editor-preview')\nexpect(preview).not.toBeNull()"
              },
              {
                "title": "includes duration section",
                "line": 28,
                "source": "const frame = {name: 'idle_0'}\nconst editor = buildFrameEditor(frame, {})\nconst sections = editor.querySelectorAll('.frame-editor-section')\nexpect(sections.length).toBeGreaterThanOrEqual(2)"
              }
            ],
            "describes": []
          },
          {
            "title": "buildDurationSection",
            "line": 38,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates section with label",
                "line": 40,
                "source": "const frame = {duration: 1}\nconst section = buildDurationSection(frame, () => {})\nconst label = section.querySelector('.frame-editor-label')\nexpect(label.textContent).toBe('Duration multiplier')"
              },
              {
                "title": "creates slider and number input",
                "line": 48,
                "source": "const frame = {duration: 1}\nconst section = buildDurationSection(frame, () => {})\nconst slider = section.querySelector('slider-input')\nconst numberInput = section.querySelector('number-input')\nexpect(slider).not.toBeNull()\nexpect(numberInput).not.toBeNull()"
              },
              {
                "title": "calls onUpdate when slider changes",
                "line": 58,
                "source": "const frame = {duration: 1}\nconst onUpdate = vi.fn()\nconst section = buildDurationSection(frame, onUpdate)\nconst slider = section.querySelector('slider-input')\n\nslider.dispatchEvent(new CustomEvent('change', {detail: {value: 2}}))\n\nexpect(frame.duration).toBe(2)\nexpect(onUpdate).toHaveBeenCalled()"
              },
              {
                "title": "calls onUpdate when number input changes",
                "line": 71,
                "source": "const frame = {duration: 1}\nconst onUpdate = vi.fn()\nconst section = buildDurationSection(frame, onUpdate)\nconst numberInput = section.querySelector('number-input')\n\nnumberInput.dispatchEvent(new CustomEvent('change', {detail: {value: 1.5}}))\n\nexpect(frame.duration).toBe(1.5)\nexpect(onUpdate).toHaveBeenCalled()"
              }
            ],
            "describes": []
          },
          {
            "title": "buildEventsSection",
            "line": 86,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates section with label",
                "line": 88,
                "source": "const frame = {}\nconst section = buildEventsSection(frame, {})\nconst label = section.querySelector('.frame-editor-label')\nexpect(label.textContent).toBe('Events')"
              },
              {
                "title": "displays existing events as chips",
                "line": 96,
                "source": "const frame = {events: ['footstep', 'dust']}\nconst section = buildEventsSection(frame, {})\nconst chips = section.querySelectorAll('.event-chip')\nexpect(chips.length).toBe(2)"
              },
              {
                "title": "displays event suggestions",
                "line": 104,
                "source": "const frame = {}\nconst section = buildEventsSection(frame, {\n    getSuggestions: () => ['footstep', 'jump']\n})\nconst suggestions = section.querySelectorAll('.event-suggestion')\nexpect(suggestions.length).toBe(2)"
              },
              {
                "title": "adds event when suggestion clicked",
                "line": 114,
                "source": "const frame = {}\nconst onFramesUpdate = vi.fn()\nconst section = buildEventsSection(frame, {\n    onFramesUpdate,\n    getSuggestions: () => ['footstep']\n})\n\nconst suggestion = section.querySelector('.event-suggestion')\nsuggestion.click()\n\nexpect(frame.events).toContain('footstep')\nexpect(onFramesUpdate).toHaveBeenCalled()"
              },
              {
                "title": "removes event when remove button clicked",
                "line": 130,
                "source": "const frame = {events: ['footstep', 'dust']}\nconst onFramesUpdate = vi.fn()\nconst section = buildEventsSection(frame, {onFramesUpdate})\n\nconst removeBtn = section.querySelector('.event-chip-remove')\nremoveBtn.click()\n\nexpect(frame.events.length).toBe(1)\nexpect(onFramesUpdate).toHaveBeenCalled()"
              },
              {
                "title": "adds event from input when Enter pressed",
                "line": 143,
                "source": "const frame = {}\nconst onFramesUpdate = vi.fn()\nconst section = buildEventsSection(frame, {onFramesUpdate})\n\nconst input = section.querySelector('.event-input')\ninput.value = 'custom_event'\ninput.dispatchEvent(new KeyboardEvent('keydown', {key: 'Enter'}))\n\nexpect(frame.events).toContain('custom_event')\nexpect(onFramesUpdate).toHaveBeenCalled()"
              },
              {
                "title": "adds event from input on Enter key",
                "line": 157,
                "source": "const frame = {}\nconst onFramesUpdate = vi.fn()\nconst section = buildEventsSection(frame, {onFramesUpdate})\n\nconst input = section.querySelector('.event-input')\ninput.value = 'enter_event'\ninput.dispatchEvent(new KeyboardEvent('keydown', {key: 'Enter'}))\n\nexpect(frame.events).toContain('enter_event')"
              },
              {
                "title": "does not add duplicate events",
                "line": 170,
                "source": "const frame = {events: ['footstep']}\nconst onFramesUpdate = vi.fn()\nconst section = buildEventsSection(frame, {onFramesUpdate})\n\nconst input = section.querySelector('.event-input')\ninput.value = 'footstep'\ninput.dispatchEvent(new KeyboardEvent('keydown', {key: 'Enter'}))\n\nexpect(frame.events.length).toBe(1)"
              },
              {
                "title": "does not add empty events",
                "line": 183,
                "source": "const frame = {}\nconst onFramesUpdate = vi.fn()\nconst section = buildEventsSection(frame, {onFramesUpdate})\n\nconst input = section.querySelector('.event-input')\ninput.value = '   '\ninput.dispatchEvent(new KeyboardEvent('keydown', {key: 'Enter'}))\n\nexpect(frame.events).toBeUndefined()\nexpect(onFramesUpdate).not.toHaveBeenCalled()"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/studio/components/conflict_resolver.doc.js": {
    "file": "/studio/components/conflict_resolver.test.js",
    "describes": [
      {
        "title": "ConflictResolver",
        "line": 6,
        "beforeEach": {
          "line": 12,
          "source": "container = document.createElement('div')\ndocument.body.appendChild(container)\n\nresolver = document.createElement('conflict-resolver')\ncontainer.appendChild(resolver)"
        },
        "afterEach": {
          "line": 21,
          "source": "container.remove()"
        },
        "tests": [
          {
            "title": "extends EditorComponent",
            "line": 26,
            "source": "expect(resolver).toBeInstanceOf(EditorComponent)"
          },
          {
            "title": "has shadow DOM",
            "line": 31,
            "source": "expect(resolver.shadowRoot).not.toBeNull()"
          },
          {
            "title": "creates overlay element",
            "line": 36,
            "source": "const overlay = resolver.shadowRoot.querySelector('editor-overlay')\nexpect(overlay).not.toBeNull()\nexpect(overlay.hasAttribute('fullscreen')).toBe(true)"
          },
          {
            "title": "resolve opens overlay",
            "line": 43,
            "source": "const conflicts = [{\n    id: 'anim1',\n    name: 'Walk',\n    customDate: Date.now(),\n    gameDate: Date.now()\n}]\n\nconst promise = resolver.resolve(conflicts)\nconst overlay = resolver.shadowRoot.querySelector('editor-overlay')\n\nexpect(overlay.isOpen).toBe(true)\n\nconst continueBtn = overlay.querySelector('.continue-btn')\ncontinueBtn.click()\n\nconst result = await promise\nexpect(result).toHaveLength(1)\nexpect(result[0].id).toBe('anim1')"
          },
          {
            "title": "resolve defaults choices to custom",
            "line": 65,
            "source": "const conflicts = [{\n    id: 'anim1',\n    name: 'Walk',\n    customDate: Date.now(),\n    gameDate: Date.now()\n}]\n\nconst promise = resolver.resolve(conflicts)\nconst overlay = resolver.shadowRoot.querySelector('editor-overlay')\n\nconst continueBtn = overlay.querySelector('.continue-btn')\ncontinueBtn.click()\n\nconst result = await promise\nexpect(result[0].choice).toBe('custom')"
          },
          {
            "title": "resolve renders conflict items",
            "line": 84,
            "source": "const conflicts = [\n    {id: 'anim1', name: 'Walk', customDate: null, gameDate: null},\n    {id: 'anim2', name: 'Run', customDate: null, gameDate: null}\n]\n\nresolver.resolve(conflicts)\nconst overlay = resolver.shadowRoot.querySelector('editor-overlay')\nconst items = overlay.querySelectorAll('.conflict-item')\n\nexpect(items).toHaveLength(2)"
          },
          {
            "title": "resolve renders version cards per conflict",
            "line": 98,
            "source": "const conflicts = [{id: 'anim1', name: 'Walk', customDate: null, gameDate: null}]\n\nresolver.resolve(conflicts)\nconst overlay = resolver.shadowRoot.querySelector('editor-overlay')\nconst cards = overlay.querySelectorAll('.version-card')\n\nexpect(cards).toHaveLength(2)"
          },
          {
            "title": "clicking version card changes selection",
            "line": 109,
            "source": "const conflicts = [{id: 'anim1', name: 'Walk', customDate: null, gameDate: null}]\n\nconst promise = resolver.resolve(conflicts)\nconst overlay = resolver.shadowRoot.querySelector('editor-overlay')\nconst cards = overlay.querySelectorAll('.version-card')\n\ncards[1].click()\n\nconst continueBtn = overlay.querySelector('.continue-btn')\ncontinueBtn.click()\n\nconst result = await promise\nexpect(result[0].choice).toBe('game')"
          },
          {
            "title": "closes overlay on continue",
            "line": 126,
            "source": "const conflicts = [{id: 'anim1', name: 'Walk', customDate: null, gameDate: null}]\n\nconst promise = resolver.resolve(conflicts)\nconst overlay = resolver.shadowRoot.querySelector('editor-overlay')\n\nconst continueBtn = overlay.querySelector('.continue-btn')\ncontinueBtn.click()\n\nawait promise\nexpect(overlay.isOpen).toBe(false)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/studio/components/psd_importer.doc.js": {
    "file": "/studio/components/psd_importer.test.js",
    "describes": [
      {
        "title": "PsdImporter",
        "line": 41,
        "beforeEach": {
          "line": 46,
          "source": "container = document.createElement('div')\ndocument.body.appendChild(container)\n\nimporter = document.createElement('psd-importer')\ncontainer.appendChild(importer)"
        },
        "afterEach": {
          "line": 55,
          "source": "container.remove()"
        },
        "tests": [],
        "describes": [
          {
            "title": "initialization",
            "line": 60,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "extends HTMLElement",
                "line": 62,
                "source": "expect(importer).toBeInstanceOf(HTMLElement)"
              },
              {
                "title": "has shadow DOM",
                "line": 67,
                "source": "expect(importer.shadowRoot).not.toBeNull()"
              },
              {
                "title": "contains editor-overlay",
                "line": 72,
                "source": "const overlay = importer.shadowRoot.querySelector('editor-overlay')\nexpect(overlay).not.toBeNull()"
              },
              {
                "title": "has header with title",
                "line": 78,
                "source": "const title = importer.shadowRoot.querySelector('.header-title')\nexpect(title).not.toBeNull()\nexpect(title.textContent).toBe('Import PSD')"
              },
              {
                "title": "has back button",
                "line": 85,
                "source": "const backBtn = importer.shadowRoot.querySelector('.header-btn')\nexpect(backBtn).not.toBeNull()"
              }
            ],
            "describes": []
          },
          {
            "title": "steps",
            "line": 93,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "starts on drop step",
                "line": 95,
                "source": "const dropStep = importer.shadowRoot.querySelector('[data-step=\"drop\"]')\nexpect(dropStep.classList.contains('active')).toBe(true)"
              },
              {
                "title": "has drop zone",
                "line": 101,
                "source": "const dropZone = importer.shadowRoot.querySelector('.drop-zone')\nexpect(dropZone).not.toBeNull()"
              },
              {
                "title": "has hidden file input",
                "line": 107,
                "source": "const input = importer.shadowRoot.querySelector('input[type=\"file\"]')\nexpect(input).not.toBeNull()\nexpect(input.accept).contains('.psd')"
              },
              {
                "title": "has preview step",
                "line": 114,
                "source": "const previewStep = importer.shadowRoot.querySelector('[data-step=\"preview\"]')\nexpect(previewStep).not.toBeNull()"
              },
              {
                "title": "has progress step",
                "line": 120,
                "source": "const progressStep = importer.shadowRoot.querySelector('[data-step=\"progress\"]')\nexpect(progressStep).not.toBeNull()"
              }
            ],
            "describes": []
          },
          {
            "title": "preview step elements",
            "line": 128,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "has preview canvas container",
                "line": 130,
                "source": "const previewContainer = importer.shadowRoot.querySelector('.preview-canvas-container')\nexpect(previewContainer).not.toBeNull()"
              },
              {
                "title": "has animation tags container",
                "line": 136,
                "source": "const tags = importer.shadowRoot.querySelector('.animation-tags')\nexpect(tags).not.toBeNull()"
              },
              {
                "title": "has size inputs",
                "line": 142,
                "source": "const widthInput = importer.shadowRoot.querySelector('.size-input')\nexpect(widthInput).not.toBeNull()"
              },
              {
                "title": "has resize mode select",
                "line": 148,
                "source": "const select = importer.shadowRoot.querySelector('.resize-select')\nexpect(select).not.toBeNull()"
              },
              {
                "title": "has name input",
                "line": 154,
                "source": "const input = importer.shadowRoot.querySelector('.name-input')\nexpect(input).not.toBeNull()"
              },
              {
                "title": "has create button",
                "line": 160,
                "source": "const btn = importer.shadowRoot.querySelector('.create-btn')\nexpect(btn).not.toBeNull()\nexpect(btn.textContent).toBe('Create Animator')"
              }
            ],
            "describes": []
          },
          {
            "title": "progress step elements",
            "line": 169,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "has progress bar",
                "line": 171,
                "source": "const bar = importer.shadowRoot.querySelector('.progress-bar')\nexpect(bar).not.toBeNull()"
              },
              {
                "title": "has progress text",
                "line": 177,
                "source": "const text = importer.shadowRoot.querySelector('.progress-text')\nexpect(text).not.toBeNull()"
              }
            ],
            "describes": []
          },
          {
            "title": "public methods",
            "line": 185,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "has open method",
                "line": 187,
                "source": "expect(typeof importer.open).toBe('function')"
              },
              {
                "title": "has close method",
                "line": 192,
                "source": "expect(typeof importer.close).toBe('function')"
              },
              {
                "title": "has setExistingNames method",
                "line": 197,
                "source": "expect(typeof importer.setExistingNames).toBe('function')"
              },
              {
                "title": "setExistingNames accepts array",
                "line": 202,
                "source": "expect(() => {\n    importer.setExistingNames(['playerAnimator', 'enemyAnimator'])\n}).not.toThrow()"
              }
            ],
            "describes": []
          },
          {
            "title": "aspect ratio lock",
            "line": 211,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "has link button for aspect lock",
                "line": 213,
                "source": "const linkBtn = importer.shadowRoot.querySelector('.link-btn')\nexpect(linkBtn).not.toBeNull()"
              },
              {
                "title": "link button starts active",
                "line": 219,
                "source": "const linkBtn = importer.shadowRoot.querySelector('.link-btn')\nexpect(linkBtn.classList.contains('active')).toBe(true)"
              },
              {
                "title": "clicking link button toggles active state",
                "line": 225,
                "source": "const linkBtn = importer.shadowRoot.querySelector('.link-btn')\nlinkBtn.click()\nexpect(linkBtn.classList.contains('active')).toBe(false)\nlinkBtn.click()\nexpect(linkBtn.classList.contains('active')).toBe(true)"
              }
            ],
            "describes": []
          },
          {
            "title": "drop zone interactions",
            "line": 236,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "clicking drop zone triggers file input click",
                "line": 238,
                "source": "const dropZone = importer.shadowRoot.querySelector('.drop-zone')\nconst fileInput = importer.shadowRoot.querySelector('input[type=\"file\"]')\nconst clickSpy = vi.spyOn(fileInput, 'click')\n\ndropZone.click()\n\nexpect(clickSpy).toHaveBeenCalled()"
              },
              {
                "title": "dragover adds dragover class",
                "line": 249,
                "source": "const dropZone = importer.shadowRoot.querySelector('.drop-zone')\nconst event = new Event('dragover')\nevent.preventDefault = vi.fn()\n\ndropZone.dispatchEvent(event)\n\nexpect(dropZone.classList.contains('dragover')).toBe(true)"
              },
              {
                "title": "dragleave removes dragover class",
                "line": 260,
                "source": "const dropZone = importer.shadowRoot.querySelector('.drop-zone')\ndropZone.classList.add('dragover')\n\ndropZone.dispatchEvent(new Event('dragleave'))\n\nexpect(dropZone.classList.contains('dragover')).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "error message",
            "line": 272,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "has error message element",
                "line": 274,
                "source": "const error = importer.shadowRoot.querySelector('.error-message')\nexpect(error).not.toBeNull()"
              },
              {
                "title": "error message starts hidden",
                "line": 280,
                "source": "const error = importer.shadowRoot.querySelector('.error-message')\nexpect(error.classList.contains('hidden')).toBe(true)"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/studio/components/storage_info.doc.js": {
    "file": "/studio/components/storage_info.test.js",
    "describes": [
      {
        "title": "StorageInfo",
        "line": 6,
        "beforeEach": {
          "line": 12,
          "source": "navigator.storage = {\n    estimate: vi.fn(async () => ({usage: 1024, quota: 1048576}))\n}\n\ncontainer = document.createElement('div')\ndocument.body.appendChild(container)\n\ncomponent = document.createElement('storage-info')\ncontainer.appendChild(component)"
        },
        "afterEach": {
          "line": 25,
          "source": "container.remove()"
        },
        "tests": [
          {
            "title": "extends EditorComponent",
            "line": 30,
            "source": "expect(component).toBeInstanceOf(EditorComponent)"
          },
          {
            "title": "has shadow DOM",
            "line": 35,
            "source": "expect(component.shadowRoot).not.toBeNull()"
          },
          {
            "title": "renders title button",
            "line": 40,
            "source": "const btn = component.shadowRoot.querySelector('.title-btn')\nexpect(btn).not.toBeNull()\nexpect(btn.textContent).toBe('Perky Studio')"
          },
          {
            "title": "renders popover element",
            "line": 47,
            "source": "const popover = component.shadowRoot.querySelector('.popover')\nexpect(popover).not.toBeNull()"
          },
          {
            "title": "popover is closed by default",
            "line": 53,
            "source": "const popover = component.shadowRoot.querySelector('.popover')\nexpect(popover.classList.contains('open')).toBe(false)"
          },
          {
            "title": "clicking title button opens popover",
            "line": 59,
            "source": "const btn = component.shadowRoot.querySelector('.title-btn')\nbtn.click()\n\nawait vi.waitFor(() => {\n    const popover = component.shadowRoot.querySelector('.popover')\n    expect(popover.classList.contains('open')).toBe(true)\n})"
          },
          {
            "title": "clicking title button twice closes popover",
            "line": 70,
            "source": "const btn = component.shadowRoot.querySelector('.title-btn')\nbtn.click()\n\nawait vi.waitFor(() => {\n    const popover = component.shadowRoot.querySelector('.popover')\n    expect(popover.classList.contains('open')).toBe(true)\n})\n\nbtn.click()\n\nconst popover = component.shadowRoot.querySelector('.popover')\nexpect(popover.classList.contains('open')).toBe(false)"
          },
          {
            "title": "popover shows storage info after opening",
            "line": 86,
            "source": "const btn = component.shadowRoot.querySelector('.title-btn')\nbtn.click()\n\nawait vi.waitFor(() => {\n    const popover = component.shadowRoot.querySelector('.popover')\n    expect(popover.querySelector('.popover-section')).not.toBeNull()\n})"
          },
          {
            "title": "popover shows storage bar",
            "line": 97,
            "source": "const btn = component.shadowRoot.querySelector('.title-btn')\nbtn.click()\n\nawait vi.waitFor(() => {\n    const popover = component.shadowRoot.querySelector('.popover')\n    expect(popover.querySelector('.storage-bar')).not.toBeNull()\n})"
          }
        ],
        "describes": []
      }
    ]
  }
}