{
  "/core/perky_module.doc.js": {
    "file": "/core/perky_module.test.js",
    "describes": [
      {
        "title": "PerkyModule",
        "line": 6,
        "beforeEach": {
          "line": 11,
          "source": "const childrenRegistry = new Registry()\nhost = {\n    started: false,\n    on: vi.fn(),\n    emit: vi.fn(),\n    childrenRegistry: childrenRegistry,\n    hasChild: vi.fn((name) => childrenRegistry.has(name)),\n    getChild: vi.fn((name) => childrenRegistry.get(name))\n}\n\nchild = new PerkyModule({$id: 'testChild'})"
        },
        "afterEach": {
          "line": 26,
          "source": "vi.restoreAllMocks()"
        },
        "tests": [
          {
            "title": "constructor",
            "line": 31,
            "source": "expect(child).toBeInstanceOf(PerkyModule)\nexpect(child.$id).toBe('testChild')\nexpect(child.options).toEqual({$id: 'testChild'})\nexpect(child.host).toBeNull()\nexpect(child.installed).toBe(false)"
          },
          {
            "title": "constructor with default name",
            "line": 40,
            "source": "class TestChild extends PerkyModule { }\nconst ext = new TestChild()\nexpect(ext.$id).toBe('TestChild')"
          },
          {
            "title": "install",
            "line": 47,
            "source": "const result = child.install(host, {})\n\nexpect(result).toBe(true)\nexpect(child.host).toBe(host)\nexpect(child.installed).toBe(true)"
          },
          {
            "title": "uninstall",
            "line": 56,
            "source": "child.install(host, {})\nconst result = child.uninstall()\n\nexpect(result).toBe(true)\nexpect(child.host).toBeNull()\nexpect(child.installed).toBe(false)"
          },
          {
            "title": "uninstall when not installed",
            "line": 66,
            "source": "const result = child.uninstall()\nexpect(result).toBe(false)"
          },
          {
            "title": "use with Child class",
            "line": 72,
            "source": "class TestChild extends PerkyModule { }\n\nconst result = child.create(TestChild, {\n    $id: 'test',\n    $category: 'test'\n})\n\nexpect(result).toBeInstanceOf(TestChild)\nexpect(result).toBe(child.getChild('test'))\nexpect(child.hasChild('test')).toBe(true)"
          },
          {
            "title": "auto-generates unique IDs when $id not provided",
            "line": 86,
            "source": "class Enemy extends PerkyModule { }\n\nconst enemy1 = child.create(Enemy, {$category: 'enemy'})\nconst enemy2 = child.create(Enemy, {$category: 'enemy'})\nconst enemy3 = child.create(Enemy, {$category: 'enemy'})\n\nexpect(child.hasChild('enemy')).toBe(true)\nexpect(child.getChild('enemy')).toBe(enemy1)\n\nexpect(child.hasChild('enemy_1')).toBe(true)\nexpect(child.getChild('enemy_1')).toBe(enemy2)\n\nexpect(child.hasChild('enemy_2')).toBe(true)\nexpect(child.getChild('enemy_2')).toBe(enemy3)"
          },
          {
            "title": "explicit $id creates single instance (replacement)",
            "line": 104,
            "source": "class Player extends PerkyModule { }\n\nconst player1 = child.create(Player, {\n    $id: 'player',\n    $category: 'player'\n})\n\nconst player2 = child.create(Player, {\n    $id: 'player',\n    $category: 'player'\n})\n\nexpect(child.hasChild('player')).toBe(true)\nexpect(child.getChild('player')).toBe(player2)\nexpect(child.getChild('player')).not.toBe(player1)\n\nexpect(child.hasChild('player_1')).toBe(false)"
          },
          {
            "title": "unique IDs work with different categories",
            "line": 125,
            "source": "class Enemy extends PerkyModule { }\nclass Projectile extends PerkyModule { }\n\nconst enemy1 = child.create(Enemy, {$category: 'enemy'})\nconst enemy1Name = child.childrenRegistry.keyFor(enemy1)\n\nconst projectile1 = child.create(Projectile, {$category: 'projectile'})\nconst projectile1Name = child.childrenRegistry.keyFor(projectile1)\n\nconst enemy2 = child.create(Enemy, {$category: 'enemy'})\nconst enemy2Name = child.childrenRegistry.keyFor(enemy2)\n\nconst projectile2 = child.create(Projectile, {$category: 'projectile'})\nconst projectile2Name = child.childrenRegistry.keyFor(projectile2)\n\nexpect(child.hasChild(enemy1Name)).toBe(true)\nexpect(child.hasChild(enemy2Name)).toBe(true)\nexpect(child.hasChild(projectile1Name)).toBe(true)\nexpect(child.hasChild(projectile2Name)).toBe(true)\n\nexpect(enemy1).not.toBe(enemy2)\nexpect(projectile1).not.toBe(projectile2)"
          },
          {
            "title": "listNamesFor - single category",
            "line": 293,
            "source": "class TestChild1 extends PerkyModule { }\nclass TestChild2 extends PerkyModule { }\n\nchild.create(TestChild1, {\n    $id: 'ext1',\n    $category: 'module'\n})\n\nchild.create(TestChild2, {\n    $id: 'ext2',\n    $category: 'module'\n})\n\nconst modules = child.listNamesFor('module')\n\nexpect(modules).toHaveLength(2)\nexpect(modules).toContain('ext1')\nexpect(modules).toContain('ext2')"
          },
          {
            "title": "listNamesFor - mixed categories",
            "line": 315,
            "source": "class TestChild1 extends PerkyModule { }\nclass TestChild2 extends PerkyModule { }\nclass TestChild3 extends PerkyModule { }\n\nchild.create(TestChild1, {\n    $id: 'ext1',\n    $category: 'module'\n})\n\nchild.create(TestChild2, {\n    $id: 'ext2',\n    $category: 'service'\n})\n\nchild.create(TestChild3, {\n    $id: 'ext3',\n    $category: 'module'\n})\n\nconst modules = child.listNamesFor('module')\nconst services = child.listNamesFor('service')\n\nexpect(modules).toHaveLength(2)\nexpect(modules).toContain('ext1')\nexpect(modules).toContain('ext3')\n\nexpect(services).toHaveLength(1)\nexpect(services).toContain('ext2')"
          },
          {
            "title": "listNamesFor - empty category",
            "line": 347,
            "source": "const parent = new PerkyModule()\n\nparent.create(PerkyModule, {$category: 'module'})\nparent.create(PerkyModule, {$category: 'module'})\n\nconst services = parent.listNamesFor('service')\nexpect(services).toEqual([])"
          },
          {
            "title": "listNamesFor - dynamic category update",
            "line": 358,
            "source": "const parent = new PerkyModule()\n\nconst childA = parent.create(PerkyModule, {$id: 'childA', $category: 'module'})\nparent.create(PerkyModule, {$id: 'childB', $category: 'service'})\n\nexpect(parent.listNamesFor('module')).toEqual(['childA'])\nexpect(parent.listNamesFor('service')).toEqual(['childB'])\n\nchildA.$category = 'service'\n\nexpect(parent.listNamesFor('module')).toEqual([])\nconst serviceChildren = parent.listNamesFor('service')\nexpect(serviceChildren).toHaveLength(2)\nexpect(serviceChildren).toContain('childA')\nexpect(serviceChildren).toContain('childB')"
          },
          {
            "title": "category index is automatically created",
            "line": 377,
            "source": "const registry = child.childrenRegistry\n\nexpect(registry.hasIndex('$category')).toBe(true)"
          },
          {
            "title": "category index is updated when children are added",
            "line": 384,
            "source": "class TestChild extends PerkyModule { }\nconst registry = child.childrenRegistry\n\nchild.create(TestChild, {\n    $id: 'ext1',\n    $category: 'module'\n})\n\nchild.create(TestChild, {\n    $id: 'ext2',\n    $category: 'service'\n})\n\nconst moduleChildren = registry.lookup('$category', 'module')\nconst serviceChildren = registry.lookup('$category', 'service')\n\nexpect(moduleChildren).toHaveLength(1)\nexpect(serviceChildren).toHaveLength(1)\nexpect(moduleChildren[0]).toBe(child.getChild('ext1'))\nexpect(serviceChildren[0]).toBe(child.getChild('ext2'))"
          },
          {
            "title": "category index is updated when children are removed",
            "line": 408,
            "source": "class TestChild extends PerkyModule { }\nconst registry = child.childrenRegistry\n\nchild.create(TestChild, {\n    $id: 'ext1',\n    $category: 'module'\n})\n\nchild.create(TestChild, {\n    $id: 'ext2',\n    $category: 'module'\n})\n\nlet moduleChildren = registry.lookup('$category', 'module')\nexpect(moduleChildren).toHaveLength(2)\n\nchild.removeChild('ext1')\n\nmoduleChildren = registry.lookup('$category', 'module')\nexpect(moduleChildren).toHaveLength(1)\nexpect(moduleChildren[0]).toBe(child.getChild('ext2'))"
          },
          {
            "title": "registry key is updated when child name changes",
            "line": 433,
            "source": "const parent = new PerkyModule()\n\nconst childModule = parent.create(PerkyModule, {\n    $id: 'oldName',\n    $category: 'module'\n})\n\nexpect(parent.hasChild('oldName')).toBe(true)\nexpect(parent.getChild('oldName')).toBe(childModule)\n\nchildModule.$id = 'newName'\n\nexpect(parent.hasChild('oldName')).toBe(false)\nexpect(parent.hasChild('newName')).toBe(true)\nexpect(parent.getChild('newName')).toBe(childModule)"
          },
          {
            "title": "use with binding",
            "line": 452,
            "source": "class TestChild extends PerkyModule { }\n\nchild.create(TestChild, {\n    $id: 'test',\n    $bind: 'testProperty'\n})\n\nexpect(child.testProperty).toBeInstanceOf(TestChild)"
          },
          {
            "title": "binding updates automatically when $bind changes",
            "line": 464,
            "source": "class TestChild extends PerkyModule { }\n\nconst testChild = child.create(TestChild, {\n    $id: 'test',\n    $bind: 'oldProperty'\n})\n\nexpect(child.oldProperty).toBe(testChild)\nexpect(child.newProperty).toBeUndefined()\n\ntestChild.$bind = 'newProperty'\n\nexpect(child.oldProperty).toBeUndefined()\nexpect(child.newProperty).toBe(testChild)"
          },
          {
            "title": "use with lifecycle disabled",
            "line": 482,
            "source": "class TestChild extends PerkyModule { }\nconst startSpy = vi.spyOn(TestChild.prototype, 'start')\n\nchild.create(TestChild, {\n    $id: 'test',\n    $lifecycle: false\n})\n\nchild.start()\n\nexpect(startSpy).not.toHaveBeenCalled()"
          },
          {
            "title": "use emits registration events",
            "line": 497,
            "source": "class TestChild extends PerkyModule { }\nconst emitSpy = vi.spyOn(child, 'emit')\n\nconst granchild = child.create(TestChild, {\n    $id: 'test',\n    $category: 'testCategory'\n})\n\nexpect(emitSpy).toHaveBeenCalledWith('testCategory:set', 'test', granchild)"
          },
          {
            "title": "removeChild",
            "line": 510,
            "source": "class TestChild extends PerkyModule { }\n\nconst instance = child.create(TestChild, {\n    $id: 'test',\n    $category: 'test'\n})\n\nconst uninstallSpy = vi.spyOn(instance, 'uninstall')\nconst disposeSpy = vi.spyOn(instance, 'dispose')\n\n\nconst result = child.removeChild('test')\n\nexpect(result).toBe(true)\nexpect(uninstallSpy).toHaveBeenCalled()\nexpect(disposeSpy).toHaveBeenCalled()"
          },
          {
            "title": "removeChild non-existent",
            "line": 530,
            "source": "const result = child.removeChild('nonexistent')\nexpect(result).toBe(false)"
          },
          {
            "title": "lifecycle cascade",
            "line": 536,
            "source": "class ChildChild extends PerkyModule { }\nnew ChildChild()\n\nconst childChild = child.create(ChildChild, {\n    $id: 'default',\n    $lifecycle: true\n})\n\nconst childStartSpy = vi.spyOn(childChild, 'start')\nconst childStopSpy = vi.spyOn(childChild, 'stop')\n\nchild.start()\nexpect(childStartSpy).toHaveBeenCalled()\n\nchild.stop()\nexpect(childStopSpy).toHaveBeenCalled()"
          },
          {
            "title": "delegateTo with methods",
            "line": 556,
            "source": "const hostModule = new PerkyModule({$id: 'host'})\nconst childModule = new PerkyModule({$id: 'child'})\n\nchildModule.method1 = vi.fn()\nchildModule.method2 = vi.fn()\n\nchildModule.delegateTo(hostModule, ['method1', 'method2'])\n\nexpect(hostModule.method1).toBeDefined()\nexpect(hostModule.method2).toBeDefined()\nexpect(typeof hostModule.method1).toBe('function')\nexpect(typeof hostModule.method2).toBe('function')"
          },
          {
            "title": "delegateTo with properties",
            "line": 572,
            "source": "const hostModule = new PerkyModule({$id: 'host'})\nconst childModule = new PerkyModule({$id: 'child'})\n\nchildModule.prop1 = 'value1'\nchildModule.prop2 = 'value2'\n\nchildModule.delegateTo(hostModule, ['prop1', 'prop2'])\n\nexpect(hostModule.prop1).toBe('value1')\nexpect(hostModule.prop2).toBe('value2')\n\nhostModule.prop1 = 'newValue'\nexpect(childModule.prop1).toBe('newValue')"
          },
          {
            "title": "delegateTo with mixed methods and properties",
            "line": 589,
            "source": "const hostModule = new PerkyModule({$id: 'host'})\nconst childModule = new PerkyModule({$id: 'child'})\n\nchildModule.count = 0\nchildModule.increment = function () {\n    this.count++\n}\nchildModule.decrement = function () {\n    this.count--\n}\n\nchildModule.delegateTo(hostModule, ['count', 'increment', 'decrement'])\n\nexpect(hostModule.count).toBe(0)\nexpect(typeof hostModule.increment).toBe('function')\nexpect(typeof hostModule.decrement).toBe('function')\n\nhostModule.increment()\nexpect(childModule.count).toBe(1)\nexpect(hostModule.count).toBe(1)\n\nhostModule.decrement()\nexpect(childModule.count).toBe(0)\nexpect(hostModule.count).toBe(0)"
          },
          {
            "title": "delegateTo with getters and setters",
            "line": 617,
            "source": "const hostModule = new PerkyModule({$id: 'host'})\nconst childModule = new PerkyModule({$id: 'child'})\n\nchildModule.internalValue = 10\nObject.defineProperty(childModule, 'value', {\n    get () {\n        return this.internalValue\n    },\n    set (newValue) {\n        this.internalValue = newValue\n    },\n    enumerable: true,\n    configurable: true\n})\n\nchildModule.delegateTo(hostModule, ['value'])\n\nexpect(hostModule.value).toBe(10)\n\nhostModule.value = 20\nexpect(childModule.value).toBe(20)\nexpect(hostModule.value).toBe(20)"
          },
          {
            "title": "delegateTo with object-based aliasing",
            "line": 643,
            "source": "const hostModule = new PerkyModule({$id: 'host'})\nconst childModule = new PerkyModule({$id: 'child'})\n\nchildModule.originalMethod = vi.fn(() => 'result')\nchildModule.originalProp = 'value'\n\nchildModule.delegateTo(hostModule, {\n    originalMethod: 'aliasedMethod',\n    originalProp: 'aliasedProp'\n})\n\nexpect(hostModule.aliasedMethod).toBeDefined()\nexpect(typeof hostModule.aliasedMethod).toBe('function')\nexpect(hostModule.aliasedMethod()).toBe('result')\nexpect(childModule.originalMethod).toHaveBeenCalled()\n\nexpect(hostModule.aliasedProp).toBe('value')\n\nhostModule.aliasedProp = 'new value'\nexpect(childModule.originalProp).toBe('new value')"
          },
          {
            "title": "delegateTo cleans up delegations on uninstall",
            "line": 667,
            "source": "const hostModule = new PerkyModule({$id: 'host'})\nconst childModule = hostModule.create(PerkyModule, {$id: 'child'})\n\nchildModule.getValue = vi.fn(() => 42)\nchildModule.someData = 'test'\n\nchildModule.delegateTo(hostModule, ['getValue', 'someData'])\n\nexpect(hostModule.getValue).toBeDefined()\nexpect(hostModule.getValue()).toBe(42)\nexpect(hostModule.someData).toBe('test')\n\nchildModule.uninstall()\n\nexpect(hostModule.getValue).toBeUndefined()\nexpect(hostModule.someData).toBeUndefined()"
          },
          {
            "title": "delegateTo cleans up delegations on dispose",
            "line": 687,
            "source": "const hostModule = new PerkyModule({$id: 'host'})\nconst childModule = hostModule.create(PerkyModule, {$id: 'child'})\n\nchildModule.doSomething = vi.fn()\n\nchildModule.delegateTo(hostModule, ['doSomething'])\n\nexpect(hostModule.doSomething).toBeDefined()\n\nchildModule.dispose()\n\nexpect(hostModule.doSomething).toBeUndefined()"
          },
          {
            "title": "delegateTo with object-based aliasing cleans up on uninstall",
            "line": 703,
            "source": "const hostModule = new PerkyModule({$id: 'host'})\nconst childModule = hostModule.create(PerkyModule, {$id: 'child'})\n\nchildModule.originalMethod = vi.fn(() => 'result')\n\nchildModule.delegateTo(hostModule, {originalMethod: 'aliasedMethod'})\n\nexpect(hostModule.aliasedMethod).toBeDefined()\nexpect(hostModule.aliasedMethod()).toBe('result')\n\nchildModule.uninstall()\n\nexpect(hostModule.aliasedMethod).toBeUndefined()"
          },
          {
            "title": "cleanDelegations removes all delegated properties",
            "line": 720,
            "source": "const hostModule = new PerkyModule({$id: 'host'})\nconst childModule = new PerkyModule({$id: 'child'})\n\nchildModule.method1 = vi.fn()\nchildModule.method2 = vi.fn()\nchildModule.prop1 = 'value1'\n\nchildModule.delegateTo(hostModule, ['method1', 'prop1'])\nchildModule.delegateTo(hostModule, ['method2'])\n\nexpect(hostModule.method1).toBeDefined()\nexpect(hostModule.method2).toBeDefined()\nexpect(hostModule.prop1).toBe('value1')\n\nchildModule.cleanDelegations()\n\nexpect(hostModule.method1).toBeUndefined()\nexpect(hostModule.method2).toBeUndefined()\nexpect(hostModule.prop1).toBeUndefined()"
          },
          {
            "title": "delegateEventsTo forwards events to host",
            "line": 743,
            "source": "const hostModule = new PerkyModule({$id: 'host'})\nconst childModule = hostModule.create(PerkyModule, {$id: 'child'})\n\nconst updateSpy = vi.fn()\nconst renderSpy = vi.fn()\n\nhostModule.on('update', updateSpy)\nhostModule.on('render', renderSpy)\n\nchildModule.delegateEventsTo(hostModule, ['update', 'render'])\n\nchildModule.emit('update', 0.16)\nchildModule.emit('render', 1.0)\n\nexpect(updateSpy).toHaveBeenCalledWith(0.16)\nexpect(renderSpy).toHaveBeenCalledWith(1.0)"
          },
          {
            "title": "delegateEventsTo with namespace prefixes events",
            "line": 763,
            "source": "const hostModule = new PerkyModule({$id: 'host'})\nconst childModule = hostModule.create(PerkyModule, {$id: 'child'})\n\nconst spy = vi.fn()\nhostModule.on('child:update', spy)\n\nchildModule.delegateEventsTo(hostModule, ['update'], 'child')\n\nchildModule.emit('update', 0.16)\n\nexpect(spy).toHaveBeenCalledWith(0.16)"
          },
          {
            "title": "delegateEventsTo cleans up on uninstall",
            "line": 778,
            "source": "const hostModule = new PerkyModule({$id: 'host'})\nconst childModule = hostModule.create(PerkyModule, {$id: 'child'})\n\nconst spy = vi.fn()\nhostModule.on('update', spy)\n\nchildModule.delegateEventsTo(hostModule, ['update'])\n\nchildModule.emit('update', 0.16)\nexpect(spy).toHaveBeenCalledTimes(1)\n\nchildModule.uninstall()\n\nchildModule.emit('update', 0.16)\nexpect(spy).toHaveBeenCalledTimes(1)"
          },
          {
            "title": "delegateEventsTo cleans up on dispose",
            "line": 797,
            "source": "const hostModule = new PerkyModule({$id: 'host'})\nconst childModule = hostModule.create(PerkyModule, {$id: 'child'})\n\nconst spy = vi.fn()\nhostModule.on('update', spy)\n\nchildModule.delegateEventsTo(hostModule, ['update'])\n\nchildModule.emit('update', 0.16)\nexpect(spy).toHaveBeenCalledTimes(1)\n\nchildModule.dispose()\n\nchildModule.emit('update', 0.16)\nexpect(spy).toHaveBeenCalledTimes(1)"
          },
          {
            "title": "dispose calls dispose on all children in cascade",
            "line": 816,
            "source": "class ChildChild1 extends PerkyModule { }\nclass ChildChild2 extends PerkyModule { }\n\nconst child1 = child.create(ChildChild1, {\n    $id: 'child1'\n})\n\nconst child2 = child.create(ChildChild2, {\n    $id: 'child2'\n})\n\nconst child1DisposeSpy = vi.spyOn(child1, 'dispose')\nconst child2DisposeSpy = vi.spyOn(child2, 'dispose')\n\nchild.dispose()\n\nexpect(child1DisposeSpy).toHaveBeenCalled()\nexpect(child2DisposeSpy).toHaveBeenCalled()\nexpect(child1.disposed).toBe(true)\nexpect(child2.disposed).toBe(true)\nexpect(child.disposed).toBe(true)"
          },
          {
            "title": "dispose with multiple nested children",
            "line": 841,
            "source": "class Level1Child extends PerkyModule { }\nclass Level2Child extends PerkyModule { }\n\nconst level1 = child.create(Level1Child, {\n    $id: 'level1'\n})\n\nconst level2 = child.create(Level2Child, {\n    $id: 'level2'\n})\n\nconst level1DisposeSpy = vi.spyOn(level1, 'dispose')\nconst level2DisposeSpy = vi.spyOn(level2, 'dispose')\n\nchild.dispose()\n\nexpect(level1DisposeSpy).toHaveBeenCalled()\nexpect(level2DisposeSpy).toHaveBeenCalled()\nexpect(level2.disposed).toBe(true)\nexpect(level1.disposed).toBe(true)\nexpect(child.disposed).toBe(true)"
          },
          {
            "title": "dispose skips already disposed children",
            "line": 866,
            "source": "class ChildChild extends PerkyModule { }\n\nconst childChild = new ChildChild()\nconst childDisposeSpy = vi.spyOn(child, 'dispose')\n\nchild.create(ChildChild, {\n    instance: childChild,\n    $id: 'default'\n})\n\nchild.dispose()\nexpect(childDisposeSpy).toHaveBeenCalledTimes(1)\nexpect(child.disposed).toBe(true)\n\nchildDisposeSpy.mockClear()\n\nchildChild.dispose()\n\nexpect(childDisposeSpy).not.toHaveBeenCalled()\nexpect(childChild.disposed).toBe(true)"
          },
          {
            "title": "dispose clears children registry after disposing all children",
            "line": 890,
            "source": "class ChildChild extends PerkyModule { }\n\nconst childChild = new ChildChild()\n\nchild.create(ChildChild, {\n    instance: childChild,\n    $id: 'default'\n})\n\nexpect(child.hasChild('default')).toBe(true)\n\nchild.dispose()\n\nexpect(child.hasChild('default')).toBe(false)\nexpect(child.childrenRegistry.size).toBe(0)"
          }
        ],
        "describes": [
          {
            "title": "addChild",
            "line": 151,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "adds a pre-created module",
                "line": 153,
                "source": "const module = new PerkyModule({$id: 'player', $category: 'entity'})\n\nconst result = child.addChild(module)\n\nexpect(result).toBe(module)\nexpect(child.hasChild('player')).toBe(true)\nexpect(child.getChild('player')).toBe(module)\nexpect(module.host).toBe(child)\nexpect(module.installed).toBe(true)"
              },
              {
                "title": "auto-generates unique ID on collision",
                "line": 166,
                "source": "child.create(PerkyModule, {$id: 'enemy'})\n\nconst module = new PerkyModule({$id: 'enemy', $name: 'enemy'})\nchild.addChild(module)\n\nexpect(module.$id).toBe('enemy_1')\nexpect(child.hasChild('enemy')).toBe(true)\nexpect(child.hasChild('enemy_1')).toBe(true)"
              },
              {
                "title": "auto-generates sequential IDs on multiple collisions",
                "line": 178,
                "source": "const m1 = new PerkyModule({$id: 'enemy', $name: 'enemy'})\nconst m2 = new PerkyModule({$id: 'enemy', $name: 'enemy'})\nconst m3 = new PerkyModule({$id: 'enemy', $name: 'enemy'})\n\nchild.addChild(m1)\nchild.addChild(m2)\nchild.addChild(m3)\n\nexpect(m1.$id).toBe('enemy')\nexpect(m2.$id).toBe('enemy_1')\nexpect(m3.$id).toBe('enemy_2')"
              },
              {
                "title": "throws if module is already installed",
                "line": 193,
                "source": "const parent1 = new PerkyModule({$id: 'parent1'})\nconst parent2 = new PerkyModule({$id: 'parent2'})\nconst module = new PerkyModule({$id: 'child'})\n\nparent1.addChild(module)\n\nexpect(() => parent2.addChild(module)).toThrow('Module is already installed in another parent')"
              },
              {
                "title": "throws if not a PerkyModule instance",
                "line": 204,
                "source": "expect(() => child.addChild({})).toThrow('addChild expects a PerkyModule instance')\nexpect(() => child.addChild(null)).toThrow('addChild expects a PerkyModule instance')\nexpect(() => child.addChild('test')).toThrow('addChild expects a PerkyModule instance')\nexpect(() => child.addChild(42)).toThrow('addChild expects a PerkyModule instance')"
              },
              {
                "title": "calls onInstall hook",
                "line": 212,
                "source": "const onInstallSpy = vi.fn()\n\nclass TestModule extends PerkyModule {\n    onInstall (installedHost) {\n        onInstallSpy(installedHost)\n    }\n}\n\nconst module = new TestModule({$id: 'test'})\nchild.addChild(module)\n\nexpect(onInstallSpy).toHaveBeenCalledWith(child)"
              },
              {
                "title": "sets up lifecycle binding",
                "line": 228,
                "source": "const module = new PerkyModule({$id: 'test'})\nchild.addChild(module)\n\nconst startSpy = vi.spyOn(module, 'start')\nconst stopSpy = vi.spyOn(module, 'stop')\n\nchild.start()\nexpect(startSpy).toHaveBeenCalled()\n\nchild.stop()\nexpect(stopSpy).toHaveBeenCalled()"
              },
              {
                "title": "respects $eagerStart when parent is already started",
                "line": 243,
                "source": "child.start()\n\nconst eager = new PerkyModule({$id: 'eager', $eagerStart: true})\nconst lazy = new PerkyModule({$id: 'lazy', $eagerStart: false})\n\nchild.addChild(eager)\nchild.addChild(lazy)\n\nexpect(eager.started).toBe(true)\nexpect(lazy.started).toBe(false)"
              },
              {
                "title": "emits registration events",
                "line": 257,
                "source": "const emitSpy = vi.spyOn(child, 'emit')\nconst module = new PerkyModule({$id: 'test', $category: 'entity'})\n\nchild.addChild(module)\n\nexpect(emitSpy).toHaveBeenCalledWith('entity:set', 'test', module)"
              },
              {
                "title": "works with $bind option",
                "line": 267,
                "source": "const module = new PerkyModule({$id: 'audio', $bind: 'audioSystem'})\n\nchild.addChild(module)\n\nexpect(child.audioSystem).toBe(module)"
              },
              {
                "title": "respects $lifecycle: false",
                "line": 276,
                "source": "const module = new PerkyModule({$id: 'static', $lifecycle: false})\nchild.addChild(module)\n\nconst startSpy = vi.spyOn(module, 'start')\nconst stopSpy = vi.spyOn(module, 'stop')\n\nchild.start()\nexpect(startSpy).not.toHaveBeenCalled()\n\nchild.stop()\nexpect(stopSpy).not.toHaveBeenCalled()"
              }
            ],
            "describes": []
          },
          {
            "title": "static $category",
            "line": 909,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "uses PerkyModule default category \"perkyModule\" when not specified",
                "line": 910,
                "source": "const module = child.create(PerkyModule, {$id: 'test'})\nexpect(module.$category).toBe('perkyModule')"
              },
              {
                "title": "uses static $category from subclass",
                "line": 916,
                "source": "class GameController extends PerkyModule {\n    static $category = 'controller'\n}\n\nconst controller = child.create(GameController, {$id: 'game'})\nexpect(controller.$category).toBe('controller')"
              },
              {
                "title": "explicit $category overrides static $category",
                "line": 926,
                "source": "class GameController extends PerkyModule {\n    static $category = 'controller'\n}\n\nconst controller = child.create(GameController, {\n    $id: 'game',\n    $category: 'custom'\n})\n\nexpect(controller.$category).toBe('custom')"
              },
              {
                "title": "works with multiple levels of inheritance",
                "line": 940,
                "source": "class BaseController extends PerkyModule {\n    static $category = 'controller'\n}\n\nclass GameController extends BaseController {\n    static $category = 'gameController'\n}\n\nconst controller = child.create(GameController, {$id: 'game'})\nexpect(controller.$category).toBe('gameController')"
              },
              {
                "title": "subclass without static $category falls back to parent",
                "line": 954,
                "source": "class BaseController extends PerkyModule {\n    static $category = 'controller'\n}\n\nclass GameController extends BaseController {\n    // No static $category override\n}\n\nconst controller = child.create(GameController, {$id: 'game'})\nexpect(controller.$category).toBe('controller')"
              },
              {
                "title": "auto-generates unique IDs using static $category",
                "line": 968,
                "source": "class Monster extends PerkyModule {\n    static $category = 'monster'\n}\n\n// Use a fresh parent to ensure predictable ID generation\nconst parent = new PerkyModule()\nconst monster1 = parent.create(Monster)\nconst monster2 = parent.create(Monster)\nconst monster3 = parent.create(Monster)\n\nexpect(monster1.$category).toBe('monster')\nexpect(monster2.$category).toBe('monster')\nexpect(monster3.$category).toBe('monster')\n\nexpect(monster1.$id).toBe('monster')\nexpect(monster2.$id).toBe('monster_1')\nexpect(monster3.$id).toBe('monster_2')"
              },
              {
                "title": "emits correct event based on static $category",
                "line": 989,
                "source": "class GameController extends PerkyModule {\n    static $category = 'controller'\n}\n\nconst emitSpy = vi.spyOn(child, 'emit')\nconst controller = child.create(GameController, {$id: 'game'})\n\nexpect(emitSpy).toHaveBeenCalledWith('controller:set', 'game', controller)"
              },
              {
                "title": "listNamesFor works with static $category",
                "line": 1001,
                "source": "class GameController extends PerkyModule {\n    static $category = 'controller'\n}\n\nclass InputController extends PerkyModule {\n    static $category = 'controller'\n}\n\nchild.create(GameController, {$id: 'game'})\nchild.create(InputController, {$id: 'input'})\n\nconst controllers = child.listNamesFor('controller')\nexpect(controllers).toHaveLength(2)\nexpect(controllers).toContain('game')\nexpect(controllers).toContain('input')"
              }
            ],
            "describes": []
          },
          {
            "title": "$eagerStart",
            "line": 1021,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "default $eagerStart is true for PerkyModule",
                "line": 1022,
                "source": "const module = child.create(PerkyModule, {$id: 'test'})\nexpect(module.$eagerStart).toBe(true)"
              },
              {
                "title": "child starts eagerly when parent is already started",
                "line": 1028,
                "source": "child.start()\n\nconst module = child.create(PerkyModule, {$id: 'test'})\n\nexpect(module.started).toBe(true)"
              },
              {
                "title": "child does not start when parent is not started",
                "line": 1037,
                "source": "const module = child.create(PerkyModule, {$id: 'test'})\n\nexpect(module.started).toBe(false)"
              },
              {
                "title": "$eagerStart: false prevents automatic start",
                "line": 1044,
                "source": "child.start()\n\nconst module = child.create(PerkyModule, {\n    $id: 'test',\n    $eagerStart: false\n})\n\nexpect(module.started).toBe(false)"
              },
              {
                "title": "$eagerStart: true forces eager start",
                "line": 1056,
                "source": "child.start()\n\nconst module = child.create(PerkyModule, {\n    $id: 'test',\n    $eagerStart: true\n})\n\nexpect(module.started).toBe(true)"
              },
              {
                "title": "static $eagerStart is inherited from class",
                "line": 1068,
                "source": "class LazyModule extends PerkyModule {\n    static $eagerStart = false\n}\n\nchild.start()\n\nconst module = child.create(LazyModule, {$id: 'test'})\n\nexpect(module.$eagerStart).toBe(false)\nexpect(module.started).toBe(false)"
              },
              {
                "title": "explicit $eagerStart overrides static $eagerStart",
                "line": 1082,
                "source": "class LazyModule extends PerkyModule {\n    static $eagerStart = false\n}\n\nchild.start()\n\nconst module = child.create(LazyModule, {\n    $id: 'test',\n    $eagerStart: true\n})\n\nexpect(module.$eagerStart).toBe(true)\nexpect(module.started).toBe(true)"
              },
              {
                "title": "$eagerStart cascading: option > static > default",
                "line": 1099,
                "source": "class CustomModule extends PerkyModule {\n    static $eagerStart = false\n}\n\nconst module1 = child.create(CustomModule, {$id: 'test1'})\nexpect(module1.$eagerStart).toBe(false)\n\nconst module2 = child.create(CustomModule, {\n    $id: 'test2',\n    $eagerStart: true\n})\nexpect(module2.$eagerStart).toBe(true)\n\nconst module3 = child.create(PerkyModule, {$id: 'test3'})\nexpect(module3.$eagerStart).toBe(true)"
              },
              {
                "title": "$eagerStart works with $lifecycle: false",
                "line": 1118,
                "source": "child.start()\n\nconst module = child.create(PerkyModule, {\n    $id: 'test',\n    $eagerStart: true,\n    $lifecycle: false\n})\n\nexpect(module.started).toBe(false)"
              },
              {
                "title": "lazy module can be started manually later",
                "line": 1131,
                "source": "child.start()\n\nconst module = child.create(PerkyModule, {\n    $id: 'test',\n    $eagerStart: false\n})\n\nexpect(module.started).toBe(false)\n\nmodule.start()\n\nexpect(module.started).toBe(true)"
              },
              {
                "title": "multiple children with mixed $eagerStart",
                "line": 1147,
                "source": "child.start()\n\nconst eager1 = child.create(PerkyModule, {\n    $id: 'eager1',\n    $eagerStart: true\n})\n\nconst lazy1 = child.create(PerkyModule, {\n    $id: 'lazy1',\n    $eagerStart: false\n})\n\nconst eager2 = child.create(PerkyModule, {\n    $id: 'eager2'\n})\n\nexpect(eager1.started).toBe(true)\nexpect(lazy1.started).toBe(false)\nexpect(eager2.started).toBe(true)"
              },
              {
                "title": "eagerStart getter returns correct value",
                "line": 1170,
                "source": "const eager = child.create(PerkyModule, {\n    $id: 'eager',\n    $eagerStart: true\n})\n\nconst lazy = child.create(PerkyModule, {\n    $id: 'lazy',\n    $eagerStart: false\n})\nexpect(eager.$eagerStart).toBe(true)\nexpect(lazy.$eagerStart).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "$lifecycle",
            "line": 1186,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "$lifecycle is true by default",
                "line": 1188,
                "source": "const module = new PerkyModule()\nexpect(module.$lifecycle).toBe(true)"
              },
              {
                "title": "$lifecycle can be set to false via options",
                "line": 1194,
                "source": "const module = new PerkyModule({$lifecycle: false})\nexpect(module.$lifecycle).toBe(false)"
              },
              {
                "title": "$lifecycle is true when option is explicitly true",
                "line": 1200,
                "source": "const module = new PerkyModule({$lifecycle: true})\nexpect(module.$lifecycle).toBe(true)"
              }
            ],
            "describes": []
          },
          {
            "title": "$status",
            "line": 1208,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns \"stopped\" for new module",
                "line": 1210,
                "source": "const module = new PerkyModule()\nexpect(module.$status).toBe('stopped')"
              },
              {
                "title": "returns \"started\" when module is running",
                "line": 1216,
                "source": "const module = new PerkyModule()\nmodule.start()\nexpect(module.$status).toBe('started')"
              },
              {
                "title": "returns \"stopped\" after stopping a started module",
                "line": 1223,
                "source": "const module = new PerkyModule()\nmodule.start()\nmodule.stop()\nexpect(module.$status).toBe('stopped')"
              },
              {
                "title": "returns \"disposed\" when module is disposed",
                "line": 1231,
                "source": "const module = new PerkyModule()\nmodule.dispose()\nexpect(module.$status).toBe('disposed')"
              },
              {
                "title": "returns \"static\" when $lifecycle is false",
                "line": 1238,
                "source": "const module = new PerkyModule({$lifecycle: false})\nexpect(module.$status).toBe('static')"
              },
              {
                "title": "returns \"static\" even if started when $lifecycle is false",
                "line": 1244,
                "source": "const module = new PerkyModule({$lifecycle: false})\nmodule.start()\nexpect(module.$status).toBe('static')"
              },
              {
                "title": "disposed takes precedence over started",
                "line": 1251,
                "source": "const module = new PerkyModule()\nmodule.start()\nmodule.dispose()\nexpect(module.$status).toBe('disposed')"
              }
            ],
            "describes": []
          },
          {
            "title": "$tags",
            "line": 1261,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "initializes with empty tags by default",
                "line": 1263,
                "source": "const module = new PerkyModule()\nexpect(module.$tags).toEqual([])"
              },
              {
                "title": "initializes with tags from options",
                "line": 1269,
                "source": "const module = new PerkyModule({$tags: ['enemy', 'collidable']})\nexpect(module.$tags).toEqual(['enemy', 'collidable'])"
              },
              {
                "title": "$tags returns array copy",
                "line": 1275,
                "source": "const module = new PerkyModule({$tags: ['test']})\nconst tags1 = module.$tags\nconst tags2 = module.$tags\nexpect(tags1).not.toBe(tags2)\nexpect(tags1).toEqual(tags2)"
              },
              {
                "title": "tags property returns ObservableSet",
                "line": 1284,
                "source": "const module = new PerkyModule()\nexpect(module.tags).toBeDefined()\nexpect(module.tags.size).toBe(0)"
              },
              {
                "title": "can add tags via tags.add()",
                "line": 1291,
                "source": "const module = new PerkyModule()\nmodule.tags.add('enemy')\nmodule.tags.add('collidable')\n\nexpect(module.$tags).toEqual(['enemy', 'collidable'])\nexpect(module.tags.size).toBe(2)"
              },
              {
                "title": "can delete tags via tags.delete()",
                "line": 1301,
                "source": "const module = new PerkyModule({$tags: ['enemy', 'collidable', 'flying']})\n\nmodule.tags.delete('flying')\n\nexpect(module.$tags).toEqual(['enemy', 'collidable'])\nexpect(module.tags.size).toBe(2)"
              },
              {
                "title": "can clear tags via tags.clear()",
                "line": 1311,
                "source": "const module = new PerkyModule({$tags: ['enemy', 'collidable']})\n\nmodule.tags.clear()\n\nexpect(module.$tags).toEqual([])\nexpect(module.tags.size).toBe(0)"
              },
              {
                "title": "tags.add() emits add event",
                "line": 1321,
                "source": "const module = new PerkyModule()\nlet addedTag\n\nmodule.tags.on('add', (tag) => {\n    addedTag = tag\n})\n\nmodule.tags.add('enemy')\n\nexpect(addedTag).toBe('enemy')"
              },
              {
                "title": "tags.delete() emits delete event",
                "line": 1335,
                "source": "const module = new PerkyModule({$tags: ['enemy']})\nlet deletedTag\n\nmodule.tags.on('delete', (tag) => {\n    deletedTag = tag\n})\n\nmodule.tags.delete('enemy')\n\nexpect(deletedTag).toBe('enemy')"
              },
              {
                "title": "tags.clear() emits clear event",
                "line": 1349,
                "source": "const module = new PerkyModule({$tags: ['enemy', 'collidable']})\nlet clearedTags\n\nmodule.tags.on('clear', (tags) => {\n    clearedTags = tags\n})\n\nmodule.tags.clear()\n\nexpect(clearedTags).toEqual(['enemy', 'collidable'])"
              },
              {
                "title": "tags support chaining",
                "line": 1363,
                "source": "const module = new PerkyModule()\n\nmodule.tags.add('enemy').add('collidable').add('flying')\n\nexpect(module.$tags).toEqual(['enemy', 'collidable', 'flying'])"
              },
              {
                "title": "tags support iteration",
                "line": 1372,
                "source": "const module = new PerkyModule({$tags: ['a', 'b', 'c']})\n\nconst collected = []\nfor (const tag of module.tags) {\n    collected.push(tag)\n}\n\nexpect(collected).toEqual(['a', 'b', 'c'])"
              },
              {
                "title": "can set $tags with array",
                "line": 1384,
                "source": "const module = new PerkyModule({$tags: ['enemy', 'collidable']})\n\nmodule.$tags = ['friendly', 'flying']\n\nexpect(module.$tags).toEqual(['friendly', 'flying'])\nexpect(module.tags.size).toBe(2)"
              },
              {
                "title": "setting $tags clears old tags",
                "line": 1394,
                "source": "const module = new PerkyModule({$tags: ['a', 'b', 'c']})\n\nmodule.$tags = ['x', 'y']\n\nexpect(module.$tags).toEqual(['x', 'y'])\nexpect(module.tags.has('a')).toBe(false)\nexpect(module.tags.has('b')).toBe(false)"
              },
              {
                "title": "setting $tags emits clear and add events",
                "line": 1405,
                "source": "const module = new PerkyModule({$tags: ['old']})\nlet clearedTags\nlet addedTags = []\n\nmodule.tags.on('clear', (tags) => {\n    clearedTags = tags\n})\nmodule.tags.on('add', (tag) => {\n    addedTags.push(tag)\n})\n\nmodule.$tags = ['new1', 'new2']\n\nexpect(clearedTags).toEqual(['old'])\nexpect(addedTags).toEqual(['new1', 'new2'])"
              },
              {
                "title": "setting $tags to empty array clears all",
                "line": 1424,
                "source": "const module = new PerkyModule({$tags: ['a', 'b']})\n\nmodule.$tags = []\n\nexpect(module.$tags).toEqual([])\nexpect(module.tags.size).toBe(0)"
              },
              {
                "title": "hasTag returns true when tag exists",
                "line": 1434,
                "source": "const module = new PerkyModule({$tags: ['enemy', 'collidable']})\nexpect(module.hasTag('enemy')).toBe(true)\nexpect(module.hasTag('collidable')).toBe(true)"
              },
              {
                "title": "hasTag returns false when tag does not exist",
                "line": 1441,
                "source": "const module = new PerkyModule({$tags: ['enemy']})\nexpect(module.hasTag('friendly')).toBe(false)\nexpect(module.hasTag('collidable')).toBe(false)"
              },
              {
                "title": "hasTag returns false when no tags set",
                "line": 1448,
                "source": "const module = new PerkyModule()\nexpect(module.hasTag('enemy')).toBe(false)"
              },
              {
                "title": "addTag adds a tag",
                "line": 1454,
                "source": "const module = new PerkyModule()\nmodule.addTag('enemy')\nexpect(module.hasTag('enemy')).toBe(true)"
              },
              {
                "title": "addTag returns true when tag is new",
                "line": 1461,
                "source": "const module = new PerkyModule()\nexpect(module.addTag('enemy')).toBe(true)"
              },
              {
                "title": "addTag returns false when tag already exists",
                "line": 1467,
                "source": "const module = new PerkyModule({$tags: ['enemy']})\nexpect(module.addTag('enemy')).toBe(false)"
              },
              {
                "title": "removeTag removes a tag",
                "line": 1473,
                "source": "const module = new PerkyModule({$tags: ['enemy', 'collidable']})\nmodule.removeTag('enemy')\nexpect(module.hasTag('enemy')).toBe(false)\nexpect(module.hasTag('collidable')).toBe(true)"
              },
              {
                "title": "removeTag returns true when tag existed",
                "line": 1481,
                "source": "const module = new PerkyModule({$tags: ['enemy']})\nexpect(module.removeTag('enemy')).toBe(true)"
              },
              {
                "title": "removeTag returns false when tag did not exist",
                "line": 1487,
                "source": "const module = new PerkyModule()\nexpect(module.removeTag('enemy')).toBe(false)"
              },
              {
                "title": "hasTags returns true when all tags exist (array)",
                "line": 1493,
                "source": "const module = new PerkyModule({$tags: ['enemy', 'collidable', 'flying']})\nexpect(module.hasTags(['enemy', 'collidable'])).toBe(true)\nexpect(module.hasTags(['enemy'])).toBe(true)"
              },
              {
                "title": "hasTags returns false when some tags missing (array)",
                "line": 1500,
                "source": "const module = new PerkyModule({$tags: ['enemy', 'collidable']})\nexpect(module.hasTags(['enemy', 'flying'])).toBe(false)\nexpect(module.hasTags(['friendly', 'enemy'])).toBe(false)"
              },
              {
                "title": "hasTags returns false when no tags match (array)",
                "line": 1507,
                "source": "const module = new PerkyModule({$tags: ['enemy']})\nexpect(module.hasTags(['friendly', 'collidable'])).toBe(false)"
              },
              {
                "title": "hasTags fallback: accepts string and checks single tag",
                "line": 1513,
                "source": "const module = new PerkyModule({$tags: ['enemy', 'collidable']})\nexpect(module.hasTags('enemy')).toBe(true)\nexpect(module.hasTags('collidable')).toBe(true)\nexpect(module.hasTags('friendly')).toBe(false)"
              },
              {
                "title": "hasTags returns true for empty array",
                "line": 1521,
                "source": "const module = new PerkyModule({$tags: ['enemy']})\nexpect(module.hasTags([])).toBe(true)"
              },
              {
                "title": "hasTags returns false when no tags set",
                "line": 1527,
                "source": "const module = new PerkyModule()\nexpect(module.hasTags(['enemy'])).toBe(false)\nexpect(module.hasTags('enemy')).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "composite tag indexing",
            "line": 1536,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "childrenByTags returns children matching all tags (without index)",
                "line": 1538,
                "source": "const child1 = child.create(PerkyModule, {$id: 'c1', $tags: ['enemy', 'collidable', 'flying']})\nconst child2 = child.create(PerkyModule, {$id: 'c2', $tags: ['enemy', 'collidable']})\nchild.create(PerkyModule, {$id: 'c3', $tags: ['friendly', 'collidable']})\n\nconst enemyColliders = child.childrenByTags(['enemy', 'collidable'])\n\nexpect(enemyColliders).toHaveLength(2)\nexpect(enemyColliders).toContain(child1)\nexpect(enemyColliders).toContain(child2)"
              },
              {
                "title": "childrenByTags returns empty array for no matches",
                "line": 1551,
                "source": "child.create(PerkyModule, {$id: 'c1', $tags: ['enemy']})\n\nconst result = child.childrenByTags(['enemy', 'collidable'])\n\nexpect(result).toEqual([])"
              },
              {
                "title": "childrenByTags returns empty array for empty tags",
                "line": 1560,
                "source": "const result = child.childrenByTags()\n\nexpect(result).toEqual([])"
              },
              {
                "title": "addTagsIndex creates composite index",
                "line": 1567,
                "source": "const result = child.addTagsIndex(['enemy', 'collidable'])\n\nexpect(result).toBe(true)\nexpect(child.childrenRegistry.hasIndex('collidable_enemy')).toBe(true)"
              },
              {
                "title": "addTagsIndex normalizes tag order",
                "line": 1575,
                "source": "child.addTagsIndex(['collidable', 'enemy'])\n\nexpect(child.childrenRegistry.hasIndex('collidable_enemy')).toBe(true)"
              },
              {
                "title": "addTagsIndex returns false if already indexed",
                "line": 1582,
                "source": "const result1 = child.addTagsIndex(['enemy', 'collidable'])\nconst result2 = child.addTagsIndex(['enemy', 'collidable'])\n\nexpect(result1).toBe(true)\nexpect(result2).toBe(false)"
              },
              {
                "title": "addTagsIndex returns false for empty array",
                "line": 1591,
                "source": "const result = child.addTagsIndex([])\n\nexpect(result).toBe(false)"
              },
              {
                "title": "addTagsIndex returns false for non-array",
                "line": 1598,
                "source": "const result = child.addTagsIndex('invalid')\n\nexpect(result).toBe(false)"
              },
              {
                "title": "childrenByTags uses index when available",
                "line": 1605,
                "source": "const child1 = child.create(PerkyModule, {$id: 'c1', $tags: ['enemy', 'collidable']})\nchild.create(PerkyModule, {$id: 'c2', $tags: ['enemy']})\n\nchild.addTagsIndex(['enemy', 'collidable'])\n\nconst result = child.childrenByTags(['enemy', 'collidable'])\n\nexpect(result).toHaveLength(1)\nexpect(result).toContain(child1)"
              },
              {
                "title": "removeTagsIndex removes composite index",
                "line": 1618,
                "source": "child.addTagsIndex(['enemy', 'collidable'])\nconst result = child.removeTagsIndex(['enemy', 'collidable'])\n\nexpect(result).toBe(true)\nexpect(child.childrenRegistry.hasIndex('collidable_enemy')).toBe(false)"
              },
              {
                "title": "removeTagsIndex returns false if not indexed",
                "line": 1627,
                "source": "const result = child.removeTagsIndex(['enemy', 'collidable'])\n\nexpect(result).toBe(false)"
              },
              {
                "title": "index automatically updates when child tags change (add)",
                "line": 1634,
                "source": "const testChild = child.create(PerkyModule, {$id: 'test', $tags: ['enemy']})\nchild.addTagsIndex(['enemy', 'collidable'])\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(0)\n\ntestChild.tags.add('collidable')\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(1)\nexpect(child.childrenByTags(['enemy', 'collidable'])).toContain(testChild)"
              },
              {
                "title": "index automatically updates when child tags change (delete)",
                "line": 1646,
                "source": "const testChild = child.create(PerkyModule, {$id: 'test', $tags: ['enemy', 'collidable']})\nchild.addTagsIndex(['enemy', 'collidable'])\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(1)\n\ntestChild.tags.delete('collidable')\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(0)"
              },
              {
                "title": "index automatically updates when child tags change (clear)",
                "line": 1658,
                "source": "const testChild = child.create(PerkyModule, {$id: 'test', $tags: ['enemy', 'collidable']})\nchild.addTagsIndex(['enemy', 'collidable'])\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(1)\n\ntestChild.tags.clear()\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(0)"
              },
              {
                "title": "index updates when $tags is reassigned",
                "line": 1670,
                "source": "const testChild = child.create(PerkyModule, {$id: 'test', $tags: ['enemy']})\nchild.addTagsIndex(['enemy', 'collidable'])\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(0)\n\ntestChild.$tags = ['enemy', 'collidable']\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(1)"
              },
              {
                "title": "multiple composite indexes work independently",
                "line": 1682,
                "source": "const enemy = child.create(PerkyModule, {$id: 'enemy', $tags: ['enemy', 'collidable']})\nconst friendly = child.create(PerkyModule, {$id: 'friendly', $tags: ['friendly', 'collidable']})\n\nchild.addTagsIndex(['enemy', 'collidable'])\nchild.addTagsIndex(['friendly', 'collidable'])\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toEqual([enemy])\nexpect(child.childrenByTags(['friendly', 'collidable'])).toEqual([friendly])"
              },
              {
                "title": "events are cleaned up when child is removed",
                "line": 1694,
                "source": "const testChild = child.create(PerkyModule, {$id: 'test', $tags: ['enemy', 'collidable']})\nchild.addTagsIndex(['enemy', 'collidable'])\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(1)\n\nchild.removeChild('test')\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(0)\n\ntestChild.tags.add('flying')\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(0)"
              },
              {
                "title": "index hooks are added to existing children",
                "line": 1709,
                "source": "const testChild = child.create(PerkyModule, {$id: 'test', $tags: ['enemy']})\n\nchild.addTagsIndex(['enemy', 'collidable'])\n\ntestChild.tags.add('collidable')\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(1)"
              },
              {
                "title": "single tag query works",
                "line": 1720,
                "source": "const child1 = child.create(PerkyModule, {$id: 'c1', $tags: ['enemy']})\nconst child2 = child.create(PerkyModule, {$id: 'c2', $tags: ['enemy', 'flying']})\nchild.create(PerkyModule, {$id: 'c3', $tags: ['friendly']})\n\nconst enemies = child.childrenByTags('enemy')\n\nexpect(enemies).toHaveLength(2)\nexpect(enemies).toContain(child1)\nexpect(enemies).toContain(child2)"
              },
              {
                "title": "works with children without tags",
                "line": 1733,
                "source": "child.create(PerkyModule, {$id: 'c1'})\nconst child2 = child.create(PerkyModule, {$id: 'c2', $tags: ['enemy']})\n\nconst result = child.childrenByTags('enemy')\n\nexpect(result).toEqual([child2])"
              }
            ],
            "describes": []
          },
          {
            "title": "#setupTagIndexListeners",
            "line": 1745,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "listeners are set up when creating a child with tags and indexes exist",
                "line": 1747,
                "source": "child.addTagsIndex(['enemy', 'collidable'])\n\nconst testChild = child.create(PerkyModule, {$id: 'test', $tags: ['enemy']})\n\ntestChild.tags.add('collidable')\n\nconst result = child.childrenByTags(['enemy', 'collidable'])\nexpect(result).toHaveLength(1)\nexpect(result).toContain(testChild)"
              },
              {
                "title": "listeners ARE set up when addTagsIndex is called for existing children",
                "line": 1760,
                "source": "const testChild = child.create(PerkyModule, {$id: 'test', $tags: ['enemy']})\n\nchild.addTagsIndex(['enemy', 'collidable'])\n\ntestChild.tags.add('collidable')\n\nconst result = child.childrenByTags(['enemy', 'collidable'])\nexpect(result).toHaveLength(1)\nexpect(result).toContain(testChild)"
              },
              {
                "title": "listeners ARE set up for children even without initial tags",
                "line": 1773,
                "source": "child.addTagsIndex(['enemy', 'collidable'])\n\nconst testChild = child.create(PerkyModule, {$id: 'test'})\n\ntestChild.tags.add('enemy')\ntestChild.tags.add('collidable')\n\nconst result = child.childrenByTags(['enemy', 'collidable'])\nexpect(result).toHaveLength(1)\nexpect(result).toContain(testChild)"
              },
              {
                "title": "adding a tag triggers index update for all registered indexes",
                "line": 1787,
                "source": "child.addTagsIndex(['enemy', 'collidable'])\nchild.addTagsIndex(['enemy', 'flying'])\n\nconst testChild = child.create(PerkyModule, {$id: 'test', $tags: ['enemy']})\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(0)\nexpect(child.childrenByTags(['enemy', 'flying'])).toHaveLength(0)\n\ntestChild.tags.add('collidable')\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(1)\nexpect(child.childrenByTags(['enemy', 'flying'])).toHaveLength(0)\n\ntestChild.tags.add('flying')\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(1)\nexpect(child.childrenByTags(['enemy', 'flying'])).toHaveLength(1)"
              },
              {
                "title": "deleting a tag triggers index update for all registered indexes",
                "line": 1808,
                "source": "child.addTagsIndex(['enemy', 'collidable'])\nchild.addTagsIndex(['enemy', 'flying'])\n\nconst testChild = child.create(PerkyModule, {$id: 'test', $tags: ['enemy', 'collidable', 'flying']})\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(1)\nexpect(child.childrenByTags(['enemy', 'flying'])).toHaveLength(1)\n\ntestChild.tags.delete('collidable')\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(0)\nexpect(child.childrenByTags(['enemy', 'flying'])).toHaveLength(1)\n\ntestChild.tags.delete('flying')\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(0)\nexpect(child.childrenByTags(['enemy', 'flying'])).toHaveLength(0)"
              },
              {
                "title": "clearing tags triggers index update for all registered indexes",
                "line": 1829,
                "source": "child.addTagsIndex(['enemy', 'collidable'])\nchild.addTagsIndex(['enemy', 'flying'])\n\nconst testChild = child.create(PerkyModule, {$id: 'test', $tags: ['enemy', 'collidable', 'flying']})\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(1)\nexpect(child.childrenByTags(['enemy', 'flying'])).toHaveLength(1)\n\ntestChild.tags.clear()\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(0)\nexpect(child.childrenByTags(['enemy', 'flying'])).toHaveLength(0)"
              },
              {
                "title": "multiple children with different tag combinations",
                "line": 1845,
                "source": "child.addTagsIndex(['enemy', 'collidable'])\nchild.addTagsIndex(['friendly', 'collidable'])\n\nconst enemy = child.create(PerkyModule, {$id: 'enemy', $tags: ['enemy']})\nconst friendly = child.create(PerkyModule, {$id: 'friendly', $tags: ['friendly']})\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(0)\nexpect(child.childrenByTags(['friendly', 'collidable'])).toHaveLength(0)\n\nenemy.tags.add('collidable')\nfriendly.tags.add('collidable')\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toHaveLength(1)\nexpect(child.childrenByTags(['enemy', 'collidable'])).toContain(enemy)\n\nexpect(child.childrenByTags(['friendly', 'collidable'])).toHaveLength(1)\nexpect(child.childrenByTags(['friendly', 'collidable'])).toContain(friendly)"
              },
              {
                "title": "tag changes work correctly when adding index before creating children",
                "line": 1866,
                "source": "child.addTagsIndex(['enemy', 'collidable'])\n\nconst enemy1 = child.create(PerkyModule, {$id: 'enemy1', $tags: ['enemy']})\nconst enemy2 = child.create(PerkyModule, {$id: 'enemy2', $tags: ['enemy', 'collidable']})\n\nexpect(child.childrenByTags(['enemy', 'collidable'])).toEqual([enemy2])\n\nenemy1.tags.add('collidable')\n\nconst result = child.childrenByTags(['enemy', 'collidable'])\nexpect(result).toHaveLength(2)\nexpect(result).toContain(enemy1)\nexpect(result).toContain(enemy2)\n\nenemy2.tags.delete('enemy')\n\nconst result2 = child.childrenByTags(['enemy', 'collidable'])\nexpect(result2).toHaveLength(1)\nexpect(result2).toContain(enemy1)"
              },
              {
                "title": "listeners are set up for existing children when adding a new index",
                "line": 1889,
                "source": "const testChild = child.create(PerkyModule, {$id: 'test', $tags: ['enemy']})\n\nchild.addTagsIndex(['enemy', 'collidable'])\n\ntestChild.tags.add('collidable')\n\nconst result = child.childrenByTags(['enemy', 'collidable'])\nexpect(result).toHaveLength(1)\nexpect(result).toContain(testChild)"
              }
            ],
            "describes": []
          },
          {
            "title": "query and queryAll",
            "line": 1904,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "query finds direct child by id",
                "line": 1906,
                "source": "const player = child.create(PerkyModule, {$id: 'player'})\n\nconst result = child.query('#player')\n\nexpect(result).toBe(player)"
              },
              {
                "title": "query returns null when not found",
                "line": 1915,
                "source": "child.create(PerkyModule, {$id: 'player'})\n\nconst result = child.query('#enemy')\n\nexpect(result).toBeNull()"
              },
              {
                "title": "query finds child by tag",
                "line": 1924,
                "source": "const enemy = child.create(PerkyModule, {$id: 'e1', $tags: ['enemy']})\n\nconst result = child.query('.enemy')\n\nexpect(result).toBe(enemy)"
              },
              {
                "title": "query finds nested children",
                "line": 1933,
                "source": "const world = child.create(PerkyModule, {$id: 'world'})\nconst player = world.create(PerkyModule, {$id: 'player'})\n\nconst result = child.query('#world #player')\n\nexpect(result).toBe(player)"
              },
              {
                "title": "queryAll finds all matching children",
                "line": 1943,
                "source": "const enemy1 = child.create(PerkyModule, {$id: 'e1', $tags: ['enemy']})\nconst enemy2 = child.create(PerkyModule, {$id: 'e2', $tags: ['enemy']})\nchild.create(PerkyModule, {$id: 'player'})\n\nconst result = child.queryAll('.enemy')\n\nexpect(result).toHaveLength(2)\nexpect(result).toContain(enemy1)\nexpect(result).toContain(enemy2)"
              },
              {
                "title": "queryAll returns empty array when none found",
                "line": 1956,
                "source": "child.create(PerkyModule, {$id: 'player'})\n\nconst result = child.queryAll('.enemy')\n\nexpect(result).toEqual([])"
              },
              {
                "title": "queryAll finds nested children from multiple parents",
                "line": 1965,
                "source": "const scene1 = child.create(PerkyModule, {$id: 's1', $category: 'scene'})\nconst scene2 = child.create(PerkyModule, {$id: 's2', $category: 'scene'})\nconst enemy1 = scene1.create(PerkyModule, {$id: 'e1', $tags: ['enemy']})\nconst enemy2 = scene2.create(PerkyModule, {$id: 'e2', $tags: ['enemy']})\n\nconst result = child.queryAll('@scene .enemy')\n\nexpect(result).toHaveLength(2)\nexpect(result).toContain(enemy1)\nexpect(result).toContain(enemy2)"
              },
              {
                "title": "query with combined selectors",
                "line": 1979,
                "source": "child.create(PerkyModule, {$id: 'e1', $tags: ['enemy']})\nconst boss = child.create(PerkyModule, {$id: 'e2', $tags: ['enemy', 'boss']})\n\nconst result = child.query('.enemy.boss')\n\nexpect(result).toBe(boss)"
              }
            ],
            "describes": []
          },
          {
            "title": "childrenByCategory",
            "line": 1991,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns children matching category",
                "line": 1993,
                "source": "const controller1 = child.create(PerkyModule, {$id: 'c1', $category: 'controller'})\nconst controller2 = child.create(PerkyModule, {$id: 'c2', $category: 'controller'})\nchild.create(PerkyModule, {$id: 's1', $category: 'service'})\n\nconst controllers = child.childrenByCategory('controller')\n\nexpect(controllers).toHaveLength(2)\nexpect(controllers).toContain(controller1)\nexpect(controllers).toContain(controller2)"
              },
              {
                "title": "returns empty array for non-existent category",
                "line": 2006,
                "source": "child.create(PerkyModule, {$id: 'c1', $category: 'controller'})\n\nconst result = child.childrenByCategory('nonexistent')\n\nexpect(result).toEqual([])"
              }
            ],
            "describes": []
          },
          {
            "title": "cleanEventDelegations",
            "line": 2017,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "removes all event delegations",
                "line": 2019,
                "source": "const hostModule = new PerkyModule({$id: 'host'})\nconst childModule = hostModule.create(PerkyModule, {$id: 'child'})\n\nconst spy = vi.fn()\nhostModule.on('update', spy)\n\nchildModule.delegateEventsTo(hostModule, ['update'])\n\nchildModule.emit('update', 1)\nexpect(spy).toHaveBeenCalledTimes(1)\n\nchildModule.cleanEventDelegations()\n\nchildModule.emit('update', 2)\nexpect(spy).toHaveBeenCalledTimes(1)"
              },
              {
                "title": "cleanEventDelegations clears delegation list",
                "line": 2038,
                "source": "const hostModule = new PerkyModule({$id: 'host'})\nconst childModule = new PerkyModule({$id: 'child'})\n\nchildModule.delegateEventsTo(hostModule, ['update', 'render'])\n\nchildModule.cleanEventDelegations()\n\nchildModule.delegateEventsTo(hostModule, ['update'])\n\nconst spy = vi.fn()\nhostModule.on('update', spy)\nchildModule.emit('update')\nexpect(spy).toHaveBeenCalledTimes(1)"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/core/utils.doc.js": {
    "file": "/core/utils.test.js",
    "describes": [
      {
        "title": "String Utils",
        "line": 26,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "toCamelCase",
            "line": 28,
            "source": "expect(toCamelCase('hello_world')).toEqual('helloWorld')\nexpect(toCamelCase('hello-world')).toEqual('helloWorld')\nexpect(toCamelCase('hello world')).toEqual('helloWorld')\nexpect(toCamelCase('HelloWorld')).toEqual('helloWorld')\nexpect(toCamelCase('Hello')).toEqual('hello')"
          },
          {
            "title": "toPascalCase",
            "line": 37,
            "source": "expect(toPascalCase('hello_world')).toEqual('HelloWorld')\nexpect(toPascalCase('hello-world')).toEqual('HelloWorld')\nexpect(toPascalCase('hello world')).toEqual('HelloWorld')\nexpect(toPascalCase('HelloWorld')).toEqual('HelloWorld')\nexpect(toPascalCase('Hello')).toEqual('Hello')"
          },
          {
            "title": "toSnakeCase",
            "line": 46,
            "source": "expect(toSnakeCase('helloWorld')).toEqual('hello_world')\nexpect(toSnakeCase('HelloWorld')).toEqual('hello_world')\nexpect(toSnakeCase('hello-world')).toEqual('hello_world')\nexpect(toSnakeCase('hello world')).toEqual('hello_world')\nexpect(toSnakeCase('Hello')).toEqual('hello')"
          },
          {
            "title": "toKebabCase",
            "line": 55,
            "source": "expect(toKebabCase('helloWorld')).toEqual('hello-world')\nexpect(toKebabCase('HelloWorld')).toEqual('hello-world')\nexpect(toKebabCase('hello_world')).toEqual('hello-world')\nexpect(toKebabCase('hello world')).toEqual('hello-world')\nexpect(toKebabCase('Hello')).toEqual('hello')"
          },
          {
            "title": "toHumanCase",
            "line": 64,
            "source": "expect(toHumanCase('GettingStarted')).toEqual('Getting Started')\nexpect(toHumanCase('helloWorld')).toEqual('hello World')\nexpect(toHumanCase('hello_world')).toEqual('hello world')\nexpect(toHumanCase('hello-world')).toEqual('hello world')\nexpect(toHumanCase('HTMLParser')).toEqual('HTML Parser')\nexpect(toHumanCase('Hello')).toEqual('Hello')"
          },
          {
            "title": "singularize",
            "line": 74,
            "source": "expect(singularize('books')).toEqual('book')\nexpect(singularize('cars')).toEqual('car')\nexpect(singularize('houses')).toEqual('house')\n\nexpect(singularize('boxes')).toEqual('box')\nexpect(singularize('dishes')).toEqual('dish')\nexpect(singularize('buses')).toEqual('bus')\nexpect(singularize('wishes')).toEqual('wish')\n\nexpect(singularize('cities')).toEqual('city')\nexpect(singularize('flies')).toEqual('fly')\nexpect(singularize('stories')).toEqual('story')\n\nexpect(singularize('leaves')).toEqual('leaf')\nexpect(singularize('lives')).toEqual('life')\nexpect(singularize('wolves')).toEqual('wolf')\n\nexpect(singularize('men')).toEqual('man')\nexpect(singularize('women')).toEqual('woman')\nexpect(singularize('children')).toEqual('child')\nexpect(singularize('people')).toEqual('person')\nexpect(singularize('mice')).toEqual('mouse')\nexpect(singularize('feet')).toEqual('foot')\nexpect(singularize('teeth')).toEqual('tooth')\nexpect(singularize('cacti')).toEqual('cactus')\n\nexpect(singularize('fish')).toEqual('fish')\nexpect(singularize('deer')).toEqual('deer')"
          },
          {
            "title": "pluralize",
            "line": 106,
            "source": "expect(pluralize('cat', 1)).toEqual('cat')\nexpect(pluralize('cat', 2)).toEqual('cats')\nexpect(pluralize('cat', 0)).toEqual('cats')\nexpect(pluralize('child', 1)).toEqual('child')\nexpect(pluralize('child', 5)).toEqual('children')\nexpect(pluralize('cat', 1, true)).toEqual('1 cat')\nexpect(pluralize('cat', 3, true)).toEqual('3 cats')"
          },
          {
            "title": "plural",
            "line": 117,
            "source": "expect(plural('cat')).toEqual('cats')\nexpect(plural('child')).toEqual('children')\nexpect(plural('person')).toEqual('people')\nexpect(plural('fish')).toEqual('fish')"
          },
          {
            "title": "isPlural",
            "line": 125,
            "source": "expect(isPlural('cats')).toBe(true)\nexpect(isPlural('children')).toBe(true)\nexpect(isPlural('cat')).toBe(false)\nexpect(isPlural('child')).toBe(false)"
          },
          {
            "title": "isSingular",
            "line": 133,
            "source": "expect(isSingular('cat')).toBe(true)\nexpect(isSingular('child')).toBe(true)\nexpect(isSingular('cats')).toBe(false)\nexpect(isSingular('children')).toBe(false)"
          },
          {
            "title": "uniqueId",
            "line": 141,
            "source": "beforeEach(() => {\n    resetUniqueId('testCollection')\n    resetUniqueId('anotherCollection')\n})\n\nconst id1 = uniqueId('testCollection', 'item')\nexpect(id1).toBe('item')\n\nconst id2 = uniqueId('testCollection', 'item')\nexpect(id2).toBe('item_1')\n\nconst id3 = uniqueId('testCollection', 'item')\nexpect(id3).toBe('item_2')\n\nconst user1 = uniqueId('testCollection', 'user')\nexpect(user1).toBe('user')\n\nconst user2 = uniqueId('testCollection', 'user')\nexpect(user2).toBe('user_1')\n\nconst product1 = uniqueId('anotherCollection', 'product')\nexpect(product1).toBe('product')\n\nconst product2 = uniqueId('anotherCollection', 'product')\nexpect(product2).toBe('product_1')\n\nconst single1 = uniqueId('single')\nexpect(single1).toBe('single')\n\nconst single2 = uniqueId('single')\nexpect(single2).toBe('single_1')\n\nconst single3 = uniqueId('single')\nexpect(single3).toBe('single_2')\n\nconst other1 = uniqueId('other')\nexpect(other1).toBe('other')\n\nconst other2 = uniqueId('other')\nexpect(other2).toBe('other_1')"
          },
          {
            "title": "resetUniqueId",
            "line": 185,
            "source": "// Start fresh\nresetUniqueId('testCollection')\n\nuniqueId('testCollection', 'item')\nuniqueId('testCollection', 'item')\nuniqueId('testCollection', 'user')\n\nresetUniqueId('testCollection', 'item')\n\nconst newItem = uniqueId('testCollection', 'item')\nexpect(newItem).toBe('item')\n\nconst newUser = uniqueId('testCollection', 'user')\nexpect(newUser).toBe('user_1')\n\nresetUniqueId('testCollection')\n\nconst resetItem = uniqueId('testCollection', 'item')\nexpect(resetItem).toBe('item')\n\nconst resetUser = uniqueId('testCollection', 'user')\nexpect(resetUser).toBe('user')"
          }
        ],
        "describes": []
      },
      {
        "title": "Object Utils",
        "line": 213,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "deepMerge",
            "line": 215,
            "source": "expect(deepMerge({a: 1}, {b: 2})).toEqual({a: 1, b: 2})\nexpect(deepMerge({a: 1, b: 2}, {b: 3})).toEqual({a: 1, b: 3})\n\nexpect(deepMerge(\n    {a: {b: 1, c: 2}},\n    {a: {c: 3, d: 4}}\n)).toEqual({a: {b: 1, c: 3, d: 4}})\n\nexpect(deepMerge(\n    {a: [1, 2]},\n    {a: [3, 4]}\n)).toEqual({a: [1, 2, 3, 4]})\n\nexpect(deepMerge({a: 1}, null)).toEqual({a: 1})\nexpect(deepMerge({a: 1}, undefined)).toEqual({a: 1})"
          },
          {
            "title": "deepMerge handles circular references",
            "line": 234,
            "source": "const circular = {a: 1}\ncircular.self = circular\n\nexpect(() => {\n    deepMerge({}, circular)\n}).not.toThrow()\n\nconst result = deepMerge({b: 2}, circular)\nexpect(result.a).toBe(1)\nexpect(result.b).toBe(2)\nexpect(result.self).toBe(circular)"
          },
          {
            "title": "setDefaults",
            "line": 249,
            "source": "expect(setDefaults({a: 1}, {a: 0, b: 2})).toEqual({a: 1, b: 2})\n\nexpect(setDefaults(\n    {a: {b: 1}},\n    {a: {b: 0, c: 2}, d: 3}\n)).toEqual({a: {b: 1, c: 2}, d: 3})\n\nexpect(setDefaults({}, {a: 1, b: 2})).toEqual({a: 1, b: 2})\n\nexpect(setDefaults(null, {a: 1, b: 2})).toEqual({a: 1, b: 2})\nexpect(setDefaults(undefined, {a: 1, b: 2})).toEqual({a: 1, b: 2})"
          },
          {
            "title": "getNestedValue",
            "line": 264,
            "source": "const obj = {\n    a: 1,\n    b: {\n        c: 2,\n        d: {\n            e: 3\n        }\n    }\n}\n\nexpect(getNestedValue(obj, 'a')).toBe(1)\nexpect(getNestedValue(obj, 'b.c')).toBe(2)\nexpect(getNestedValue(obj, 'b.d.e')).toBe(3)\n\nexpect(getNestedValue(obj, 'x')).toBeUndefined()\nexpect(getNestedValue(obj, 'b.x')).toBeUndefined()\nexpect(getNestedValue(obj, 'b.d.x')).toBeUndefined()\n\nexpect(getNestedValue(obj)).toEqual(obj)"
          },
          {
            "title": "setNestedValue",
            "line": 287,
            "source": "const obj = {}\n\nsetNestedValue(obj, 'a', 1)\nexpect(obj).toEqual({a: 1})\n\nsetNestedValue(obj, 'b.c', 2)\nexpect(obj.b.c).toBe(2)\n\nsetNestedValue(obj, 'b.c', 3)\nexpect(obj.b.c).toBe(3)\n\nsetNestedValue(obj, 'b.d.e', 4)\nexpect(obj.b.d.e).toBe(4)\nexpect(obj).toEqual({a: 1, b: {c: 3, d: {e: 4}}})"
          }
        ],
        "describes": []
      },
      {
        "title": "delegateProperties",
        "line": 307,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "delegates methods with array notation",
            "line": 309,
            "source": "const source = {\n    method1: () => 'result1',\n    method2: () => 'result2'\n}\nconst receiver = {}\n\ndelegateProperties(receiver, source, ['method1', 'method2'])\n\nexpect(receiver.method1()).toBe('result1')\nexpect(receiver.method2()).toBe('result2')"
          },
          {
            "title": "delegates properties with array notation",
            "line": 323,
            "source": "const source = {prop1: 'value1', prop2: 'value2'}\nconst receiver = {}\n\ndelegateProperties(receiver, source, ['prop1', 'prop2'])\n\nexpect(receiver.prop1).toBe('value1')\nexpect(receiver.prop2).toBe('value2')"
          },
          {
            "title": "property changes reflect on source",
            "line": 334,
            "source": "const source = {prop: 'initial'}\nconst receiver = {}\n\ndelegateProperties(receiver, source, ['prop'])\n\nreceiver.prop = 'changed'\nexpect(source.prop).toBe('changed')"
          },
          {
            "title": "delegates with object notation (aliasing)",
            "line": 345,
            "source": "const source = {\n    originalMethod: () => 'result',\n    originalProp: 'value'\n}\nconst receiver = {}\n\ndelegateProperties(receiver, source, {\n    originalMethod: 'aliasedMethod',\n    originalProp: 'aliasedProp'\n})\n\nexpect(receiver.aliasedMethod()).toBe('result')\nexpect(receiver.aliasedProp).toBe('value')"
          },
          {
            "title": "delegates getters and setters",
            "line": 362,
            "source": "let internalValue = 10\nconst source = {}\nObject.defineProperty(source, 'value', {\n    get () {\n        return internalValue\n    },\n    set (newValue) {\n        internalValue = newValue\n    },\n    enumerable: true,\n    configurable: true\n})\n\nconst receiver = {}\ndelegateProperties(receiver, source, ['value'])\n\nexpect(receiver.value).toBe(10)\nreceiver.value = 20\nexpect(internalValue).toBe(20)\nexpect(receiver.value).toBe(20)"
          },
          {
            "title": "methods are bound to source context",
            "line": 386,
            "source": "const source = {\n    name: 'source',\n    getName () {\n        return this.name\n    }\n}\nconst receiver = {name: 'receiver'}\n\ndelegateProperties(receiver, source, ['getName'])\n\nexpect(receiver.getName()).toBe('source')"
          }
        ],
        "describes": []
      },
      {
        "title": "exportValue",
        "line": 403,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "returns primitive values as-is",
            "line": 405,
            "source": "expect(exportValue(42)).toBe(42)\nexpect(exportValue('hello')).toBe('hello')\nexpect(exportValue(true)).toBe(true)\nexpect(exportValue(null)).toBe(null)\nexpect(exportValue(undefined)).toBe(undefined)"
          },
          {
            "title": "calls export method if available",
            "line": 414,
            "source": "const obj = {\n    value: 42,\n    export () {\n        return {exported: this.value}\n    }\n}\n\nexpect(exportValue(obj)).toEqual({exported: 42})"
          },
          {
            "title": "recursively exports arrays",
            "line": 426,
            "source": "const arr = [1, 2, {value: 3, export: () => 'exported'}]\n\nexpect(exportValue(arr)).toEqual([1, 2, 'exported'])"
          },
          {
            "title": "recursively exports object properties",
            "line": 433,
            "source": "const obj = {\n    a: 1,\n    b: {\n        c: 2,\n        export: () => 'nested'\n    }\n}\n\nexpect(exportValue(obj)).toEqual({a: 1, b: 'nested'})"
          }
        ],
        "describes": []
      },
      {
        "title": "formatNumber",
        "line": 448,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "formats integers without decimals",
            "line": 450,
            "source": "expect(formatNumber(42)).toBe('42')\nexpect(formatNumber(1000)).toBe('1000')\nexpect(formatNumber(0)).toBe('0')"
          },
          {
            "title": "formats floats with 2 decimal places",
            "line": 457,
            "source": "expect(formatNumber(3.14159)).toBe('3.14')\nexpect(formatNumber(42.5)).toBe('42.50')\nexpect(formatNumber(0.123)).toBe('0.12')"
          },
          {
            "title": "handles non-numbers",
            "line": 464,
            "source": "expect(formatNumber('hello')).toBe('hello')\nexpect(formatNumber(null)).toBe('null')"
          }
        ],
        "describes": []
      },
      {
        "title": "formatBytes",
        "line": 472,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "formats 0 bytes",
            "line": 474,
            "source": "expect(formatBytes(0)).toBe('0 B')"
          },
          {
            "title": "formats bytes",
            "line": 479,
            "source": "expect(formatBytes(500)).toBe('500 B')\nexpect(formatBytes(1023)).toBe('1023 B')"
          },
          {
            "title": "formats kilobytes",
            "line": 485,
            "source": "expect(formatBytes(1024)).toBe('1 KB')\nexpect(formatBytes(2048)).toBe('2 KB')"
          },
          {
            "title": "formats megabytes",
            "line": 491,
            "source": "expect(formatBytes(1024 * 1024)).toBe('1.00 MB')\nexpect(formatBytes(1.5 * 1024 * 1024)).toBe('1.50 MB')"
          },
          {
            "title": "formats gigabytes",
            "line": 497,
            "source": "expect(formatBytes(1024 * 1024 * 1024)).toBe('1.00 GB')\nexpect(formatBytes(2.5 * 1024 * 1024 * 1024)).toBe('2.50 GB')"
          }
        ],
        "describes": []
      }
    ]
  },
  "/core/action_controller.doc.js": {
    "file": "/core/action_controller.test.js",
    "describes": [
      {
        "title": "ActionController",
        "line": 5,
        "beforeEach": {
          "line": 9,
          "source": "controller = new ActionController()"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor",
            "line": 14,
            "source": "expect(controller.getAction('any')).toBeUndefined()"
          },
          {
            "title": "addAction and getAction",
            "line": 19,
            "source": "const action = vi.fn()\n\ncontroller.addAction('testAction', action)\n\nexpect(controller.getAction('testAction')).toBe(action)"
          },
          {
            "title": "removeAction",
            "line": 28,
            "source": "const action = vi.fn()\n\ncontroller.addAction('testAction', action)\ncontroller.removeAction('testAction')\n\nexpect(controller.getAction('testAction')).toBeUndefined()"
          },
          {
            "title": "hasAction - registered action",
            "line": 38,
            "source": "const action = vi.fn()\ncontroller.addAction('testAction', action)\n\nexpect(controller.hasAction('testAction')).toBe(true)"
          },
          {
            "title": "hasAction - method action",
            "line": 46,
            "source": "class TestController extends ActionController {\n    testMethod () { }\n}\n\nconst testController = new TestController()\nexpect(testController.hasAction('testMethod')).toBe(true)"
          },
          {
            "title": "hasAction - non-existent action",
            "line": 56,
            "source": "expect(controller.hasAction('nonExistent')).toBe(false)"
          },
          {
            "title": "shouldPropagate - default (no propagable)",
            "line": 61,
            "source": "expect(controller.shouldPropagate('anyAction')).toBe(false)"
          },
          {
            "title": "shouldPropagate - with propagable whitelist",
            "line": 66,
            "source": "class TestController extends ActionController {\n    static propagable = ['move', 'look']\n}\n\nconst testController = new TestController()\n\nexpect(testController.shouldPropagate('move')).toBe(true)\nexpect(testController.shouldPropagate('look')).toBe(true)\nexpect(testController.shouldPropagate('shoot')).toBe(false)"
          },
          {
            "title": "listActions - registered actions",
            "line": 79,
            "source": "controller.addAction('action1', vi.fn())\ncontroller.addAction('action2', vi.fn())\n\nconst actions = controller.listActions()\n\nexpect(actions).toContain('action1')\nexpect(actions).toContain('action2')"
          },
          {
            "title": "listActions - method actions",
            "line": 90,
            "source": "class TestController extends ActionController {\n    jump () { }\n    move () { }\n}\n\nconst testController = new TestController()\nconst actions = testController.listActions()\n\nexpect(actions).toContain('jump')\nexpect(actions).toContain('move')"
          },
          {
            "title": "listActions - excludes internal methods",
            "line": 104,
            "source": "const actions = controller.listActions()\n\nexpect(actions).not.toContain('start')\nexpect(actions).not.toContain('stop')\nexpect(actions).not.toContain('addAction')\nexpect(actions).not.toContain('execute')"
          },
          {
            "title": "listActionsWithParams - returns actions with parameters",
            "line": 114,
            "source": "const testController = new ActionController()\ntestController.addAction('jump', (height, force = 10) => [height, force])\ntestController.addAction('move', (x, y) => [x, y])\n\nconst actionsWithParams = testController.listActionsWithParams()\n\nconst jumpAction = actionsWithParams.find(a => a.name === 'jump')\nexpect(jumpAction).toBeDefined()\nexpect(jumpAction.params).toEqual([\n    {name: 'height', defaultValue: null},\n    {name: 'force', defaultValue: '10'}\n])\n\nconst moveAction = actionsWithParams.find(a => a.name === 'move')\nexpect(moveAction).toBeDefined()\nexpect(moveAction.params).toEqual([\n    {name: 'x', defaultValue: null},\n    {name: 'y', defaultValue: null}\n])"
          },
          {
            "title": "listActionsWithParams - includes registered actions",
            "line": 137,
            "source": "controller.addAction('customAction', (value) => value * 2)\n\nconst actionsWithParams = controller.listActionsWithParams()\n\nconst customAction = actionsWithParams.find(a => a.name === 'customAction')\nexpect(customAction).toBeDefined()\nexpect(customAction.params).toEqual([{name: 'value', defaultValue: null}])"
          },
          {
            "title": "listActionsWithParams - handles functions with no params",
            "line": 148,
            "source": "controller.addAction('noParams', () => {})\n\nconst actionsWithParams = controller.listActionsWithParams()\n\nconst noParamsAction = actionsWithParams.find(a => a.name === 'noParams')\nexpect(noParamsAction).toBeDefined()\nexpect(noParamsAction.params).toEqual([])"
          },
          {
            "title": "listActionsWithParams - handles rest parameters",
            "line": 159,
            "source": "controller.addAction('withRest', (first, ...rest) => [first, rest])\n\nconst actionsWithParams = controller.listActionsWithParams()\n\nconst action = actionsWithParams.find(a => a.name === 'withRest')\nexpect(action).toBeDefined()\nexpect(action.params).toEqual([{name: 'first', defaultValue: null}])"
          },
          {
            "title": "execute with existing registered action",
            "line": 170,
            "source": "const action = vi.fn()\nconst actionListener = vi.fn()\nconst genericListener = vi.fn()\n\ncontroller.addAction('testAction', action)\ncontroller.on('testAction', actionListener)\ncontroller.on('action', genericListener)\n\ncontroller.execute('testAction', 'arg1', 'arg2')\n\nexpect(action).toHaveBeenCalledWith('arg1', 'arg2')\nexpect(actionListener).toHaveBeenCalledWith('arg1', 'arg2')\nexpect(genericListener).toHaveBeenCalledWith('testAction', 'arg1', 'arg2')"
          },
          {
            "title": "execute with method action",
            "line": 187,
            "source": "const action = vi.fn()\nconst actionListener = vi.fn()\n\ncontroller.addAction('testMethod', action)\ncontroller.on('testMethod', actionListener)\n\ncontroller.execute('testMethod', 'arg1')\n\nexpect(action).toHaveBeenCalledWith('arg1')\nexpect(actionListener).toHaveBeenCalledWith('arg1')"
          },
          {
            "title": "execute with non-existent action still emits events",
            "line": 201,
            "source": "const actionListener = vi.fn()\nconst genericListener = vi.fn()\n\ncontroller.on('nonExistentAction', actionListener)\ncontroller.on('action', genericListener)\n\ncontroller.execute('nonExistentAction', 'arg1', 'arg2')\n\nexpect(actionListener).toHaveBeenCalledWith('arg1', 'arg2')\nexpect(genericListener).toHaveBeenCalledWith('nonExistentAction', 'arg1', 'arg2')"
          },
          {
            "title": "multiple event listeners",
            "line": 215,
            "source": "const action = vi.fn()\nconst listener1 = vi.fn()\nconst listener2 = vi.fn()\nconst genericListener = vi.fn()\n\ncontroller.addAction('testAction', action)\ncontroller.on('testAction', listener1)\ncontroller.on('testAction', listener2)\ncontroller.on('action', genericListener)\n\ncontroller.execute('testAction', 'arg')\n\nexpect(action).toHaveBeenCalledWith('arg')\nexpect(listener1).toHaveBeenCalledWith('arg')\nexpect(listener2).toHaveBeenCalledWith('arg')\nexpect(genericListener).toHaveBeenCalledWith('testAction', 'arg')"
          }
        ],
        "describes": [
          {
            "title": "normalizeBindings",
            "line": 235,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "empty bindings",
                "line": 237,
                "source": "class TestController extends ActionController {\n    static bindings = {}\n}\n\nconst normalized = TestController.normalizeBindings('test')\nexpect(normalized).toEqual([])"
              },
              {
                "title": "simple string binding",
                "line": 247,
                "source": "class TestController extends ActionController {\n    static bindings = {\n        shoot: 'Space'\n    }\n}\n\nconst normalized = TestController.normalizeBindings('test')\nexpect(normalized).toEqual([\n    {\n        action: 'shoot',\n        key: 'Space',\n        scoped: false,\n        eventType: 'pressed',\n        controllerName: null\n    }\n])"
              },
              {
                "title": "array of keys binding",
                "line": 267,
                "source": "class TestController extends ActionController {\n    static bindings = {\n        moveUp: ['KeyW', 'ArrowUp']\n    }\n}\n\nconst normalized = TestController.normalizeBindings('test')\nexpect(normalized).toEqual([\n    {\n        action: 'moveUp',\n        key: 'KeyW',\n        scoped: false,\n        eventType: 'pressed',\n        controllerName: null\n    },\n    {\n        action: 'moveUp',\n        key: 'ArrowUp',\n        scoped: false,\n        eventType: 'pressed',\n        controllerName: null\n    }\n])"
              },
              {
                "title": "scoped binding",
                "line": 294,
                "source": "class TestController extends ActionController {\n    static bindings = {\n        shoot: {keys: 'Space', scoped: true}\n    }\n}\n\nconst normalized = TestController.normalizeBindings('game')\nexpect(normalized).toEqual([\n    {\n        action: 'shoot',\n        key: 'Space',\n        scoped: true,\n        eventType: 'pressed',\n        controllerName: 'game'\n    }\n])"
              },
              {
                "title": "scoped binding with multiple keys",
                "line": 314,
                "source": "class TestController extends ActionController {\n    static bindings = {\n        move: {keys: ['KeyW', 'KeyS'], scoped: true}\n    }\n}\n\nconst normalized = TestController.normalizeBindings('game')\nexpect(normalized).toEqual([\n    {\n        action: 'move',\n        key: 'KeyW',\n        scoped: true,\n        eventType: 'pressed',\n        controllerName: 'game'\n    },\n    {\n        action: 'move',\n        key: 'KeyS',\n        scoped: true,\n        eventType: 'pressed',\n        controllerName: 'game'\n    }\n])"
              },
              {
                "title": "custom eventType",
                "line": 341,
                "source": "class TestController extends ActionController {\n    static bindings = {\n        shoot: {keys: 'Space', eventType: 'released'}\n    }\n}\n\nconst normalized = TestController.normalizeBindings('test')\nexpect(normalized).toEqual([\n    {\n        action: 'shoot',\n        key: 'Space',\n        scoped: false,\n        eventType: 'released',\n        controllerName: null\n    }\n])"
              },
              {
                "title": "mixed binding formats",
                "line": 361,
                "source": "class TestController extends ActionController {\n    static bindings = {\n        shoot: 'Space',\n        moveUp: ['KeyW', 'ArrowUp'],\n        jump: {keys: 'KeyJ', scoped: true},\n        dash: {keys: ['KeyD', 'ShiftLeft'], scoped: false, eventType: 'released'}\n    }\n}\n\nconst normalized = TestController.normalizeBindings('player')\nexpect(normalized).toHaveLength(6)\n\nexpect(normalized).toContainEqual({\n    action: 'shoot',\n    key: 'Space',\n    scoped: false,\n    eventType: 'pressed',\n    controllerName: null\n})\n\nexpect(normalized).toContainEqual({\n    action: 'jump',\n    key: 'KeyJ',\n    scoped: true,\n    eventType: 'pressed',\n    controllerName: 'player'\n})"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/core/action_dispatcher.doc.js": {
    "file": "/core/action_dispatcher.test.js",
    "describes": [
      {
        "title": "ActionDispatcher",
        "line": 7,
        "beforeEach": {
          "line": 11,
          "source": "dispatcher = new ActionDispatcher()"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor",
            "line": 16,
            "source": "expect(dispatcher.getController('any')).toBeNull()\nexpect(dispatcher.getActive()).toEqual([])"
          },
          {
            "title": "register",
            "line": 22,
            "source": "const controller = dispatcher.register('main', ActionController)\n\nexpect(dispatcher.getController('main')).toBe(controller)"
          },
          {
            "title": "register with existing name",
            "line": 29,
            "source": "dispatcher.register('main', ActionController)\nconst controller2 = dispatcher.register('main', ActionController)\nexpect(dispatcher.getController('main')).toBe(controller2)"
          },
          {
            "title": "onInstall creates main controller by default",
            "line": 36,
            "source": "const host = new PerkyModule()\nconst newDispatcher = new ActionDispatcher()\n\nnewDispatcher.install(host, {main: true})\n\nexpect(newDispatcher.mainControllerName).toBe('main')\nexpect(newDispatcher.getController('main')).toBeInstanceOf(ActionController)\nexpect(newDispatcher.getActive()).toEqual(['main'])\nexpect(newDispatcher.mainController).toBeInstanceOf(ActionController)"
          },
          {
            "title": "onInstall creates main controller with custom name",
            "line": 49,
            "source": "const host = new PerkyModule()\nconst newDispatcher = new ActionDispatcher()\n\nnewDispatcher.install(host, {main: 'base'})\n\nexpect(newDispatcher.mainControllerName).toBe('base')\nexpect(newDispatcher.getController('base')).toBeInstanceOf(ActionController)\nexpect(newDispatcher.getActive()).toEqual(['base'])\nexpect(newDispatcher.mainController).toBeInstanceOf(ActionController)"
          },
          {
            "title": "onInstall skips main controller when main is false",
            "line": 62,
            "source": "const host = new PerkyModule()\nconst newDispatcher = new ActionDispatcher()\n\nnewDispatcher.install(host, {main: false})\n\nexpect(newDispatcher.mainControllerName).toBeNull()\nexpect(newDispatcher.getActive()).toEqual([])\nexpect(newDispatcher.mainController).toBeNull()"
          },
          {
            "title": "unregister",
            "line": 74,
            "source": "dispatcher.register('main', ActionController)\nconst result = dispatcher.unregister('main')\n\nexpect(result).toBe(true)\nexpect(dispatcher.getController('main')).toBeNull()"
          },
          {
            "title": "unregister non-existent controller",
            "line": 83,
            "source": "const result = dispatcher.unregister('nonExistent')\n\nexpect(result).toBe(false)"
          },
          {
            "title": "unregister active controller",
            "line": 90,
            "source": "dispatcher.register('main', ActionController)\ndispatcher.setActive('main')\ndispatcher.unregister('main')\n\nexpect(dispatcher.getActive()).toEqual([])"
          },
          {
            "title": "unregister controller in stack",
            "line": 99,
            "source": "dispatcher.register('main', ActionController)\ndispatcher.pushActive('main')\n\nexpect(dispatcher.getActive()).toContain('main')\n\ndispatcher.unregister('main')\n\nexpect(dispatcher.getActive()).not.toContain('main')"
          },
          {
            "title": "getController",
            "line": 111,
            "source": "const controller = dispatcher.register('main', ActionController)\n\nexpect(dispatcher.getController('main')).toBe(controller)"
          },
          {
            "title": "setActive valid controller",
            "line": 118,
            "source": "dispatcher.register('main', ActionController)\nconst result = dispatcher.setActive('main')\n\nexpect(result).toBe(true)\nexpect(dispatcher.getActive()).toEqual(['main'])"
          },
          {
            "title": "setActive invalid controller",
            "line": 127,
            "source": "const consoleSpy = vi.spyOn(console, 'warn').mockImplementation(() => { })\n\nconst result = dispatcher.setActive('nonExistent')\n\nexpect(result).toBe(false)\nexpect(dispatcher.getActive()).toEqual([])\nexpect(consoleSpy).toHaveBeenCalled()\n\nconsoleSpy.mockRestore()"
          },
          {
            "title": "setActive with array",
            "line": 140,
            "source": "dispatcher.register('main', ActionController)\ndispatcher.register('pause', ActionController)\n\nconst result = dispatcher.setActive(['main', 'pause'])\n\nexpect(result).toBe(true)\nexpect(dispatcher.getActive()).toEqual(['main', 'pause'])"
          },
          {
            "title": "getActive returns array",
            "line": 151,
            "source": "dispatcher.register('main', ActionController)\ndispatcher.setActive('main')\n\nconst active = dispatcher.getActive()\nexpect(active).toEqual(['main'])\nexpect(Array.isArray(active)).toBe(true)"
          },
          {
            "title": "dispatch - single mode (default)",
            "line": 161,
            "source": "class TestController extends ActionController {\n    someAction = vi.fn()\n}\nconst controller = dispatcher.register('main', TestController)\ndispatcher.setActive('main')\n\ndispatcher.execute('someAction', 'arg1', 'arg2')\n\nexpect(controller.someAction).toHaveBeenCalledWith('arg1', 'arg2')"
          },
          {
            "title": "dispatch - no active controller",
            "line": 174,
            "source": "const consoleSpy = vi.spyOn(console, 'warn').mockImplementation(() => { })\n\ndispatcher.execute('someAction')\n\nexpect(consoleSpy).toHaveBeenCalled()\n\nconsoleSpy.mockRestore()"
          },
          {
            "title": "executeTo",
            "line": 185,
            "source": "class TestController extends PerkyModule {\n    someAction = vi.fn()\n}\nconst controller = dispatcher.register('main', TestController)\ndispatcher.setActive('main')\n\ndispatcher.executeTo('main', 'someAction', 'arg1', 'arg2')\n\nexpect(controller.someAction).toHaveBeenCalledWith('arg1', 'arg2')"
          },
          {
            "title": "dispatchAction",
            "line": 198,
            "source": "class TestController extends PerkyModule {\n    jump = vi.fn()\n}\nconst controller = dispatcher.register('game', TestController)\ndispatcher.setActive('game')\n\nconst binding = {\n    deviceName: 'keyboard',\n    controlName: 'Space',\n    actionName: 'jump',\n    controllerName: 'game'\n}\n\ndispatcher.dispatchAction(binding, 'event', 'device')\n\nexpect(controller.jump).toHaveBeenCalledWith('event', 'device')"
          },
          {
            "title": "dispatchAction - inactive controller does not call action",
            "line": 218,
            "source": "class TestController extends PerkyModule {\n    jump = vi.fn()\n}\n\nconst gameController = dispatcher.register('game', TestController)\ndispatcher.register('other', ActionController)\ndispatcher.register('game', TestController)\ndispatcher.register('other', ActionController)\ndispatcher.setActive('other')\n\nconst binding = {\n    deviceName: 'keyboard',\n    controlName: 'Space',\n    actionName: 'jump',\n    controllerName: 'game'\n}\n\ndispatcher.dispatchAction(binding, 'event', 'device')\n\nexpect(gameController.jump).not.toHaveBeenCalled()"
          },
          {
            "title": "dispatchAction - controller in stack works",
            "line": 242,
            "source": "class TestController extends PerkyModule {\n    jump = vi.fn()\n}\n\nconst gameController = dispatcher.register('game', TestController)\ndispatcher.register('pause', ActionController)\ndispatcher.pushActive('game')\ndispatcher.pushActive('pause')\n\nconst binding = {\n    deviceName: 'keyboard',\n    controlName: 'Space',\n    actionName: 'jump',\n    controllerName: 'game'\n}\n\ndispatcher.dispatchAction(binding, 'event', 'device')\n\nexpect(gameController.jump).toHaveBeenCalledWith('event', 'device')"
          },
          {
            "title": "dispatchAction - active controller fallback",
            "line": 265,
            "source": "class TestController extends ActionController {\n    jump = vi.fn()\n}\n\nconst controller = dispatcher.register('main', TestController)\ndispatcher.setActive('main')\n\nconst binding = {\n    deviceName: 'keyboard',\n    controlName: 'Space',\n    actionName: 'jump'\n}\n\ndispatcher.dispatchAction(binding, 'event', 'device')\n\nexpect(controller.jump).toHaveBeenCalledWith('event', 'device')"
          },
          {
            "title": "pushActive",
            "line": 285,
            "source": "dispatcher.register('main', ActionController)\n\ndispatcher.pushActive('main')\n\nexpect(dispatcher.getActive()).toEqual(['main'])"
          },
          {
            "title": "pushActive - non-existent controller",
            "line": 294,
            "source": "const consoleSpy = vi.spyOn(console, 'warn').mockImplementation(() => { })\n\nconst result = dispatcher.pushActive('nonExistent')\n\nexpect(result).toBe(false)\nexpect(consoleSpy).toHaveBeenCalled()\n\nconsoleSpy.mockRestore()"
          },
          {
            "title": "pushActive - prevents duplicate controller",
            "line": 306,
            "source": "dispatcher.register('main', ActionController)\n\ndispatcher.pushActive('main')\nexpect(dispatcher.getActive()).toEqual(['main'])\n\nconst result = dispatcher.pushActive('main')\n\nexpect(result).toBe(false)\nexpect(dispatcher.getActive()).toEqual(['main'])"
          },
          {
            "title": "pushActive - prevents duplicate even if not on top",
            "line": 319,
            "source": "dispatcher.register('main', ActionController)\ndispatcher.register('other', ActionController)\n\ndispatcher.pushActive('main')\ndispatcher.pushActive('other')\nconst result = dispatcher.pushActive('main')\n\nexpect(result).toBe(false)\nexpect(dispatcher.getActive()).toEqual(['main', 'other'])"
          },
          {
            "title": "popActive - returns popped controller",
            "line": 332,
            "source": "dispatcher.register('main', ActionController)\n\ndispatcher.pushActive('main')\nconst popped = dispatcher.popActive()\n\nexpect(popped).toBe('main')\nexpect(dispatcher.getActive()).toEqual([])"
          },
          {
            "title": "popActive - empty stack",
            "line": 343,
            "source": "const consoleSpy = vi.spyOn(console, 'warn').mockImplementation(() => { })\n\nconst result = dispatcher.popActive()\n\nexpect(result).toBeNull()\nexpect(consoleSpy).toHaveBeenCalled()\n\nconsoleSpy.mockRestore()"
          },
          {
            "title": "getActive - returns copy",
            "line": 355,
            "source": "dispatcher.register('main', ActionController)\n\ndispatcher.pushActive('main')\nconst stack = dispatcher.getActive()\n\nstack.push('other')\n\nexpect(dispatcher.getActive()).toEqual(['main'])"
          },
          {
            "title": "getActive - returns empty array when no active controllers",
            "line": 367,
            "source": "expect(dispatcher.getActive()).toEqual([])"
          },
          {
            "title": "clearActive",
            "line": 372,
            "source": "dispatcher.register('main', ActionController)\ndispatcher.register('pause', ActionController)\n\ndispatcher.pushActive('main')\ndispatcher.pushActive('pause')\n\ndispatcher.clearActive()\n\nexpect(dispatcher.getActive()).toEqual([])"
          },
          {
            "title": "dispatch - stack mode with propagation",
            "line": 385,
            "source": "class GameController extends ActionController {\n    static propagable = ['move']\n\n    move = vi.fn()\n    shoot = vi.fn()\n}\n\nclass PauseController extends ActionController {\n    resume = vi.fn()\n}\n\nconst gameController = dispatcher.register('game', GameController)\nconst pauseController = dispatcher.register('pause', PauseController)\n\ndispatcher.pushActive('game')\ndispatcher.pushActive('pause')\n\ndispatcher.execute('move')\nexpect(gameController.move).toHaveBeenCalled()\n\ndispatcher.execute('shoot')\nexpect(gameController.shoot).toHaveBeenCalled()\n\ndispatcher.execute('resume')\nexpect(pauseController.resume).toHaveBeenCalled()"
          },
          {
            "title": "dispatch - stack mode propagates to lower controller",
            "line": 414,
            "source": "class GameController extends ActionController {\n    static propagable = ['move']\n\n    move = vi.fn()\n}\n\nclass PauseController extends ActionController {\n    resume = vi.fn()\n}\n\nconst gameController = dispatcher.register('game', GameController)\ndispatcher.register('pause', PauseController)\n\ndispatcher.pushActive('game')\ndispatcher.pushActive('pause')\n\ndispatcher.execute('move')\n\nexpect(gameController.move).toHaveBeenCalled()"
          },
          {
            "title": "listControllers",
            "line": 437,
            "source": "dispatcher.register('main', ActionController)\ndispatcher.register('pause', ActionController)\n\nconst controllers = dispatcher.listControllers()\n\nexpect(controllers).toContain('main')\nexpect(controllers).toContain('pause')"
          },
          {
            "title": "listAllActions",
            "line": 448,
            "source": "class GameController extends ActionController {\n    jump () { }\n    move () { }\n}\n\nconst gameController = dispatcher.register('game', GameController)\ngameController.addAction('shoot', vi.fn())\n\nconst allActions = dispatcher.listAllActions()\nconst actionNames = allActions.get('game').map(a => a.name)\n\nexpect(actionNames).toContain('jump')\nexpect(actionNames).toContain('move')\nexpect(actionNames).toContain('shoot')"
          },
          {
            "title": "addAction delegates to main controller",
            "line": 466,
            "source": "const host = new PerkyModule()\nconst newDispatcher = new ActionDispatcher()\nnewDispatcher.install(host, {main: true})\n\nconst action = vi.fn()\nnewDispatcher.addAction('customAction', action)\n\nexpect(newDispatcher.mainController.getAction('customAction')).toBe(action)"
          },
          {
            "title": "addAction returns false without main controller",
            "line": 478,
            "source": "const consoleSpy = vi.spyOn(console, 'warn').mockImplementation(() => {})\n\nconst result = dispatcher.addAction('customAction', vi.fn())\n\nexpect(result).toBe(false)\nexpect(consoleSpy).toHaveBeenCalled()\n\nconsoleSpy.mockRestore()"
          },
          {
            "title": "removeAction delegates to main controller",
            "line": 490,
            "source": "const host = new PerkyModule()\nconst newDispatcher = new ActionDispatcher()\nnewDispatcher.install(host, {main: true})\n\nconst action = vi.fn()\nnewDispatcher.addAction('customAction', action)\nnewDispatcher.removeAction('customAction')\n\nexpect(newDispatcher.mainController.getAction('customAction')).toBeUndefined()"
          },
          {
            "title": "removeAction returns false without main controller",
            "line": 503,
            "source": "const consoleSpy = vi.spyOn(console, 'warn').mockImplementation(() => {})\n\nconst result = dispatcher.removeAction('customAction')\n\nexpect(result).toBe(false)\nexpect(consoleSpy).toHaveBeenCalled()\n\nconsoleSpy.mockRestore()"
          }
        ],
        "describes": []
      }
    ]
  },
  "/core/inflector.doc.js": {
    "file": "/core/inflector.test.js",
    "describes": [
      {
        "title": "Inflector",
        "line": 8,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "addPluralRule adds a custom plural rule",
            "line": 409,
            "source": "const customInflector = new Inflector()\ncustomInflector.addPluralRule(/zyx$/i, 'zyxes')\n\nexpect(customInflector.plural('zyx')).toBe('zyxes')"
          },
          {
            "title": "addSingularRule adds a custom singular rule",
            "line": 417,
            "source": "const customInflector = new Inflector()\ncustomInflector.addSingularRule(/zyxes$/i, 'zyx')\n\nexpect(customInflector.singular('zyxes')).toBe('zyx')"
          },
          {
            "title": "addUncountableRule adds an uncountable word",
            "line": 425,
            "source": "const customInflector = new Inflector()\ncustomInflector.addUncountableRule('customword')\n\nexpect(customInflector.plural('customword')).toBe('customword')\nexpect(customInflector.singular('customword')).toBe('customword')"
          },
          {
            "title": "addIrregularRule adds an irregular plural/singular pair",
            "line": 434,
            "source": "const customInflector = new Inflector()\ncustomInflector.addIrregularRule('customsingle', 'customplural')\n\nexpect(customInflector.plural('customsingle')).toBe('customplural')\nexpect(customInflector.singular('customplural')).toBe('customsingle')"
          }
        ],
        "describes": [
          {
            "title": "plural",
            "line": 10,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "regular plurals",
                "line": 12,
                "source": "expect(inflector.plural('cat')).toBe('cats')\nexpect(inflector.plural('dog')).toBe('dogs')\nexpect(inflector.plural('book')).toBe('books')\nexpect(inflector.plural('car')).toBe('cars')"
              },
              {
                "title": "words ending in s, x, z, ch, sh",
                "line": 20,
                "source": "expect(inflector.plural('bus')).toBe('buses')\nexpect(inflector.plural('box')).toBe('boxes')\nexpect(inflector.plural('quiz')).toBe('quizzes')\nexpect(inflector.plural('church')).toBe('churches')\nexpect(inflector.plural('dish')).toBe('dishes')"
              },
              {
                "title": "words ending in consonant + y",
                "line": 29,
                "source": "expect(inflector.plural('city')).toBe('cities')\nexpect(inflector.plural('fly')).toBe('flies')\nexpect(inflector.plural('story')).toBe('stories')"
              },
              {
                "title": "irregular plurals",
                "line": 36,
                "source": "expect(inflector.plural('child')).toBe('children')\nexpect(inflector.plural('person')).toBe('people')\nexpect(inflector.plural('man')).toBe('men')\nexpect(inflector.plural('woman')).toBe('women')\nexpect(inflector.plural('foot')).toBe('feet')\nexpect(inflector.plural('tooth')).toBe('teeth')\nexpect(inflector.plural('goose')).toBe('geese')\nexpect(inflector.plural('mouse')).toBe('mice')"
              },
              {
                "title": "words ending in f/fe become ves",
                "line": 48,
                "source": "expect(inflector.plural('knife')).toBe('knives')\nexpect(inflector.plural('wife')).toBe('wives')\nexpect(inflector.plural('life')).toBe('lives')\nexpect(inflector.plural('leaf')).toBe('leaves')\nexpect(inflector.plural('half')).toBe('halves')\nexpect(inflector.plural('wolf')).toBe('wolves')\nexpect(inflector.plural('thief')).toBe('thieves')"
              },
              {
                "title": "words ending in o",
                "line": 59,
                "source": "expect(inflector.plural('hero')).toBe('heroes')\nexpect(inflector.plural('potato')).toBe('potatoes')\nexpect(inflector.plural('tomato')).toBe('tomatoes')\nexpect(inflector.plural('echo')).toBe('echoes')\nexpect(inflector.plural('volcano')).toBe('volcanoes')\nexpect(inflector.plural('tornado')).toBe('tornadoes')"
              },
              {
                "title": "Latin/Greek endings",
                "line": 69,
                "source": "expect(inflector.plural('focus')).toBe('foci')\nexpect(inflector.plural('cactus')).toBe('cacti')\nexpect(inflector.plural('fungus')).toBe('fungi')\nexpect(inflector.plural('nucleus')).toBe('nuclei')\nexpect(inflector.plural('radius')).toBe('radii')\nexpect(inflector.plural('stimulus')).toBe('stimuli')\nexpect(inflector.plural('syllabus')).toBe('syllabi')\nexpect(inflector.plural('alumnus')).toBe('alumni')"
              },
              {
                "title": "words ending in -is become -es",
                "line": 81,
                "source": "expect(inflector.plural('analysis')).toBe('analyses')\nexpect(inflector.plural('basis')).toBe('bases')\nexpect(inflector.plural('crisis')).toBe('crises')\nexpect(inflector.plural('diagnosis')).toBe('diagnoses')\nexpect(inflector.plural('hypothesis')).toBe('hypotheses')\nexpect(inflector.plural('thesis')).toBe('theses')\nexpect(inflector.plural('axis')).toBe('axes')"
              },
              {
                "title": "words ending in -um become -a",
                "line": 92,
                "source": "expect(inflector.plural('datum')).toBe('data')\nexpect(inflector.plural('curriculum')).toBe('curricula')\nexpect(inflector.plural('symposium')).toBe('symposia')\nexpect(inflector.plural('bacterium')).toBe('bacteria')\nexpect(inflector.plural('millennium')).toBe('millennia')\nexpect(inflector.plural('addendum')).toBe('addenda')\nexpect(inflector.plural('erratum')).toBe('errata')"
              },
              {
                "title": "words ending in -on become -a",
                "line": 103,
                "source": "expect(inflector.plural('criterion')).toBe('criteria')\nexpect(inflector.plural('phenomenon')).toBe('phenomena')"
              },
              {
                "title": "words ending in -a become -ae",
                "line": 109,
                "source": "expect(inflector.plural('alumna')).toBe('alumnae')\nexpect(inflector.plural('vertebra')).toBe('vertebrae')\nexpect(inflector.plural('alga')).toBe('algae')"
              },
              {
                "title": "words ending in -ex/-ix become -ices",
                "line": 116,
                "source": "expect(inflector.plural('index')).toBe('indices')\nexpect(inflector.plural('appendix')).toBe('appendices')\nexpect(inflector.plural('matrix')).toBe('matrices')"
              },
              {
                "title": "pronouns and special irregulars",
                "line": 123,
                "source": "expect(inflector.plural('I')).toBe('WE')\nexpect(inflector.plural('me')).toBe('us')\nexpect(inflector.plural('he')).toBe('they')\nexpect(inflector.plural('she')).toBe('they')\nexpect(inflector.plural('this')).toBe('these')\nexpect(inflector.plural('that')).toBe('those')\nexpect(inflector.plural('is')).toBe('are')\nexpect(inflector.plural('was')).toBe('were')\nexpect(inflector.plural('has')).toBe('have')"
              }
            ],
            "describes": []
          },
          {
            "title": "singular",
            "line": 138,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "regular singulars",
                "line": 140,
                "source": "expect(inflector.singular('cats')).toBe('cat')\nexpect(inflector.singular('dogs')).toBe('dog')\nexpect(inflector.singular('books')).toBe('book')\nexpect(inflector.singular('cars')).toBe('car')"
              },
              {
                "title": "words ending in es",
                "line": 148,
                "source": "expect(inflector.singular('buses')).toBe('bus')\nexpect(inflector.singular('boxes')).toBe('box')\nexpect(inflector.singular('churches')).toBe('church')\nexpect(inflector.singular('dishes')).toBe('dish')"
              },
              {
                "title": "words ending in ies",
                "line": 156,
                "source": "expect(inflector.singular('cities')).toBe('city')\nexpect(inflector.singular('flies')).toBe('fly')\nexpect(inflector.singular('stories')).toBe('story')"
              },
              {
                "title": "irregular singulars",
                "line": 163,
                "source": "expect(inflector.singular('children')).toBe('child')\nexpect(inflector.singular('people')).toBe('person')\nexpect(inflector.singular('men')).toBe('man')\nexpect(inflector.singular('women')).toBe('woman')\nexpect(inflector.singular('feet')).toBe('foot')\nexpect(inflector.singular('teeth')).toBe('tooth')\nexpect(inflector.singular('geese')).toBe('goose')\nexpect(inflector.singular('mice')).toBe('mouse')"
              }
            ],
            "describes": []
          },
          {
            "title": "isPlural / isSingular",
            "line": 177,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "isPlural returns true for plural words",
                "line": 179,
                "source": "expect(inflector.isPlural('cats')).toBe(true)\nexpect(inflector.isPlural('children')).toBe(true)\nexpect(inflector.isPlural('people')).toBe(true)"
              },
              {
                "title": "isSingular returns true for singular words",
                "line": 186,
                "source": "expect(inflector.isSingular('cat')).toBe(true)\nexpect(inflector.isSingular('child')).toBe(true)\nexpect(inflector.isSingular('person')).toBe(true)"
              }
            ],
            "describes": []
          },
          {
            "title": "uncountables",
            "line": 195,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "uncountable words stay the same in plural",
                "line": 197,
                "source": "expect(inflector.plural('fish')).toBe('fish')\nexpect(inflector.plural('sheep')).toBe('sheep')\nexpect(inflector.plural('deer')).toBe('deer')\nexpect(inflector.plural('moose')).toBe('moose')"
              },
              {
                "title": "uncountable words stay the same in singular",
                "line": 205,
                "source": "expect(inflector.singular('fish')).toBe('fish')\nexpect(inflector.singular('sheep')).toBe('sheep')\nexpect(inflector.singular('deer')).toBe('deer')\nexpect(inflector.singular('moose')).toBe('moose')"
              }
            ],
            "describes": []
          },
          {
            "title": "pluralize with count",
            "line": 215,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns singular for count 1",
                "line": 217,
                "source": "expect(inflector.pluralize('cat', 1)).toBe('cat')\nexpect(inflector.pluralize('child', 1)).toBe('child')"
              },
              {
                "title": "returns plural for count != 1",
                "line": 223,
                "source": "expect(inflector.pluralize('cat', 0)).toBe('cats')\nexpect(inflector.pluralize('cat', 2)).toBe('cats')\nexpect(inflector.pluralize('child', 5)).toBe('children')"
              },
              {
                "title": "includes count when inclusive is true",
                "line": 230,
                "source": "expect(inflector.pluralize('cat', 1, true)).toBe('1 cat')\nexpect(inflector.pluralize('cat', 3, true)).toBe('3 cats')\nexpect(inflector.pluralize('child', 1, true)).toBe('1 child')\nexpect(inflector.pluralize('child', 5, true)).toBe('5 children')"
              }
            ],
            "describes": []
          },
          {
            "title": "case preservation",
            "line": 240,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "preserves lowercase",
                "line": 242,
                "source": "expect(inflector.plural('cat')).toBe('cats')"
              },
              {
                "title": "preserves uppercase",
                "line": 247,
                "source": "expect(inflector.plural('CAT')).toBe('CATS')"
              },
              {
                "title": "preserves title case",
                "line": 252,
                "source": "expect(inflector.plural('Cat')).toBe('Cats')"
              }
            ],
            "describes": []
          },
          {
            "title": "toCamelCase",
            "line": 259,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "converts snake_case",
                "line": 261,
                "source": "expect(inflector.toCamelCase('hello_world')).toBe('helloWorld')"
              },
              {
                "title": "converts kebab-case",
                "line": 266,
                "source": "expect(inflector.toCamelCase('hello-world')).toBe('helloWorld')"
              },
              {
                "title": "converts space separated",
                "line": 271,
                "source": "expect(inflector.toCamelCase('hello world')).toBe('helloWorld')"
              },
              {
                "title": "converts PascalCase",
                "line": 276,
                "source": "expect(inflector.toCamelCase('HelloWorld')).toBe('helloWorld')"
              },
              {
                "title": "handles single word",
                "line": 281,
                "source": "expect(inflector.toCamelCase('Hello')).toBe('hello')"
              }
            ],
            "describes": []
          },
          {
            "title": "toPascalCase",
            "line": 288,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "converts snake_case",
                "line": 290,
                "source": "expect(inflector.toPascalCase('hello_world')).toBe('HelloWorld')"
              },
              {
                "title": "converts kebab-case",
                "line": 295,
                "source": "expect(inflector.toPascalCase('hello-world')).toBe('HelloWorld')"
              },
              {
                "title": "converts space separated",
                "line": 300,
                "source": "expect(inflector.toPascalCase('hello world')).toBe('HelloWorld')"
              },
              {
                "title": "keeps PascalCase",
                "line": 305,
                "source": "expect(inflector.toPascalCase('HelloWorld')).toBe('HelloWorld')"
              },
              {
                "title": "handles single word",
                "line": 310,
                "source": "expect(inflector.toPascalCase('Hello')).toBe('Hello')"
              }
            ],
            "describes": []
          },
          {
            "title": "toSnakeCase",
            "line": 317,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "converts camelCase",
                "line": 319,
                "source": "expect(inflector.toSnakeCase('helloWorld')).toBe('hello_world')"
              },
              {
                "title": "converts PascalCase",
                "line": 324,
                "source": "expect(inflector.toSnakeCase('HelloWorld')).toBe('hello_world')"
              },
              {
                "title": "converts kebab-case",
                "line": 329,
                "source": "expect(inflector.toSnakeCase('hello-world')).toBe('hello_world')"
              },
              {
                "title": "converts space separated",
                "line": 334,
                "source": "expect(inflector.toSnakeCase('hello world')).toBe('hello_world')"
              },
              {
                "title": "handles single word",
                "line": 339,
                "source": "expect(inflector.toSnakeCase('Hello')).toBe('hello')"
              }
            ],
            "describes": []
          },
          {
            "title": "toKebabCase",
            "line": 346,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "converts camelCase",
                "line": 348,
                "source": "expect(inflector.toKebabCase('helloWorld')).toBe('hello-world')"
              },
              {
                "title": "converts PascalCase",
                "line": 353,
                "source": "expect(inflector.toKebabCase('HelloWorld')).toBe('hello-world')"
              },
              {
                "title": "converts snake_case",
                "line": 358,
                "source": "expect(inflector.toKebabCase('hello_world')).toBe('hello-world')"
              },
              {
                "title": "converts space separated",
                "line": 363,
                "source": "expect(inflector.toKebabCase('hello world')).toBe('hello-world')"
              },
              {
                "title": "handles single word",
                "line": 368,
                "source": "expect(inflector.toKebabCase('Hello')).toBe('hello')"
              }
            ],
            "describes": []
          },
          {
            "title": "toHumanCase",
            "line": 375,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "converts PascalCase",
                "line": 377,
                "source": "expect(inflector.toHumanCase('GettingStarted')).toBe('Getting Started')"
              },
              {
                "title": "converts camelCase",
                "line": 382,
                "source": "expect(inflector.toHumanCase('helloWorld')).toBe('hello World')"
              },
              {
                "title": "converts snake_case",
                "line": 387,
                "source": "expect(inflector.toHumanCase('hello_world')).toBe('hello world')"
              },
              {
                "title": "converts kebab-case",
                "line": 392,
                "source": "expect(inflector.toHumanCase('hello-world')).toBe('hello world')"
              },
              {
                "title": "handles consecutive uppercase",
                "line": 397,
                "source": "expect(inflector.toHumanCase('HTMLParser')).toBe('HTML Parser')"
              },
              {
                "title": "handles single word",
                "line": 402,
                "source": "expect(inflector.toHumanCase('Hello')).toBe('Hello')"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/core/logger.doc.js": {
    "file": "/core/logger.test.js",
    "describes": [
      {
        "title": "Logger",
        "line": 6,
        "beforeEach": {
          "line": 8,
          "source": "logger.consoleOutput = false\nlogger.removeListeners()\nlogger.clearHistory()\nlogger.maxHistory = 100"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "is an instance of Notifier",
            "line": 16,
            "source": "expect(logger).toBeInstanceOf(Notifier)"
          },
          {
            "title": "is a singleton",
            "line": 21,
            "source": "const logger2 = (await import('./logger.js')).default\nexpect(logger2).toBe(logger)"
          },
          {
            "title": "clear emits clear event",
            "line": 124,
            "source": "const listener = vi.fn()\nlogger.on('clear', listener)\n\nlogger.clear()\n\nexpect(listener).toHaveBeenCalledTimes(1)"
          },
          {
            "title": "spacer emits spacer event",
            "line": 134,
            "source": "const listener = vi.fn()\nlogger.on('spacer', listener)\n\nlogger.spacer()\n\nexpect(listener).toHaveBeenCalledTimes(1)"
          },
          {
            "title": "title emits title event with title payload",
            "line": 144,
            "source": "const listener = vi.fn()\nlogger.on('title', listener)\n\nlogger.title('My Title')\n\nconst payload = listener.mock.calls[0][0]\nexpect(payload.title).toBe('My Title')\nexpect(payload.event).toBe('title')"
          }
        ],
        "describes": [
          {
            "title": "log",
            "line": 27,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "emits log event with notice type",
                "line": 28,
                "source": "const listener = vi.fn()\nlogger.on('log', listener)\n\nlogger.log('hello', 'world')\n\nexpect(listener).toHaveBeenCalledTimes(1)\nconst payload = listener.mock.calls[0][0]\nexpect(payload.type).toBe('notice')\nexpect(payload.items).toEqual(['hello', 'world'])\nexpect(payload.timestamp).toBeTypeOf('number')"
              },
              {
                "title": "handles objects in items",
                "line": 42,
                "source": "const listener = vi.fn()\nlogger.on('log', listener)\n\nconst obj = {foo: 'bar'}\nlogger.log('data:', obj)\n\nconst payload = listener.mock.calls[0][0]\nexpect(payload.items).toEqual(['data:', obj])"
              }
            ],
            "describes": []
          },
          {
            "title": "convenience methods",
            "line": 55,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "info calls log with type info",
                "line": 56,
                "source": "const listener = vi.fn()\nlogger.on('log', listener)\n\nlogger.info('message')\n\nconst payload = listener.mock.calls[0][0]\nexpect(payload.type).toBe('info')\nexpect(payload.items).toEqual(['message'])"
              },
              {
                "title": "notice calls log with type notice",
                "line": 68,
                "source": "const listener = vi.fn()\nlogger.on('log', listener)\n\nlogger.notice('message')\n\nconst payload = listener.mock.calls[0][0]\nexpect(payload.type).toBe('notice')"
              },
              {
                "title": "warn calls log with type warn",
                "line": 79,
                "source": "const listener = vi.fn()\nlogger.on('log', listener)\n\nlogger.warn('message')\n\nconst payload = listener.mock.calls[0][0]\nexpect(payload.type).toBe('warn')"
              },
              {
                "title": "error calls log with type error",
                "line": 90,
                "source": "const listener = vi.fn()\nlogger.on('log', listener)\n\nlogger.error('message')\n\nconst payload = listener.mock.calls[0][0]\nexpect(payload.type).toBe('error')"
              },
              {
                "title": "success calls log with type success",
                "line": 101,
                "source": "const listener = vi.fn()\nlogger.on('log', listener)\n\nlogger.success('message')\n\nconst payload = listener.mock.calls[0][0]\nexpect(payload.type).toBe('success')"
              },
              {
                "title": "convenience methods accept multiple arguments",
                "line": 112,
                "source": "const listener = vi.fn()\nlogger.on('log', listener)\n\nlogger.info('a', 'b', 'c')\n\nconst payload = listener.mock.calls[0][0]\nexpect(payload.items).toEqual(['a', 'b', 'c'])"
              }
            ],
            "describes": []
          },
          {
            "title": "history",
            "line": 156,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "stores log entries in history",
                "line": 157,
                "source": "logger.info('message 1')\nlogger.warn('message 2')\n\nexpect(logger.history).toHaveLength(2)\nexpect(logger.history[0].event).toBe('log')\nexpect(logger.history[0].type).toBe('info')\nexpect(logger.history[1].type).toBe('warn')"
              },
              {
                "title": "stores all event types in history",
                "line": 168,
                "source": "logger.info('log')\nlogger.clear()\nlogger.spacer()\nlogger.title('Title')\n\nexpect(logger.history).toHaveLength(4)\nexpect(logger.history[0].event).toBe('log')\nexpect(logger.history[1].event).toBe('clear')\nexpect(logger.history[2].event).toBe('spacer')\nexpect(logger.history[3].event).toBe('title')"
              },
              {
                "title": "respects maxHistory limit",
                "line": 182,
                "source": "logger.maxHistory = 3\n\nlogger.info('1')\nlogger.info('2')\nlogger.info('3')\nlogger.info('4')\n\nexpect(logger.history).toHaveLength(3)\nexpect(logger.history[0].items).toEqual(['2'])\nexpect(logger.history[2].items).toEqual(['4'])"
              },
              {
                "title": "clearHistory empties history",
                "line": 196,
                "source": "logger.info('message')\nexpect(logger.history).toHaveLength(1)\n\nlogger.clearHistory()\nexpect(logger.history).toHaveLength(0)"
              },
              {
                "title": "default maxHistory is 100",
                "line": 205,
                "source": "expect(logger.maxHistory).toBe(100)"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/core/notifier.doc.js": {
    "file": "/core/notifier.test.js",
    "describes": [
      {
        "title": "Notifier",
        "line": 5,
        "beforeEach": {
          "line": 9,
          "source": "notifier = new Notifier()"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor",
            "line": 14,
            "source": "expect(notifier.getListenersFor('any')).toBeUndefined()"
          },
          {
            "title": "getListenersFor",
            "line": 19,
            "source": "expect(notifier.getListenersFor('foo')).toBeUndefined()\n\nnotifier.on('foo', () => { })\nexpect(notifier.getListenersFor('foo')).toHaveLength(1)"
          },
          {
            "title": "on",
            "line": 27,
            "source": "const listener = () => { }\n\nexpect(notifier.on('foo', listener)).toBe(listener)\nexpect(notifier.getListenersFor('foo')).toEqual([listener])"
          },
          {
            "title": "once",
            "line": 35,
            "source": "const listener = vi.fn()\nconst wrapper = notifier.once('foo', listener)\n\nexpect(wrapper).not.toBe(listener)\nexpect(notifier.getListenersFor('foo')).toEqual([wrapper])\n\nnotifier.emit('foo', 1, 2, 3)\nexpect(listener).toHaveBeenCalledWith(1, 2, 3)\nexpect(notifier.getListenersFor('foo')).toEqual([])"
          },
          {
            "title": "off",
            "line": 48,
            "source": "const listener = () => { }\n\nexpect(notifier.off('foo', listener)).toBe(false)\n\nnotifier.on('foo', listener)\nexpect(notifier.off('foo', listener)).toBe(true)\nexpect(notifier.getListenersFor('foo')).toEqual([])"
          },
          {
            "title": "emit",
            "line": 59,
            "source": "const listener = vi.fn()\n\nnotifier.on('foo', listener)\nnotifier.emit('foo', 1, 2, 3)\nexpect(listener).toHaveBeenCalledWith(1, 2, 3)\n\nnotifier.emit('bar')\nexpect(listener).toHaveBeenCalledTimes(1)"
          },
          {
            "title": "removeListeners",
            "line": 71,
            "source": "notifier.on('foo', () => { })\nnotifier.on('bar', () => { })\n\nexpect(notifier.getListenersFor('foo')).toHaveLength(1)\nexpect(notifier.getListenersFor('bar')).toHaveLength(1)\n\nnotifier.removeListeners()\nexpect(notifier.getListenersFor('foo')).toBeUndefined()\nexpect(notifier.getListenersFor('bar')).toBeUndefined()"
          },
          {
            "title": "removeListenersFor",
            "line": 84,
            "source": "notifier.on('foo', () => { })\nnotifier.on('bar', () => { })\n\nexpect(notifier.getListenersFor('foo')).toHaveLength(1)\nexpect(notifier.getListenersFor('bar')).toHaveLength(1)\n\nnotifier.removeListenersFor('foo')\nexpect(notifier.getListenersFor('foo')).toBeUndefined()\nexpect(notifier.getListenersFor('bar')).toHaveLength(1)"
          },
          {
            "title": "instances have separate listeners",
            "line": 97,
            "source": "const notifier1 = new Notifier()\nconst notifier2 = new Notifier()\n\nnotifier1.on('test', () => { })\nexpect(notifier1.getListenersFor('test')).toHaveLength(1)\nexpect(notifier2.getListenersFor('test')).toBeUndefined()\n\nnotifier2.on('test', () => { })\nnotifier2.on('test', () => { })\nexpect(notifier1.getListenersFor('test')).toHaveLength(1)\nexpect(notifier2.getListenersFor('test')).toHaveLength(2)"
          },
          {
            "title": "emit passes notifier as this context to listeners",
            "line": 112,
            "source": "let receivedContext\n\nfunction listener () {\n    receivedContext = this\n}\n\nnotifier.on('test', listener)\nnotifier.emit('test', 'arg1', 'arg2')\n\nexpect(receivedContext).toBe(notifier)"
          }
        ],
        "describes": [
          {
            "title": "listenTo",
            "line": 126,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "should register listener on target and track it",
                "line": 127,
                "source": "const target = new Notifier()\nconst listener = vi.fn()\n\nnotifier.listenTo(target, 'test', listener)\ntarget.emit('test', 1, 2, 3)\n\nexpect(listener).toHaveBeenCalledWith(1, 2, 3)"
              },
              {
                "title": "should track multiple listeners on same target",
                "line": 137,
                "source": "const target = new Notifier()\nconst listener1 = vi.fn()\nconst listener2 = vi.fn()\n\nnotifier.listenTo(target, 'event1', listener1)\nnotifier.listenTo(target, 'event2', listener2)\n\ntarget.emit('event1', 'a')\ntarget.emit('event2', 'b')\n\nexpect(listener1).toHaveBeenCalledWith('a')\nexpect(listener2).toHaveBeenCalledWith('b')"
              },
              {
                "title": "should track listeners on multiple targets",
                "line": 152,
                "source": "const target1 = new Notifier()\nconst target2 = new Notifier()\nconst listener1 = vi.fn()\nconst listener2 = vi.fn()\n\nnotifier.listenTo(target1, 'test', listener1)\nnotifier.listenTo(target2, 'test', listener2)\n\ntarget1.emit('test', 1)\ntarget2.emit('test', 2)\n\nexpect(listener1).toHaveBeenCalledWith(1)\nexpect(listener2).toHaveBeenCalledWith(2)"
              }
            ],
            "describes": []
          },
          {
            "title": "listenToOnce",
            "line": 170,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "should register one-time listener on target",
                "line": 171,
                "source": "const target = new Notifier()\nconst listener = vi.fn()\n\nnotifier.listenToOnce(target, 'test', listener)\n\ntarget.emit('test', 1, 2, 3)\nexpect(listener).toHaveBeenCalledWith(1, 2, 3)\nexpect(listener).toHaveBeenCalledTimes(1)\n\n// Should not be called again\ntarget.emit('test', 4, 5, 6)\nexpect(listener).toHaveBeenCalledTimes(1)"
              },
              {
                "title": "should remove from tracking after execution",
                "line": 186,
                "source": "const target = new Notifier()\nconst listener = vi.fn()\n\nnotifier.listenToOnce(target, 'test', listener)\ntarget.emit('test', 'data')\n\n// Cleanup should not fail even if listener already executed\nexpect(() => notifier.cleanExternalListeners()).not.toThrow()"
              },
              {
                "title": "should work with multiple one-time listeners",
                "line": 197,
                "source": "const target = new Notifier()\nconst listener1 = vi.fn()\nconst listener2 = vi.fn()\n\nnotifier.listenToOnce(target, 'event1', listener1)\nnotifier.listenToOnce(target, 'event2', listener2)\n\ntarget.emit('event1', 'a')\ntarget.emit('event2', 'b')\n\nexpect(listener1).toHaveBeenCalledWith('a')\nexpect(listener2).toHaveBeenCalledWith('b')\nexpect(listener1).toHaveBeenCalledTimes(1)\nexpect(listener2).toHaveBeenCalledTimes(1)"
              }
            ],
            "describes": []
          },
          {
            "title": "cleanExternalListeners",
            "line": 216,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "should remove all tracked listeners",
                "line": 217,
                "source": "const target = new Notifier()\nconst listener1 = vi.fn()\nconst listener2 = vi.fn()\n\nnotifier.listenTo(target, 'event1', listener1)\nnotifier.listenTo(target, 'event2', listener2)\n\nnotifier.cleanExternalListeners()\n\n// Listeners should not be called after cleanup\ntarget.emit('event1', 'a')\ntarget.emit('event2', 'b')\n\nexpect(listener1).not.toHaveBeenCalled()\nexpect(listener2).not.toHaveBeenCalled()"
              },
              {
                "title": "should remove listeners from multiple targets",
                "line": 235,
                "source": "const target1 = new Notifier()\nconst target2 = new Notifier()\nconst listener1 = vi.fn()\nconst listener2 = vi.fn()\n\nnotifier.listenTo(target1, 'test', listener1)\nnotifier.listenTo(target2, 'test', listener2)\n\nnotifier.cleanExternalListeners()\n\ntarget1.emit('test', 1)\ntarget2.emit('test', 2)\n\nexpect(listener1).not.toHaveBeenCalled()\nexpect(listener2).not.toHaveBeenCalled()"
              },
              {
                "title": "should handle empty listener list",
                "line": 253,
                "source": "expect(() => notifier.cleanExternalListeners()).not.toThrow()"
              },
              {
                "title": "should allow reusing notifier after cleanup",
                "line": 257,
                "source": "const target = new Notifier()\nconst listener1 = vi.fn()\nconst listener2 = vi.fn()\n\nnotifier.listenTo(target, 'test', listener1)\nnotifier.cleanExternalListeners()\nnotifier.listenTo(target, 'test', listener2)\n\ntarget.emit('test', 'data')\n\nexpect(listener1).not.toHaveBeenCalled()\nexpect(listener2).toHaveBeenCalledWith('data')"
              },
              {
                "title": "should cleanup mix of listenTo and listenToOnce",
                "line": 272,
                "source": "const target = new Notifier()\nconst listener1 = vi.fn()\nconst listener2 = vi.fn()\n\nnotifier.listenTo(target, 'event1', listener1)\nnotifier.listenToOnce(target, 'event2', listener2)\n\nnotifier.cleanExternalListeners()\n\ntarget.emit('event1', 'a')\ntarget.emit('event2', 'b')\n\nexpect(listener1).not.toHaveBeenCalled()\nexpect(listener2).not.toHaveBeenCalled()"
              }
            ],
            "describes": []
          },
          {
            "title": "emitter",
            "line": 291,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "should return a function that emits the given event",
                "line": 292,
                "source": "const listener = vi.fn()\nnotifier.on('test', listener)\n\nconst emitTest = notifier.emitter('test')\nemitTest(1, 2, 3)\n\nexpect(listener).toHaveBeenCalledWith(1, 2, 3)"
              },
              {
                "title": "should pass all arguments to emit",
                "line": 302,
                "source": "const listener = vi.fn()\nnotifier.on('foo', listener)\n\nconst emitFoo = notifier.emitter('foo')\nemitFoo('a', 'b', 'c', 'd')\n\nexpect(listener).toHaveBeenCalledWith('a', 'b', 'c', 'd')"
              },
              {
                "title": "should work with no arguments",
                "line": 312,
                "source": "const listener = vi.fn()\nnotifier.on('bar', listener)\n\nconst emitBar = notifier.emitter('bar')\nemitBar()\n\nexpect(listener).toHaveBeenCalledWith()"
              },
              {
                "title": "should create different emitters for different events",
                "line": 322,
                "source": "const listener1 = vi.fn()\nconst listener2 = vi.fn()\nnotifier.on('event1', listener1)\nnotifier.on('event2', listener2)\n\nconst emit1 = notifier.emitter('event1')\nconst emit2 = notifier.emitter('event2')\n\nemit1('data1')\nemit2('data2')\n\nexpect(listener1).toHaveBeenCalledWith('data1')\nexpect(listener2).toHaveBeenCalledWith('data2')"
              }
            ],
            "describes": []
          },
          {
            "title": "delegateEvents",
            "line": 340,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "should delegate events from target without namespace",
                "line": 341,
                "source": "const target = new Notifier()\nconst listener = vi.fn()\n\nnotifier.on('test', listener)\nnotifier.delegateEvents(target, ['test'])\n\ntarget.emit('test', 1, 2, 3)\nexpect(listener).toHaveBeenCalledWith(1, 2, 3)"
              },
              {
                "title": "should delegate events with namespace prefix",
                "line": 352,
                "source": "const target = new Notifier()\nconst listener = vi.fn()\n\nnotifier.on('child:test', listener)\nnotifier.delegateEvents(target, ['test'], 'child')\n\ntarget.emit('test', 'data')\nexpect(listener).toHaveBeenCalledWith('data')"
              },
              {
                "title": "should handle multiple events from array",
                "line": 363,
                "source": "const target = new Notifier()\nconst listener1 = vi.fn()\nconst listener2 = vi.fn()\n\nnotifier.on('event1', listener1)\nnotifier.on('event2', listener2)\nnotifier.delegateEvents(target, ['event1', 'event2'])\n\ntarget.emit('event1', 'a')\ntarget.emit('event2', 'b')\n\nexpect(listener1).toHaveBeenCalledWith('a')\nexpect(listener2).toHaveBeenCalledWith('b')"
              },
              {
                "title": "should handle events object",
                "line": 379,
                "source": "const target = new Notifier()\nconst listener1 = vi.fn()\nconst listener2 = vi.fn()\n\nnotifier.on('foo', listener1)\nnotifier.on('bar', listener2)\nnotifier.delegateEvents(target, {foo: true, bar: true})\n\ntarget.emit('foo', 1)\ntarget.emit('bar', 2)\n\nexpect(listener1).toHaveBeenCalledWith(1)\nexpect(listener2).toHaveBeenCalledWith(2)"
              },
              {
                "title": "should combine namespace with events object",
                "line": 395,
                "source": "const target = new Notifier()\nconst listener1 = vi.fn()\nconst listener2 = vi.fn()\n\nnotifier.on('ns:foo', listener1)\nnotifier.on('ns:bar', listener2)\nnotifier.delegateEvents(target, {foo: true, bar: true}, 'ns')\n\ntarget.emit('foo', 'x')\ntarget.emit('bar', 'y')\n\nexpect(listener1).toHaveBeenCalledWith('x')\nexpect(listener2).toHaveBeenCalledWith('y')"
              },
              {
                "title": "should return early if target is null",
                "line": 411,
                "source": "expect(() => notifier.delegateEvents(null, ['test'])).not.toThrow()"
              },
              {
                "title": "should return early if target is undefined",
                "line": 415,
                "source": "expect(() => notifier.delegateEvents(undefined, ['test'])).not.toThrow()"
              },
              {
                "title": "should return early if events is not array or object",
                "line": 419,
                "source": "const target = new Notifier()\nexpect(() => notifier.delegateEvents(target, 'string')).not.toThrow()\nexpect(() => notifier.delegateEvents(target, 123)).not.toThrow()"
              },
              {
                "title": "should cleanup delegated listeners",
                "line": 425,
                "source": "const target = new Notifier()\nconst listener = vi.fn()\n\nnotifier.on('test', listener)\nnotifier.delegateEvents(target, ['test'])\n\ntarget.emit('test', 'before')\nexpect(listener).toHaveBeenCalledWith('before')\n\nnotifier.cleanExternalListeners()\n\ntarget.emit('test', 'after')\nexpect(listener).toHaveBeenCalledTimes(1)"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/core/observable_map.doc.js": {
    "file": "/core/observable_map.test.js",
    "describes": [
      {
        "title": "ObservableMap",
        "line": 5,
        "beforeEach": {
          "line": 9,
          "source": "observableMap = new ObservableMap()"
        },
        "afterEach": null,
        "tests": [],
        "describes": [
          {
            "title": "Constructor",
            "line": 14,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates empty map when no collection provided",
                "line": 16,
                "source": "const map = new ObservableMap()\nexpect(map.size).toBe(0)"
              },
              {
                "title": "creates map with initial collection from object",
                "line": 22,
                "source": "const map = new ObservableMap({a: 1, b: 2})\nexpect(map.size).toBe(2)\nexpect(map.get('a')).toBe(1)\nexpect(map.get('b')).toBe(2)"
              },
              {
                "title": "creates map with initial collection from Map",
                "line": 30,
                "source": "const map = new ObservableMap(new Map([['x', 10], ['y', 20]]))\nexpect(map.size).toBe(2)\nexpect(map.get('x')).toBe(10)\nexpect(map.get('y')).toBe(20)"
              }
            ],
            "describes": []
          },
          {
            "title": "set",
            "line": 40,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "sets key-value pair",
                "line": 42,
                "source": "observableMap.set('key', 'value')\nexpect(observableMap.get('key')).toBe('value')\nexpect(observableMap.size).toBe(1)"
              },
              {
                "title": "returns true",
                "line": 49,
                "source": "const result = observableMap.set('a', 1)\nexpect(result).toBe(true)"
              },
              {
                "title": "emits set event when value is added",
                "line": 55,
                "source": "let emittedKey\nlet emittedValue\nlet emittedOldValue\n\nobservableMap.on('set', (key, value, oldValue) => {\n    emittedKey = key\n    emittedValue = value\n    emittedOldValue = oldValue\n})\n\nobservableMap.set('test', 'value')\nexpect(emittedKey).toBe('test')\nexpect(emittedValue).toBe('value')\nexpect(emittedOldValue).toBe(undefined)"
              },
              {
                "title": "emits delete then set event when replacing value",
                "line": 73,
                "source": "const events = []\nobservableMap.on('delete', (key, value) => {\n    events.push({type: 'delete', key, value})\n})\nobservableMap.on('set', (key, value, oldValue) => {\n    events.push({type: 'set', key, value, oldValue})\n})\n\nobservableMap.set('key', 'value1')\nevents.length = 0 // Clear after initial set\n\nobservableMap.set('key', 'value2')\n\nexpect(events).toEqual([\n    {type: 'delete', key: 'key', value: 'value1'},\n    {type: 'set', key: 'key', value: 'value2', oldValue: 'value1'}\n])"
              },
              {
                "title": "does not emit delete event when setting same value",
                "line": 94,
                "source": "let deleteCount = 0\nobservableMap.on('delete', () => {\n    deleteCount++\n})\n\nobservableMap.set('key', 'value')\nobservableMap.set('key', 'value')\n\nexpect(deleteCount).toBe(0)"
              }
            ],
            "describes": []
          },
          {
            "title": "get",
            "line": 109,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns value for existing key",
                "line": 111,
                "source": "observableMap.set('test', 'value')\nexpect(observableMap.get('test')).toBe('value')"
              },
              {
                "title": "returns undefined for non-existent key",
                "line": 117,
                "source": "expect(observableMap.get('nonexistent')).toBe(undefined)"
              }
            ],
            "describes": []
          },
          {
            "title": "has",
            "line": 124,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns true for existing key",
                "line": 126,
                "source": "observableMap.set('test', 'value')\nexpect(observableMap.has('test')).toBe(true)"
              },
              {
                "title": "returns false for non-existent key",
                "line": 132,
                "source": "expect(observableMap.has('test')).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "delete",
            "line": 139,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "deletes key-value pair",
                "line": 141,
                "source": "observableMap.set('test', 'value')\nconst result = observableMap.delete('test')\n\nexpect(result).toBe(true)\nexpect(observableMap.has('test')).toBe(false)\nexpect(observableMap.size).toBe(0)"
              },
              {
                "title": "returns false when deleting non-existent key",
                "line": 151,
                "source": "const result = observableMap.delete('nonexistent')\nexpect(result).toBe(false)"
              },
              {
                "title": "emits delete event when key is deleted",
                "line": 157,
                "source": "let emittedKey\nlet emittedValue\n\nobservableMap.on('delete', (key, value) => {\n    emittedKey = key\n    emittedValue = value\n})\n\nobservableMap.set('test', 'value')\nobservableMap.delete('test')\nexpect(emittedKey).toBe('test')\nexpect(emittedValue).toBe('value')"
              },
              {
                "title": "does not emit delete event for non-existe>nt key",
                "line": 173,
                "source": "let callCount = 0\nobservableMap.on('delete', () => {\n    callCount++\n})\n\nobservableMap.delete('nonexistent')\nexpect(callCount).toBe(0)"
              }
            ],
            "describes": []
          },
          {
            "title": "clear",
            "line": 186,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "clears all key-value pairs",
                "line": 188,
                "source": "observableMap.set('a', 1)\nobservableMap.set('b', 2)\nobservableMap.clear()\n\nexpect(observableMap.size).toBe(0)\nexpect(observableMap.has('a')).toBe(false)"
              },
              {
                "title": "emits delete events for all entries then clear event",
                "line": 198,
                "source": "const events = []\nobservableMap.on('delete', (key, value) => {\n    events.push({type: 'delete', key, value})\n})\nobservableMap.on('clear', () => {\n    events.push({type: 'clear'})\n})\n\nobservableMap.set('a', 1)\nobservableMap.set('b', 2)\nevents.length = 0 // Clear after initial sets\n\nobservableMap.clear()\n\nexpect(events).toEqual([\n    {type: 'delete', key: 'a', value: 1},\n    {type: 'delete', key: 'b', value: 2},\n    {type: 'clear'}\n])"
              },
              {
                "title": "does not emit events when map is already empty",
                "line": 221,
                "source": "let callCount = 0\nobservableMap.on('delete', () => callCount++)\nobservableMap.on('clear', () => callCount++)\n\nobservableMap.clear()\nexpect(callCount).toBe(0)"
              }
            ],
            "describes": []
          },
          {
            "title": "size",
            "line": 233,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns 0 for empty map",
                "line": 235,
                "source": "expect(observableMap.size).toBe(0)"
              },
              {
                "title": "returns correct size after adding entries",
                "line": 240,
                "source": "observableMap.set('a', 1)\nobservableMap.set('b', 2)\nobservableMap.set('c', 3)\nexpect(observableMap.size).toBe(3)"
              },
              {
                "title": "updates size after deletion",
                "line": 248,
                "source": "observableMap.set('a', 1)\nobservableMap.set('b', 2)\nobservableMap.delete('a')\nexpect(observableMap.size).toBe(1)"
              }
            ],
            "describes": []
          },
          {
            "title": "updateKey",
            "line": 258,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "updates key for existing entry",
                "line": 260,
                "source": "observableMap.set('oldKey', 'value')\nconst result = observableMap.updateKey('oldKey', 'newKey')\n\nexpect(result).toBe(true)\nexpect(observableMap.has('oldKey')).toBe(false)\nexpect(observableMap.has('newKey')).toBe(true)\nexpect(observableMap.get('newKey')).toBe('value')"
              },
              {
                "title": "emits key:updated event",
                "line": 271,
                "source": "let emittedOldKey\nlet emittedNewKey\nlet emittedValue\n\nobservableMap.on('key:updated', (oldKey, newKey, value) => {\n    emittedOldKey = oldKey\n    emittedNewKey = newKey\n    emittedValue = value\n})\n\nobservableMap.set('oldKey', 'value')\nobservableMap.updateKey('oldKey', 'newKey')\n\nexpect(emittedOldKey).toBe('oldKey')\nexpect(emittedNewKey).toBe('newKey')\nexpect(emittedValue).toBe('value')"
              },
              {
                "title": "returns false when updating to same key",
                "line": 291,
                "source": "observableMap.set('key', 'value')\nconst result = observableMap.updateKey('key', 'key')\nexpect(result).toBe(false)"
              },
              {
                "title": "returns false when old key does not exist",
                "line": 298,
                "source": "const result = observableMap.updateKey('nonexistent', 'newKey')\nexpect(result).toBe(false)"
              },
              {
                "title": "validates item if provided",
                "line": 304,
                "source": "const value1 = {id: 1}\nconst value2 = {id: 2}\n\nobservableMap.set('key1', value1)\nobservableMap.set('key2', value2)\n\nexpect(observableMap.updateKey('key1', 'newKey1', value1)).toBe(true)\nexpect(observableMap.updateKey('key2', 'newKey2', value1)).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "hasValue",
            "line": 318,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns true for existing value",
                "line": 320,
                "source": "const value = {test: true}\nobservableMap.set('key', value)\nexpect(observableMap.hasValue(value)).toBe(true)"
              },
              {
                "title": "returns false for non-existent value",
                "line": 327,
                "source": "expect(observableMap.hasValue('nonexistent')).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "keyFor",
            "line": 334,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns key for existing value",
                "line": 336,
                "source": "const value = {test: true}\nobservableMap.set('key', value)\nexpect(observableMap.keyFor(value)).toBe('key')"
              },
              {
                "title": "returns undefined for non-existent value",
                "line": 343,
                "source": "expect(observableMap.keyFor('nonexistent')).toBe(undefined)"
              }
            ],
            "describes": []
          },
          {
            "title": "hasEntry",
            "line": 350,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns true when key-value pair exists",
                "line": 352,
                "source": "observableMap.set('key', 'value')\nexpect(observableMap.hasEntry('key', 'value')).toBe(true)"
              },
              {
                "title": "returns false when key exists but value differs",
                "line": 358,
                "source": "observableMap.set('key', 'value1')\nexpect(observableMap.hasEntry('key', 'value2')).toBe(false)"
              },
              {
                "title": "returns false when key does not exist",
                "line": 364,
                "source": "expect(observableMap.hasEntry('key', 'value')).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "isKeyOf",
            "line": 371,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns true when key matches value",
                "line": 373,
                "source": "const value = {test: true}\nobservableMap.set('key', value)\nexpect(observableMap.isKeyOf('key', value)).toBe(true)"
              },
              {
                "title": "returns false when key does not match value",
                "line": 380,
                "source": "const value = {test: true}\nobservableMap.set('key1', value)\nexpect(observableMap.isKeyOf('key2', value)).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "Iteration",
            "line": 389,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "keys returns iterator",
                "line": 391,
                "source": "observableMap.set('a', 1)\nobservableMap.set('b', 2)\nconst keys = Array.from(observableMap.keys)\nexpect(keys).toEqual(['a', 'b'])"
              },
              {
                "title": "values returns iterator",
                "line": 399,
                "source": "observableMap.set('a', 1)\nobservableMap.set('b', 2)\nconst values = Array.from(observableMap.values)\nexpect(values).toEqual([1, 2])"
              },
              {
                "title": "entries returns array",
                "line": 407,
                "source": "observableMap.set('a', 1)\nobservableMap.set('b', 2)\nexpect(observableMap.entries).toEqual([['a', 1], ['b', 2]])"
              },
              {
                "title": "forEach iterates over entries",
                "line": 414,
                "source": "observableMap.set('a', 1)\nobservableMap.set('b', 2)\n\nconst collected = []\nobservableMap.forEach((value, key) => {\n    collected.push({key, value})\n})\n\nexpect(collected).toEqual([\n    {key: 'a', value: 1},\n    {key: 'b', value: 2}\n])"
              },
              {
                "title": "forEach with thisArg",
                "line": 430,
                "source": "observableMap.set('test', 'value')\n\nconst context = {result: null}\nobservableMap.forEach(function (value, key) {\n    this.result = {key, value}\n}, context)\n\nexpect(context.result).toEqual({key: 'test', value: 'value'})"
              }
            ],
            "describes": []
          },
          {
            "title": "all",
            "line": 444,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns empty array for empty map",
                "line": 446,
                "source": "expect(observableMap.all).toEqual([])"
              },
              {
                "title": "returns array with all values",
                "line": 451,
                "source": "observableMap.set('a', 1)\nobservableMap.set('b', 2)\nexpect(observableMap.all).toEqual([1, 2])"
              }
            ],
            "describes": []
          },
          {
            "title": "toObject",
            "line": 460,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns empty object for empty map",
                "line": 462,
                "source": "expect(observableMap.toObject()).toEqual({})"
              },
              {
                "title": "returns object with all entries",
                "line": 467,
                "source": "const foo = {name: 'foo'}\nconst bar = {name: 'bar'}\n\nobservableMap.set('foo', foo)\nobservableMap.set('bar', bar)\n\nconst object = observableMap.toObject()\n\nexpect(object).toEqual({foo, bar})"
              },
              {
                "title": "returns new object each time",
                "line": 480,
                "source": "observableMap.set('a', 1)\nconst obj1 = observableMap.toObject()\nconst obj2 = observableMap.toObject()\nexpect(obj1).not.toBe(obj2)"
              }
            ],
            "describes": []
          },
          {
            "title": "addCollection",
            "line": 490,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "adds object entries",
                "line": 492,
                "source": "const collection = {\n    foo: 'bar',\n    baz: 'qux'\n}\n\nobservableMap.addCollection(collection)\nexpect(observableMap.get('foo')).toBe('bar')\nexpect(observableMap.get('baz')).toBe('qux')\nexpect(observableMap.size).toBe(2)"
              },
              {
                "title": "adds Map entries",
                "line": 505,
                "source": "const map = new Map([\n    ['one', 1],\n    ['two', 2]\n])\n\nobservableMap.addCollection(map)\nexpect(observableMap.get('one')).toBe(1)\nexpect(observableMap.get('two')).toBe(2)\nexpect(observableMap.size).toBe(2)"
              },
              {
                "title": "returns false for invalid collection",
                "line": 518,
                "source": "expect(observableMap.addCollection(null)).toBe(false)\nexpect(observableMap.addCollection(123)).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "Event composition",
            "line": 526,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "multiple listeners receive events",
                "line": 528,
                "source": "let count1 = 0\nlet count2 = 0\n\nobservableMap.on('set', () => count1++)\nobservableMap.on('set', () => count2++)\n\nobservableMap.set('test', 'value')\n\nexpect(count1).toBe(1)\nexpect(count2).toBe(1)"
              },
              {
                "title": "can unsubscribe from events",
                "line": 542,
                "source": "let count = 0\nconst listener = () => count++\n\nobservableMap.on('set', listener)\nobservableMap.set('a', 1)\n\nobservableMap.off('set', listener)\nobservableMap.set('b', 2)\n\nexpect(count).toBe(1)"
              }
            ],
            "describes": []
          },
          {
            "title": "Complex scenarios",
            "line": 558,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "handles different value types",
                "line": 560,
                "source": "const obj = {key: 'value'}\nconst arr = [1, 2, 3]\n\nobservableMap.set('num', 1)\nobservableMap.set('str', 'string')\nobservableMap.set('obj', obj)\nobservableMap.set('arr', arr)\nobservableMap.set('null', null)\nobservableMap.set('undefined', undefined)\n\nexpect(observableMap.size).toBe(6)\nexpect(observableMap.get('obj')).toBe(obj)\nexpect(observableMap.get('arr')).toBe(arr)"
              },
              {
                "title": "maintains map semantics with object references",
                "line": 577,
                "source": "const obj1 = {id: 1}\nconst obj2 = {id: 1}  // Different reference, same content\n\nobservableMap.set('key1', obj1)\nobservableMap.set('key2', obj2)\n\nexpect(observableMap.hasValue(obj1)).toBe(true)\nexpect(observableMap.hasValue(obj2)).toBe(true)\nexpect(observableMap.size).toBe(2)"
              }
            ],
            "describes": []
          },
          {
            "title": "hasValue with shared values",
            "line": 592,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "hasValue returns true when same value is used by multiple keys",
                "line": 594,
                "source": "const sharedValue = {shared: true}\n\nobservableMap.set('key1', sharedValue)\nobservableMap.set('key2', sharedValue)\n\nexpect(observableMap.hasValue(sharedValue)).toBe(true)\nexpect(observableMap.size).toBe(2)"
              },
              {
                "title": "hasValue still returns true after deleting one key when value is shared",
                "line": 605,
                "source": "const sharedValue = {shared: true}\n\nobservableMap.set('key1', sharedValue)\nobservableMap.set('key2', sharedValue)\n\nobservableMap.delete('key1')\n\nexpect(observableMap.hasValue(sharedValue)).toBe(true)\nexpect(observableMap.size).toBe(1)"
              },
              {
                "title": "hasValue returns false only after all keys with shared value are deleted",
                "line": 618,
                "source": "const sharedValue = {shared: true}\n\nobservableMap.set('key1', sharedValue)\nobservableMap.set('key2', sharedValue)\nobservableMap.set('key3', sharedValue)\n\nobservableMap.delete('key1')\nexpect(observableMap.hasValue(sharedValue)).toBe(true)\n\nobservableMap.delete('key2')\nexpect(observableMap.hasValue(sharedValue)).toBe(true)\n\nobservableMap.delete('key3')\nexpect(observableMap.hasValue(sharedValue)).toBe(false)"
              },
              {
                "title": "hasValue works correctly when replacing a shared value",
                "line": 636,
                "source": "const sharedValue = {shared: true}\nconst newValue = {new: true}\n\nobservableMap.set('key1', sharedValue)\nobservableMap.set('key2', sharedValue)\n\nobservableMap.set('key1', newValue)\n\nexpect(observableMap.hasValue(sharedValue)).toBe(true)\nexpect(observableMap.hasValue(newValue)).toBe(true)\n\nobservableMap.set('key2', newValue)\n\nexpect(observableMap.hasValue(sharedValue)).toBe(false)\nexpect(observableMap.hasValue(newValue)).toBe(true)"
              },
              {
                "title": "clear removes all values from hasValue tracking",
                "line": 655,
                "source": "const value1 = {id: 1}\nconst value2 = {id: 2}\n\nobservableMap.set('key1', value1)\nobservableMap.set('key2', value1)\nobservableMap.set('key3', value2)\n\nobservableMap.clear()\n\nexpect(observableMap.hasValue(value1)).toBe(false)\nexpect(observableMap.hasValue(value2)).toBe(false)"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/core/observable_set.doc.js": {
    "file": "/core/observable_set.test.js",
    "describes": [
      {
        "title": "ObservableSet",
        "line": 5,
        "beforeEach": {
          "line": 9,
          "source": "observableSet = new ObservableSet()"
        },
        "afterEach": null,
        "tests": [],
        "describes": [
          {
            "title": "Constructor",
            "line": 14,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates empty set when no values provided",
                "line": 16,
                "source": "const set = new ObservableSet()\nexpect(set.size).toBe(0)"
              },
              {
                "title": "creates set with initial values from array",
                "line": 22,
                "source": "const set = new ObservableSet(['a', 'b', 'c'])\nexpect(set.size).toBe(3)\nexpect(set.has('a')).toBe(true)\nexpect(set.has('b')).toBe(true)\nexpect(set.has('c')).toBe(true)"
              },
              {
                "title": "creates set with initial values from Set",
                "line": 31,
                "source": "const set = new ObservableSet(new Set([1, 2, 3]))\nexpect(set.size).toBe(3)\nexpect(set.has(1)).toBe(true)\nexpect(set.has(2)).toBe(true)\nexpect(set.has(3)).toBe(true)"
              },
              {
                "title": "deduplicates initial values",
                "line": 40,
                "source": "const set = new ObservableSet(['a', 'b', 'a', 'c', 'b'])\nexpect(set.size).toBe(3)"
              }
            ],
            "describes": []
          },
          {
            "title": "add",
            "line": 48,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "adds value to set",
                "line": 50,
                "source": "observableSet.add('test')\nexpect(observableSet.has('test')).toBe(true)\nexpect(observableSet.size).toBe(1)"
              },
              {
                "title": "returns this for chaining",
                "line": 57,
                "source": "const result = observableSet.add('a')\nexpect(result).toBe(observableSet)"
              },
              {
                "title": "allows chaining multiple adds",
                "line": 63,
                "source": "observableSet.add('a').add('b').add('c')\nexpect(observableSet.size).toBe(3)"
              },
              {
                "title": "does not add duplicate values",
                "line": 69,
                "source": "observableSet.add('test')\nobservableSet.add('test')\nexpect(observableSet.size).toBe(1)"
              },
              {
                "title": "emits add event when value is added",
                "line": 76,
                "source": "let emittedValue\nobservableSet.on('add', (value) => {\n    emittedValue = value\n})\n\nobservableSet.add('test')\nexpect(emittedValue).toBe('test')"
              },
              {
                "title": "does not emit add event for duplicate values",
                "line": 87,
                "source": "let callCount = 0\nobservableSet.on('add', () => {\n    callCount++\n})\n\nobservableSet.add('test')\nobservableSet.add('test')\nexpect(callCount).toBe(1)"
              }
            ],
            "describes": []
          },
          {
            "title": "delete",
            "line": 101,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "deletes value from set",
                "line": 103,
                "source": "observableSet.add('test')\nconst result = observableSet.delete('test')\n\nexpect(result).toBe(true)\nexpect(observableSet.has('test')).toBe(false)\nexpect(observableSet.size).toBe(0)"
              },
              {
                "title": "returns false when deleting non-existent value",
                "line": 113,
                "source": "const result = observableSet.delete('nonexistent')\nexpect(result).toBe(false)"
              },
              {
                "title": "emits delete event when value is deleted",
                "line": 119,
                "source": "let emittedValue\nobservableSet.on('delete', (value) => {\n    emittedValue = value\n})\n\nobservableSet.add('test')\nobservableSet.delete('test')\nexpect(emittedValue).toBe('test')"
              },
              {
                "title": "does not emit delete event for non-existent value",
                "line": 131,
                "source": "let callCount = 0\nobservableSet.on('delete', () => {\n    callCount++\n})\n\nobservableSet.delete('nonexistent')\nexpect(callCount).toBe(0)"
              }
            ],
            "describes": []
          },
          {
            "title": "clear",
            "line": 144,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "clears all values from set",
                "line": 146,
                "source": "observableSet.add('a').add('b').add('c')\nobservableSet.clear()\n\nexpect(observableSet.size).toBe(0)\nexpect(observableSet.has('a')).toBe(false)"
              },
              {
                "title": "emits clear event with all values",
                "line": 155,
                "source": "let clearedValues\nobservableSet.on('clear', (values) => {\n    clearedValues = values\n})\n\nobservableSet.add('a').add('b').add('c')\nobservableSet.clear()\n\nexpect(clearedValues).toEqual(['a', 'b', 'c'])"
              },
              {
                "title": "does not emit clear event when set is already empty",
                "line": 168,
                "source": "let callCount = 0\nobservableSet.on('clear', () => {\n    callCount++\n})\n\nobservableSet.clear()\nexpect(callCount).toBe(0)"
              }
            ],
            "describes": []
          },
          {
            "title": "has",
            "line": 181,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns true for existing value",
                "line": 183,
                "source": "observableSet.add('test')\nexpect(observableSet.has('test')).toBe(true)"
              },
              {
                "title": "returns false for non-existent value",
                "line": 189,
                "source": "expect(observableSet.has('test')).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "size",
            "line": 196,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns 0 for empty set",
                "line": 198,
                "source": "expect(observableSet.size).toBe(0)"
              },
              {
                "title": "returns correct size after adding values",
                "line": 203,
                "source": "observableSet.add('a').add('b').add('c')\nexpect(observableSet.size).toBe(3)"
              },
              {
                "title": "updates size after deletion",
                "line": 209,
                "source": "observableSet.add('a').add('b')\nobservableSet.delete('a')\nexpect(observableSet.size).toBe(1)"
              }
            ],
            "describes": []
          },
          {
            "title": "Iteration",
            "line": 218,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "values returns iterator",
                "line": 220,
                "source": "observableSet.add('a').add('b').add('c')\nconst values = Array.from(observableSet.values())\nexpect(values).toEqual(['a', 'b', 'c'])"
              },
              {
                "title": "keys returns iterator",
                "line": 227,
                "source": "observableSet.add('a').add('b')\nconst keys = Array.from(observableSet.keys())\nexpect(keys).toEqual(['a', 'b'])"
              },
              {
                "title": "entries returns iterator",
                "line": 234,
                "source": "observableSet.add('a').add('b')\nconst entries = Array.from(observableSet.entries())\nexpect(entries).toEqual([['a', 'a'], ['b', 'b']])"
              },
              {
                "title": "forEach iterates over values",
                "line": 241,
                "source": "observableSet.add('a').add('b').add('c')\n\nconst collected = []\nobservableSet.forEach((value) => {\n    collected.push(value)\n})\n\nexpect(collected).toEqual(['a', 'b', 'c'])"
              },
              {
                "title": "forEach with thisArg",
                "line": 253,
                "source": "observableSet.add('test')\n\nconst context = {result: null}\nobservableSet.forEach(function (value) {\n    this.result = value\n}, context)\n\nexpect(context.result).toBe('test')"
              },
              {
                "title": "is iterable with for...of",
                "line": 265,
                "source": "observableSet.add('a').add('b').add('c')\n\nconst values = []\nfor (const value of observableSet) {\n    values.push(value)\n}\n\nexpect(values).toEqual(['a', 'b', 'c'])"
              },
              {
                "title": "spread operator works",
                "line": 277,
                "source": "observableSet.add('a').add('b').add('c')\nconst values = [...observableSet]\nexpect(values).toEqual(['a', 'b', 'c'])"
              }
            ],
            "describes": []
          },
          {
            "title": "toArray",
            "line": 286,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns empty array for empty set",
                "line": 288,
                "source": "expect(observableSet.toArray()).toEqual([])"
              },
              {
                "title": "returns array with all values",
                "line": 293,
                "source": "observableSet.add('a').add('b').add('c')\nexpect(observableSet.toArray()).toEqual(['a', 'b', 'c'])"
              },
              {
                "title": "returns new array each time",
                "line": 299,
                "source": "observableSet.add('a')\nconst arr1 = observableSet.toArray()\nconst arr2 = observableSet.toArray()\nexpect(arr1).not.toBe(arr2)"
              }
            ],
            "describes": []
          },
          {
            "title": "Event composition",
            "line": 309,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "multiple listeners receive events",
                "line": 311,
                "source": "let count1 = 0\nlet count2 = 0\n\nobservableSet.on('add', () => count1++)\nobservableSet.on('add', () => count2++)\n\nobservableSet.add('test')\n\nexpect(count1).toBe(1)\nexpect(count2).toBe(1)"
              },
              {
                "title": "can unsubscribe from events",
                "line": 325,
                "source": "let count = 0\nconst listener = () => count++\n\nobservableSet.on('add', listener)\nobservableSet.add('a')\n\nobservableSet.off('add', listener)\nobservableSet.add('b')\n\nexpect(count).toBe(1)"
              }
            ],
            "describes": []
          },
          {
            "title": "Complex scenarios",
            "line": 341,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "handles different value types",
                "line": 343,
                "source": "const obj = {key: 'value'}\nconst arr = [1, 2, 3]\n\nobservableSet.add(1)\nobservableSet.add('string')\nobservableSet.add(obj)\nobservableSet.add(arr)\nobservableSet.add(null)\nobservableSet.add(undefined)\n\nexpect(observableSet.size).toBe(6)\nexpect(observableSet.has(obj)).toBe(true)\nexpect(observableSet.has(arr)).toBe(true)"
              },
              {
                "title": "maintains set semantics with object references",
                "line": 360,
                "source": "const obj1 = {id: 1}\nconst obj2 = {id: 1}  // Different reference, same content\n\nobservableSet.add(obj1)\nobservableSet.add(obj2)\n\nexpect(observableSet.size).toBe(2)  // Different objects"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/core/perky_query.doc.js": {
    "file": "/core/perky_query.test.js",
    "describes": [
      {
        "title": "parseSelector",
        "line": 6,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "parses single id selector",
            "line": 8,
            "source": "const result = parseSelector('#player')\n\nexpect(result).toEqual([\n    [{type: 'id', value: 'player'}]\n])"
          },
          {
            "title": "parses single tag selector",
            "line": 17,
            "source": "const result = parseSelector('.enemy')\n\nexpect(result).toEqual([\n    [{type: 'tag', value: 'enemy'}]\n])"
          },
          {
            "title": "parses single name selector",
            "line": 26,
            "source": "const result = parseSelector('$GameRenderer')\n\nexpect(result).toEqual([\n    [{type: 'name', value: 'GameRenderer'}]\n])"
          },
          {
            "title": "parses single category selector",
            "line": 35,
            "source": "const result = parseSelector('@controller')\n\nexpect(result).toEqual([\n    [{type: 'category', value: 'controller'}]\n])"
          },
          {
            "title": "parses combined selectors (same level)",
            "line": 44,
            "source": "const result = parseSelector('#player.alive')\n\nexpect(result).toEqual([\n    [\n        {type: 'id', value: 'player'},\n        {type: 'tag', value: 'alive'}\n    ]\n])"
          },
          {
            "title": "parses multiple tags combined",
            "line": 56,
            "source": "const result = parseSelector('.enemy.boss.flying')\n\nexpect(result).toEqual([\n    [\n        {type: 'tag', value: 'enemy'},\n        {type: 'tag', value: 'boss'},\n        {type: 'tag', value: 'flying'}\n    ]\n])"
          },
          {
            "title": "parses descendant selectors (space separated)",
            "line": 69,
            "source": "const result = parseSelector('#world .enemy')\n\nexpect(result).toEqual([\n    [{type: 'id', value: 'world'}],\n    [{type: 'tag', value: 'enemy'}]\n])"
          },
          {
            "title": "parses multi-level descendants",
            "line": 79,
            "source": "const result = parseSelector('#world #player .weapon')\n\nexpect(result).toEqual([\n    [{type: 'id', value: 'world'}],\n    [{type: 'id', value: 'player'}],\n    [{type: 'tag', value: 'weapon'}]\n])"
          },
          {
            "title": "parses complex mixed selector",
            "line": 90,
            "source": "const result = parseSelector('@scene#main .enemy.boss')\n\nexpect(result).toEqual([\n    [\n        {type: 'category', value: 'scene'},\n        {type: 'id', value: 'main'}\n    ],\n    [\n        {type: 'tag', value: 'enemy'},\n        {type: 'tag', value: 'boss'}\n    ]\n])"
          },
          {
            "title": "handles extra whitespace",
            "line": 106,
            "source": "const result = parseSelector('  #world   .enemy  ')\n\nexpect(result).toEqual([\n    [{type: 'id', value: 'world'}],\n    [{type: 'tag', value: 'enemy'}]\n])"
          },
          {
            "title": "returns empty array for empty selector",
            "line": 116,
            "source": "const result = parseSelector('')\n\nexpect(result).toEqual([])"
          },
          {
            "title": "returns empty array for whitespace only",
            "line": 123,
            "source": "const result = parseSelector('   ')\n\nexpect(result).toEqual([])"
          },
          {
            "title": "parses selector with hyphens in values",
            "line": 130,
            "source": "const result = parseSelector('#game-loop')\n\nexpect(result).toEqual([\n    [{type: 'id', value: 'game-loop'}]\n])"
          },
          {
            "title": "parses selector with underscores in values",
            "line": 139,
            "source": "const result = parseSelector('#game_loop')\n\nexpect(result).toEqual([\n    [{type: 'id', value: 'game_loop'}]\n])"
          }
        ],
        "describes": []
      },
      {
        "title": "matchesConditions",
        "line": 150,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "matches id condition",
            "line": 152,
            "source": "const module = new PerkyModule({$id: 'player'})\nconst conditions = [{type: 'id', value: 'player'}]\n\nexpect(matchesConditions(module, conditions)).toBe(true)"
          },
          {
            "title": "does not match wrong id",
            "line": 160,
            "source": "const module = new PerkyModule({$id: 'enemy'})\nconst conditions = [{type: 'id', value: 'player'}]\n\nexpect(matchesConditions(module, conditions)).toBe(false)"
          },
          {
            "title": "matches tag condition",
            "line": 168,
            "source": "const module = new PerkyModule({$tags: ['enemy', 'collidable']})\nconst conditions = [{type: 'tag', value: 'enemy'}]\n\nexpect(matchesConditions(module, conditions)).toBe(true)"
          },
          {
            "title": "does not match missing tag",
            "line": 176,
            "source": "const module = new PerkyModule({$tags: ['friendly']})\nconst conditions = [{type: 'tag', value: 'enemy'}]\n\nexpect(matchesConditions(module, conditions)).toBe(false)"
          },
          {
            "title": "matches name condition",
            "line": 184,
            "source": "const module = new PerkyModule({$name: 'GameRenderer'})\nconst conditions = [{type: 'name', value: 'GameRenderer'}]\n\nexpect(matchesConditions(module, conditions)).toBe(true)"
          },
          {
            "title": "does not match wrong name",
            "line": 192,
            "source": "const module = new PerkyModule({$name: 'OtherRenderer'})\nconst conditions = [{type: 'name', value: 'GameRenderer'}]\n\nexpect(matchesConditions(module, conditions)).toBe(false)"
          },
          {
            "title": "matches category condition",
            "line": 200,
            "source": "const module = new PerkyModule({$category: 'controller'})\nconst conditions = [{type: 'category', value: 'controller'}]\n\nexpect(matchesConditions(module, conditions)).toBe(true)"
          },
          {
            "title": "does not match wrong category",
            "line": 208,
            "source": "const module = new PerkyModule({$category: 'renderer'})\nconst conditions = [{type: 'category', value: 'controller'}]\n\nexpect(matchesConditions(module, conditions)).toBe(false)"
          },
          {
            "title": "matches multiple conditions (AND)",
            "line": 216,
            "source": "const module = new PerkyModule({\n    $id: 'player',\n    $tags: ['alive', 'controllable']\n})\nconst conditions = [\n    {type: 'id', value: 'player'},\n    {type: 'tag', value: 'alive'}\n]\n\nexpect(matchesConditions(module, conditions)).toBe(true)"
          },
          {
            "title": "fails if any condition does not match",
            "line": 230,
            "source": "const module = new PerkyModule({\n    $id: 'player',\n    $tags: ['dead']\n})\nconst conditions = [\n    {type: 'id', value: 'player'},\n    {type: 'tag', value: 'alive'}\n]\n\nexpect(matchesConditions(module, conditions)).toBe(false)"
          },
          {
            "title": "matches empty conditions",
            "line": 244,
            "source": "const module = new PerkyModule()\nconst conditions = []\n\nexpect(matchesConditions(module, conditions)).toBe(true)"
          },
          {
            "title": "returns false for unknown condition type",
            "line": 252,
            "source": "const module = new PerkyModule({$id: 'test'})\nconst conditions = [{type: 'unknown', value: 'test'}]\n\nexpect(matchesConditions(module, conditions)).toBe(false)"
          }
        ],
        "describes": []
      },
      {
        "title": "query",
        "line": 262,
        "beforeEach": {
          "line": 265,
          "source": "root = new PerkyModule({$id: 'root'})"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "finds child by id",
            "line": 270,
            "source": "const player = root.create(PerkyModule, {$id: 'player'})\n\nconst result = query(root, '#player')\n\nexpect(result).toBe(player)"
          },
          {
            "title": "returns null when not found",
            "line": 279,
            "source": "root.create(PerkyModule, {$id: 'player'})\n\nconst result = query(root, '#enemy')\n\nexpect(result).toBeNull()"
          },
          {
            "title": "finds child by tag",
            "line": 288,
            "source": "const enemy = root.create(PerkyModule, {$id: 'enemy1', $tags: ['enemy']})\n\nconst result = query(root, '.enemy')\n\nexpect(result).toBe(enemy)"
          },
          {
            "title": "finds child by name",
            "line": 297,
            "source": "class GameRenderer extends PerkyModule {\n    static $name = 'GameRenderer'\n}\nconst renderer = root.create(GameRenderer, {$id: 'renderer'})\n\nconst result = query(root, '$GameRenderer')\n\nexpect(result).toBe(renderer)"
          },
          {
            "title": "finds child by category",
            "line": 309,
            "source": "const controller = root.create(PerkyModule, {\n    $id: 'gameCtrl',\n    $category: 'controller'\n})\n\nconst result = query(root, '@controller')\n\nexpect(result).toBe(controller)"
          },
          {
            "title": "finds child with combined selectors",
            "line": 321,
            "source": "root.create(PerkyModule, {$id: 'player', $tags: ['dead']})\nconst alivePlayer = root.create(PerkyModule, {$id: 'player2', $tags: ['alive']})\n\nconst result = query(root, '.alive')\n\nexpect(result).toBe(alivePlayer)"
          },
          {
            "title": "finds nested child (descendant)",
            "line": 331,
            "source": "const world = root.create(PerkyModule, {$id: 'world'})\nconst player = world.create(PerkyModule, {$id: 'player'})\n\nconst result = query(root, '#world #player')\n\nexpect(result).toBe(player)"
          },
          {
            "title": "finds deeply nested child",
            "line": 341,
            "source": "const world = root.create(PerkyModule, {$id: 'world'})\nconst player = world.create(PerkyModule, {$id: 'player'})\nconst weapon = player.create(PerkyModule, {$id: 'sword', $tags: ['weapon']})\n\nconst result = query(root, '#world #player .weapon')\n\nexpect(result).toBe(weapon)"
          },
          {
            "title": "returns null for partial match",
            "line": 352,
            "source": "const world = root.create(PerkyModule, {$id: 'world'})\nworld.create(PerkyModule, {$id: 'enemy'})\n\nconst result = query(root, '#world #player')\n\nexpect(result).toBeNull()"
          },
          {
            "title": "returns first match when multiple exist",
            "line": 362,
            "source": "const enemy1 = root.create(PerkyModule, {$id: 'enemy1', $tags: ['enemy']})\nroot.create(PerkyModule, {$id: 'enemy2', $tags: ['enemy']})\n\nconst result = query(root, '.enemy')\n\nexpect(result).toBe(enemy1)"
          },
          {
            "title": "returns null for empty selector",
            "line": 372,
            "source": "root.create(PerkyModule, {$id: 'player'})\n\nconst result = query(root, '')\n\nexpect(result).toBeNull()"
          },
          {
            "title": "does not search deeper than specified",
            "line": 381,
            "source": "const world = root.create(PerkyModule, {$id: 'world'})\nworld.create(PerkyModule, {$id: 'player'})\n\nconst result = query(root, '#player')\n\nexpect(result).toBeNull()"
          }
        ],
        "describes": []
      },
      {
        "title": "queryAll",
        "line": 393,
        "beforeEach": {
          "line": 396,
          "source": "root = new PerkyModule({$id: 'root'})"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "finds all children by tag",
            "line": 401,
            "source": "const enemy1 = root.create(PerkyModule, {$id: 'enemy1', $tags: ['enemy']})\nconst enemy2 = root.create(PerkyModule, {$id: 'enemy2', $tags: ['enemy']})\nroot.create(PerkyModule, {$id: 'player', $tags: ['player']})\n\nconst result = queryAll(root, '.enemy')\n\nexpect(result).toHaveLength(2)\nexpect(result).toContain(enemy1)\nexpect(result).toContain(enemy2)"
          },
          {
            "title": "returns empty array when none found",
            "line": 414,
            "source": "root.create(PerkyModule, {$id: 'player'})\n\nconst result = queryAll(root, '.enemy')\n\nexpect(result).toEqual([])"
          },
          {
            "title": "finds all children by category",
            "line": 423,
            "source": "const ctrl1 = root.create(PerkyModule, {$id: 'ctrl1', $category: 'controller'})\nconst ctrl2 = root.create(PerkyModule, {$id: 'ctrl2', $category: 'controller'})\nroot.create(PerkyModule, {$id: 'renderer', $category: 'renderer'})\n\nconst result = queryAll(root, '@controller')\n\nexpect(result).toHaveLength(2)\nexpect(result).toContain(ctrl1)\nexpect(result).toContain(ctrl2)"
          },
          {
            "title": "finds all with combined selectors",
            "line": 436,
            "source": "const boss1 = root.create(PerkyModule, {$id: 'boss1', $tags: ['enemy', 'boss']})\nconst boss2 = root.create(PerkyModule, {$id: 'boss2', $tags: ['enemy', 'boss']})\nroot.create(PerkyModule, {$id: 'minion', $tags: ['enemy']})\n\nconst result = queryAll(root, '.enemy.boss')\n\nexpect(result).toHaveLength(2)\nexpect(result).toContain(boss1)\nexpect(result).toContain(boss2)"
          },
          {
            "title": "finds all nested children",
            "line": 449,
            "source": "const world = root.create(PerkyModule, {$id: 'world'})\nconst enemy1 = world.create(PerkyModule, {$id: 'enemy1', $tags: ['enemy']})\nconst enemy2 = world.create(PerkyModule, {$id: 'enemy2', $tags: ['enemy']})\n\nconst result = queryAll(root, '#world .enemy')\n\nexpect(result).toHaveLength(2)\nexpect(result).toContain(enemy1)\nexpect(result).toContain(enemy2)"
          },
          {
            "title": "finds deeply nested children",
            "line": 462,
            "source": "const world = root.create(PerkyModule, {$id: 'world'})\nconst player = world.create(PerkyModule, {$id: 'player'})\nconst sword = player.create(PerkyModule, {$id: 'sword', $tags: ['weapon']})\nconst shield = player.create(PerkyModule, {$id: 'shield', $tags: ['weapon']})\n\nconst result = queryAll(root, '#world #player .weapon')\n\nexpect(result).toHaveLength(2)\nexpect(result).toContain(sword)\nexpect(result).toContain(shield)"
          },
          {
            "title": "returns empty array for empty selector",
            "line": 476,
            "source": "root.create(PerkyModule, {$id: 'player'})\n\nconst result = queryAll(root, '')\n\nexpect(result).toEqual([])"
          },
          {
            "title": "branches correctly with multiple parents",
            "line": 485,
            "source": "const scene1 = root.create(PerkyModule, {$id: 'scene1', $category: 'scene'})\nconst scene2 = root.create(PerkyModule, {$id: 'scene2', $category: 'scene'})\n\nconst enemy1 = scene1.create(PerkyModule, {$id: 'e1', $tags: ['enemy']})\nconst enemy2 = scene2.create(PerkyModule, {$id: 'e2', $tags: ['enemy']})\n\nconst result = queryAll(root, '@scene .enemy')\n\nexpect(result).toHaveLength(2)\nexpect(result).toContain(enemy1)\nexpect(result).toContain(enemy2)"
          },
          {
            "title": "does not search deeper than specified",
            "line": 500,
            "source": "const world = root.create(PerkyModule, {$id: 'world'})\nconst area = world.create(PerkyModule, {$id: 'area'})\narea.create(PerkyModule, {$id: 'enemy', $tags: ['enemy']})\n\nconst result = queryAll(root, '#world .enemy')\n\nexpect(result).toEqual([])"
          }
        ],
        "describes": []
      }
    ]
  },
  "/core/registry.doc.js": {
    "file": "/core/registry.test.js",
    "describes": [
      {
        "title": "Registry",
        "line": 5,
        "beforeEach": {
          "line": 9,
          "source": "registry = new Registry()"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "set",
            "line": 14,
            "source": "const spy = vi.spyOn(registry, 'emit')\n\nregistry.set('key', 'value')\n\nexpect(registry.get('key')).toBe('value')\nexpect(spy).toHaveBeenCalledWith('set', 'key', 'value', undefined)\n\nspy.mockClear()\nregistry.set('key', 'newValue')\n\nexpect(registry.get('key')).toBe('newValue')\n\nexpect(spy).toHaveBeenCalledTimes(2)\nexpect(spy).toHaveBeenNthCalledWith(1, 'delete', 'key', 'value')\nexpect(spy).toHaveBeenNthCalledWith(2, 'set', 'key', 'newValue', 'value')"
          },
          {
            "title": "set with same value does not emit delete",
            "line": 33,
            "source": "const spy = vi.spyOn(registry, 'emit')\n\nregistry.set('key', 'value')\nspy.mockClear()\n\nregistry.set('key', 'value')\n\nexpect(spy).toHaveBeenCalledTimes(1)\nexpect(spy).toHaveBeenCalledWith('set', 'key', 'value', 'value')"
          },
          {
            "title": "delete",
            "line": 46,
            "source": "const spy = vi.spyOn(registry, 'emit')\n\nregistry.set('key', 'value')\nspy.mockClear()\n\nconst result = registry.delete('key')\n\nexpect(result).toBe(true)\nexpect(registry.has('key')).toBe(false)\nexpect(spy).toHaveBeenCalledWith('delete', 'key', 'value')\nexpect(spy).toHaveBeenCalledTimes(1)"
          },
          {
            "title": "delete non-existent",
            "line": 61,
            "source": "const spy = vi.spyOn(registry, 'emit')\nconst result = registry.delete('nonexistent')\nexpect(result).toBe(false)\nexpect(spy).not.toHaveBeenCalled()"
          },
          {
            "title": "updateKey",
            "line": 69,
            "source": "const spy = vi.spyOn(registry, 'emit')\n\nregistry.set('oldKey', 'value')\nspy.mockClear()\n\nconst result = registry.updateKey('oldKey', 'newKey')\n\nexpect(result).toBe(true)\nexpect(registry.has('oldKey')).toBe(false)\nexpect(registry.has('newKey')).toBe(true)\nexpect(registry.get('newKey')).toBe('value')\nexpect(spy).toHaveBeenCalledWith('key:updated', 'oldKey', 'newKey', 'value')\nexpect(spy).toHaveBeenCalledTimes(1)"
          },
          {
            "title": "updateKey with same key does nothing",
            "line": 86,
            "source": "const spy = vi.spyOn(registry, 'emit')\n\nregistry.set('key', 'value')\nspy.mockClear()\n\nconst result = registry.updateKey('key', 'key')\n\nexpect(result).toBe(false)\nexpect(registry.has('key')).toBe(true)\nexpect(registry.get('key')).toBe('value')\nexpect(spy).not.toHaveBeenCalled()"
          },
          {
            "title": "updateKey with item verification",
            "line": 101,
            "source": "const value1 = 'value1'\nconst value2 = 'value2'\n\nregistry.set('key1', value1)\nregistry.set('key2', value2)\n\nexpect(registry.updateKey('key1', 'newKey1', value1)).toBe(true)\nexpect(registry.has('key1')).toBe(false)\nexpect(registry.get('newKey1')).toBe(value1)\n\nexpect(registry.updateKey('key2', 'newKey2', value1)).toBe(false)\nexpect(registry.has('key2')).toBe(true)\nexpect(registry.get('key2')).toBe(value2)"
          },
          {
            "title": "updateKey with non-existent key returns false",
            "line": 118,
            "source": "const result = registry.updateKey('nonexistent', 'newKey')\nexpect(result).toBe(false)"
          },
          {
            "title": "clear",
            "line": 124,
            "source": "registry.set('key1', 'value1')\nregistry.set('key2', 'value2')\nregistry.clear()\n\nexpect(registry.size).toBe(0)"
          },
          {
            "title": "clear empty",
            "line": 133,
            "source": "const spy = vi.spyOn(registry, 'emit')\nregistry.clear()\nexpect(registry.size).toBe(0)\nexpect(spy).not.toHaveBeenCalled()"
          },
          {
            "title": "addCollection object",
            "line": 141,
            "source": "const spy = vi.spyOn(registry, 'emit')\nconst collection = {\n    foo: 'bar',\n    baz: 'qux'\n}\n\nregistry.addCollection(collection)\nexpect(registry.get('foo')).toBe('bar')\nexpect(registry.get('baz')).toBe('qux')\nexpect(registry.size).toBe(2)\nexpect(spy).toHaveBeenCalledTimes(2)\nexpect(spy).toHaveBeenCalledWith('set', 'foo', 'bar', undefined)\nexpect(spy).toHaveBeenCalledWith('set', 'baz', 'qux', undefined)"
          },
          {
            "title": "addCollection map",
            "line": 158,
            "source": "const spy = vi.spyOn(registry, 'emit')\nconst map = new Map([\n    ['one', 1],\n    ['two', 2]\n])\n\nregistry.addCollection(map)\nexpect(registry.get('one')).toBe(1)\nexpect(registry.get('two')).toBe(2)\nexpect(registry.size).toBe(2)\nexpect(spy).toHaveBeenCalledTimes(2)\nexpect(spy).toHaveBeenCalledWith('set', 'one', 1, undefined)\nexpect(spy).toHaveBeenCalledWith('set', 'two', 2, undefined)"
          },
          {
            "title": "addCollection invalid",
            "line": 175,
            "source": "expect(registry.addCollection(null)).toBe(false)\nexpect(registry.addCollection(123)).toBe(false)"
          },
          {
            "title": "toObject",
            "line": 181,
            "source": "const foo = {name: 'foo'}\nconst bar = {name: 'bar'}\n\nregistry.set('foo', foo)\nregistry.set('bar', bar)\n\nconst object = registry.toObject()\n\nexpect(object).toEqual({\n    foo,\n    bar\n})\nexpect(registry.toObject()).not.toBe(registry.map)"
          },
          {
            "title": "keys",
            "line": 198,
            "source": "registry.set('a', 1)\nregistry.set('b', 2)\n\nexpect(Array.from(registry.keys)).toEqual(['a', 'b'])"
          },
          {
            "title": "values",
            "line": 206,
            "source": "registry.set('a', 1)\nregistry.set('b', 2)\n\nexpect(Array.from(registry.values)).toEqual([1, 2])"
          },
          {
            "title": "entries",
            "line": 214,
            "source": "registry.set('a', 1)\nregistry.set('b', 2)\n\nexpect(Array.from(registry.entries)).toEqual([['a', 1], ['b', 2]])"
          },
          {
            "title": "hasValue",
            "line": 222,
            "source": "registry.set('a', 1)\nregistry.set('b', 2)\n\nexpect(registry.hasValue(1)).toBe(true)\nexpect(registry.hasValue(3)).toBe(false)"
          },
          {
            "title": "keyFor",
            "line": 231,
            "source": "registry.set('a', 1)\nregistry.set('b', 2)\n\nexpect(registry.keyFor(1)).toBe('a')\nexpect(registry.keyFor(3)).toBe(undefined)"
          },
          {
            "title": "Map methods",
            "line": 240,
            "source": "registry.set('a', 1)\nregistry.set('b', 2)\n\nexpect(registry.size).toBe(2)\nexpect(registry.has('a')).toBe(true)\nexpect(registry.has('c')).toBe(false)\n\nconst results = []\nregistry.forEach((value, key) => {\n    results.push({key, value})\n})\nexpect(results).toEqual([{key: 'a', value: 1}, {key: 'b', value: 2}])"
          },
          {
            "title": "constructor with default collection",
            "line": 256,
            "source": "const collection = {\n    key1: 'value1',\n    key2: 'value2'\n}\n\nconst registryWithCollection = new Registry(collection)\n\nexpect(registryWithCollection.size).toBe(2)\nexpect(registryWithCollection.get('key1')).toBe('value1')\nexpect(registryWithCollection.get('key2')).toBe('value2')"
          }
        ],
        "describes": [
          {
            "title": "Indexing",
            "line": 270,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "addIndex creates a new index",
                "line": 272,
                "source": "registry.addIndex('byName', (item) => item.name)\nexpect(registry.hasIndex('byName')).toBe(true)"
              },
              {
                "title": "addIndex with property name string",
                "line": 278,
                "source": "registry.addIndex('byName', 'name')\n\nregistry.set('1', {name: 'Alice', age: 30})\nregistry.set('2', {name: 'Bob', age: 25})\n\nexpect(registry.lookup('byName', 'Alice')).toEqual([{name: 'Alice', age: 30}])\nexpect(registry.lookup('byName', 'Bob')).toEqual([{name: 'Bob', age: 25}])"
              },
              {
                "title": "addIndex with single argument (property name)",
                "line": 289,
                "source": "registry.addIndex('name')\n\nregistry.set('1', {name: 'Alice', age: 30})\nregistry.set('2', {name: 'Bob', age: 25})\n\nexpect(registry.lookup('name', 'Alice')).toEqual([{name: 'Alice', age: 30}])\nexpect(registry.lookup('name', 'Bob')).toEqual([{name: 'Bob', age: 25}])"
              },
              {
                "title": "addIndex returns false if keyFunction is invalid type",
                "line": 300,
                "source": "expect(registry.addIndex('test', 123)).toBe(false)\nexpect(registry.addIndex('test', null)).toBe(false)"
              },
              {
                "title": "lookup returns empty array for non-existent key",
                "line": 306,
                "source": "registry.addIndex('byName', (item) => item.name)\nexpect(registry.lookup('byName', 'John')).toEqual([])"
              },
              {
                "title": "lookup throws if index does not exist",
                "line": 312,
                "source": "expect(() => registry.lookup('nonExistent', 'key')).toThrow()"
              },
              {
                "title": "items are automatically added to index on set",
                "line": 317,
                "source": "registry.addIndex('byName', (item) => item.name)\n\nregistry.set('1', {name: 'Alice', age: 30})\nregistry.set('2', {name: 'Bob', age: 25})\n\nexpect(registry.lookup('byName', 'Alice')).toEqual([{name: 'Alice', age: 30}])\nexpect(registry.lookup('byName', 'Bob')).toEqual([{name: 'Bob', age: 25}])"
              },
              {
                "title": "multiple items with same key are stored in index",
                "line": 328,
                "source": "registry.addIndex('byAge', (item) => item.age)\n\nregistry.set('1', {name: 'Alice', age: 30})\nregistry.set('2', {name: 'Bob', age: 30})\nregistry.set('3', {name: 'Charlie', age: 25})\n\nconst age30 = registry.lookup('byAge', 30)\nexpect(age30).toHaveLength(2)\nexpect(age30).toContainEqual({name: 'Alice', age: 30})\nexpect(age30).toContainEqual({name: 'Bob', age: 30})"
              },
              {
                "title": "items are removed from index on delete",
                "line": 342,
                "source": "registry.addIndex('byName', (item) => item.name)\n\nregistry.set('1', {name: 'Alice', age: 30})\nexpect(registry.lookup('byName', 'Alice')).toHaveLength(1)\n\nregistry.delete('1')\nexpect(registry.lookup('byName', 'Alice')).toEqual([])"
              },
              {
                "title": "items are updated in index when replaced",
                "line": 353,
                "source": "registry.addIndex('byName', (item) => item.name)\n\nregistry.set('1', {name: 'Alice', age: 30})\nexpect(registry.lookup('byName', 'Alice')).toHaveLength(1)\n\nregistry.set('1', {name: 'Bob', age: 30})\nexpect(registry.lookup('byName', 'Alice')).toEqual([])\nexpect(registry.lookup('byName', 'Bob')).toHaveLength(1)"
              },
              {
                "title": "index can be added after items are inserted",
                "line": 365,
                "source": "registry.set('1', {name: 'Alice', age: 30})\nregistry.set('2', {name: 'Bob', age: 25})\n\nregistry.addIndex('byName', (item) => item.name)\n\nexpect(registry.lookup('byName', 'Alice')).toHaveLength(1)\nexpect(registry.lookup('byName', 'Bob')).toHaveLength(1)"
              },
              {
                "title": "multiple indexes can coexist",
                "line": 376,
                "source": "registry.addIndex('byName', (item) => item.name)\nregistry.addIndex('byAge', (item) => item.age)\n\nregistry.set('1', {name: 'Alice', age: 30})\nregistry.set('2', {name: 'Bob', age: 30})\n\nexpect(registry.lookup('byName', 'Alice')).toHaveLength(1)\nexpect(registry.lookup('byAge', 30)).toHaveLength(2)"
              },
              {
                "title": "keyFunction can return array of keys",
                "line": 388,
                "source": "registry.addIndex('byTags', (item) => item.tags)\n\nregistry.set('1', {name: 'Post1', tags: ['javascript', 'testing']})\nregistry.set('2', {name: 'Post2', tags: ['javascript', 'nodejs']})\n\nconst jsPosts = registry.lookup('byTags', 'javascript')\nexpect(jsPosts).toHaveLength(2)\n\nconst testingPosts = registry.lookup('byTags', 'testing')\nexpect(testingPosts).toHaveLength(1)\nexpect(testingPosts[0].name).toBe('Post1')"
              },
              {
                "title": "keyFunction returning null/undefined is ignored",
                "line": 403,
                "source": "registry.addIndex('byOptional', (item) => item.optional)\n\nregistry.set('1', {name: 'Item1', optional: null})\nregistry.set('2', {name: 'Item2', optional: undefined})\nregistry.set('3', {name: 'Item3', optional: 'value'})\n\nexpect(registry.lookup('byOptional', null)).toEqual([])\nexpect(registry.lookup('byOptional', undefined)).toEqual([])\nexpect(registry.lookup('byOptional', 'value')).toHaveLength(1)"
              },
              {
                "title": "removeIndex removes an index",
                "line": 416,
                "source": "registry.addIndex('byName', (item) => item.name)\nexpect(registry.hasIndex('byName')).toBe(true)\n\nregistry.removeIndex('byName')\nexpect(registry.hasIndex('byName')).toBe(false)"
              },
              {
                "title": "complex index key function",
                "line": 425,
                "source": "registry.addIndex('byActionEvent', (item) =>\n    `${item.action}:${item.event}`)\n\nregistry.set('1', {action: 'jump', event: 'pressed'})\nregistry.set('2', {action: 'jump', event: 'released'})\nregistry.set('3', {action: 'run', event: 'pressed'})\n\nconst jumpPressed = registry.lookup('byActionEvent', 'jump:pressed')\nexpect(jumpPressed).toHaveLength(1)\nexpect(jumpPressed[0].action).toBe('jump')\nexpect(jumpPressed[0].event).toBe('pressed')"
              },
              {
                "title": "index updated on clear",
                "line": 440,
                "source": "registry.addIndex('byName', (item) => item.name)\n\nregistry.set('1', {name: 'Alice', age: 30})\nregistry.set('2', {name: 'Bob', age: 25})\n\nexpect(registry.lookup('byName', 'Alice')).toHaveLength(1)\n\nregistry.clear()\n\nexpect(registry.lookup('byName', 'Alice')).toEqual([])\nexpect(registry.lookup('byName', 'Bob')).toEqual([])"
              },
              {
                "title": "updateIndexFor moves item from old key to new key",
                "line": 455,
                "source": "registry.addIndex('byCategory', (item) => item.$category)\n\nconst item = {name: 'Item', $category: 'foo'}\nregistry.set('1', item)\n\nexpect(registry.lookup('byCategory', 'foo')).toHaveLength(1)\nexpect(registry.lookup('byCategory', 'bar')).toHaveLength(0)\n\nitem.$category = 'bar'\nregistry.updateIndexFor(item, 'byCategory', 'foo', 'bar')\n\nexpect(registry.lookup('byCategory', 'foo')).toHaveLength(0)\nexpect(registry.lookup('byCategory', 'bar')).toHaveLength(1)"
              },
              {
                "title": "updateIndexFor handles array keys",
                "line": 472,
                "source": "registry.addIndex('byTags', (item) => item.tags)\n\nconst item = {name: 'Post', tags: ['javascript', 'testing']}\nregistry.set('1', item)\n\nexpect(registry.lookup('byTags', 'javascript')).toHaveLength(1)\nexpect(registry.lookup('byTags', 'testing')).toHaveLength(1)\n\nitem.tags = ['react', 'hooks']\nregistry.updateIndexFor(item, 'byTags', ['javascript', 'testing'], ['react', 'hooks'])\n\nexpect(registry.lookup('byTags', 'javascript')).toHaveLength(0)\nexpect(registry.lookup('byTags', 'testing')).toHaveLength(0)\nexpect(registry.lookup('byTags', 'react')).toHaveLength(1)\nexpect(registry.lookup('byTags', 'hooks')).toHaveLength(1)"
              },
              {
                "title": "updateIndexFor returns false if value not in registry",
                "line": 491,
                "source": "registry.addIndex('byCategory', (item) => item.$category)\nconst item = {name: 'Item', category: 'foo'}\n\nexpect(registry.updateIndexFor(item, 'byCategory', 'foo', 'bar')).toBe(false)"
              },
              {
                "title": "updateIndexFor returns false if index does not exist",
                "line": 499,
                "source": "const item = {name: 'Item', category: 'foo'}\nregistry.set('1', item)\n\nexpect(registry.updateIndexFor(item, 'nonExistent', 'foo', 'bar')).toBe(false)"
              },
              {
                "title": "refreshIndexFor recalculates index automatically",
                "line": 507,
                "source": "registry.addIndex('byCategory', (item) => item.$category)\n\nconst item = {name: 'Item', $category: 'foo'}\nregistry.set('1', item)\n\nexpect(registry.lookup('byCategory', 'foo')).toHaveLength(1)\nexpect(registry.lookup('byCategory', 'bar')).toHaveLength(0)\n\nitem.$category = 'bar'\nregistry.refreshIndexFor(item, 'byCategory')\n\nexpect(registry.lookup('byCategory', 'foo')).toHaveLength(0)\nexpect(registry.lookup('byCategory', 'bar')).toHaveLength(1)"
              },
              {
                "title": "refreshIndexFor handles array values",
                "line": 524,
                "source": "registry.addIndex('byTags', (item) => item.tags)\n\nconst item = {name: 'Post', tags: ['javascript', 'testing']}\nregistry.set('1', item)\n\nexpect(registry.lookup('byTags', 'javascript')).toHaveLength(1)\n\nitem.tags = ['react', 'hooks']\nregistry.refreshIndexFor(item, 'byTags')\n\nexpect(registry.lookup('byTags', 'javascript')).toHaveLength(0)\nexpect(registry.lookup('byTags', 'react')).toHaveLength(1)"
              },
              {
                "title": "refreshIndexFor returns false if value not in registry",
                "line": 540,
                "source": "registry.addIndex('byCategory', (item) => item.$category)\nconst item = {name: 'Item', category: 'foo'}\n\nexpect(registry.refreshIndexFor(item, 'byCategory')).toBe(false)"
              },
              {
                "title": "refreshIndexFor returns false if index does not exist",
                "line": 548,
                "source": "const item = {name: 'Item', category: 'foo'}\nregistry.set('1', item)\n\nexpect(registry.refreshIndexFor(item, 'nonExistent')).toBe(false)"
              },
              {
                "title": "lookupKeys returns keys for indexed value",
                "line": 556,
                "source": "registry.addIndex('byCategory', (item) => item.category)\n\nregistry.set('item1', {name: 'Item1', category: 'electronics'})\nregistry.set('item2', {name: 'Item2', category: 'electronics'})\nregistry.set('item3', {name: 'Item3', category: 'clothing'})\n\nconst electronicKeys = registry.lookupKeys('byCategory', 'electronics')\n\nexpect(electronicKeys).toHaveLength(2)\nexpect(electronicKeys).toContain('item1')\nexpect(electronicKeys).toContain('item2')"
              },
              {
                "title": "lookupKeys returns empty array for non-existent value",
                "line": 571,
                "source": "registry.addIndex('byCategory', (item) => item.category)\n\nregistry.set('item1', {name: 'Item1', category: 'electronics'})\n\nconst result = registry.lookupKeys('byCategory', 'nonexistent')\n\nexpect(result).toEqual([])"
              },
              {
                "title": "lookupKeys throws for non-existent index",
                "line": 582,
                "source": "expect(() => registry.lookupKeys('nonExistent', 'value')).toThrow()"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/application/application.doc.js": {
    "file": "/application/application.test.js",
    "describes": [
      {
        "title": "Application",
        "line": 12,
        "beforeEach": {
          "line": 17,
          "source": "mockManifest = {\n    getAsset: vi.fn(),\n    getSource: vi.fn(),\n    getConfig: vi.fn(),\n    setConfig: vi.fn()\n}\n\nvi.spyOn(Manifest.prototype, 'getAsset').mockImplementation((...args) => {\n    return mockManifest.getAsset(...args)\n})\n\nvi.spyOn(Manifest.prototype, 'getSource').mockImplementation((...args) => {\n    return mockManifest.getSource(...args)\n})\n\nvi.spyOn(Manifest.prototype, 'getConfig').mockImplementation((path) => {\n    return mockManifest.getConfig(path)\n})\n\nvi.spyOn(Manifest.prototype, 'setConfig').mockImplementation((path, value) => {\n    return mockManifest.setConfig(path, value)\n})\n\nconst mockPerkyViewElement = document.createElement('div')\nmockPerkyViewElement.exitFullscreenMode = vi.fn()\nmockPerkyViewElement.enterFullscreenMode = vi.fn()\nvi.spyOn(PerkyView.prototype, 'mount').mockReturnValue(null)\nvi.spyOn(PerkyView, 'defaultElement').mockReturnValue(mockPerkyViewElement)\n\napplication = new Application()"
        },
        "afterEach": {
          "line": 51,
          "source": "vi.restoreAllMocks()"
        },
        "tests": [
          {
            "title": "constructor",
            "line": 56,
            "source": "expect(application).toBeInstanceOf(PerkyModule)\nexpect(application.manifest).toBeInstanceOf(Manifest)\nexpect(application.actionDispatcher).toBeDefined()\nexpect(application.loaders).toBeInstanceOf(Registry)\nexpect(application.perkyView).toBeInstanceOf(PerkyView)\nexpect(application.sourceManager).toBeDefined()"
          },
          {
            "title": "constructor with custom manifest",
            "line": 66,
            "source": "vi.restoreAllMocks()\n\nconst customManifestData = {\n    config: {name: 'Test App'}\n}\n\nconst customApp = new Application({manifest: customManifestData})\n\nexpect(customApp.manifest).toBeDefined()\nexpect(customApp.manifest.getConfig('name')).toBe('Test App')"
          },
          {
            "title": "constructor with manifest instance",
            "line": 80,
            "source": "vi.restoreAllMocks()\n\nconst manifest = new Manifest({\n    data: {\n        config: {name: 'Test App Instance'}\n    }\n})\nconst customApp = new Application({manifest})\n\nexpect(customApp.manifest).toBeInstanceOf(Manifest)\nexpect(customApp.manifest.getConfig('name')).toBe('Test App Instance')"
          },
          {
            "title": "constructor with static manifest",
            "line": 95,
            "source": "vi.restoreAllMocks()\n\nclass CustomApp extends Application {\n    static manifest = {\n        config: {name: 'Static Manifest App'}\n    }\n}\n\nconst customApp = new CustomApp()\n\nexpect(customApp.manifest).toBeInstanceOf(Manifest)\nexpect(customApp.manifest.getConfig('name')).toBe('Static Manifest App')"
          },
          {
            "title": "constructor registers keyboard and mouse devices",
            "line": 111,
            "source": "const testApp = new Application()\n\nexpect(testApp.getDevice('keyboard')).toBeInstanceOf(KeyboardDevice)\nexpect(testApp.getDevice('mouse')).toBeInstanceOf(MouseDevice)"
          },
          {
            "title": "constructor calls configure if defined",
            "line": 119,
            "source": "class ConfiguredApp extends Application {\n    constructor () {\n        super()\n    }\n\n    configureApplication () {\n        this.configureCalled = true\n    }\n}\n\nconst app = new ConfiguredApp()\nexpect(app.configureCalled).toBe(true)"
          },
          {
            "title": "loadAsset",
            "line": 136,
            "source": "vi.spyOn(application, 'loadAsset').mockResolvedValue('loaded')\n\nconst promise = application.loadAsset('logo')\n\nexpect(application.loadAsset).toHaveBeenCalledWith('logo')\nawait expect(promise).resolves.toBe('loaded')"
          },
          {
            "title": "loadTag",
            "line": 146,
            "source": "vi.spyOn(application, 'loadTag').mockResolvedValue('loaded')\n\nconst promise = application.loadTag('mainScene')\n\nexpect(application.loadTag).toHaveBeenCalledWith('mainScene')\nawait expect(promise).resolves.toBe('loaded')"
          },
          {
            "title": "loadAll",
            "line": 156,
            "source": "vi.spyOn(application, 'loadAll').mockResolvedValue('loaded')\n\nconst promise = application.loadAll()\n\nexpect(application.loadAll).toHaveBeenCalled()\nawait expect(promise).resolves.toBe('loaded')"
          },
          {
            "title": "getSource",
            "line": 166,
            "source": "application.getSource('logo')\n\nexpect(mockManifest.getSource).toHaveBeenCalledWith('logo')"
          },
          {
            "title": "config",
            "line": 173,
            "source": "application.setConfig('debug', true)\n\nexpect(mockManifest.setConfig).toHaveBeenCalledWith('debug', true)"
          },
          {
            "title": "dispose calls perkyView.dispose() which dismounts",
            "line": 180,
            "source": "const perkyView = application.perkyView\nvi.spyOn(perkyView, 'dispose')\nvi.spyOn(perkyView, 'dismount')\n\napplication.dispose()\n\nexpect(perkyView.dispose).toHaveBeenCalled()\nexpect(perkyView.dismount).toHaveBeenCalled()"
          },
          {
            "title": "input event handling integration",
            "line": 192,
            "source": "class TestController extends PerkyModule {\n    jump = vi.fn()\n}\n\nconst testApp = new Application()\nconst controller = testApp.registerController('game', TestController)\ntestApp.setActiveControllers('game')\ntestApp.bindInput({\n    deviceName: 'keyboard',\n    controlName: 'Space',\n    actionName: 'jump',\n    controllerName: 'game'\n})\n\nconst keyboardDevice = testApp.getDevice('keyboard')\nexpect(keyboardDevice).toBeDefined()\n\nconst spaceControl = keyboardDevice.getControl('Space') || keyboardDevice.findOrCreateControl(ButtonControl, {name: 'Space'})\n\nspaceControl.press({code: 'Space'})\n\nawait new Promise(resolve => setTimeout(resolve, 0))\nexpect(controller.jump).toHaveBeenCalled()"
          },
          {
            "title": "inputSystem alias provides access to InputSystem",
            "line": 219,
            "source": "expect(application.inputSystem.getDevice('keyboard')).toBeDefined()\nexpect(application.inputSystem.getDevice('mouse')).toBeDefined()"
          },
          {
            "title": "inputSystem and inputBinder getters",
            "line": 225,
            "source": "expect(application.inputSystem).toBeDefined()\nexpect(application.inputBinder).toBeDefined()"
          },
          {
            "title": "bind and unbind",
            "line": 231,
            "source": "const binding = application.bindInput({\n    deviceName: 'keyboard',\n    controlName: 'Enter',\n    actionName: 'select'\n})\n\nexpect(binding).toBeDefined()\nexpect(binding.actionName).toBe('select')\nexpect(application.getAllBindings()).toHaveLength(1)\n\nconst result = application.unbind({actionName: 'select'})\nexpect(result).toBe(true)\nexpect(application.getAllBindings()).toHaveLength(0)"
          },
          {
            "title": "getBinding and hasBinding",
            "line": 248,
            "source": "application.bindInput({\n    deviceName: 'keyboard',\n    controlName: 'Tab',\n    actionName: 'nextTab'\n})\n\nexpect(application.hasBinding({actionName: 'nextTab'})).toBe(true)\n\nconst binding = application.getBinding({actionName: 'nextTab'})\nexpect(binding).toBeDefined()\nexpect(binding.actionName).toBe('nextTab')\n\nexpect(application.hasBinding({actionName: 'nonExistent'})).toBe(false)\nexpect(application.getBinding({actionName: 'nonExistent'})).toBeNull()"
          },
          {
            "title": "getBindingsForInput",
            "line": 266,
            "source": "application.bindInput({\n    deviceName: 'keyboard',\n    controlName: 'F1',\n    actionName: 'help'\n})\n\nconst bindings = application.getBindingsForInput({\n    deviceName: 'keyboard',\n    controlName: 'F1',\n    eventType: 'pressed'\n})\n\nexpect(bindings).toHaveLength(1)\nexpect(bindings[0].actionName).toBe('help')"
          },
          {
            "title": "clearBindings",
            "line": 284,
            "source": "application.bindInput({deviceName: 'keyboard', controlName: 'A', actionName: 'action1'})\napplication.bindInput({deviceName: 'keyboard', controlName: 'B', actionName: 'action2'})\n\nexpect(application.getAllBindings()).toHaveLength(2)\n\napplication.clearBindings()\nexpect(application.getAllBindings()).toHaveLength(0)"
          },
          {
            "title": "device management",
            "line": 295,
            "source": "expect(application.registerDevice).toBeDefined()\nexpect(application.getDevice).toBeDefined()\n\nconst keyboardDevice = application.getDevice('keyboard')\nconst mouseDevice = application.getDevice('mouse')\nexpect(keyboardDevice).toBeInstanceOf(KeyboardDevice)\nexpect(mouseDevice).toBeInstanceOf(MouseDevice)\nexpect(application.getDevice('nonExistent')).toBeNull()"
          },
          {
            "title": "input state queries",
            "line": 307,
            "source": "expect(application.isPressed('keyboard', 'Space')).toBe(false)\nexpect(application.isPressedAny('Jump')).toBe(false)\nexpect(application.getInputValue('mouse', 'leftButton')).toBe(0)\nexpect(application.getInputValueAny('Fire')).toBeUndefined()\nexpect(application.getControl('keyboard', 'Space')).toBeNull()\nexpect(application.getControlAny('Jump')).toBeNull()"
          },
          {
            "title": "input state shortcuts - isKeyPressed and isMousePressed",
            "line": 317,
            "source": "expect(application.isKeyPressed('Space')).toBe(false)\nexpect(application.isKeyPressed('ArrowLeft')).toBe(false)\nexpect(application.isKeyPressed('KeyW')).toBe(false)\n\nexpect(application.isMousePressed('leftButton')).toBe(false)\nexpect(application.isMousePressed('rightButton')).toBe(false)\nexpect(application.isMousePressed('middleButton')).toBe(false)\n\nexpect(application.isKeyPressed('Space')).toBe(application.isPressed('keyboard', 'Space'))\nexpect(application.isMousePressed('leftButton')).toBe(application.isPressed('mouse', 'leftButton'))"
          },
          {
            "title": "input value shortcuts - getKeyValue and getMouseValue",
            "line": 331,
            "source": "expect(application.getKeyValue('Space')).toBeUndefined()\nexpect(application.getKeyValue('ArrowLeft')).toBeUndefined()\nexpect(application.getKeyValue('KeyW')).toBeUndefined()\n\nexpect(application.getMouseValue('leftButton')).toBe(application.getInputValue('mouse', 'leftButton'))\nexpect(application.getMouseValue('rightButton')).toBe(application.getInputValue('mouse', 'rightButton'))\nexpect(application.getMouseValue('position')).toBe(application.getInputValue('mouse', 'position'))\n\nexpect(application.getKeyValue('Space')).toBe(application.getInputValue('keyboard', 'Space'))\nexpect(application.getMouseValue('leftButton')).toBe(application.getInputValue('mouse', 'leftButton'))\nexpect(application.getMouseValue('unknownControl')).toBe(application.getInputValue('mouse', 'unknownControl'))"
          },
          {
            "title": "input shortcuts with simulated key presses",
            "line": 346,
            "source": "const keyboardDevice = application.getDevice('keyboard')\nconst mouseDevice = application.getDevice('mouse')\n\nconst spaceControl = keyboardDevice.findOrCreateControl(ButtonControl, {name: 'Space'})\nspaceControl.press()\n\nexpect(application.isKeyPressed('Space')).toBe(true)\nexpect(application.getKeyValue('Space')).toBe(1)\nexpect(application.isPressed('keyboard', 'Space')).toBe(true)\n\nconst leftButtonControl = mouseDevice.findOrCreateControl(ButtonControl, {name: 'leftButton'})\nleftButtonControl.press()\n\nexpect(application.isMousePressed('leftButton')).toBe(true)\nexpect(application.getMouseValue('leftButton')).toBe(1)\nexpect(application.isPressed('mouse', 'leftButton')).toBe(true)\n\nspaceControl.release()\nleftButtonControl.release()\n\nexpect(application.isKeyPressed('Space')).toBe(false)\nexpect(application.getKeyValue('Space')).toBe(0)\nexpect(application.isMousePressed('leftButton')).toBe(false)\nexpect(application.getMouseValue('leftButton')).toBe(0)"
          },
          {
            "title": "input shortcuts consistency verification",
            "line": 374,
            "source": "const testCases = [\n    {key: 'Space', device: 'keyboard'},\n    {key: 'ArrowLeft', device: 'keyboard'},\n    {key: 'KeyW', device: 'keyboard'},\n    {key: 'leftButton', device: 'mouse'},\n    {key: 'rightButton', device: 'mouse'},\n    {key: 'unknownControl', device: 'keyboard'},\n    {key: 'unknownControl', device: 'mouse'}\n]\n\ntestCases.forEach(({key, device}) => {\n    if (device === 'keyboard') {\n        expect(application.isKeyPressed(key)).toBe(application.isPressed('keyboard', key))\n        expect(application.getKeyValue(key)).toBe(application.getInputValue('keyboard', key))\n    } else {\n        expect(application.isMousePressed(key)).toBe(application.isPressed('mouse', key))\n        expect(application.getMouseValue(key)).toBe(application.getInputValue('mouse', key))\n    }\n})\n\nexpect(application.isKeyPressed('NonExistentKey')).toBe(false)\nexpect(application.isMousePressed('NonExistentButton')).toBe(false)"
          },
          {
            "title": "bindKey convenience method",
            "line": 400,
            "source": "const binding = application.bindInput({controlName: 'Escape', actionName: 'pause'})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('keyboard')\nexpect(binding.controlName).toBe('Escape')\nexpect(binding.actionName).toBe('pause')\nexpect(binding.eventType).toBe('pressed')\n\nconst releasedBinding = application.bindInput({controlName: 'Escape', actionName: 'resume', eventType: 'released'})\nexpect(releasedBinding.eventType).toBe('released')"
          },
          {
            "title": "bindMouse convenience method",
            "line": 414,
            "source": "const binding = application.bindInput({controlName: 'leftButton', actionName: 'shoot'})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('mouse')\nexpect(binding.controlName).toBe('leftButton')\nexpect(binding.actionName).toBe('shoot')\nexpect(binding.eventType).toBe('pressed')\n\nconst releasedBinding = application.bindInput({controlName: 'rightButton', actionName: 'aim', eventType: 'released'})\nexpect(releasedBinding.eventType).toBe('released')"
          },
          {
            "title": "addControl",
            "line": 428,
            "source": "const control = application.addControl('keyboard', ButtonControl, {name: 'CustomKey'})\n\nexpect(control).toBeInstanceOf(ButtonControl)\nexpect(control.name).toBe('CustomKey')\n\nconst keyboardDevice = application.getDevice('keyboard')\nexpect(keyboardDevice.getControl('CustomKey')).toBe(control)"
          },
          {
            "title": "use method installs child class",
            "line": 439,
            "source": "class TestChild extends PerkyModule {\n    constructor (options) {\n        super({...options, $id: 'testChild'})\n    }\n}\n\napplication.create(TestChild, {$id: 'testChild', $category: 'default'})\n\nexpect(application.hasChild('testChild')).toBe(true)"
          },
          {
            "title": "use method installs child instance",
            "line": 452,
            "source": "class TestChild extends PerkyModule {\n    constructor (options) {\n        super({...options, $id: 'testChild'})\n    }\n}\n\napplication.create(TestChild, {\n    $id: 'testChild',\n    $category: 'default'\n})\n\nexpect(application.hasChild('testChild')).toBe(true)"
          },
          {
            "title": "use method with options",
            "line": 468,
            "source": "class TestChild extends PerkyModule {\n    constructor (options) {\n        super({...options, $id: 'testChild'})\n    }\n}\n\napplication.create(TestChild, {\n    $id: 'testChild',\n    $category: 'default',\n    someOption: true\n})\n\nconst child = application.getChild('testChild')\nexpect(child.options.someOption).toBe(true)"
          }
        ],
        "describes": [
          {
            "title": "bindKey flexible API",
            "line": 486,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "parameter format with controllerName",
                "line": 488,
                "source": "const binding = application.bindInput({controlName: 'KeyF', actionName: 'fire', eventType: 'pressed', controllerName: 'player1'})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('keyboard')\nexpect(binding.controlName).toBe('KeyF')\nexpect(binding.actionName).toBe('fire')\nexpect(binding.eventType).toBe('pressed')\nexpect(binding.controllerName).toBe('player1')"
              },
              {
                "title": "parameter format with eventType and no controllerName",
                "line": 499,
                "source": "const binding = application.bindInput({controlName: 'KeyG', actionName: 'grenade', eventType: 'released'})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('keyboard')\nexpect(binding.controlName).toBe('KeyG')\nexpect(binding.actionName).toBe('grenade')\nexpect(binding.eventType).toBe('released')\nexpect(binding.controllerName).toBeNull()"
              },
              {
                "title": "object format with actionName only",
                "line": 510,
                "source": "const binding = application.bindInput({controlName: 'KeyH', actionName: 'heal'})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('keyboard')\nexpect(binding.controlName).toBe('KeyH')\nexpect(binding.actionName).toBe('heal')\nexpect(binding.eventType).toBe('pressed')\nexpect(binding.controllerName).toBeNull()"
              },
              {
                "title": "object format with actionName and eventType",
                "line": 521,
                "source": "const binding = application.bindInput({\n    controlName: 'KeyI',\n    actionName: 'inventory',\n    eventType: 'released'\n})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('keyboard')\nexpect(binding.controlName).toBe('KeyI')\nexpect(binding.actionName).toBe('inventory')\nexpect(binding.eventType).toBe('released')\nexpect(binding.controllerName).toBeNull()"
              },
              {
                "title": "object format with all options",
                "line": 536,
                "source": "const binding = application.bindInput({\n    controlName: 'KeyJ',\n    actionName: 'jump',\n    eventType: 'pressed',\n    controllerName: 'player2'\n})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('keyboard')\nexpect(binding.controlName).toBe('KeyJ')\nexpect(binding.actionName).toBe('jump')\nexpect(binding.eventType).toBe('pressed')\nexpect(binding.controllerName).toBe('player2')"
              },
              {
                "title": "object format with partial options uses defaults",
                "line": 552,
                "source": "const binding = application.bindInput({\n    controlName: 'KeyK',\n    actionName: 'kick',\n    controllerName: 'player3'\n})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('keyboard')\nexpect(binding.controlName).toBe('KeyK')\nexpect(binding.actionName).toBe('kick')\nexpect(binding.eventType).toBe('pressed')\nexpect(binding.controllerName).toBe('player3')"
              },
              {
                "title": "backwards compatibility - original format still works",
                "line": 567,
                "source": "const binding = application.bindInput({controlName: 'KeyL', actionName: 'look'})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('keyboard')\nexpect(binding.controlName).toBe('KeyL')\nexpect(binding.actionName).toBe('look')\nexpect(binding.eventType).toBe('pressed')\nexpect(binding.controllerName).toBeNull()"
              }
            ],
            "describes": []
          },
          {
            "title": "bindMouse flexible API",
            "line": 581,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "parameter format with controllerName",
                "line": 583,
                "source": "const binding = application.bindInput({controlName: 'middleButton', actionName: 'zoom', eventType: 'pressed', controllerName: 'camera'})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('mouse')\nexpect(binding.controlName).toBe('middleButton')\nexpect(binding.actionName).toBe('zoom')\nexpect(binding.eventType).toBe('pressed')\nexpect(binding.controllerName).toBe('camera')"
              },
              {
                "title": "parameter format with eventType and no controllerName",
                "line": 594,
                "source": "const binding = application.bindInput({controlName: 'rightButton', actionName: 'context', eventType: 'released'})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('mouse')\nexpect(binding.controlName).toBe('rightButton')\nexpect(binding.actionName).toBe('context')\nexpect(binding.eventType).toBe('released')\nexpect(binding.controllerName).toBeNull()"
              },
              {
                "title": "object format with actionName only",
                "line": 605,
                "source": "const binding = application.bindInput({controlName: 'leftButton', actionName: 'select'})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('mouse')\nexpect(binding.controlName).toBe('leftButton')\nexpect(binding.actionName).toBe('select')\nexpect(binding.eventType).toBe('pressed')\nexpect(binding.controllerName).toBeNull()"
              },
              {
                "title": "object format with actionName and eventType",
                "line": 616,
                "source": "const binding = application.bindInput({\n    controlName: 'rightButton',\n    actionName: 'menu',\n    eventType: 'released'\n})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('mouse')\nexpect(binding.controlName).toBe('rightButton')\nexpect(binding.actionName).toBe('menu')\nexpect(binding.eventType).toBe('released')\nexpect(binding.controllerName).toBeNull()"
              },
              {
                "title": "object format with all options",
                "line": 631,
                "source": "const binding = application.bindInput({\n    controlName: 'leftButton',\n    actionName: 'fire',\n    eventType: 'pressed',\n    controllerName: 'weapon'\n})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('mouse')\nexpect(binding.controlName).toBe('leftButton')\nexpect(binding.actionName).toBe('fire')\nexpect(binding.eventType).toBe('pressed')\nexpect(binding.controllerName).toBe('weapon')"
              },
              {
                "title": "object format with partial options uses defaults",
                "line": 647,
                "source": "const binding = application.bindInput({\n    controlName: 'middleButton',\n    actionName: 'special',\n    controllerName: 'ui'\n})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('mouse')\nexpect(binding.controlName).toBe('middleButton')\nexpect(binding.actionName).toBe('special')\nexpect(binding.eventType).toBe('pressed')\nexpect(binding.controllerName).toBe('ui')"
              },
              {
                "title": "backwards compatibility - original format still works",
                "line": 662,
                "source": "const binding = application.bindInput({controlName: 'rightButton', actionName: 'aim'})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('mouse')\nexpect(binding.controlName).toBe('rightButton')\nexpect(binding.actionName).toBe('aim')\nexpect(binding.eventType).toBe('pressed')\nexpect(binding.controllerName).toBeNull()"
              },
              {
                "title": "object format validation - empty object should throw",
                "line": 673,
                "source": "expect(() => {\n    application.bindMouse('leftButton', {})\n}).toThrow()"
              },
              {
                "title": "object format validation - undefined actionName should throw",
                "line": 679,
                "source": "expect(() => {\n    application.bindMouse('rightButton', {actionName: undefined})\n}).toThrow()"
              },
              {
                "title": "parameter format validation - undefined actionName should throw",
                "line": 685,
                "source": "expect(() => {\n    application.bindMouse('middleButton', undefined)\n}).toThrow()"
              }
            ],
            "describes": []
          },
          {
            "title": "flexible API edge cases",
            "line": 694,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "mixed usage in same application",
                "line": 696,
                "source": "const binding1 = application.bindInput({controlName: 'Digit1', actionName: 'slot1', eventType: 'pressed', controllerName: 'inventory'})\n\nconst binding2 = application.bindInput({\n    controlName: 'Digit2',\n    actionName: 'slot2',\n    eventType: 'pressed',\n    controllerName: 'inventory'\n})\n\nexpect(binding1.actionName).toBe('slot1')\nexpect(binding1.controllerName).toBe('inventory')\nexpect(binding2.actionName).toBe('slot2')\nexpect(binding2.controllerName).toBe('inventory')\n\nconst allBindings = application.getAllBindings()\nconst inventoryBindings = allBindings.filter(b => b.controllerName === 'inventory')\nexpect(inventoryBindings).toHaveLength(2)"
              },
              {
                "title": "object format with empty object defaults everything",
                "line": 716,
                "source": "expect(() => {\n    application.bindKey('KeyEmpty', {})\n}).toThrow()"
              },
              {
                "title": "object format with undefined actionName",
                "line": 722,
                "source": "expect(() => {\n    application.bindKey('KeyUndef', {actionName: undefined})\n}).toThrow()"
              },
              {
                "title": "object format with null actionName",
                "line": 728,
                "source": "expect(() => {\n    application.bindKey('KeyNull', {actionName: null})\n}).toThrow()"
              },
              {
                "title": "object format with empty string actionName",
                "line": 734,
                "source": "expect(() => {\n    application.bindKey('KeyEmpty', {actionName: ''})\n}).toThrow()"
              },
              {
                "title": "parameter format with undefined actionName",
                "line": 740,
                "source": "expect(() => {\n    application.bindKey('KeyParamUndef', undefined)\n}).toThrow()"
              },
              {
                "title": "parameter format with null actionName",
                "line": 746,
                "source": "expect(() => {\n    application.bindKey('KeyParamNull', null)\n}).toThrow()"
              }
            ],
            "describes": []
          },
          {
            "title": "bindCombo",
            "line": 755,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "accepts string format with auto-detection",
                "line": 757,
                "source": "const combo = application.bindCombo(['ShiftLeft', 'leftButton'], 'shiftClick')\n\nexpect(combo).toBeDefined()\nexpect(combo.controls).toHaveLength(2)\nexpect(combo.controls[0].deviceName).toBe('keyboard')\nexpect(combo.controls[0].controlName).toBe('ShiftLeft')\nexpect(combo.controls[1].deviceName).toBe('mouse')\nexpect(combo.controls[1].controlName).toBe('leftButton')\nexpect(combo.actionName).toBe('shiftClick')"
              },
              {
                "title": "accepts object format",
                "line": 770,
                "source": "const combo = application.bindCombo([\n    {deviceName: 'keyboard', controlName: 'ControlLeft'},\n    {deviceName: 'mouse', controlName: 'rightButton'}\n], 'ctrlRightClick')\n\nexpect(combo.controls).toHaveLength(2)\nexpect(combo.controls[0].deviceName).toBe('keyboard')\nexpect(combo.controls[1].deviceName).toBe('mouse')"
              },
              {
                "title": "accepts mixed string and object formats",
                "line": 782,
                "source": "const combo = application.bindCombo([\n    'ControlLeft',\n    {deviceName: 'mouse', controlName: 'leftButton'}\n], 'mixedCombo')\n\nexpect(combo.controls).toHaveLength(2)\nexpect(combo.controls[0].deviceName).toBe('keyboard')\nexpect(combo.controls[0].controlName).toBe('ControlLeft')\nexpect(combo.controls[1].deviceName).toBe('mouse')\nexpect(combo.controls[1].controlName).toBe('leftButton')"
              },
              {
                "title": "works with keyboard-only combinations",
                "line": 796,
                "source": "const combo = application.bindCombo(['ControlLeft', 'KeyS'], 'save')\n\nexpect(combo.controls).toHaveLength(2)\nexpect(combo.controls.every(c => c.deviceName === 'keyboard')).toBe(true)"
              },
              {
                "title": "works with mouse-only combinations",
                "line": 804,
                "source": "const combo = application.bindCombo(['leftButton', 'rightButton'], 'bothButtons')\n\nexpect(combo.controls).toHaveLength(2)\nexpect(combo.controls.every(c => c.deviceName === 'mouse')).toBe(true)"
              },
              {
                "title": "supports controller and eventType",
                "line": 812,
                "source": "const combo = application.bindCombo(\n    ['AltLeft', 'middleButton'],\n    'special',\n    'editor',\n    'released'\n)\n\nexpect(combo.controllerName).toBe('editor')\nexpect(combo.eventType).toBe('released')"
              },
              {
                "title": "integration test - triggers when all controls are pressed",
                "line": 825,
                "source": "class TestController extends PerkyModule {\n    smartCombo = vi.fn()\n}\n\nconst testApp = new Application()\n\n\nconst controller = testApp.registerController('editor', TestController)\ntestApp.setActiveControllers('editor')\ntestApp.bindCombo(['ControlLeft', 'leftButton'], 'smartCombo', 'editor')\n\nconst keyboardDevice = testApp.getDevice('keyboard')\nconst mouseDevice = testApp.getDevice('mouse')\n\nconst ctrlControl = keyboardDevice.findOrCreateControl(ButtonControl, {name: 'ControlLeft'})\nconst leftButtonControl = mouseDevice.findOrCreateControl(ButtonControl, {name: 'leftButton'})\n\nctrlControl.press({code: 'ControlLeft'})\nawait new Promise(resolve => setTimeout(resolve, 0))\nexpect(controller.smartCombo).not.toHaveBeenCalled()\n\nleftButtonControl.press()\nawait new Promise(resolve => setTimeout(resolve, 0))\nexpect(controller.smartCombo).toHaveBeenCalled()"
              }
            ],
            "describes": []
          },
          {
            "title": "isActionPressed and getActionControls",
            "line": 855,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "isActionPressed - returns false when action not bound",
                "line": 857,
                "source": "expect(application.isActionPressed('nonExistent')).toBe(false)"
              },
              {
                "title": "isActionPressed - returns false when control not pressed",
                "line": 862,
                "source": "application.bindInput({controlName: 'Space', actionName: 'jump'})\nexpect(application.isActionPressed('jump')).toBe(false)"
              },
              {
                "title": "isActionPressed - returns true when control is pressed",
                "line": 868,
                "source": "application.bindInput({controlName: 'Space', actionName: 'jump'})\n\nconst keyboardDevice = application.getDevice('keyboard')\nconst spaceControl = keyboardDevice.findOrCreateControl(ButtonControl, {name: 'Space'})\nspaceControl.press()\n\nexpect(application.isActionPressed('jump')).toBe(true)"
              },
              {
                "title": "isActionPressed - works with multiple bindings for same action",
                "line": 879,
                "source": "application.bindInput({controlName: 'Space', actionName: 'jump'})\napplication.bindInput({controlName: 'KeyW', actionName: 'jump'})\n\nconst keyboardDevice = application.getDevice('keyboard')\nconst wControl = keyboardDevice.findOrCreateControl(ButtonControl, {name: 'KeyW'})\nwControl.press()\n\nexpect(application.isActionPressed('jump')).toBe(true)"
              },
              {
                "title": "isActionPressed - filters by controllerName",
                "line": 891,
                "source": "application.bindInput({controlName: 'Space', actionName: 'jump', eventType: 'pressed', controllerName: 'player1'})\napplication.bindInput({controlName: 'KeyW', actionName: 'jump', eventType: 'pressed', controllerName: 'player2'})\n\nconst keyboardDevice = application.getDevice('keyboard')\nconst spaceControl = keyboardDevice.findOrCreateControl(ButtonControl, {name: 'Space'})\nspaceControl.press()\n\nexpect(application.isActionPressed('jump', 'player1')).toBe(true)\nexpect(application.isActionPressed('jump', 'player2')).toBe(false)\nexpect(application.isActionPressed('jump')).toBe(true)"
              },
              {
                "title": "isActionPressed - works with composite bindings",
                "line": 905,
                "source": "application.bindCombo(['ControlLeft', 'KeyS'], 'save')\n\nconst keyboardDevice = application.getDevice('keyboard')\nconst ctrlControl = keyboardDevice.findOrCreateControl(ButtonControl, {name: 'ControlLeft'})\nconst sControl = keyboardDevice.findOrCreateControl(ButtonControl, {name: 'KeyS'})\n\nctrlControl.press()\nexpect(application.isActionPressed('save')).toBe(false)\n\nsControl.press()\nexpect(application.isActionPressed('save')).toBe(true)\n\nctrlControl.release()\nexpect(application.isActionPressed('save')).toBe(false)"
              },
              {
                "title": "getActionControls - returns empty array when action not bound",
                "line": 923,
                "source": "const controls = application.getActionControls('nonExistent')\nexpect(controls).toHaveLength(0)"
              },
              {
                "title": "getActionControls - returns control for simple binding",
                "line": 929,
                "source": "application.bindInput({controlName: 'Space', actionName: 'jump'})\n\nconst keyboardDevice = application.getDevice('keyboard')\nconst spaceControl = keyboardDevice.findOrCreateControl(ButtonControl, {name: 'Space'})\n\nconst controls = application.getActionControls('jump')\nexpect(controls).toHaveLength(1)\nexpect(controls[0]).toBe(spaceControl)"
              },
              {
                "title": "getActionControls - returns multiple controls for multiple bindings",
                "line": 941,
                "source": "application.bindInput({controlName: 'Space', actionName: 'jump', eventType: 'pressed', controllerName: 'player1'})\napplication.bindInput({controlName: 'KeyW', actionName: 'jump', eventType: 'pressed', controllerName: 'player2'})\n\nconst keyboardDevice = application.getDevice('keyboard')\nconst spaceControl = keyboardDevice.findOrCreateControl(ButtonControl, {name: 'Space'})\nconst wControl = keyboardDevice.findOrCreateControl(ButtonControl, {name: 'KeyW'})\n\nconst controls = application.getActionControls('jump')\nexpect(controls).toHaveLength(2)\nexpect(controls).toContain(spaceControl)\nexpect(controls).toContain(wControl)"
              },
              {
                "title": "getActionControls - filters by controllerName",
                "line": 956,
                "source": "application.bindInput({controlName: 'Space', actionName: 'jump', eventType: 'pressed', controllerName: 'player1'})\napplication.bindInput({controlName: 'KeyW', actionName: 'jump', eventType: 'pressed', controllerName: 'player2'})\n\nconst keyboardDevice = application.getDevice('keyboard')\nkeyboardDevice.findOrCreateControl(ButtonControl, {name: 'Space'})\nkeyboardDevice.findOrCreateControl(ButtonControl, {name: 'KeyW'})\n\nconst player1Controls = application.getActionControls('jump', 'player1')\nexpect(player1Controls).toHaveLength(1)\nexpect(player1Controls[0].name).toBe('Space')\n\nconst player2Controls = application.getActionControls('jump', 'player2')\nexpect(player2Controls).toHaveLength(1)\nexpect(player2Controls[0].name).toBe('KeyW')\n\nconst allControls = application.getActionControls('jump')\nexpect(allControls).toHaveLength(2)"
              },
              {
                "title": "getActionControls - works with composite bindings",
                "line": 977,
                "source": "application.bindCombo(['ControlLeft', 'KeyS'], 'save')\n\nconst keyboardDevice = application.getDevice('keyboard')\nconst ctrlControl = keyboardDevice.findOrCreateControl(ButtonControl, {name: 'ControlLeft'})\nconst sControl = keyboardDevice.findOrCreateControl(ButtonControl, {name: 'KeyS'})\n\nconst controls = application.getActionControls('save')\nexpect(controls).toHaveLength(2)\nexpect(controls).toContain(ctrlControl)\nexpect(controls).toContain(sControl)"
              },
              {
                "title": "getActionControls - handles non-existent controls gracefully",
                "line": 991,
                "source": "application.bindInput({controlName: 'Space', actionName: 'jump'})\n\nconst controls = application.getActionControls('jump')\nexpect(controls).toHaveLength(0)"
              },
              {
                "title": "getActionControls - works with cross-device bindings",
                "line": 999,
                "source": "application.bindInput({controlName: 'Space', actionName: 'action', eventType: 'pressed', controllerName: 'keyboard-input'})\napplication.bindInput({controlName: 'leftButton', actionName: 'action', eventType: 'pressed', controllerName: 'mouse-input'})\n\nconst keyboardDevice = application.getDevice('keyboard')\nconst mouseDevice = application.getDevice('mouse')\nconst spaceControl = keyboardDevice.findOrCreateControl(ButtonControl, {name: 'Space'})\nconst leftButtonControl = mouseDevice.findOrCreateControl(ButtonControl, {name: 'leftButton'})\n\nconst controls = application.getActionControls('action')\nexpect(controls).toHaveLength(2)\nexpect(controls).toContain(spaceControl)\nexpect(controls).toContain(leftButtonControl)"
              }
            ],
            "describes": []
          },
          {
            "title": "controller bindings auto-registration",
            "line": 1017,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "registers simple bindings when controller is registered",
                "line": 1019,
                "source": "class TestController extends PerkyModule {\n    static bindings = {\n        shoot: 'Space',\n        jump: 'KeyJ'\n    }\n\n    static normalizeBindings () {\n        return [\n            {action: 'shoot', key: 'Space', scoped: false, eventType: 'pressed', controllerName: null},\n            {action: 'jump', key: 'KeyJ', scoped: false, eventType: 'pressed', controllerName: null}\n        ]\n    }\n}\n\nconst beforeBindings = application.getAllBindings()\nexpect(beforeBindings.filter(b => b.actionName === 'shoot')).toHaveLength(0)\n\napplication.registerController('game', TestController)\n\nconst afterBindings = application.getAllBindings()\nconst shootBinding = afterBindings.find(b => b.actionName === 'shoot')\nconst jumpBinding = afterBindings.find(b => b.actionName === 'jump')\n\nexpect(shootBinding).toBeDefined()\nexpect(shootBinding.controlName).toBe('Space')\nexpect(shootBinding.controllerName).toBeNull()\n\nexpect(jumpBinding).toBeDefined()\nexpect(jumpBinding.controlName).toBe('KeyJ')\nexpect(jumpBinding.controllerName).toBeNull()"
              },
              {
                "title": "registers scoped bindings with controllerName",
                "line": 1053,
                "source": "class TestController extends PerkyModule {\n    static bindings = {\n        shoot: {keys: 'Space', scoped: true}\n    }\n\n    static normalizeBindings (controllerName) {\n        return [\n            {action: 'shoot', key: 'Space', scoped: true, eventType: 'pressed', controllerName}\n        ]\n    }\n}\n\napplication.registerController('player', TestController)\n\nconst bindings = application.getAllBindings()\nconst shootBinding = bindings.find(b => b.actionName === 'shoot' && b.controllerName === 'player')\n\nexpect(shootBinding).toBeDefined()\nexpect(shootBinding.controlName).toBe('Space')\nexpect(shootBinding.controllerName).toBe('player')"
              },
              {
                "title": "registers multiple keys for same action",
                "line": 1077,
                "source": "class TestController extends PerkyModule {\n    static bindings = {\n        moveUp: ['KeyW', 'ArrowUp']\n    }\n\n    static normalizeBindings () {\n        return [\n            {action: 'moveUp', key: 'KeyW', scoped: false, eventType: 'pressed', controllerName: null},\n            {action: 'moveUp', key: 'ArrowUp', scoped: false, eventType: 'pressed', controllerName: null}\n        ]\n    }\n}\n\napplication.registerController('game', TestController)\n\nconst bindings = application.getAllBindings()\nconst moveUpBindings = bindings.filter(b => b.actionName === 'moveUp')\n\nexpect(moveUpBindings.length).toBeGreaterThanOrEqual(2)\nexpect(moveUpBindings.some(b => b.controlName === 'KeyW')).toBe(true)\nexpect(moveUpBindings.some(b => b.controlName === 'ArrowUp')).toBe(true)"
              },
              {
                "title": "registers bindings with custom eventType",
                "line": 1102,
                "source": "class TestController extends PerkyModule {\n    static bindings = {\n        boost: {keys: 'ShiftLeft', eventType: 'released'}\n    }\n\n    static normalizeBindings () {\n        return [\n            {action: 'boost', key: 'ShiftLeft', scoped: false, eventType: 'released', controllerName: null}\n        ]\n    }\n}\n\napplication.registerController('game', TestController)\n\nconst bindings = application.getAllBindings()\nconst boostBinding = bindings.find(b => b.actionName === 'boost')\n\nexpect(boostBinding).toBeDefined()\nexpect(boostBinding.eventType).toBe('released')"
              },
              {
                "title": "allows multiple controllers with same keys (different scopes)",
                "line": 1125,
                "source": "class GameController extends PerkyModule {\n    static bindings = {\n        move: {keys: 'ArrowUp', scoped: true}\n    }\n\n    static normalizeBindings (controllerName) {\n        return [\n            {action: 'move', key: 'ArrowUp', scoped: true, eventType: 'pressed', controllerName}\n        ]\n    }\n}\n\nclass MenuController extends PerkyModule {\n    static bindings = {\n        navigate: {keys: 'ArrowUp', scoped: true}\n    }\n\n    static normalizeBindings (controllerName) {\n        return [\n            {action: 'navigate', key: 'ArrowUp', scoped: true, eventType: 'pressed', controllerName}\n        ]\n    }\n}\n\napplication.registerController('game', GameController)\napplication.registerController('menu', MenuController)\n\nconst bindings = application.getAllBindings()\nconst arrowUpBindings = bindings.filter(b => b.controlName === 'ArrowUp')\n\nexpect(arrowUpBindings.length).toBeGreaterThanOrEqual(2)\n\nconst gameBinding = arrowUpBindings.find(b => b.controllerName === 'game')\nconst menuBinding = arrowUpBindings.find(b => b.controllerName === 'menu')\n\nexpect(gameBinding).toBeDefined()\nexpect(gameBinding.actionName).toBe('move')\n\nexpect(menuBinding).toBeDefined()\nexpect(menuBinding.actionName).toBe('navigate')"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/application/asset.doc.js": {
    "file": "/application/asset.test.js",
    "describes": [
      {
        "title": "Asset",
        "line": 5,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "constructor with parameters",
            "line": 7,
            "source": "const params = {\n    type: 'image',\n    name: 'example',\n    id: 'test_id',\n    url: '/path/to/file.jpg',\n    source: {key: 'value'},\n    tags: ['titleScreen', 'mainScene'],\n    config: {width: 100, height: 100}\n}\n\nconst asset = new Asset(params)\n\nexpect(asset.type).toBe('image')\nexpect(asset.name).toBe('example')\nexpect(asset.id).toBe('test_id')\nexpect(asset.url).toBe('/path/to/file.jpg')\nexpect(asset.source).toEqual({key: 'value'})\nexpect(asset.tags).toEqual(['titleScreen', 'mainScene'])\nexpect(asset.config).toEqual({width: 100, height: 100})"
          },
          {
            "title": "constructor name defaults to id",
            "line": 30,
            "source": "const asset = new Asset({\n    type: 'video',\n    id: 'custom_id'\n})\n\nexpect(asset.id).toBe('custom_id')\nexpect(asset.name).toBe('custom_id')"
          },
          {
            "title": "loaded returns true when source exists",
            "line": 41,
            "source": "const asset = new Asset({\n    type: 'json',\n    id: 'test_id',\n    source: {content: 'source'}\n})\n\nexpect(asset.loaded).toBe(true)"
          },
          {
            "title": "loaded returns false when source is missing",
            "line": 52,
            "source": "const asset = new Asset({\n    type: 'text',\n    id: 'test_id',\n    url: '/path/to/text.txt'\n})\n\nexpect(asset.loaded).toBe(false)"
          },
          {
            "title": "hasTag returns true for existing tags",
            "line": 63,
            "source": "const asset = new Asset({\n    type: 'image',\n    id: 'test_id',\n    tags: ['titleScreen', 'mainScene']\n})\n\nexpect(asset.hasTag('titleScreen')).toBe(true)\nexpect(asset.hasTag('mainScene')).toBe(true)\nexpect(asset.hasTag('endingScene')).toBe(false)"
          },
          {
            "title": "hasTag returns false when tags are empty",
            "line": 76,
            "source": "const asset = new Asset({\n    type: 'image',\n    id: 'test_id'\n})\n\nexpect(asset.hasTag('titleScreen')).toBe(false)"
          },
          {
            "title": "export with url",
            "line": 86,
            "source": "const asset = new Asset({\n    type: 'image',\n    name: 'example',\n    id: 'test_id',\n    url: '/path/to/file.jpg',\n    tags: ['titleScreen'],\n    config: {width: 100}\n})\n\nconst exported = asset.export()\n\nexpect(exported).toEqual({\n    type: 'image',\n    id: 'test_id',\n    name: 'example',\n    url: '/path/to/file.jpg',\n    tags: ['titleScreen'],\n    config: {width: 100}\n})\nexpect(exported.source).toBeUndefined()"
          },
          {
            "title": "export with source",
            "line": 110,
            "source": "const asset = new Asset({\n    type: 'json',\n    name: 'config',\n    id: 'config_id',\n    source: {settings: true},\n    tags: ['config', 'settings'],\n    config: {parse: true}\n})\n\nconst exported = asset.export()\n\nexpect(exported).toEqual({\n    type: 'json',\n    id: 'config_id',\n    name: 'config',\n    source: {settings: true},\n    tags: ['config', 'settings'],\n    config: {parse: true}\n})\nexpect(exported.path).toBeUndefined()"
          },
          {
            "title": "default tags and config",
            "line": 134,
            "source": "const asset = new Asset({\n    type: 'audio',\n    id: 'audio_id'\n})\n\nexpect(asset.tags).toEqual([])\nexpect(asset.config).toEqual({})"
          }
        ],
        "describes": []
      }
    ]
  },
  "/application/manifest.doc.js": {
    "file": "/application/manifest.test.js",
    "describes": [
      {
        "title": "Manifest",
        "line": 5,
        "beforeEach": {
          "line": 8,
          "source": "manifest = new Manifest()"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor",
            "line": 13,
            "source": "expect(manifest.getConfig()).toEqual({})\nexpect(manifest.getAllAssets()).toEqual([])"
          },
          {
            "title": "constructor with data",
            "line": 19,
            "source": "const customManifest = new Manifest({\n    data: {\n        config: {name: 'Test Manifest'}\n    }\n})\n\nexpect(customManifest.getConfig('name')).toBe('Test Manifest')\nexpect(customManifest.getAllAssets()).toEqual([])"
          },
          {
            "title": "import with JSON string",
            "line": 31,
            "source": "const jsonData = JSON.stringify({\n    config: {debug: true},\n    assets: {\n        logo: {type: 'image', url: '/assets/logo.png', tags: ['preload']}\n    }\n})\n\nmanifest.import(jsonData)\n\nexpect(manifest.getConfig('debug')).toBe(true)\nexpect(manifest.getAsset('logo').id).toBe('logo')\nexpect(manifest.getAsset('logo').type).toBe('image')"
          },
          {
            "title": "import with object",
            "line": 47,
            "source": "const data = {\n    config: {version: '1.0.0'}\n}\n\nmanifest.import(data)\n\nexpect(manifest.getConfig('version')).toBe('1.0.0')"
          },
          {
            "title": "import clears existing assets",
            "line": 58,
            "source": "manifest.addAsset({id: 'old', type: 'image', url: '/old.png'})\n\nmanifest.import({\n    config: {},\n    assets: {\n        new: {type: 'image', url: '/new.png'}\n    }\n})\n\nexpect(manifest.getAsset('old')).toBeNull()\nexpect(manifest.getAsset('new')).not.toBeNull()"
          },
          {
            "title": "export",
            "line": 73,
            "source": "manifest.setConfig('version', '1.0.0')\nmanifest.addAsset({id: 'logo', type: 'image', url: '/logo.png'})\n\nconst exported = manifest.export()\n\nexpect(exported.config.version).toBe('1.0.0')\nexpect(exported.assets.logo.id).toBe('logo')"
          },
          {
            "title": "getConfig",
            "line": 84,
            "source": "manifest.setConfig('debug', true)\nmanifest.setConfig('logging.level', 'info')\n\nexpect(manifest.getConfig()).toEqual({debug: true, logging: {level: 'info'}})"
          },
          {
            "title": "getConfig with path",
            "line": 92,
            "source": "manifest.setConfig('debug', true)\nmanifest.setConfig('logging.level', 'info')\n\nexpect(manifest.getConfig('logging.level')).toBe('info')"
          },
          {
            "title": "setConfig",
            "line": 100,
            "source": "const result = manifest.setConfig('logging.level', 'debug')\n\nexpect(manifest.getConfig('logging.level')).toBe('debug')\nexpect(result).toBe(manifest)"
          },
          {
            "title": "addAsset",
            "line": 108,
            "source": "manifest.addAsset({id: 'logo', type: 'image', url: '/assets/logo.png'})\n\nexpect(manifest.getAllAssets()).toHaveLength(1)\nexpect(manifest.getAsset('logo').id).toBe('logo')"
          },
          {
            "title": "addAsset updates existing",
            "line": 116,
            "source": "manifest.addAsset({id: 'logo', type: 'image', url: '/assets/logo.png'})\nmanifest.addAsset({id: 'logo', type: 'image', url: '/assets/new-logo.png'})\n\nexpect(manifest.getAllAssets()).toHaveLength(1)\nexpect(manifest.getAsset('logo').url).toBe('/assets/new-logo.png')"
          },
          {
            "title": "addAsset with Asset instance",
            "line": 125,
            "source": "const asset = new Asset({id: 'logo', type: 'image', url: '/logo.png'})\nmanifest.addAsset(asset)\n\nexpect(manifest.getAsset('logo')).toBe(asset)"
          },
          {
            "title": "getAsset returns null for missing",
            "line": 133,
            "source": "expect(manifest.getAsset('nonexistent')).toBeNull()"
          },
          {
            "title": "getAsset",
            "line": 138,
            "source": "const assetData = {id: 'logo', type: 'image', url: '/assets/logo.png'}\nmanifest.addAsset(assetData)\n\nconst asset = manifest.getAsset('logo')\nexpect(asset).toBeInstanceOf(Asset)\nexpect(asset.id).toBe(assetData.id)\nexpect(asset.url).toBe(assetData.url)"
          },
          {
            "title": "getSource",
            "line": 149,
            "source": "const assetData = {id: 'logo', type: 'image', url: '/assets/logo.png', source: 'fakeImage'}\nmanifest.addAsset(assetData)\n\nconst source = manifest.getSource('logo')\nexpect(source).toBe('fakeImage')"
          },
          {
            "title": "getSource returns null for missing",
            "line": 158,
            "source": "expect(manifest.getSource('nonexistent')).toBeNull()"
          },
          {
            "title": "getAssetsByType",
            "line": 163,
            "source": "manifest.addAsset({id: 'logo', type: 'image', url: '/logo.png'})\nmanifest.addAsset({id: 'icon', type: 'image', url: '/icon.png'})\nmanifest.addAsset({id: 'music', type: 'audio', url: '/music.mp3'})\n\nconst images = manifest.getAssetsByType('image')\nexpect(images).toHaveLength(2)\nexpect(images.map(a => a.id)).toContain('logo')\nexpect(images.map(a => a.id)).toContain('icon')"
          },
          {
            "title": "getAssetsByTag",
            "line": 175,
            "source": "manifest.addAsset({id: 'logo', type: 'image', url: '/logo.png', tags: ['titleScreen']})\nmanifest.addAsset({id: 'icon', type: 'image', url: '/icon.png', tags: ['mainScene']})\n\nconst titleScreenAssets = manifest.getAssetsByTag('titleScreen')\nexpect(titleScreenAssets).toHaveLength(1)\nexpect(titleScreenAssets[0].id).toBe('logo')"
          },
          {
            "title": "getAssetsByTag multiple types",
            "line": 185,
            "source": "manifest.addAsset({id: 'icon', type: 'image', url: '/icon.png', tags: ['titleScreen']})\nmanifest.addAsset({id: 'music', type: 'audio', url: '/music.mp3', tags: ['titleScreen']})\n\nconst titleScreenAssets = manifest.getAssetsByTag('titleScreen')\nexpect(titleScreenAssets).toHaveLength(2)"
          },
          {
            "title": "getAssetsByTag multiple tags",
            "line": 194,
            "source": "manifest.addAsset({id: 'icon', type: 'image', url: '/icon.png', tags: ['titleScreen', 'mainScene', 'endingScene']})\nmanifest.addAsset({id: 'logo', type: 'image', url: '/logo.png', tags: ['endingScene']})\n\nconst titleScreenAssets = manifest.getAssetsByTag('titleScreen')\nexpect(titleScreenAssets).toHaveLength(1)\nexpect(titleScreenAssets[0].id).toBe('icon')\n\nconst endingSceneAssets = manifest.getAssetsByTag('endingScene')\nexpect(endingSceneAssets).toHaveLength(2)"
          },
          {
            "title": "getAssetsByTag no assets",
            "line": 207,
            "source": "const tagAssets = manifest.getAssetsByTag('titleScreen')\nexpect(tagAssets).toHaveLength(0)"
          },
          {
            "title": "getAssetsByTag invalid tag",
            "line": 213,
            "source": "expect(manifest.getAssetsByTag(null)).toEqual([])\nexpect(manifest.getAssetsByTag('')).toEqual([])\nexpect(manifest.getAssetsByTag(123)).toEqual([])"
          },
          {
            "title": "getAllAssets",
            "line": 220,
            "source": "manifest.addAsset({id: 'logo', type: 'image', url: '/logo.png'})\nmanifest.addAsset({id: 'music', type: 'audio', url: '/music.mp3'})\n\nconst allAssets = manifest.getAllAssets()\nexpect(allAssets).toHaveLength(2)"
          },
          {
            "title": "getAssets is alias for getAllAssets",
            "line": 229,
            "source": "manifest.addAsset({id: 'logo', type: 'image', url: '/logo.png'})\n\nexpect(manifest.getAssets()).toEqual(manifest.getAllAssets())"
          },
          {
            "title": "hasAsset",
            "line": 236,
            "source": "manifest.addAsset({id: 'logo', type: 'image', url: '/logo.png'})\n\nexpect(manifest.hasAsset('logo')).toBe(true)\nexpect(manifest.hasAsset('nonexistent')).toBe(false)"
          },
          {
            "title": "removeAsset",
            "line": 244,
            "source": "manifest.addAsset({id: 'logo', type: 'image', url: '/logo.png'})\n\nexpect(manifest.removeAsset('logo')).toBe(true)\nexpect(manifest.getAsset('logo')).toBeNull()"
          },
          {
            "title": "removeAsset nonexistent",
            "line": 252,
            "source": "expect(manifest.removeAsset('nonexistent')).toBe(false)"
          },
          {
            "title": "assets registry has type index",
            "line": 257,
            "source": "manifest.addAsset({id: 'logo', type: 'image', url: '/logo.png'})\n\nexpect(manifest.assets.hasIndex('type')).toBe(true)\nexpect(manifest.assets.lookup('type', 'image')).toHaveLength(1)"
          },
          {
            "title": "assets registry has tags index",
            "line": 265,
            "source": "manifest.addAsset({id: 'logo', type: 'image', url: '/logo.png', tags: ['preload']})\n\nexpect(manifest.assets.hasIndex('tags')).toBe(true)\nexpect(manifest.assets.lookup('tags', 'preload')).toHaveLength(1)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/application/perky_view.doc.js": {
    "file": "/application/perky_view.test.js",
    "describes": [
      {
        "title": "PerkyView",
        "line": 6,
        "beforeEach": {
          "line": 11,
          "source": "element = document.createElement('div')\nelement.id = 'test-view'\n\ncontainer = document.createElement('div')\ncontainer.id = 'test-container'\ndocument.body.appendChild(container)\n\nvi.spyOn(element, 'offsetWidth', 'get').mockReturnValue(0)\nvi.spyOn(element, 'offsetHeight', 'get').mockReturnValue(0)\nvi.spyOn(element, 'getBoundingClientRect').mockReturnValue({\n    left: 0,\n    top: 0,\n    width: 0,\n    height: 0,\n    right: 0,\n    bottom: 0,\n    x: 0,\n    y: 0\n})\n\nvi.spyOn(PerkyModule.prototype, 'emit')\n\nview = new PerkyView({element})"
        },
        "afterEach": {
          "line": 38,
          "source": "vi.restoreAllMocks()\ndocument.body.innerHTML = ''"
        },
        "tests": [
          {
            "title": "constructor with element",
            "line": 44,
            "source": "expect(view.element).toBe(element)"
          },
          {
            "title": "constructor with container",
            "line": 49,
            "source": "const viewWithContainer = new PerkyView({\n    element,\n    container\n})\n\nexpect(container.contains(element)).toBe(true)\nexpect(viewWithContainer.container).toBe(container)"
          },
          {
            "title": "constructor with default element",
            "line": 60,
            "source": "const defaultView = new PerkyView()\n\nexpect(defaultView.element.tagName).toBe('DIV')\nexpect(defaultView.element.className).toBe('perky-view')"
          },
          {
            "title": "html getter",
            "line": 68,
            "source": "element.innerHTML = '<div>test content</div>'\nexpect(view.html).toBe('<div>test content</div>')"
          },
          {
            "title": "width getter",
            "line": 74,
            "source": "element.style.width = '300px'\nvi.spyOn(element, 'offsetWidth', 'get').mockReturnValue(300)\nexpect(view.width).toBe(300)"
          },
          {
            "title": "height getter",
            "line": 81,
            "source": "element.style.height = '400px'\nvi.spyOn(element, 'offsetHeight', 'get').mockReturnValue(400)\nexpect(view.height).toBe(400)"
          },
          {
            "title": "aspectRatio getter",
            "line": 88,
            "source": "element.style.width = '300px'\nelement.style.height = '400px'\nvi.spyOn(element, 'offsetWidth', 'get').mockReturnValue(300)\nvi.spyOn(element, 'offsetHeight', 'get').mockReturnValue(400)\nexpect(view.aspectRatio).toBe(300 / 400)"
          },
          {
            "title": "size getter",
            "line": 97,
            "source": "element.style.width = '300px'\nelement.style.height = '400px'\nvi.spyOn(element, 'offsetWidth', 'get').mockReturnValue(300)\nvi.spyOn(element, 'offsetHeight', 'get').mockReturnValue(400)\nexpect(view.size).toEqual({\n    width: 300,\n    height: 400\n})"
          },
          {
            "title": "addClass",
            "line": 109,
            "source": "view.addClass('test-class')\nexpect(element.classList.contains('test-class')).toBe(true)"
          },
          {
            "title": "removeClass",
            "line": 115,
            "source": "element.classList.add('test-class')\nview.removeClass('test-class')\nexpect(element.classList.contains('test-class')).toBe(false)"
          },
          {
            "title": "hasClass",
            "line": 122,
            "source": "element.classList.add('test-class')\nexpect(view.hasClass('test-class')).toBe(true)"
          },
          {
            "title": "setSize",
            "line": 128,
            "source": "view.setSize({width: 100, height: 200})\n\nexpect(element.style.width).toBe('100px')\nexpect(element.style.height).toBe('200px')"
          },
          {
            "title": "setSize with custom unit",
            "line": 136,
            "source": "view.setSize({width: 100, height: 200, unit: '%'})\n\nexpect(element.style.width).toBe('100%')\nexpect(element.style.height).toBe('200%')"
          },
          {
            "title": "fit",
            "line": 144,
            "source": "container.style.width = '500px'\ncontainer.style.height = '600px'\ncontainer.appendChild(element)\n\nvi.spyOn(container, 'getBoundingClientRect').mockReturnValue({\n    width: 500,\n    height: 600,\n    left: 0,\n    top: 0,\n    right: 500,\n    bottom: 600,\n    x: 0,\n    y: 0\n})\n\nview.fit()\n\nexpect(element.style.width).toBe('500px')\nexpect(element.style.height).toBe('600px')"
          },
          {
            "title": "mount",
            "line": 167,
            "source": "view.mount(container)\n\nexpect(container.contains(element)).toBe(true)\nexpect(view.container).toBe(container)\nexpect(view.emit).toHaveBeenCalledWith('mount', {container})"
          },
          {
            "title": "isVisible",
            "line": 176,
            "source": "element.style.display = 'block'\nexpect(view.isVisible()).toBe(true)\n\nelement.style.display = 'none'\nexpect(view.isVisible()).toBe(false)"
          },
          {
            "title": "display getter and setter",
            "line": 185,
            "source": "view.display = 'flex'\nexpect(element.style.display).toBe('flex')\nexpect(view.display).toBe('flex')\nexpect(view.display = 'flex').toBe('flex')"
          },
          {
            "title": "hide",
            "line": 193,
            "source": "element.style.display = 'flex'\nview.hide()\n\nexpect(element.style.display).toBe('none')"
          },
          {
            "title": "show restores previous display",
            "line": 201,
            "source": "element.style.display = 'flex'\nview.hide()\nview.show()\n\nexpect(element.style.display).toBe('flex')"
          },
          {
            "title": "show without previous display",
            "line": 210,
            "source": "view.show()\nexpect(element.style.display).toBe('')"
          },
          {
            "title": "dismount removes element from container",
            "line": 216,
            "source": "view.mount(container)\nexpect(container.contains(element)).toBe(true)\n\nview.dismount()\n\nexpect(container.contains(element)).toBe(false)\nexpect(view.emit).toHaveBeenCalledWith('dismount', {container: null})"
          },
          {
            "title": "dismount when not mounted does nothing",
            "line": 227,
            "source": "view.dismount()\n\nexpect(view.emit).not.toHaveBeenCalledWith('dismount', expect.anything())"
          },
          {
            "title": "setDisplayMode normal calls exitFullscreenMode",
            "line": 234,
            "source": "vi.spyOn(view, 'exitFullscreenMode')\n\nview.setDisplayMode('normal')\n\nexpect(view.exitFullscreenMode).toHaveBeenCalled()"
          },
          {
            "title": "setDisplayMode fullscreen calls enterFullscreenMode",
            "line": 243,
            "source": "vi.spyOn(view, 'enterFullscreenMode')\n\nview.setDisplayMode('fullscreen')\n\nexpect(view.enterFullscreenMode).toHaveBeenCalled()"
          },
          {
            "title": "setDisplayMode with invalid mode does nothing",
            "line": 252,
            "source": "vi.spyOn(view, 'enterFullscreenMode')\nvi.spyOn(view, 'exitFullscreenMode')\n\nview.setDisplayMode('invalid')\n\nexpect(view.enterFullscreenMode).not.toHaveBeenCalled()\nexpect(view.exitFullscreenMode).not.toHaveBeenCalled()"
          },
          {
            "title": "enterFullscreenMode sets fullscreen styles",
            "line": 263,
            "source": "element.requestFullscreen = vi.fn()\n\nview.enterFullscreenMode()\n\nexpect(view.displayMode).toBe('fullscreen')\nexpect(element.style.position).toBe('fixed')\nexpect(element.style.top).toBe('0px')\nexpect(element.style.left).toBe('0px')\nexpect(element.style.width).toBe('100vw')\nexpect(element.style.height).toBe('100vh')\nexpect(element.style.zIndex).toBe('10000')\nexpect(document.body.classList.contains('fullscreen-mode')).toBe(true)\nexpect(element.requestFullscreen).toHaveBeenCalled()"
          },
          {
            "title": "enterFullscreenMode does nothing if already fullscreen",
            "line": 280,
            "source": "element.requestFullscreen = vi.fn()\nview.displayMode = 'fullscreen'\n\nview.enterFullscreenMode()\n\nexpect(element.requestFullscreen).not.toHaveBeenCalled()"
          },
          {
            "title": "exitFullscreenMode restores previous styles",
            "line": 290,
            "source": "element.requestFullscreen = vi.fn()\nelement.style.position = 'relative'\nelement.style.width = '200px'\nelement.style.height = '300px'\n\nview.enterFullscreenMode()\nview.exitFullscreenMode()\n\nexpect(view.displayMode).toBe('normal')\nexpect(element.style.position).toBe('relative')\nexpect(element.style.width).toBe('200px')\nexpect(element.style.height).toBe('300px')\nexpect(document.body.classList.contains('fullscreen-mode')).toBe(false)"
          },
          {
            "title": "exitFullscreenMode does nothing if already normal",
            "line": 307,
            "source": "view.displayMode = 'normal'\n\nview.exitFullscreenMode()\n\nexpect(view.displayMode).toBe('normal')"
          },
          {
            "title": "toggleFullscreen enters fullscreen from normal",
            "line": 316,
            "source": "vi.spyOn(view, 'enterFullscreenMode')\n\nview.toggleFullscreen()\n\nexpect(view.enterFullscreenMode).toHaveBeenCalled()"
          },
          {
            "title": "toggleFullscreen exits fullscreen from fullscreen",
            "line": 325,
            "source": "vi.spyOn(view, 'exitFullscreenMode')\nview.displayMode = 'fullscreen'\n\nview.toggleFullscreen()\n\nexpect(view.exitFullscreenMode).toHaveBeenCalled()"
          }
        ],
        "describes": []
      }
    ]
  },
  "/application/source_manager.doc.js": {
    "file": "/application/source_manager.test.js",
    "describes": [
      {
        "title": "SourceManager",
        "line": 7,
        "beforeEach": {
          "line": 12,
          "source": "loaders = {\n    image: vi.fn().mockResolvedValue('loaded image'),\n    audio: vi.fn().mockResolvedValue('loaded audio')\n}\n\nmanifest = {\n    getAsset: vi.fn(),\n    getAssetsByTag: vi.fn(),\n    getAllAssets: vi.fn()\n}\n\nmanager = new SourceManager({loaders, manifest})"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor",
            "line": 28,
            "source": "expect(manager).toBeInstanceOf(PerkyModule)\nexpect(manager.manifest).toBe(manifest)"
          },
          {
            "title": "loadAsset success",
            "line": 34,
            "source": "const asset = {type: 'image', id: 'logo', url: '/assets/logo.png'}\nmanifest.getAsset.mockReturnValueOnce(asset)\n\nconst result = await manager.loadAsset('logo')\n\nexpect(manifest.getAsset).toHaveBeenCalledWith('logo')\nexpect(result).toBeInstanceOf(SourceLoader)\nexpect(result.assets).toEqual([asset])"
          },
          {
            "title": "loadAsset not found",
            "line": 46,
            "source": "manifest.getAsset.mockReturnValueOnce(null)\n\nawait expect(manager.loadAsset('nonexistent')).rejects.toThrow('Asset not found: nonexistent')\nexpect(manifest.getAsset).toHaveBeenCalledWith('nonexistent')"
          },
          {
            "title": "loadTag success",
            "line": 54,
            "source": "const assets = [\n    {type: 'image', id: 'logo', url: '/assets/logo.png', tags: ['ui']},\n    {type: 'image', id: 'background', url: '/assets/bg.png', tags: ['ui']}\n]\nmanifest.getAssetsByTag.mockReturnValueOnce(assets)\n\nconst result = await manager.loadTag('ui')\n\nexpect(manifest.getAssetsByTag).toHaveBeenCalledWith('ui')\nexpect(result).toBeInstanceOf(SourceLoader)\nexpect(result.assets).toBe(assets)"
          },
          {
            "title": "loadTag empty result",
            "line": 69,
            "source": "manifest.getAssetsByTag.mockReturnValueOnce([])\n\nconst result = await manager.loadTag('nonexistent')\n\nexpect(manifest.getAssetsByTag).toHaveBeenCalledWith('nonexistent')\nexpect(result).toBeInstanceOf(SourceLoader)\nexpect(result.assets).toEqual([])"
          },
          {
            "title": "loadAll success",
            "line": 80,
            "source": "const assets = [\n    {type: 'image', id: 'logo', url: '/assets/logo.png'},\n    {type: 'audio', id: 'music', url: '/assets/music.mp3'}\n]\nmanifest.getAllAssets.mockReturnValueOnce(assets)\n\nconst result = await manager.loadAll()\n\nexpect(manifest.getAllAssets).toHaveBeenCalled()\nexpect(result).toBeInstanceOf(SourceLoader)\nexpect(result.assets).toBe(assets)"
          },
          {
            "title": "loadAll empty result",
            "line": 95,
            "source": "manifest.getAllAssets.mockReturnValueOnce([])\n\nconst result = await manager.loadAll()\n\nexpect(manifest.getAllAssets).toHaveBeenCalled()\nexpect(result).toBeInstanceOf(SourceLoader)\nexpect(result.assets).toEqual([])"
          }
        ],
        "describes": []
      }
    ]
  },
  "/game/game.doc.js": {
    "file": "/game/game.test.js",
    "describes": [
      {
        "title": "Game",
        "line": 10,
        "beforeEach": {
          "line": 15,
          "source": "mockRequestAnimationFrame = global.requestAnimationFrame\nmockPerformanceNow = global.performance?.now\n\nglobal.requestAnimationFrame = vi.fn(() => 1)\nglobal.performance = {now: vi.fn(() => 0)}\n\ngame = new Game()"
        },
        "afterEach": {
          "line": 26,
          "source": "if (mockRequestAnimationFrame) {\n    global.requestAnimationFrame = mockRequestAnimationFrame\n}\nif (mockPerformanceNow) {\n    global.performance.now = mockPerformanceNow\n}"
        },
        "tests": [
          {
            "title": "extends Application",
            "line": 36,
            "source": "expect(game).toBeInstanceOf(Application)"
          },
          {
            "title": "automatically creates GameLoop",
            "line": 41,
            "source": "expect(game.gameLoop).toBeInstanceOf(GameLoop)"
          },
          {
            "title": "GameLoop is bound to game instance",
            "line": 46,
            "source": "expect(game.gameLoop).toBeDefined()\nexpect(game.gameLoop.host).toBe(game)"
          },
          {
            "title": "calls update on active controllers when GameLoop emits update",
            "line": 52,
            "source": "class TestController extends ActionController {\n    update = vi.fn()\n}\n\ngame.registerController('test', TestController)\ngame.setActiveControllers(['test'])\n\ngame.gameLoop.emit('update', 0.016)\n\nconst controller = game.getController('test')\nexpect(controller.update).toHaveBeenCalledWith(game, 0.016)"
          },
          {
            "title": "skips controllers without update method",
            "line": 67,
            "source": "class TestController extends ActionController {\n    someOtherMethod = vi.fn()\n}\n\ngame.registerController('test', TestController)\ngame.setActiveControllers(['test'])\n\nexpect(() => {\n    game.gameLoop.emit('update', 0.016)\n}).not.toThrow()\n\nconst controller = game.getController('test')\nexpect(controller.someOtherMethod).not.toHaveBeenCalled()"
          },
          {
            "title": "only updates active controllers",
            "line": 84,
            "source": "class ActiveController extends ActionController {\n    update = vi.fn()\n}\nclass InactiveController extends ActionController {\n    update = vi.fn()\n}\n\ngame.registerController('active', ActiveController)\ngame.registerController('inactive', InactiveController)\ngame.setActiveControllers(['active'])\n\ngame.gameLoop.emit('update', 0.016)\n\nconst activeController = game.getController('active')\nconst inactiveController = game.getController('inactive')\n\nexpect(activeController.update).toHaveBeenCalledWith(game, 0.016)\nexpect(inactiveController.update).not.toHaveBeenCalled()"
          },
          {
            "title": "updates multiple active controllers in order",
            "line": 106,
            "source": "class Controller1 extends ActionController {\n    update = vi.fn()\n}\nclass Controller2 extends ActionController {\n    update = vi.fn()\n}\n\ngame.registerController('controller1', Controller1)\ngame.registerController('controller2', Controller2)\ngame.setActiveControllers(['controller1', 'controller2'])\n\ngame.gameLoop.emit('update', 0.016)\n\nconst controller1 = game.getController('controller1')\nconst controller2 = game.getController('controller2')\n\nexpect(controller1.update).toHaveBeenCalledWith(game, 0.016)\nexpect(controller2.update).toHaveBeenCalledWith(game, 0.016)"
          },
          {
            "title": "passes params to Application constructor",
            "line": 128,
            "source": "const testManifest = {\n    sources: {\n        images: []\n    }\n}\nconst customGame = new Game({\n    manifest: testManifest\n})\n\nexpect(customGame.manifest).toBeDefined()"
          },
          {
            "title": "automatically creates RenderSystem",
            "line": 142,
            "source": "expect(game.renderSystem).toBeInstanceOf(RenderSystem)"
          },
          {
            "title": "RenderSystem is bound to game instance",
            "line": 147,
            "source": "expect(game.renderSystem).toBeDefined()\nexpect(game.renderSystem.host).toBe(game)"
          },
          {
            "title": "passes renderSystem options through to RenderSystem",
            "line": 153,
            "source": "const customGame = new Game({\n    renderSystem: {\n        width: 1024,\n        height: 768\n    }\n})\n\nexpect(customGame.renderSystem.layerWidth).toBe(1024)\nexpect(customGame.renderSystem.layerHeight).toBe(768)"
          },
          {
            "title": "delegates createLayer method to host",
            "line": 166,
            "source": "const container = document.createElement('div')\ngame.mount(container)\n\nconst layer = game.createLayer('test', 'canvas')\n\nexpect(layer).toBeDefined()\nexpect(game.renderSystem.getLayer('test')).toBe(layer)"
          },
          {
            "title": "delegates getLayer method to host",
            "line": 177,
            "source": "const container = document.createElement('div')\ngame.mount(container)\n\ngame.createLayer('game', 'canvas')\nconst layer = game.getLayer('game')\n\nexpect(layer).toBeDefined()\nexpect(layer.$id).toBe('game')"
          },
          {
            "title": "delegates renderAll method to host",
            "line": 189,
            "source": "expect(typeof game.renderAll).toBe('function')\n\nconst container = document.createElement('div')\ngame.mount(container)\ngame.createLayer('test', 'canvas')\n\nexpect(() => game.renderAll()).not.toThrow()"
          }
        ],
        "describes": []
      }
    ]
  },
  "/game/entity.doc.js": {
    "file": "/game/entity.test.js",
    "describes": [
      {
        "title": "Entity",
        "line": 6,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "has static $category \"entity\"",
            "line": 8,
            "source": "expect(Entity.$category).toBe('entity')"
          },
          {
            "title": "can be instantiated with tags",
            "line": 13,
            "source": "const entity = new Entity({$tags: ['enemy', 'collidable']})\n\nexpect(entity.$category).toBe('entity')\nexpect(entity.$tags).toEqual(['enemy', 'collidable'])"
          },
          {
            "title": "has default position at origin",
            "line": 21,
            "source": "const entity = new Entity()\n\nexpect(entity.position).toBeInstanceOf(Vec2)\nexpect(entity.x).toBe(0)\nexpect(entity.y).toBe(0)"
          },
          {
            "title": "accepts initial position",
            "line": 30,
            "source": "const entity = new Entity({x: 5, y: 10})\n\nexpect(entity.x).toBe(5)\nexpect(entity.y).toBe(10)"
          },
          {
            "title": "has default velocity at zero",
            "line": 38,
            "source": "const entity = new Entity()\n\nexpect(entity.velocity).toBeInstanceOf(Vec2)\nexpect(entity.velocity.x).toBe(0)\nexpect(entity.velocity.y).toBe(0)"
          },
          {
            "title": "x and y setters update position",
            "line": 47,
            "source": "const entity = new Entity()\n\nentity.x = 42\nentity.y = 84\n\nexpect(entity.position.x).toBe(42)\nexpect(entity.position.y).toBe(84)"
          },
          {
            "title": "has update method",
            "line": 58,
            "source": "const entity = new Entity()\n\nexpect(typeof entity.update).toBe('function')"
          }
        ],
        "describes": []
      }
    ]
  },
  "/game/entity_view.doc.js": {
    "file": "/game/entity_view.test.js",
    "describes": [
      {
        "title": "EntityView",
        "line": 22,
        "beforeEach": {
          "line": 28,
          "source": "entity = new MockEntity(10, 20)\ncontext = new MockContext()\nview = new EntityView(entity, context)"
        },
        "afterEach": null,
        "tests": [],
        "describes": [
          {
            "title": "constructor",
            "line": 35,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "stores entity reference",
                "line": 37,
                "source": "expect(view.entity).toBe(entity)"
              },
              {
                "title": "stores context reference",
                "line": 42,
                "source": "expect(view.context).toBe(context)"
              },
              {
                "title": "initializes root as null",
                "line": 47,
                "source": "expect(view.root).toBeNull()"
              }
            ],
            "describes": []
          },
          {
            "title": "sync",
            "line": 54,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "does nothing when root is null",
                "line": 56,
                "source": "expect(() => view.sync()).not.toThrow()"
              },
              {
                "title": "syncs root position from entity",
                "line": 61,
                "source": "view.root = {x: 0, y: 0}\n\nentity.x = 100\nentity.y = 200\nview.sync()\n\nexpect(view.root.x).toBe(100)\nexpect(view.root.y).toBe(200)"
              },
              {
                "title": "updates root when entity moves",
                "line": 73,
                "source": "view.root = {x: 0, y: 0}\n\nview.sync()\nexpect(view.root.x).toBe(10)\nexpect(view.root.y).toBe(20)\n\nentity.x = 50\nentity.y = 75\nview.sync()\n\nexpect(view.root.x).toBe(50)\nexpect(view.root.y).toBe(75)"
              }
            ],
            "describes": []
          },
          {
            "title": "dispose",
            "line": 91,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "removes root from context group",
                "line": 93,
                "source": "const mockRoot = new Group2D({name: 'mock-root'})\ncontext.group.addChild(mockRoot)\nview.root = mockRoot\n\nexpect(context.group.children).toContain(mockRoot)\n\nview.dispose()\n\nexpect(context.group.children).not.toContain(mockRoot)"
              },
              {
                "title": "sets root to null",
                "line": 106,
                "source": "view.root = {x: 0, y: 0}\nview.dispose()\n\nexpect(view.root).toBeNull()"
              },
              {
                "title": "sets entity to null",
                "line": 114,
                "source": "view.dispose()\nexpect(view.entity).toBeNull()"
              },
              {
                "title": "sets context to null",
                "line": 120,
                "source": "view.dispose()\nexpect(view.context).toBeNull()"
              },
              {
                "title": "handles null root gracefully",
                "line": 126,
                "source": "view.root = null\nexpect(() => view.dispose()).not.toThrow()"
              },
              {
                "title": "handles null context.group gracefully",
                "line": 132,
                "source": "view.root = {x: 0, y: 0}\ncontext.group = null\n\nexpect(() => view.dispose()).not.toThrow()"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/game/game_loop.doc.js": {
    "file": "/game/game_loop.test.js",
    "describes": [
      {
        "title": "GameLoop",
        "line": 6,
        "beforeEach": {
          "line": 12,
          "source": "originalRequestAnimationFrame = global.requestAnimationFrame\noriginalPerformanceNow = global.performance.now\nanimationCallbacks = []\n\nlet time = 0\nglobal.performance.now = vi.fn(() => {\n    time += 16.7 // ~60fps\n    return time\n})\n\nglobal.requestAnimationFrame = vi.fn(callback => {\n    animationCallbacks.push(callback)\n    return 1 // Return a dummy ID\n})\n\nvi.spyOn(PerkyModule.prototype, 'emit')\n\ngameLoop = new GameLoop()"
        },
        "afterEach": {
          "line": 34,
          "source": "vi.restoreAllMocks()\nglobal.requestAnimationFrame = originalRequestAnimationFrame\nglobal.performance.now = originalPerformanceNow\nanimationCallbacks = []"
        },
        "tests": [
          {
            "title": "constructor",
            "line": 42,
            "source": "expect(gameLoop).toBeInstanceOf(PerkyModule)\nexpect(gameLoop.frameInterval).toBe(1000 / 60)\nexpect(gameLoop.paused).toBe(false)\nexpect(gameLoop.maxFrameSkip).toBe(5)"
          },
          {
            "title": "constructor with custom params",
            "line": 50,
            "source": "const customLoop = new GameLoop({\n    fps: 30,\n    maxFrameSkip: 3\n})\n\nexpect(customLoop.frameInterval).toBe(1000 / 30)\nexpect(customLoop.maxFrameSkip).toBe(3)"
          },
          {
            "title": "running getter",
            "line": 61,
            "source": "expect(gameLoop.running).toBe(false)\n\ngameLoop.start()\nexpect(gameLoop.running).toBe(true)\n\ngameLoop.paused = true\nexpect(gameLoop.running).toBe(false)"
          },
          {
            "title": "start",
            "line": 72,
            "source": "gameLoop.start()\n\nexpect(gameLoop.started).toBe(true)\nexpect(gameLoop.lastTime).toBeDefined()\nexpect(gameLoop.accumulator).toBe(0)\nexpect(gameLoop.frameCount).toBe(0)\nexpect(global.requestAnimationFrame).toHaveBeenCalled()"
          },
          {
            "title": "start with already started",
            "line": 83,
            "source": "gameLoop.start()\n\nvi.clearAllMocks()\nconst result = gameLoop.start()\n\nexpect(result).toBe(false)\nexpect(requestAnimationFrame).not.toHaveBeenCalled()"
          },
          {
            "title": "pause",
            "line": 94,
            "source": "gameLoop.start()\ngameLoop.paused = false\n\nconst result = gameLoop.pause('param')\n\nexpect(result).toBe(true)\nexpect(gameLoop.paused).toBe(true)\nexpect(gameLoop.emit).toHaveBeenCalledWith('pause', 'param')"
          },
          {
            "title": "pause when not running",
            "line": 106,
            "source": "vi.clearAllMocks()\n\nconst result = gameLoop.pause()\n\nexpect(result).toBe(false)\nexpect(gameLoop.emit).not.toHaveBeenCalled()"
          },
          {
            "title": "resume",
            "line": 116,
            "source": "gameLoop.start()\ngameLoop.paused = true\n\nconst result = gameLoop.resume('param')\n\nexpect(result).toBe(true)\nexpect(gameLoop.paused).toBe(false)\nexpect(gameLoop.emit).toHaveBeenCalledWith('resume', 'param')\nexpect(requestAnimationFrame).toHaveBeenCalled()"
          },
          {
            "title": "resume when not paused",
            "line": 129,
            "source": "gameLoop.start()\ngameLoop.paused = false\n\nvi.clearAllMocks()\n\nconst result = gameLoop.resume()\n\nexpect(result).toBe(false)\nexpect(gameLoop.emit).not.toHaveBeenCalled()"
          },
          {
            "title": "setFps and getFps",
            "line": 142,
            "source": "gameLoop.setFps(30)\n\nexpect(gameLoop.frameInterval).toBe(1000 / 30)\nexpect(gameLoop.getFps()).toBe(30)"
          },
          {
            "title": "getCurrentFps",
            "line": 150,
            "source": "expect(gameLoop.getCurrentFps()).toBe(0)\n\ngameLoop.currentFps = 59\nexpect(gameLoop.getCurrentFps()).toBe(59)"
          },
          {
            "title": "update function emits events",
            "line": 158,
            "source": "const testLoop = new GameLoop()\nconst update = vi.fn()\nconst render = vi.fn()\n\ntestLoop.on('update', update)\ntestLoop.on('render', render)\n\ntestLoop.start()\nexpect(animationCallbacks.length).toBeGreaterThan(0)\n\ntestLoop.lastTime = performance.now() - 50 // 50ms ago\n\nconst updateFn = animationCallbacks[0]\nupdateFn(performance.now())\n\nexpect(update).toHaveBeenCalled()\n\nexpect(render).toHaveBeenCalled()"
          },
          {
            "title": "update function with paused loop",
            "line": 179,
            "source": "const testLoop = new GameLoop()\nconst update = vi.fn()\nconst render = vi.fn()\n\ntestLoop.on('update', update)\ntestLoop.on('render', render)\n\ntestLoop.start()\nexpect(animationCallbacks.length).toBeGreaterThan(0)\n\ntestLoop.paused = true\n\nconst updateFn = animationCallbacks[0]\nconst result = updateFn(performance.now())\n\nexpect(result).toBe(false)\nexpect(update).not.toHaveBeenCalled()\nexpect(render).not.toHaveBeenCalled()"
          },
          {
            "title": "getScreenFps",
            "line": 201,
            "source": "expect(gameLoop.getScreenFps()).toBe(0)\n\ngameLoop.screenFps = 120\nexpect(gameLoop.getScreenFps()).toBe(120)"
          },
          {
            "title": "setFpsLimited",
            "line": 209,
            "source": "expect(gameLoop.fpsLimited).toBe(false)\n\ngameLoop.setFpsLimited(true)\n\nexpect(gameLoop.fpsLimited).toBe(true)\nexpect(gameLoop.emit).toHaveBeenCalledWith('changed:fpsLimited', true)"
          },
          {
            "title": "constructor with fpsLimited param",
            "line": 219,
            "source": "const limitedLoop = new GameLoop({fpsLimited: true})\n\nexpect(limitedLoop.fpsLimited).toBe(true)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/game/world.doc.js": {
    "file": "/game/world.test.js",
    "describes": [
      {
        "title": "World",
        "line": 6,
        "beforeEach": {
          "line": 10,
          "source": "world = new World()"
        },
        "afterEach": null,
        "tests": [],
        "describes": [
          {
            "title": "static properties",
            "line": 15,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "has correct $category",
                "line": 17,
                "source": "expect(World.$category).toBe('world')"
              },
              {
                "title": "extends PerkyModule",
                "line": 22,
                "source": "expect(world.constructor.name).toBe('World')"
              }
            ],
            "describes": []
          },
          {
            "title": "entities",
            "line": 29,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns empty array when no entities",
                "line": 31,
                "source": "expect(world.entities).toEqual([])"
              },
              {
                "title": "returns entities created in world",
                "line": 36,
                "source": "const entity1 = world.create(Entity, {$id: 'entity-1'})\nconst entity2 = world.create(Entity, {$id: 'entity-2'})\n\nconst entities = world.entities\n\nexpect(entities).toContain(entity1)\nexpect(entities).toContain(entity2)\nexpect(entities.length).toBe(2)"
              },
              {
                "title": "does not return non-entity children",
                "line": 48,
                "source": "world.create(Entity, {$id: 'entity-1'})\n\n// Create a non-entity child\nclass NonEntity extends Entity {\n    static $category = 'other'\n}\nworld.create(NonEntity, {$id: 'non-entity'})\n\nconst entities = world.entities\n\nexpect(entities.length).toBe(1)\nexpect(entities[0].$id).toBe('entity-1')"
              }
            ],
            "describes": []
          },
          {
            "title": "update",
            "line": 66,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "does not call preUpdate when not started",
                "line": 68,
                "source": "let called = false\nworld.preUpdate = () => {\n    called = true\n}\n\nworld.update(0.016, {})\n\nexpect(called).toBe(false)"
              },
              {
                "title": "calls preUpdate when started",
                "line": 80,
                "source": "let called = false\nworld.preUpdate = () => {\n    called = true\n}\n\nworld.start()\nworld.update(0.016, {})\n\nexpect(called).toBe(true)"
              },
              {
                "title": "calls postUpdate when started",
                "line": 93,
                "source": "let called = false\nworld.postUpdate = () => {\n    called = true\n}\n\nworld.start()\nworld.update(0.016, {})\n\nexpect(called).toBe(true)"
              },
              {
                "title": "passes deltaTime and context to preUpdate",
                "line": 106,
                "source": "let receivedDeltaTime\nlet receivedContext\nconst context = {foo: 'bar'}\nworld.preUpdate = (dt, ctx) => {\n    receivedDeltaTime = dt\n    receivedContext = ctx\n}\n\nworld.start()\nworld.update(0.016, context)\n\nexpect(receivedDeltaTime).toBe(0.016)\nexpect(receivedContext).toBe(context)"
              },
              {
                "title": "passes deltaTime and context to postUpdate",
                "line": 123,
                "source": "let receivedDeltaTime\nlet receivedContext\nconst context = {foo: 'bar'}\nworld.postUpdate = (dt, ctx) => {\n    receivedDeltaTime = dt\n    receivedContext = ctx\n}\n\nworld.start()\nworld.update(0.016, context)\n\nexpect(receivedDeltaTime).toBe(0.016)\nexpect(receivedContext).toBe(context)"
              },
              {
                "title": "calls update on started entities",
                "line": 140,
                "source": "let updateCalled = false\nclass TestEntity extends Entity {\n    update () {  \n        updateCalled = true\n    }\n}\n\nworld.start()\nconst entity = world.create(TestEntity, {$id: 'test'})\nentity.start()\n\nworld.update(0.016, {})\n\nexpect(updateCalled).toBe(true)"
              },
              {
                "title": "does not call update on non-started entities",
                "line": 158,
                "source": "let updateCalled = false\nclass TestEntity extends Entity {\n    update () {  \n        updateCalled = true\n    }\n}\n\nworld.start()\nworld.create(TestEntity, {$id: 'test', $eagerStart: false})\n\nworld.update(0.016, {})\n\nexpect(updateCalled).toBe(false)"
              },
              {
                "title": "passes deltaTime to entity update",
                "line": 175,
                "source": "let receivedDeltaTime\nclass TestEntity extends Entity {\n    update (deltaTime) {  \n        receivedDeltaTime = deltaTime\n    }\n}\n\nworld.start()\nconst entity = world.create(TestEntity, {$id: 'test'})\nentity.start()\n\nworld.update(0.033, {})\n\nexpect(receivedDeltaTime).toBe(0.033)"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/game/world_view.doc.js": {
    "file": "/game/world_view.test.js",
    "describes": [
      {
        "title": "WorldView",
        "line": 73,
        "beforeEach": {
          "line": 79,
          "source": "mockWorld = new MockWorld()\nmockGame = {getSource: vi.fn()}\n\nworldView = new WorldView({\n    world: mockWorld,\n    game: mockGame\n})"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "clearRegistry clears all registrations",
            "line": 183,
            "source": "worldView.register(MockEntity, MockEntityView)\nworldView.register(AnotherMockEntity, MockEntityView)\n\nconst result = worldView.clearRegistry()\n\nexpect(result).toBe(worldView)"
          },
          {
            "title": "onStop disposes all views",
            "line": 240,
            "source": "worldView.register(MockEntity, MockEntityView)\nworldView.onStart()\n\nconst entity = new MockEntity({$id: 'stop-test'})\nmockWorld.addEntity(entity)\n\nconst views = worldView.getViews('stop-test')\nexpect(views.length).toBe(1)\n\nworldView.onStop()\n\n// After stop, views should be cleared\nexpect(worldView.getViews('stop-test').length).toBe(0)"
          },
          {
            "title": "sync calls sync on all views",
            "line": 257,
            "source": "worldView.register(MockEntity, MockEntityView)\nworldView.onStart()\n\nconst entity1 = new MockEntity({$id: 'sync-1'})\nconst entity2 = new MockEntity({$id: 'sync-2'})\nmockWorld.addEntity(entity1)\nmockWorld.addEntity(entity2)\n\nworldView.sync()\n\nconst views1 = worldView.getViews('sync-1')\nconst views2 = worldView.getViews('sync-2')\n\nexpect(views1[0].syncCalled).toBe(true)\nexpect(views2[0].syncCalled).toBe(true)"
          }
        ],
        "describes": [
          {
            "title": "constructor",
            "line": 90,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "initializes with world and game references",
                "line": 92,
                "source": "expect(worldView.world).toBe(mockWorld)\nexpect(worldView.game).toBe(mockGame)"
              },
              {
                "title": "creates a rootGroup",
                "line": 98,
                "source": "expect(worldView.rootGroup).toBeInstanceOf(Group2D)"
              },
              {
                "title": "has correct $category",
                "line": 103,
                "source": "expect(WorldView.$category).toBe('worldView')"
              }
            ],
            "describes": []
          },
          {
            "title": "register",
            "line": 110,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "registers a view by class",
                "line": 112,
                "source": "worldView.register(MockEntity, MockEntityView)\n\nconst entity = new MockEntity({$id: 'test-1'})\nmockWorld.addEntity(entity)\nworldView.onStart()\n\nexpect(worldView.getViews('test-1').length).toBe(1)"
              },
              {
                "title": "registers a view by matcher function",
                "line": 123,
                "source": "const matcher = (entity) => entity.hasTag('enemy')\nworldView.register(matcher, MockEntityView)\n\nconst entity = new MockEntity({$id: 'test-2', entityTags: ['enemy']})\nmockWorld.addEntity(entity)\nworldView.onStart()\n\nexpect(worldView.getViews('test-2').length).toBe(1)"
              },
              {
                "title": "registers with config",
                "line": 135,
                "source": "const config = {color: 'red', size: 10}\nworldView.register(MockEntity, MockEntityView, config)\n\nconst entity = new MockEntity({$id: 'test-3'})\nmockWorld.addEntity(entity)\nworldView.onStart()\n\nconst views = worldView.getViews('test-3')\nexpect(views[0].context.config).toEqual(config)"
              },
              {
                "title": "returns this for chaining",
                "line": 148,
                "source": "const result = worldView.register(MockEntity, MockEntityView)\nexpect(result).toBe(worldView)"
              }
            ],
            "describes": []
          },
          {
            "title": "unregister",
            "line": 156,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "unregisters a class registration",
                "line": 158,
                "source": "worldView.register(MockEntity, MockEntityView)\nconst result = worldView.unregister(MockEntity)\n\nexpect(result).toBe(true)"
              },
              {
                "title": "unregisters a matcher registration",
                "line": 166,
                "source": "const matcher = (entity) => entity.hasTag('test')\nworldView.register(matcher, MockEntityView)\nconst result = worldView.unregister(matcher)\n\nexpect(result).toBe(true)"
              },
              {
                "title": "returns false for non-existent registration",
                "line": 175,
                "source": "const result = worldView.unregister(MockEntity)\nexpect(result).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "onStart",
            "line": 193,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "listens to world entity:set events",
                "line": 195,
                "source": "worldView.register(MockEntity, MockEntityView)\nworldView.onStart()\n\nconst entity = new MockEntity({$id: 'dynamic-1'})\nmockWorld.addEntity(entity)\n\nexpect(worldView.getViews('dynamic-1').length).toBe(1)"
              },
              {
                "title": "listens to world entity:delete events",
                "line": 206,
                "source": "worldView.register(MockEntity, MockEntityView)\nworldView.onStart()\n\nconst entity = new MockEntity({$id: 'to-delete'})\nmockWorld.addEntity(entity)\n\nexpect(worldView.getViews('to-delete').length).toBe(1)\n\nmockWorld.removeEntity('to-delete')\n\nexpect(worldView.getViews('to-delete').length).toBe(0)"
              },
              {
                "title": "processes existing entities on start",
                "line": 221,
                "source": "const entity = new MockEntity({$id: 'existing-1'})\nmockWorld.addEntity(entity)\n\nworldView.register(MockEntity, MockEntityView)\nworldView.onStart()\n\nexpect(worldView.getViews('existing-1').length).toBe(1)"
              },
              {
                "title": "does nothing if no world",
                "line": 232,
                "source": "const noWorldView = new WorldView({game: mockGame})\nexpect(() => noWorldView.onStart()).not.toThrow()"
              }
            ],
            "describes": []
          },
          {
            "title": "getViews",
            "line": 276,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns empty array for unknown entity",
                "line": 278,
                "source": "expect(worldView.getViews('unknown')).toEqual([])"
              },
              {
                "title": "returns views for known entity",
                "line": 283,
                "source": "worldView.register(MockEntity, MockEntityView)\nworldView.onStart()\n\nconst entity = new MockEntity({$id: 'get-test'})\nmockWorld.addEntity(entity)\n\nconst views = worldView.getViews('get-test')\nexpect(views.length).toBe(1)\nexpect(views[0]).toBeInstanceOf(MockEntityView)"
              }
            ],
            "describes": []
          },
          {
            "title": "events",
            "line": 298,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "emits view:added when entity is added",
                "line": 300,
                "source": "const addedHandler = vi.fn()\nworldView.on('view:added', addedHandler)\n\nworldView.register(MockEntity, MockEntityView)\nworldView.onStart()\n\nconst entity = new MockEntity({$id: 'event-add'})\nmockWorld.addEntity(entity)\n\nexpect(addedHandler).toHaveBeenCalledWith('event-add', expect.any(Array))"
              },
              {
                "title": "emits view:removed when entity is deleted",
                "line": 314,
                "source": "const removedHandler = vi.fn()\nworldView.on('view:removed', removedHandler)\n\nworldView.register(MockEntity, MockEntityView)\nworldView.onStart()\n\nconst entity = new MockEntity({$id: 'event-remove'})\nmockWorld.addEntity(entity)\nmockWorld.removeEntity('event-remove')\n\nexpect(removedHandler).toHaveBeenCalledWith('event-remove', expect.any(Array))"
              }
            ],
            "describes": []
          },
          {
            "title": "view root integration",
            "line": 331,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "adds view root to rootGroup",
                "line": 333,
                "source": "worldView.register(MockEntity, MockEntityView)\nworldView.onStart()\n\nconst entity = new MockEntity({$id: 'root-test'})\nmockWorld.addEntity(entity)\n\nexpect(worldView.rootGroup.children.length).toBe(1)"
              },
              {
                "title": "sets $entity on view root",
                "line": 344,
                "source": "worldView.register(MockEntity, MockEntityView)\nworldView.onStart()\n\nconst entity = new MockEntity({$id: 'meta-test'})\nmockWorld.addEntity(entity)\n\nconst child = worldView.rootGroup.children[0]\nexpect(child.$entity).toBe(entity)"
              },
              {
                "title": "sets $view and $viewName on view root",
                "line": 356,
                "source": "worldView.register(MockEntity, MockEntityView)\nworldView.onStart()\n\nconst entity = new MockEntity({$id: 'view-meta'})\nmockWorld.addEntity(entity)\n\nconst child = worldView.rootGroup.children[0]\nexpect(child.$view).toBeInstanceOf(MockEntityView)\nexpect(child.$viewName).toBe('MockEntityView')"
              }
            ],
            "describes": []
          },
          {
            "title": "AutoView (Object2D registration)",
            "line": 371,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "registers an Object2D class directly",
                "line": 373,
                "source": "worldView.register(MockEntity, Circle, {radius: 0.5, color: '#ff0000'})\nworldView.onStart()\n\nconst entity = new MockEntity({$id: 'circle-1', x: 10, y: 20})\nmockWorld.addEntity(entity)\n\nconst views = worldView.getViews('circle-1')\nexpect(views.length).toBe(1)\nexpect(views[0].root).toBeInstanceOf(Circle)\nexpect(views[0].root.radius).toBe(0.5)\nexpect(views[0].root.color).toBe('#ff0000')"
              },
              {
                "title": "auto-syncs x and y from entity",
                "line": 388,
                "source": "worldView.register(MockEntity, Circle, {radius: 0.5})\nworldView.onStart()\n\nconst entity = new MockEntity({$id: 'sync-xy', x: 5, y: 10})\nmockWorld.addEntity(entity)\n\nconst view = worldView.getViews('sync-xy')[0]\nexpect(view.root.x).toBe(5)\nexpect(view.root.y).toBe(10)\n\nentity.x = 15\nentity.y = 25\nworldView.sync()\n\nexpect(view.root.x).toBe(15)\nexpect(view.root.y).toBe(25)"
              },
              {
                "title": "supports custom sync bindings with string property name",
                "line": 408,
                "source": "worldView.register(MockEntity, Circle, {\n    radius: 0.5,\n    sync: {\n        opacity: 'health'\n    }\n})\nworldView.onStart()\n\nconst entity = new MockEntity({$id: 'sync-string', x: 0, y: 0})\nentity.health = 0.75\nmockWorld.addEntity(entity)\n\nworldView.sync()\n\nconst view = worldView.getViews('sync-string')[0]\nexpect(view.root.opacity).toBe(0.75)"
              },
              {
                "title": "supports custom sync bindings with function",
                "line": 428,
                "source": "worldView.register(MockEntity, Circle, {\n    radius: 0.5,\n    sync: {\n        scaleX: (entity) => entity.health / 100\n    }\n})\nworldView.onStart()\n\nconst entity = new MockEntity({$id: 'sync-fn', x: 0, y: 0})\nentity.health = 50\nmockWorld.addEntity(entity)\n\nworldView.sync()\n\nconst view = worldView.getViews('sync-fn')[0]\nexpect(view.root.scaleX).toBe(0.5)"
              },
              {
                "title": "passes deltaTime to sync function",
                "line": 448,
                "source": "const syncFn = vi.fn((entity, dt) => dt * 2)\nworldView.register(MockEntity, Circle, {\n    radius: 0.5,\n    sync: {\n        opacity: syncFn\n    }\n})\nworldView.onStart()\n\nconst entity = new MockEntity({$id: 'sync-dt', x: 0, y: 0})\nmockWorld.addEntity(entity)\n\nworldView.sync(0.016)\n\nexpect(syncFn).toHaveBeenCalledWith(entity, 0.016)"
              },
              {
                "title": "sets $viewName to Object2D class name",
                "line": 467,
                "source": "worldView.register(MockEntity, Circle, {radius: 0.5})\nworldView.onStart()\n\nconst entity = new MockEntity({$id: 'viewname-test'})\nmockWorld.addEntity(entity)\n\nconst child = worldView.rootGroup.children[0]\nexpect(child.$viewName).toBe('Circle')"
              },
              {
                "title": "works with Sprite",
                "line": 479,
                "source": "const mockImage = {width: 100, height: 100}\nworldView.register(MockEntity, Sprite, {image: mockImage, width: 1, height: 1})\nworldView.onStart()\n\nconst entity = new MockEntity({$id: 'image-test', x: 0, y: 0})\nmockWorld.addEntity(entity)\n\nconst view = worldView.getViews('image-test')[0]\nexpect(view.root).toBeInstanceOf(Sprite)\nexpect(view.root.image).toBe(mockImage)"
              },
              {
                "title": "disposes correctly",
                "line": 493,
                "source": "worldView.register(MockEntity, Circle, {radius: 0.5})\nworldView.onStart()\n\nconst entity = new MockEntity({$id: 'dispose-test'})\nmockWorld.addEntity(entity)\n\nexpect(worldView.rootGroup.children.length).toBe(1)\n\nmockWorld.removeEntity('dispose-test')\n\nexpect(worldView.getViews('dispose-test').length).toBe(0)"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/math/random.doc.js": {
    "file": "/math/random.test.js",
    "describes": [
      {
        "title": "Random",
        "line": 4,
        "beforeEach": {
          "line": 7,
          "source": "random = new Random('testSeed')"
        },
        "afterEach": null,
        "tests": [],
        "describes": [
          {
            "title": "constructor",
            "line": 12,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates instance with default seed",
                "line": 14,
                "source": "const randomWithDefaultSeed = new Random()\nexpect(randomWithDefaultSeed).toBeInstanceOf(Random)\nexpect(randomWithDefaultSeed.getSeed()).toBeDefined()"
              },
              {
                "title": "creates instance with custom seed",
                "line": 21,
                "source": "const randomWithCustomSeed = new Random('mySeed')\nexpect(randomWithCustomSeed).toBeInstanceOf(Random)\nexpect(randomWithCustomSeed.getSeed()).toEqual('mySeed')"
              }
            ],
            "describes": []
          },
          {
            "title": "determinism",
            "line": 30,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "same seed produces same sequence",
                "line": 32,
                "source": "const random1 = new Random('same-seed')\nconst random2 = new Random('same-seed')\n\nfor (let i = 0; i < 10; i++) {\n    expect(random1.between(0, 1)).toBe(random2.between(0, 1))\n}"
              },
              {
                "title": "different seeds produce different sequences",
                "line": 42,
                "source": "const random1 = new Random('seed-a')\nconst random2 = new Random('seed-b')\n\nconst sequence1 = Array.from({length: 5}, () => random1.between(0, 1))\nconst sequence2 = Array.from({length: 5}, () => random2.between(0, 1))\n\nexpect(sequence1).not.toEqual(sequence2)"
              },
              {
                "title": "returns numbers between 0 and 1",
                "line": 53,
                "source": "const testRandom = new Random('test')\nfor (let i = 0; i < 100; i++) {\n    const value = testRandom.between(0, 1)\n    expect(value).toBeGreaterThanOrEqual(0)\n    expect(value).toBeLessThan(1)\n}"
              }
            ],
            "describes": []
          },
          {
            "title": "setSeed & getSeed",
            "line": 65,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "gets and sets seed",
                "line": 67,
                "source": "expect(random.getSeed()).toEqual('testSeed')\n\nrandom.setSeed('newSeed')\nexpect(random.getSeed()).toEqual('newSeed')"
              },
              {
                "title": "setSeed resets the generator",
                "line": 75,
                "source": "const firstSequence = [\n    random.between(0, 1),\n    random.between(0, 1),\n    random.between(0, 1)\n]\n\nrandom.setSeed('testSeed')\n\nconst resetSequence = [\n    random.between(0, 1),\n    random.between(0, 1),\n    random.between(0, 1)\n]\n\nexpect(resetSequence).toEqual(firstSequence)"
              },
              {
                "title": "setSeed returns this for chaining",
                "line": 94,
                "source": "expect(random.setSeed('newSeed')).toBe(random)"
              }
            ],
            "describes": []
          },
          {
            "title": "setState & getState",
            "line": 101,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "getState returns current state with all properties",
                "line": 103,
                "source": "const state = random.getState()\n\nexpect(state).toHaveProperty('c')\nexpect(state).toHaveProperty('s0')\nexpect(state).toHaveProperty('s1')\nexpect(state).toHaveProperty('s2')"
              },
              {
                "title": "state changes after generating numbers",
                "line": 113,
                "source": "const initialState = random.getState()\n\nrandom.between(0, 10)\n\nconst newState = random.getState()\nexpect(newState).not.toEqual(initialState)"
              },
              {
                "title": "setState restores state",
                "line": 123,
                "source": "random.between(0, 1)\nrandom.between(0, 1)\nrandom.between(0, 1)\n\nconst savedState = random.getState()\n\nconst afterSave = [\n    random.between(0, 1),\n    random.between(0, 1),\n    random.between(0, 1)\n]\n\nrandom.setState(savedState)\n\nconst afterRestore = [\n    random.between(0, 1),\n    random.between(0, 1),\n    random.between(0, 1)\n]\n\nexpect(afterRestore).toEqual(afterSave)"
              },
              {
                "title": "setState returns this for chaining",
                "line": 148,
                "source": "const state = random.getState()\nexpect(random.setState(state)).toBe(random)"
              },
              {
                "title": "sequence reproduction with state",
                "line": 154,
                "source": "const initialState = random.getState()\n\nconst firstSequence = [\n    random.between(0, 100),\n    random.between(10, 50),\n    random.between(-10, 10)\n]\n\nrandom.setState(initialState)\n\nconst secondSequence = [\n    random.between(0, 100),\n    random.between(10, 50),\n    random.between(-10, 10)\n]\n\nexpect(secondSequence).toEqual(firstSequence)"
              }
            ],
            "describes": []
          },
          {
            "title": "fork",
            "line": 177,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates a new Random instance",
                "line": 179,
                "source": "const forkedRandom = random.fork()\nexpect(forkedRandom).toBeInstanceOf(Random)\nexpect(forkedRandom).not.toBe(random)"
              },
              {
                "title": "forked instance has same seed and state",
                "line": 186,
                "source": "random.between(0, 10)\n\nconst forkedRandom = random.fork()\nexpect(forkedRandom.getSeed()).toEqual(random.getSeed())\nexpect(forkedRandom.getState()).toEqual(random.getState())"
              },
              {
                "title": "forked instance produces same sequence",
                "line": 195,
                "source": "random.between(0, 10)\n\nconst forkedRandom = random.fork()\n\nconst originalSequence = [\n    random.between(0, 100),\n    random.between(0, 100),\n    random.between(0, 100)\n]\n\nrandom.setState(forkedRandom.getState())\n\nconst forkedSequence = [\n    forkedRandom.between(0, 100),\n    forkedRandom.between(0, 100),\n    forkedRandom.between(0, 100)\n]\n\nexpect(forkedSequence).toEqual(originalSequence)"
              },
              {
                "title": "forked instance diverges independently",
                "line": 218,
                "source": "random.between(0, 10)\n\nconst forkedRandom = random.fork()\n\nforkedRandom.between(0, 10)\nexpect(forkedRandom.getState()).not.toEqual(random.getState())"
              }
            ],
            "describes": []
          },
          {
            "title": "between",
            "line": 230,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns value in range",
                "line": 232,
                "source": "const value = random.between(0, 10)\nexpect(value).toBeGreaterThanOrEqual(0)\nexpect(value).toBeLessThan(10)"
              },
              {
                "title": "works with negative ranges",
                "line": 239,
                "source": "const negativeValue = random.between(-10, 0)\nexpect(negativeValue).toBeGreaterThanOrEqual(-10)\nexpect(negativeValue).toBeLessThan(0)"
              },
              {
                "title": "works with decimal ranges",
                "line": 246,
                "source": "const value = random.between(0.5, 1.5)\nexpect(value).toBeGreaterThanOrEqual(0.5)\nexpect(value).toBeLessThan(1.5)"
              }
            ],
            "describes": []
          },
          {
            "title": "intBetween",
            "line": 255,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns integer in range",
                "line": 257,
                "source": "const value = random.intBetween(0, 10)\nexpect(value).toBeGreaterThanOrEqual(0)\nexpect(value).toBeLessThan(10)\nexpect(Number.isInteger(value)).toBe(true)"
              },
              {
                "title": "returns integers for many iterations",
                "line": 265,
                "source": "for (let i = 0; i < 100; i++) {\n    const value = random.intBetween(0, 100)\n    expect(Number.isInteger(value)).toBe(true)\n}"
              }
            ],
            "describes": []
          },
          {
            "title": "pick",
            "line": 275,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns element from array",
                "line": 277,
                "source": "const array = [1, 2, 3, 4, 5]\nconst value = random.pick(array)\nexpect(array).toContain(value)"
              },
              {
                "title": "can pick all elements over many iterations",
                "line": 284,
                "source": "const array = ['a', 'b', 'c']\nconst picked = new Set()\n\nfor (let i = 0; i < 100; i++) {\n    picked.add(random.pick(array))\n}\n\nexpect(picked.size).toBe(3)"
              }
            ],
            "describes": []
          },
          {
            "title": "oneChanceIn",
            "line": 298,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns boolean",
                "line": 300,
                "source": "const result = random.oneChanceIn(2)\nexpect(typeof result).toBe('boolean')"
              },
              {
                "title": "higher chances produce fewer true results",
                "line": 306,
                "source": "const testRandom = new Random('oneChanceTest')\nlet trueCount2 = 0\nlet trueCount10 = 0\n\nfor (let i = 0; i < 1000; i++) {\n    if (testRandom.oneChanceIn(2)) {\n        trueCount2++\n    }\n    if (testRandom.oneChanceIn(10)) {\n        trueCount10++\n    }\n}\n\nexpect(trueCount2).toBeGreaterThan(trueCount10)"
              }
            ],
            "describes": []
          },
          {
            "title": "coinToss",
            "line": 326,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns boolean",
                "line": 328,
                "source": "const result = random.coinToss()\nexpect(typeof result).toBe('boolean')"
              },
              {
                "title": "produces roughly equal distribution",
                "line": 334,
                "source": "const testRandom = new Random('coinTossTest')\nlet trueCount = 0\n\nfor (let i = 0; i < 1000; i++) {\n    if (testRandom.coinToss()) {\n        trueCount++\n    }\n}\n\nexpect(trueCount).toBeGreaterThan(400)\nexpect(trueCount).toBeLessThan(600)"
              }
            ],
            "describes": []
          },
          {
            "title": "weightedChoice",
            "line": 351,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "respects weights distribution",
                "line": 353,
                "source": "const choices = [\n    {value: 'rare', weight: 1},\n    {value: 'common', weight: 99}\n]\n\nconst results = {rare: 0, common: 0}\nconst testRandom = new Random('weightedTestSeed')\n\nfor (let i = 0; i < 1000; i++) {\n    const result = testRandom.weightedChoice(choices)\n    results[result]++\n}\n\nexpect(results.common).toBeGreaterThan(results.rare)\nexpect(results.rare).toBeGreaterThan(0)"
              },
              {
                "title": "returns undefined for empty array",
                "line": 372,
                "source": "expect(random.weightedChoice([])).toBeUndefined()"
              },
              {
                "title": "returns undefined for undefined input",
                "line": 377,
                "source": "expect(random.weightedChoice()).toBeUndefined()"
              },
              {
                "title": "works with single choice",
                "line": 382,
                "source": "const choices = [{value: 'only', weight: 1}]\nexpect(random.weightedChoice(choices)).toBe('only')"
              }
            ],
            "describes": []
          },
          {
            "title": "generateSeed",
            "line": 390,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns string of default length 10",
                "line": 392,
                "source": "const seed = Random.generateSeed()\nexpect(typeof seed).toBe('string')\nexpect(seed.length).toBe(10)"
              },
              {
                "title": "respects custom length",
                "line": 399,
                "source": "const customLengthSeed = Random.generateSeed(15)\nexpect(customLengthSeed.length).toBe(15)"
              },
              {
                "title": "generates different seeds",
                "line": 405,
                "source": "const seed1 = Random.generateSeed()\nconst seed2 = Random.generateSeed()\nexpect(seed1).not.toEqual(seed2)"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/math/vec2.doc.js": {
    "file": "/math/vec2.test.js",
    "describes": [
      {
        "title": "Vec2",
        "line": 4,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "isVector2",
            "line": 571,
            "source": "const vec = new Vec2()\nexpect(vec.isVector2).toBe(true)"
          }
        ],
        "describes": [
          {
            "title": "constructor",
            "line": 6,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "with x and y",
                "line": 8,
                "source": "const vec = new Vec2(1, 2)\nexpect(vec.x).toBe(1)\nexpect(vec.y).toBe(2)"
              },
              {
                "title": "with object",
                "line": 14,
                "source": "const vec = new Vec2({x: 3, y: 4})\nexpect(vec.x).toBe(3)\nexpect(vec.y).toBe(4)"
              },
              {
                "title": "with array",
                "line": 20,
                "source": "const vec = new Vec2([7, 8])\nexpect(vec.x).toBe(7)\nexpect(vec.y).toBe(8)"
              },
              {
                "title": "with no parameters",
                "line": 26,
                "source": "const vec = new Vec2()\nexpect(vec.x).toBe(0)\nexpect(vec.y).toBe(0)"
              },
              {
                "title": "with only x",
                "line": 32,
                "source": "const vec = new Vec2(5)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(0)"
              }
            ],
            "describes": []
          },
          {
            "title": "setters",
            "line": 41,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "set",
                "line": 43,
                "source": "const vec = new Vec2()\nexpect(vec.set(3, 4)).toBe(vec)\nexpect(vec.x).toBe(3)\nexpect(vec.y).toBe(4)"
              },
              {
                "title": "setX",
                "line": 50,
                "source": "const vec = new Vec2(1, 2)\nexpect(vec.setX(5)).toBe(vec)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(2)"
              },
              {
                "title": "setY",
                "line": 57,
                "source": "const vec = new Vec2(1, 2)\nexpect(vec.setY(6)).toBe(vec)\nexpect(vec.x).toBe(1)\nexpect(vec.y).toBe(6)"
              },
              {
                "title": "setScalar",
                "line": 64,
                "source": "const vec = new Vec2()\nexpect(vec.setScalar(7)).toBe(vec)\nexpect(vec.x).toBe(7)\nexpect(vec.y).toBe(7)"
              },
              {
                "title": "setComponent",
                "line": 71,
                "source": "const vec = new Vec2(1, 2)\nexpect(vec.setComponent(0, 10)).toBe(vec)\nexpect(vec.x).toBe(10)\nexpect(vec.setComponent(1, 20)).toBe(vec)\nexpect(vec.y).toBe(20)"
              },
              {
                "title": "setComponent throws on invalid index",
                "line": 79,
                "source": "const vec = new Vec2()\nexpect(() => {\n    vec.setComponent(2, 5)\n}).toThrow('index out of range: 2')"
              }
            ],
            "describes": []
          },
          {
            "title": "copy and clone",
            "line": 89,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "copy",
                "line": 91,
                "source": "const vec1 = new Vec2(1, 2)\nconst vec2 = new Vec2(3, 4)\nexpect(vec1.copy(vec2)).toBe(vec1)\nexpect(vec1.x).toBe(3)\nexpect(vec1.y).toBe(4)"
              },
              {
                "title": "clone",
                "line": 99,
                "source": "const vec1 = new Vec2(5, 6)\nconst vec2 = vec1.clone()\nexpect(vec2).not.toBe(vec1)\nexpect(vec2.x).toBe(5)\nexpect(vec2.y).toBe(6)"
              }
            ],
            "describes": []
          },
          {
            "title": "addition",
            "line": 110,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "add",
                "line": 112,
                "source": "const vec = new Vec2(1, 2)\nexpect(vec.add(new Vec2(3, 4))).toBe(vec)\nexpect(vec.x).toBe(4)\nexpect(vec.y).toBe(6)"
              },
              {
                "title": "addScalar",
                "line": 119,
                "source": "const vec = new Vec2(1, 2)\nexpect(vec.addScalar(5)).toBe(vec)\nexpect(vec.x).toBe(6)\nexpect(vec.y).toBe(7)"
              },
              {
                "title": "addVectors",
                "line": 126,
                "source": "const vec = new Vec2()\nexpect(vec.addVectors(new Vec2(1, 2), new Vec2(3, 4))).toBe(vec)\nexpect(vec.x).toBe(4)\nexpect(vec.y).toBe(6)"
              },
              {
                "title": "addScaledVector",
                "line": 133,
                "source": "const vec = new Vec2(1, 2)\nexpect(vec.addScaledVector(new Vec2(2, 3), 2)).toBe(vec)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(8)"
              }
            ],
            "describes": []
          },
          {
            "title": "subtraction",
            "line": 143,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "sub",
                "line": 145,
                "source": "const vec = new Vec2(5, 7)\nexpect(vec.sub(new Vec2(2, 3))).toBe(vec)\nexpect(vec.x).toBe(3)\nexpect(vec.y).toBe(4)"
              },
              {
                "title": "subScalar",
                "line": 152,
                "source": "const vec = new Vec2(10, 20)\nexpect(vec.subScalar(5)).toBe(vec)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(15)"
              },
              {
                "title": "subVectors",
                "line": 159,
                "source": "const vec = new Vec2()\nexpect(vec.subVectors(new Vec2(8, 10), new Vec2(3, 4))).toBe(vec)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(6)"
              }
            ],
            "describes": []
          },
          {
            "title": "multiplication",
            "line": 169,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "multiply",
                "line": 171,
                "source": "const vec = new Vec2(2, 3)\nexpect(vec.multiply(new Vec2(4, 5))).toBe(vec)\nexpect(vec.x).toBe(8)\nexpect(vec.y).toBe(15)"
              },
              {
                "title": "multiplyScalar",
                "line": 178,
                "source": "const vec = new Vec2(3, 4)\nexpect(vec.multiplyScalar(2)).toBe(vec)\nexpect(vec.x).toBe(6)\nexpect(vec.y).toBe(8)"
              }
            ],
            "describes": []
          },
          {
            "title": "division",
            "line": 188,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "divide",
                "line": 190,
                "source": "const vec = new Vec2(12, 20)\nexpect(vec.divide(new Vec2(3, 4))).toBe(vec)\nexpect(vec.x).toBe(4)\nexpect(vec.y).toBe(5)"
              },
              {
                "title": "divideScalar",
                "line": 197,
                "source": "const vec = new Vec2(10, 20)\nexpect(vec.divideScalar(2)).toBe(vec)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(10)"
              }
            ],
            "describes": []
          },
          {
            "title": "vector operations",
            "line": 207,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "dot",
                "line": 209,
                "source": "const vec1 = new Vec2(2, 3)\nconst vec2 = new Vec2(4, 5)\nexpect(vec1.dot(vec2)).toBe(23)"
              },
              {
                "title": "cross",
                "line": 215,
                "source": "const vec1 = new Vec2(2, 3)\nconst vec2 = new Vec2(4, 5)\nexpect(vec1.cross(vec2)).toBe(-2)"
              },
              {
                "title": "lengthSq",
                "line": 221,
                "source": "const vec = new Vec2(3, 4)\nexpect(vec.lengthSq()).toBe(25)"
              },
              {
                "title": "length",
                "line": 226,
                "source": "const vec = new Vec2(3, 4)\nexpect(vec.length()).toBe(5)"
              },
              {
                "title": "manhattanLength",
                "line": 231,
                "source": "const vec = new Vec2(3, -4)\nexpect(vec.manhattanLength()).toBe(7)"
              },
              {
                "title": "normalize",
                "line": 236,
                "source": "const vec = new Vec2(3, 4)\nexpect(vec.normalize()).toBe(vec)\nexpect(vec.x).toBeCloseTo(0.6)\nexpect(vec.y).toBeCloseTo(0.8)\nexpect(vec.length()).toBeCloseTo(1)"
              },
              {
                "title": "normalize zero vector",
                "line": 244,
                "source": "const vec = new Vec2(0, 0)\nexpect(vec.normalize()).toBe(vec)\nexpect(vec.x).toBe(0)\nexpect(vec.y).toBe(0)"
              },
              {
                "title": "setLength",
                "line": 251,
                "source": "const vec = new Vec2(3, 4)\nexpect(vec.setLength(10)).toBe(vec)\nexpect(vec.length()).toBeCloseTo(10)\nexpect(vec.x).toBeCloseTo(6)\nexpect(vec.y).toBeCloseTo(8)"
              }
            ],
            "describes": []
          },
          {
            "title": "angles",
            "line": 262,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "angle",
                "line": 264,
                "source": "const vec = new Vec2(1, 0)\nexpect(vec.angle()).toBeCloseTo(0)\nconst vec2 = new Vec2(0, 1)\nexpect(vec2.angle()).toBeCloseTo(Math.PI / 2)"
              },
              {
                "title": "angleTo",
                "line": 271,
                "source": "const vec1 = new Vec2(1, 0)\nconst vec2 = new Vec2(0, 1)\nexpect(vec1.angleTo(vec2)).toBeCloseTo(Math.PI / 2)"
              },
              {
                "title": "angleTo parallel vectors",
                "line": 277,
                "source": "const vec1 = new Vec2(1, 0)\nconst vec2 = new Vec2(2, 0)\nexpect(vec1.angleTo(vec2)).toBeCloseTo(0)"
              }
            ],
            "describes": []
          },
          {
            "title": "distance",
            "line": 286,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "distanceTo",
                "line": 288,
                "source": "const vec1 = new Vec2(1, 2)\nconst vec2 = new Vec2(4, 6)\nexpect(vec1.distanceTo(vec2)).toBe(5)"
              },
              {
                "title": "distanceToSquared",
                "line": 294,
                "source": "const vec1 = new Vec2(1, 2)\nconst vec2 = new Vec2(4, 6)\nexpect(vec1.distanceToSquared(vec2)).toBe(25)"
              },
              {
                "title": "manhattanDistanceTo",
                "line": 300,
                "source": "const vec1 = new Vec2(1, 2)\nconst vec2 = new Vec2(4, 6)\nexpect(vec1.manhattanDistanceTo(vec2)).toBe(7)"
              }
            ],
            "describes": []
          },
          {
            "title": "interpolation",
            "line": 309,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "lerp",
                "line": 311,
                "source": "const vec = new Vec2(0, 0)\nexpect(vec.lerp(new Vec2(10, 20), 0.5)).toBe(vec)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(10)"
              },
              {
                "title": "lerp at 0",
                "line": 318,
                "source": "const vec = new Vec2(1, 2)\nvec.lerp(new Vec2(10, 20), 0)\nexpect(vec.x).toBe(1)\nexpect(vec.y).toBe(2)"
              },
              {
                "title": "lerp at 1",
                "line": 325,
                "source": "const vec = new Vec2(1, 2)\nvec.lerp(new Vec2(10, 20), 1)\nexpect(vec.x).toBe(10)\nexpect(vec.y).toBe(20)"
              },
              {
                "title": "lerpVectors",
                "line": 332,
                "source": "const vec = new Vec2()\nexpect(vec.lerpVectors(new Vec2(0, 0), new Vec2(10, 20), 0.5)).toBe(vec)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(10)"
              }
            ],
            "describes": []
          },
          {
            "title": "comparison",
            "line": 342,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "equals with Vec2",
                "line": 344,
                "source": "const vec1 = new Vec2(1, 2)\nconst vec2 = new Vec2(1, 2)\nconst vec3 = new Vec2(3, 4)\nexpect(vec1.equals(vec2)).toBe(true)\nexpect(vec1.equals(vec3)).toBe(false)"
              },
              {
                "title": "equals with object",
                "line": 352,
                "source": "const vec1 = new Vec2(1, 2)\nconst vec4 = {x: 1, y: 2, z: 0}\nexpect(vec1.equals(vec4)).toBe(true)"
              }
            ],
            "describes": []
          },
          {
            "title": "array conversion",
            "line": 361,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "fromArray",
                "line": 363,
                "source": "const vec = new Vec2()\nexpect(vec.fromArray([5, 6])).toBe(vec)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(6)"
              },
              {
                "title": "fromArray with offset",
                "line": 370,
                "source": "const vec = new Vec2()\nvec.fromArray([1, 2, 3, 4], 2)\nexpect(vec.x).toBe(3)\nexpect(vec.y).toBe(4)"
              },
              {
                "title": "toArray",
                "line": 377,
                "source": "const vec = new Vec2(7, 8)\nconst arr = vec.toArray()\nexpect(arr).toEqual([7, 8])"
              },
              {
                "title": "toArray with existing array",
                "line": 383,
                "source": "const vec = new Vec2(9, 10)\nconst arr = [1, 2, 3, 4]\nexpect(vec.toArray(arr, 2)).toBe(arr)\nexpect(arr).toEqual([1, 2, 9, 10])"
              }
            ],
            "describes": []
          },
          {
            "title": "negation and min/max",
            "line": 393,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "negate",
                "line": 395,
                "source": "const vec = new Vec2(3, -4)\nexpect(vec.negate()).toBe(vec)\nexpect(vec.x).toBe(-3)\nexpect(vec.y).toBe(4)"
              },
              {
                "title": "min",
                "line": 402,
                "source": "const vec = new Vec2(5, 2)\nexpect(vec.min(new Vec2(3, 4))).toBe(vec)\nexpect(vec.x).toBe(3)\nexpect(vec.y).toBe(2)"
              },
              {
                "title": "max",
                "line": 409,
                "source": "const vec = new Vec2(5, 2)\nexpect(vec.max(new Vec2(3, 4))).toBe(vec)\nexpect(vec.x).toBe(5)\nexpect(vec.y).toBe(4)"
              }
            ],
            "describes": []
          },
          {
            "title": "clamping",
            "line": 419,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "clamp",
                "line": 421,
                "source": "const vec = new Vec2(15, -5)\nexpect(vec.clamp(new Vec2(0, 0), new Vec2(10, 10))).toBe(vec)\nexpect(vec.x).toBe(10)\nexpect(vec.y).toBe(0)"
              },
              {
                "title": "clampScalar",
                "line": 428,
                "source": "const vec = new Vec2(15, -5)\nexpect(vec.clampScalar(0, 10)).toBe(vec)\nexpect(vec.x).toBe(10)\nexpect(vec.y).toBe(0)"
              },
              {
                "title": "clampLength min",
                "line": 435,
                "source": "const vec = new Vec2(1, 0)\nvec.clampLength(5, 10)\nexpect(vec.length()).toBeCloseTo(5)"
              },
              {
                "title": "clampLength max",
                "line": 441,
                "source": "const vec = new Vec2(20, 0)\nvec.clampLength(5, 10)\nexpect(vec.length()).toBeCloseTo(10)"
              },
              {
                "title": "clampLength in range",
                "line": 447,
                "source": "const vec = new Vec2(7, 0)\nvec.clampLength(5, 10)\nexpect(vec.length()).toBeCloseTo(7)"
              }
            ],
            "describes": []
          },
          {
            "title": "rounding",
            "line": 456,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "floor",
                "line": 458,
                "source": "const vec = new Vec2(1.7, 2.3)\nexpect(vec.floor()).toBe(vec)\nexpect(vec.x).toBe(1)\nexpect(vec.y).toBe(2)"
              },
              {
                "title": "ceil",
                "line": 465,
                "source": "const vec = new Vec2(1.3, 2.7)\nexpect(vec.ceil()).toBe(vec)\nexpect(vec.x).toBe(2)\nexpect(vec.y).toBe(3)"
              },
              {
                "title": "round",
                "line": 472,
                "source": "const vec = new Vec2(1.4, 2.6)\nexpect(vec.round()).toBe(vec)\nexpect(vec.x).toBe(1)\nexpect(vec.y).toBe(3)"
              },
              {
                "title": "roundToZero positive",
                "line": 479,
                "source": "const vec = new Vec2(1.9, 2.9)\nexpect(vec.roundToZero()).toBe(vec)\nexpect(vec.x).toBe(1)\nexpect(vec.y).toBe(2)"
              },
              {
                "title": "roundToZero negative",
                "line": 486,
                "source": "const vec = new Vec2(-1.9, -2.9)\nvec.roundToZero()\nexpect(vec.x).toBe(-1)\nexpect(vec.y).toBe(-2)"
              }
            ],
            "describes": []
          },
          {
            "title": "rotation",
            "line": 496,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "rotateAround",
                "line": 498,
                "source": "const vec = new Vec2(1, 0)\nconst center = new Vec2(0, 0)\nexpect(vec.rotateAround(center, Math.PI / 2)).toBe(vec)\nexpect(vec.x).toBeCloseTo(0)\nexpect(vec.y).toBeCloseTo(1)"
              },
              {
                "title": "rotateAround with offset center",
                "line": 506,
                "source": "const vec = new Vec2(2, 1)\nconst center = new Vec2(1, 1)\nvec.rotateAround(center, Math.PI / 2)\nexpect(vec.x).toBeCloseTo(1)\nexpect(vec.y).toBeCloseTo(2)"
              }
            ],
            "describes": []
          },
          {
            "title": "random and component access",
            "line": 517,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "random",
                "line": 519,
                "source": "const vec = new Vec2()\nexpect(vec.random()).toBe(vec)\nexpect(vec.x).toBeGreaterThanOrEqual(0)\nexpect(vec.x).toBeLessThan(1)\nexpect(vec.y).toBeGreaterThanOrEqual(0)\nexpect(vec.y).toBeLessThan(1)"
              },
              {
                "title": "getComponent",
                "line": 528,
                "source": "const vec = new Vec2(5, 7)\nexpect(vec.getComponent(0)).toBe(5)\nexpect(vec.getComponent(1)).toBe(7)"
              },
              {
                "title": "getComponent throws on invalid index",
                "line": 534,
                "source": "const vec = new Vec2()\nexpect(() => {\n    vec.getComponent(2)\n}).toThrow('index out of range: 2')"
              }
            ],
            "describes": []
          },
          {
            "title": "aliases",
            "line": 544,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "width getter",
                "line": 546,
                "source": "const vec = new Vec2(10, 20)\nexpect(vec.width).toBe(10)"
              },
              {
                "title": "width setter",
                "line": 551,
                "source": "const vec = new Vec2()\nvec.width = 15\nexpect(vec.x).toBe(15)"
              },
              {
                "title": "height getter",
                "line": 557,
                "source": "const vec = new Vec2(10, 20)\nexpect(vec.height).toBe(20)"
              },
              {
                "title": "height setter",
                "line": 562,
                "source": "const vec = new Vec2()\nvec.height = 25\nexpect(vec.y).toBe(25)"
              }
            ],
            "describes": []
          },
          {
            "title": "iteration",
            "line": 577,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "iterator",
                "line": 579,
                "source": "const vec = new Vec2(3, 4)\nconst [x, y] = vec\nexpect(x).toBe(3)\nexpect(y).toBe(4)"
              },
              {
                "title": "spread operator",
                "line": 586,
                "source": "const vec = new Vec2(5, 6)\nconst arr = [...vec]\nexpect(arr).toEqual([5, 6])"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/render/canvas_renderer.doc.js": {
    "file": "/render/canvas_renderer.test.js",
    "describes": [
      {
        "title": "CanvasRenderer",
        "line": 9,
        "beforeEach": {
          "line": 14,
          "source": "canvas = document.createElement('canvas')\ncanvas.width = 800\ncanvas.height = 600\nrenderer = new CanvasRenderer({canvas})"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor with canvas",
            "line": 22,
            "source": "expect(renderer.canvas).toBe(canvas)\nexpect(renderer.ctx).toBe(canvas.getContext('2d'))\nexpect(renderer.camera).toBeInstanceOf(Camera)\nexpect(renderer.backgroundColor).toBe(null)"
          },
          {
            "title": "constructor with container",
            "line": 30,
            "source": "const container = document.createElement('div')\nconst r = new CanvasRenderer({container, width: 400, height: 300})\n\nexpect(r.canvas).toBeInstanceOf(HTMLCanvasElement)\nexpect(r.container).toBe(container)\nexpect(container.contains(r.canvas)).toBe(true)"
          },
          {
            "title": "constructor with options",
            "line": 40,
            "source": "const camera = new Camera()\nconst r = new CanvasRenderer({\n    canvas,\n    camera,\n    backgroundColor: '#ffffff'\n})\n\nexpect(r.camera).toBe(camera)\nexpect(r.backgroundColor).toBe('#ffffff')"
          },
          {
            "title": "autoFit observes container resize",
            "line": 53,
            "source": "const container = document.createElement('div')\n\nObject.defineProperty(container, 'clientWidth', {value: 400, writable: true})\nObject.defineProperty(container, 'clientHeight', {value: 300, writable: true})\n\nconst r = new CanvasRenderer({container, autoFit: true})\n\nexpect(r.displayWidth).toBe(400)\nexpect(r.displayHeight).toBe(300)\n\nr.dispose()"
          },
          {
            "title": "dispose cleans up autoFit observer",
            "line": 68,
            "source": "const container = document.createElement('div')\nObject.defineProperty(container, 'clientWidth', {value: 400, writable: true})\nObject.defineProperty(container, 'clientHeight', {value: 300, writable: true})\n\nconst r = new CanvasRenderer({container, autoFit: true})\n\nexpect(r.canvas).toBeInstanceOf(HTMLCanvasElement)\nexpect(r.ctx).toBeDefined()\n\nr.dispose()\n\nexpect(r.canvas).toBe(null)\nexpect(r.ctx).toBe(null)"
          },
          {
            "title": "autoFitEnabled can be toggled dynamically",
            "line": 85,
            "source": "const container = document.createElement('div')\nObject.defineProperty(container, 'clientWidth', {value: 400, writable: true})\nObject.defineProperty(container, 'clientHeight', {value: 300, writable: true})\n\nconst r = new CanvasRenderer({container, autoFit: true})\n\nexpect(r.autoFitEnabled).toBe(true)\nexpect(r.displayWidth).toBe(400)\nexpect(r.displayHeight).toBe(300)\n\n// Disable autoFit\nr.autoFitEnabled = false\nexpect(r.autoFitEnabled).toBe(false)\n\n// Re-enable autoFit\nr.autoFitEnabled = true\nexpect(r.autoFitEnabled).toBe(true)\n\nr.dispose()"
          },
          {
            "title": "changing container with autoFit updates observer",
            "line": 108,
            "source": "const container1 = document.createElement('div')\nconst container2 = document.createElement('div')\n\nObject.defineProperty(container1, 'clientWidth', {value: 400, writable: true})\nObject.defineProperty(container1, 'clientHeight', {value: 300, writable: true})\nObject.defineProperty(container2, 'clientWidth', {value: 800, writable: true})\nObject.defineProperty(container2, 'clientHeight', {value: 600, writable: true})\n\nconst r = new CanvasRenderer({container: container1, autoFit: true})\n\nexpect(r.displayWidth).toBe(400)\nexpect(r.displayHeight).toBe(300)\nexpect(r.container).toBe(container1)\n\n// Change container - should trigger resize\nr.container = container2\n\nexpect(r.container).toBe(container2)\nexpect(r.displayWidth).toBe(800)\nexpect(r.displayHeight).toBe(600)\n\nr.dispose()"
          },
          {
            "title": "changing container without autoFit does not resize",
            "line": 134,
            "source": "const container1 = document.createElement('div')\nconst container2 = document.createElement('div')\n\nObject.defineProperty(container1, 'clientWidth', {value: 400, writable: true})\nObject.defineProperty(container1, 'clientHeight', {value: 300, writable: true})\nObject.defineProperty(container2, 'clientWidth', {value: 800, writable: true})\nObject.defineProperty(container2, 'clientHeight', {value: 600, writable: true})\n\nconst r = new CanvasRenderer({container: container1, width: 400, height: 300})\n\nexpect(r.displayWidth).toBe(400)\nexpect(r.displayHeight).toBe(300)\n\n// Change container - should NOT auto-resize\nr.container = container2\n\nexpect(r.container).toBe(container2)\nexpect(r.displayWidth).toBe(400) // Should remain same\nexpect(r.displayHeight).toBe(300) // Should remain same\n\nr.dispose()"
          },
          {
            "title": "render clears canvas",
            "line": 159,
            "source": "const scene = new Group2D()\nconst ctx = canvas.getContext('2d')\n\nvi.spyOn(ctx, 'clearRect')\n\nrenderer.render(scene)\n\nexpect(ctx.clearRect).toHaveBeenCalledWith(0, 0, 800, 600)"
          },
          {
            "title": "render with background color",
            "line": 171,
            "source": "const scene = new Group2D()\nconst ctx = canvas.getContext('2d')\n\nrenderer.backgroundColor = '#ff0000'\nvi.spyOn(ctx, 'fillRect')\n\nrenderer.render(scene)\n\nexpect(ctx.fillRect).toHaveBeenCalledWith(0, 0, 800, 600)"
          },
          {
            "title": "render updates world matrix",
            "line": 184,
            "source": "const scene = new Group2D()\nvi.spyOn(scene, 'updateWorldMatrix')\n\nrenderer.render(scene)\n\nexpect(scene.updateWorldMatrix).toHaveBeenCalledWith(false)"
          },
          {
            "title": "render with visible object",
            "line": 194,
            "source": "const scene = new Group2D()\nconst circle = new Circle({radius: 10, color: '#ff0000'})\nscene.addChild(circle)\n\nexpect(() => renderer.render(scene)).not.toThrow()"
          },
          {
            "title": "render with invisible object",
            "line": 203,
            "source": "const scene = new Group2D()\nconst circle = new Circle({radius: 10, color: '#ff0000', visible: false})\nscene.addChild(circle)\n\nvi.spyOn(circle, 'render')\n\nrenderer.render(scene)\n\nexpect(circle.render).not.toHaveBeenCalled()"
          },
          {
            "title": "render with nested groups",
            "line": 216,
            "source": "const scene = new Group2D()\nconst group1 = new Group2D({x: 10, y: 20})\nconst group2 = new Group2D({x: 5, y: 5})\nconst circle = new Circle({radius: 10, color: '#ff0000'})\n\nscene.addChild(group1)\ngroup1.addChild(group2)\ngroup2.addChild(circle)\n\nexpect(() => renderer.render(scene)).not.toThrow()"
          },
          {
            "title": "render with opacity",
            "line": 230,
            "source": "const scene = new Group2D()\nconst circle = new Circle({radius: 10, color: '#ff0000', opacity: 0.5})\nscene.addChild(circle)\n\nexpect(() => renderer.render(scene)).not.toThrow()"
          },
          {
            "title": "render respects camera transformations",
            "line": 239,
            "source": "const scene = new Group2D()\nconst circle = new Circle({x: 0, y: 0, radius: 10, color: '#ff0000'})\nscene.addChild(circle)\n\nrenderer.camera.setPosition(5, 5)\nrenderer.camera.setZoom(2)\n\nexpect(() => renderer.render(scene)).not.toThrow()"
          },
          {
            "title": "render multiple objects",
            "line": 251,
            "source": "const scene = new Group2D()\nscene.addChild(\n    new Circle({x: 0, y: 0, radius: 10, color: '#ff0000'}),\n    new Rectangle({x: 50, y: 50, width: 20, height: 20, color: '#00ff00'}),\n    new Circle({x: -50, y: -50, radius: 15, color: '#0000ff'})\n)\n\nexpect(() => renderer.render(scene)).not.toThrow()"
          },
          {
            "title": "render with rotation",
            "line": 263,
            "source": "const scene = new Group2D()\nconst rect = new Rectangle({\n    x: 0,\n    y: 0,\n    width: 50,\n    height: 30,\n    rotation: Math.PI / 4,\n    color: '#ff0000'\n})\nscene.addChild(rect)\n\nexpect(() => renderer.render(scene)).not.toThrow()"
          },
          {
            "title": "render with scale",
            "line": 279,
            "source": "const scene = new Group2D()\nconst circle = new Circle({\n    x: 0,\n    y: 0,\n    radius: 10,\n    scaleX: 2,\n    scaleY: 3,\n    color: '#ff0000'\n})\nscene.addChild(circle)\n\nexpect(() => renderer.render(scene)).not.toThrow()"
          },
          {
            "title": "registerRenderer adds renderer for object types",
            "line": 295,
            "source": "class CustomObject {}\nconst customRenderer = {\n    constructor: {handles: [CustomObject]},\n    init: vi.fn(),\n    reset: vi.fn(),\n    flush: vi.fn(),\n    dispose: vi.fn()\n}\n\nconst result = renderer.registerRenderer(customRenderer)\n\nexpect(result).toBe(renderer)\nexpect(customRenderer.init).toHaveBeenCalled()"
          },
          {
            "title": "unregisterRenderer removes renderer",
            "line": 312,
            "source": "class CustomObject {}\nconst customRenderer = {\n    constructor: {handles: [CustomObject]},\n    init: vi.fn(),\n    reset: vi.fn(),\n    flush: vi.fn(),\n    dispose: vi.fn()\n}\n\nrenderer.registerRenderer(customRenderer)\nconst result = renderer.unregisterRenderer(customRenderer)\n\nexpect(result).toBe(renderer)\nexpect(customRenderer.dispose).toHaveBeenCalled()"
          }
        ],
        "describes": []
      }
    ]
  },
  "/render/webgl_renderer.doc.js": {
    "file": "/render/webgl_renderer.test.js",
    "describes": [
      {
        "title": "WebGLRenderer",
        "line": 12,
        "beforeEach": {
          "line": 17,
          "source": "canvas = document.createElement('canvas')\ncanvas.width = 800\ncanvas.height = 600\nrenderer = new WebGLRenderer({canvas})"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "setPixelRatio updates viewport on pixel ratio change",
            "line": 276,
            "source": "expect(() => renderer.setPixelRatio(2)).not.toThrow()"
          },
          {
            "title": "dispose cleans up resources",
            "line": 281,
            "source": "renderer.dispose()\n\nexpect(renderer.gl).toBe(null)\nexpect(renderer.canvas).toBe(null)"
          }
        ],
        "describes": [
          {
            "title": "constructor",
            "line": 25,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "uses provided canvas",
                "line": 27,
                "source": "expect(renderer.canvas).toBe(canvas)"
              },
              {
                "title": "gets WebGL context",
                "line": 32,
                "source": "expect(renderer.gl).toBeDefined()"
              },
              {
                "title": "initializes camera",
                "line": 37,
                "source": "expect(renderer.camera).toBeInstanceOf(Camera)"
              },
              {
                "title": "has static $name",
                "line": 42,
                "source": "expect(WebGLRenderer.$name).toBe('webGLRenderer')"
              },
              {
                "title": "with provided camera",
                "line": 47,
                "source": "const camera = new Camera({x: 10, y: 20})\nconst r = new WebGLRenderer({canvas, camera})\nexpect(r.camera).toBe(camera)"
              },
              {
                "title": "with backgroundColor",
                "line": 54,
                "source": "const r = new WebGLRenderer({canvas, backgroundColor: '#FF0000'})\nexpect(r.backgroundColor).toBe('#FF0000')"
              },
              {
                "title": "with enableCulling",
                "line": 60,
                "source": "const r = new WebGLRenderer({canvas, enableCulling: true})\nexpect(r.enableCulling).toBe(true)"
              },
              {
                "title": "initializes stats",
                "line": 66,
                "source": "expect(renderer.stats).toBeDefined()\nexpect(renderer.stats.totalObjects).toBe(0)\nexpect(renderer.stats.renderedObjects).toBe(0)\nexpect(renderer.stats.culledObjects).toBe(0)"
              }
            ],
            "describes": []
          },
          {
            "title": "shaderRegistry",
            "line": 76,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "has shaderRegistry accessor",
                "line": 78,
                "source": "expect(renderer.shaderRegistry).toBeDefined()"
              },
              {
                "title": "can register custom shaders",
                "line": 83,
                "source": "const definition = {\n    vertex: 'void main() {}',\n    fragment: 'void main() {}',\n    uniforms: [],\n    attributes: []\n}\n\nconst program = renderer.registerShader('custom', definition)\nexpect(program).toBeDefined()"
              },
              {
                "title": "can get registered shader",
                "line": 96,
                "source": "const definition = {\n    vertex: 'void main() {}',\n    fragment: 'void main() {}',\n    uniforms: [],\n    attributes: []\n}\n\nrenderer.registerShader('test', definition)\nconst shader = renderer.getShader('test')\nexpect(shader).toBeDefined()"
              }
            ],
            "describes": []
          },
          {
            "title": "shaderEffectRegistry",
            "line": 112,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "has shaderEffectRegistry accessor",
                "line": 114,
                "source": "expect(renderer.shaderEffectRegistry).toBeDefined()"
              },
              {
                "title": "registerShaderEffect registers an effect class",
                "line": 119,
                "source": "class TestEffect {\n    static shader = {\n        params: [],\n        uniforms: [],\n        fragment: ''\n    }\n}\n\nexpect(() => renderer.registerShaderEffect(TestEffect)).not.toThrow()\nexpect(renderer.shaderEffectRegistry.has('TestEffect')).toBe(true)"
              },
              {
                "title": "setUniform stores uniform value",
                "line": 133,
                "source": "renderer.setUniform('uTime', 1.5)\nexpect(renderer.getUniform('uTime')).toBe(1.5)"
              },
              {
                "title": "setUniform with type stores uniform value and type",
                "line": 139,
                "source": "renderer.setUniform('uResolution', [800, 600], 'vec2')\nexpect(renderer.getUniform('uResolution')).toEqual([800, 600])"
              },
              {
                "title": "setUniform returns this for chaining",
                "line": 145,
                "source": "const result = renderer.setUniform('uTime', 1.0)\nexpect(result).toBe(renderer)"
              },
              {
                "title": "getUniform returns undefined for unknown uniform",
                "line": 151,
                "source": "expect(renderer.getUniform('uUnknown')).toBeUndefined()"
              }
            ],
            "describes": []
          },
          {
            "title": "postProcessor",
            "line": 158,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "has postProcessor accessor",
                "line": 160,
                "source": "expect(renderer.postProcessor).toBeDefined()"
              },
              {
                "title": "can add post pass",
                "line": 165,
                "source": "const mockPass = {\n    init: vi.fn(),\n    getShaderDefinition: () => ({\n        vertex: 'void main() {}',\n        fragment: 'void main() {}',\n        uniforms: [],\n        attributes: []\n    }),\n    enabled: true,\n    render: vi.fn(),\n    dispose: vi.fn()\n}\n\nrenderer.addPostPass(mockPass)\nexpect(renderer.postProcessor.passes.length).toBe(1)"
              },
              {
                "title": "can remove post pass",
                "line": 184,
                "source": "const mockPass = {\n    init: vi.fn(),\n    getShaderDefinition: () => ({\n        vertex: 'void main() {}',\n        fragment: 'void main() {}',\n        uniforms: [],\n        attributes: []\n    }),\n    enabled: true,\n    render: vi.fn(),\n    dispose: vi.fn()\n}\n\nrenderer.addPostPass(mockPass)\nrenderer.removePostPass(mockPass)\nexpect(renderer.postProcessor.passes.length).toBe(0)"
              }
            ],
            "describes": []
          },
          {
            "title": "render",
            "line": 206,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "renders empty scene without error",
                "line": 208,
                "source": "const scene = new Group2D()\nexpect(() => renderer.render(scene)).not.toThrow()"
              },
              {
                "title": "clears the canvas",
                "line": 214,
                "source": "const scene = new Group2D()\nexpect(() => renderer.render(scene)).not.toThrow()"
              },
              {
                "title": "updates world matrix",
                "line": 220,
                "source": "const scene = new Group2D()\nvi.spyOn(scene, 'updateWorldMatrix')\n\nrenderer.render(scene)\n\nexpect(scene.updateWorldMatrix).toHaveBeenCalledWith(false)"
              },
              {
                "title": "renders circle",
                "line": 230,
                "source": "const scene = new Group2D()\nconst circle = new Circle({radius: 1, color: '#FF0000'})\nscene.addChild(circle)\n\nexpect(() => renderer.render(scene)).not.toThrow()"
              },
              {
                "title": "renders rectangle",
                "line": 239,
                "source": "const scene = new Group2D()\nconst rect = new Rectangle({width: 2, height: 1, color: '#00FF00'})\nscene.addChild(rect)\n\nexpect(() => renderer.render(scene)).not.toThrow()"
              },
              {
                "title": "skips invisible objects",
                "line": 248,
                "source": "const scene = new Group2D()\nconst circle = new Circle({radius: 1, color: '#FF0000', visible: false})\nscene.addChild(circle)\n\nrenderer.render(scene)\nexpect(renderer.stats.totalObjects).toBe(1)"
              },
              {
                "title": "applies opacity inheritance",
                "line": 258,
                "source": "const scene = new Group2D({opacity: 0.5})\nconst circle = new Circle({radius: 1, color: '#FF0000', opacity: 0.5})\nscene.addChild(circle)\n\nexpect(() => renderer.render(scene)).not.toThrow()"
              },
              {
                "title": "renders with background color",
                "line": 267,
                "source": "renderer.backgroundColor = '#0000FF'\nconst scene = new Group2D()\nexpect(() => renderer.render(scene)).not.toThrow()"
              }
            ],
            "describes": []
          },
          {
            "title": "registerRenderer and unregisterRenderer",
            "line": 289,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "registerRenderer adds custom renderer",
                "line": 291,
                "source": "class CustomObject {}\nclass CustomRenderer {\n    static get handles () {\n        return [CustomObject]\n    }\n\n    init = vi.fn()\n    reset = vi.fn()\n    flush = vi.fn()\n    dispose = vi.fn()\n}\n\nconst customRenderer = new CustomRenderer()\nconst result = renderer.registerRenderer(customRenderer)\n\nexpect(result).toBe(renderer)\nexpect(customRenderer.init).toHaveBeenCalled()"
              },
              {
                "title": "unregisterRenderer removes renderer",
                "line": 312,
                "source": "class CustomObject {}\nclass CustomRenderer {\n    static get handles () {\n        return [CustomObject]\n    }\n\n    init = vi.fn()\n    reset = vi.fn()\n    flush = vi.fn()\n    dispose = vi.fn()\n}\n\nconst customRenderer = new CustomRenderer()\nrenderer.registerRenderer(customRenderer)\n\nconst result = renderer.unregisterRenderer(customRenderer)\n\nexpect(result).toBe(renderer)\nexpect(customRenderer.dispose).toHaveBeenCalled()"
              }
            ],
            "describes": []
          },
          {
            "title": "applyPixelRatio",
            "line": 337,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "applyPixelRatio updates viewport",
                "line": 339,
                "source": "renderer.pixelRatio = 2\nexpect(() => renderer.applyPixelRatio()).not.toThrow()"
              },
              {
                "title": "applyPixelRatio resizes post processor",
                "line": 345,
                "source": "const originalWidth = canvas.width\nconst originalHeight = canvas.height\n\nrenderer.applyPixelRatio()\n\nexpect(renderer.gl).toBeDefined()\nexpect(canvas.width).toBe(originalWidth)\nexpect(canvas.height).toBe(originalHeight)"
              }
            ],
            "describes": []
          },
          {
            "title": "setRenderGroups and clearRenderGroups",
            "line": 359,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "setRenderGroups creates render groups",
                "line": 361,
                "source": "const scene = new Group2D()\n\nrenderer.setRenderGroups([\n    {$id: 'background', content: scene},\n    {$id: 'foreground', content: scene}\n])\n\nexpect(renderer.renderGroups.length).toBe(2)"
              },
              {
                "title": "setRenderGroups returns this for chaining",
                "line": 373,
                "source": "const scene = new Group2D()\n\nconst result = renderer.setRenderGroups([\n    {$id: 'test', content: scene}\n])\n\nexpect(result).toBe(renderer)"
              },
              {
                "title": "clearRenderGroups removes all render groups",
                "line": 384,
                "source": "const scene = new Group2D()\n\nrenderer.setRenderGroups([\n    {$id: 'group1', content: scene},\n    {$id: 'group2', content: scene}\n])\n\nexpect(renderer.renderGroups.length).toBe(2)\n\nconst result = renderer.clearRenderGroups()\n\nexpect(result).toBe(renderer)\nexpect(renderer.renderGroups.length).toBe(0)"
              },
              {
                "title": "setRenderGroups clears previous groups",
                "line": 401,
                "source": "const scene = new Group2D()\n\nrenderer.setRenderGroups([\n    {$id: 'oldGroup', content: scene}\n])\n\nrenderer.setRenderGroups([\n    {$id: 'newGroup', content: scene}\n])\n\nexpect(renderer.renderGroups.length).toBe(1)\nexpect(renderer.renderGroups[0].$id).toBe('newGroup')"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/render/circle.doc.js": {
    "file": "/render/circle.test.js",
    "describes": [
      {
        "title": "Circle",
        "line": 6,
        "beforeEach": {
          "line": 10,
          "source": "circle = new Circle()"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor defaults",
            "line": 15,
            "source": "expect(circle.radius).toBe(10)\nexpect(circle.color).toBe('#000000')\nexpect(circle.strokeColor).toBe('#000000')\nexpect(circle.strokeWidth).toBe(0)"
          },
          {
            "title": "constructor with options",
            "line": 23,
            "source": "const c = new Circle({\n    x: 10,\n    y: 20,\n    radius: 50,\n    color: '#ff0000',\n    strokeColor: '#00ff00',\n    strokeWidth: 2,\n    opacity: 0.5\n})\n\nexpect(c.x).toBe(10)\nexpect(c.y).toBe(20)\nexpect(c.radius).toBe(50)\nexpect(c.color).toBe('#ff0000')\nexpect(c.strokeColor).toBe('#00ff00')\nexpect(c.strokeWidth).toBe(2)\nexpect(c.opacity).toBe(0.5)"
          },
          {
            "title": "setRadius",
            "line": 44,
            "source": "const result = circle.setRadius(25)\n\nexpect(circle.radius).toBe(25)\nexpect(result).toBe(circle)"
          },
          {
            "title": "getBounds",
            "line": 52,
            "source": "circle.radius = 20\ncircle.anchorX = 0.5\ncircle.anchorY = 0.5\n\nconst bounds = circle.getBounds()\n\nexpect(bounds.minX).toBeCloseTo(-20)\nexpect(bounds.minY).toBeCloseTo(-20)\nexpect(bounds.maxX).toBeCloseTo(20)\nexpect(bounds.maxY).toBeCloseTo(20)\nexpect(bounds.width).toBe(40)\nexpect(bounds.height).toBe(40)"
          },
          {
            "title": "getBounds with custom anchor",
            "line": 68,
            "source": "circle.radius = 10\ncircle.anchorX = 0\ncircle.anchorY = 0\n\nconst bounds = circle.getBounds()\n\nexpect(bounds.minX).toBeCloseTo(0)\nexpect(bounds.minY).toBeCloseTo(0)\nexpect(bounds.maxX).toBeCloseTo(20)\nexpect(bounds.maxY).toBeCloseTo(20)\nexpect(bounds.width).toBe(20)\nexpect(bounds.height).toBe(20)"
          }
        ],
        "describes": []
      },
      {
        "title": "CanvasCircleRenderer",
        "line": 86,
        "beforeEach": {
          "line": 91,
          "source": "renderer = new CanvasCircleRenderer()\nctx = {\n    beginPath: vi.fn(),\n    arc: vi.fn(),\n    fill: vi.fn(),\n    stroke: vi.fn()\n}"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "handles Circle class",
            "line": 102,
            "source": "expect(CanvasCircleRenderer.handles).toContain(Circle)"
          },
          {
            "title": "render without stroke",
            "line": 107,
            "source": "const circle = new Circle({\n    radius: 20,\n    color: '#ff0000',\n    anchorX: 0.5,\n    anchorY: 0.5,\n    strokeWidth: 0\n})\n\nrenderer.render(circle, ctx)\n\nexpect(ctx.beginPath).toHaveBeenCalled()\nexpect(ctx.arc).toHaveBeenCalledWith(0, 0, 20, 0, Math.PI * 2)\nexpect(ctx.fill).toHaveBeenCalled()\nexpect(ctx.stroke).not.toHaveBeenCalled()"
          },
          {
            "title": "render with stroke",
            "line": 125,
            "source": "const circle = new Circle({\n    radius: 20,\n    color: '#ff0000',\n    strokeColor: '#0000ff',\n    strokeWidth: 2,\n    anchorX: 0.5,\n    anchorY: 0.5\n})\n\nrenderer.render(circle, ctx)\n\nexpect(ctx.beginPath).toHaveBeenCalled()\nexpect(ctx.arc).toHaveBeenCalledWith(0, 0, 20, 0, Math.PI * 2)\nexpect(ctx.fill).toHaveBeenCalled()\nexpect(ctx.stroke).toHaveBeenCalled()"
          },
          {
            "title": "render with custom anchor",
            "line": 144,
            "source": "const circle = new Circle({\n    radius: 20,\n    anchorX: 0,\n    anchorY: 0\n})\n\nrenderer.render(circle, ctx)\n\nexpect(ctx.arc).toHaveBeenCalledWith(20, 20, 20, 0, Math.PI * 2)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/render/group_2d.doc.js": {
    "file": "/render/group_2d.test.js",
    "describes": [
      {
        "title": "Group2D",
        "line": 6,
        "beforeEach": {
          "line": 10,
          "source": "group = new Group2D()"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor",
            "line": 15,
            "source": "expect(group).toBeInstanceOf(Object2D)\nexpect(group.children).toEqual([])"
          },
          {
            "title": "constructor with options",
            "line": 21,
            "source": "const g = new Group2D({\n    x: 10,\n    y: 20,\n    rotation: Math.PI,\n    scaleX: 2,\n    scaleY: 3,\n    opacity: 0.5,\n    visible: false\n})\n\nexpect(g.x).toBe(10)\nexpect(g.y).toBe(20)\nexpect(g.rotation).toBe(Math.PI)\nexpect(g.scaleX).toBe(2)\nexpect(g.scaleY).toBe(3)\nexpect(g.opacity).toBe(0.5)\nexpect(g.visible).toBe(false)"
          },
          {
            "title": "addChild",
            "line": 42,
            "source": "const child1 = new Object2D()\nconst child2 = new Object2D()\n\nconst result = group.addChild(child1, child2)\n\nexpect(group.children).toEqual([child1, child2])\nexpect(child1.parent).toBe(group)\nexpect(child2.parent).toBe(group)\nexpect(result).toBe(group)"
          },
          {
            "title": "addChild with single child",
            "line": 55,
            "source": "const child = new Object2D()\n\ngroup.addChild(child)\n\nexpect(group.children).toEqual([child])\nexpect(child.parent).toBe(group)"
          },
          {
            "title": "addChild is fluent",
            "line": 65,
            "source": "const child = new Object2D()\n\nconst result = group.addChild(child).setPosition(10, 20)\n\nexpect(result).toBe(group)\nexpect(group.x).toBe(10)\nexpect(group.y).toBe(20)"
          },
          {
            "title": "nested groups",
            "line": 76,
            "source": "const parent = new Group2D()\nconst child = new Group2D()\nconst grandchild = new Object2D()\n\nparent.addChild(child)\nchild.addChild(grandchild)\n\nexpect(parent.children).toEqual([child])\nexpect(child.children).toEqual([grandchild])\nexpect(child.parent).toBe(parent)\nexpect(grandchild.parent).toBe(child)"
          },
          {
            "title": "world matrix propagation",
            "line": 91,
            "source": "const parent = new Group2D()\nparent.x = 10\nparent.y = 20\n\nconst child = new Group2D()\nchild.x = 5\nchild.y = 5\n\nparent.addChild(child)\nparent.updateWorldMatrix()\n\nconst m = child.worldMatrix\nexpect(m[4]).toBeCloseTo(15)\nexpect(m[5]).toBeCloseTo(25)"
          },
          {
            "title": "getBounds returns zero bounds for empty group",
            "line": 109,
            "source": "const bounds = group.getBounds()\n\nexpect(bounds).toEqual({\n    minX: 0,\n    minY: 0,\n    maxX: 0,\n    maxY: 0,\n    width: 0,\n    height: 0\n})"
          },
          {
            "title": "getBounds calculates bounds from children",
            "line": 123,
            "source": "const child1 = new Object2D({x: 0, y: 0})\nchild1.getBounds = () => ({minX: -5, minY: -5, maxX: 5, maxY: 5, width: 10, height: 10})\n\nconst child2 = new Object2D({x: 10, y: 10})\nchild2.getBounds = () => ({minX: -2, minY: -2, maxX: 2, maxY: 2, width: 4, height: 4})\n\ngroup.addChild(child1, child2)\ngroup.updateWorldMatrix()\n\nconst bounds = group.getBounds()\n\nexpect(bounds.minX).toBe(-5)\nexpect(bounds.minY).toBe(-5)\nexpect(bounds.maxX).toBe(12)\nexpect(bounds.maxY).toBe(12)\nexpect(bounds.width).toBe(17)\nexpect(bounds.height).toBe(17)"
          },
          {
            "title": "getBounds ignores zero-size children",
            "line": 144,
            "source": "const child1 = new Object2D({x: 5, y: 5})\nchild1.getBounds = () => ({minX: -2, minY: -2, maxX: 2, maxY: 2, width: 4, height: 4})\n\nconst emptyChild = new Object2D({x: 100, y: 100})\nemptyChild.getBounds = () => ({minX: 0, minY: 0, maxX: 0, maxY: 0, width: 0, height: 0})\n\ngroup.addChild(child1, emptyChild)\ngroup.updateWorldMatrix()\n\nconst bounds = group.getBounds()\n\nexpect(bounds.minX).toBe(3)\nexpect(bounds.minY).toBe(3)\nexpect(bounds.maxX).toBe(7)\nexpect(bounds.maxY).toBe(7)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/render/object_2d.doc.js": {
    "file": "/render/object_2d.test.js",
    "describes": [
      {
        "title": "Object2D",
        "line": 5,
        "beforeEach": {
          "line": 9,
          "source": "object = new Object2D()"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor defaults",
            "line": 14,
            "source": "expect(object.visible).toBe(true)\nexpect(object.opacity).toBe(1)\nexpect(object.depth).toBe(0)\nexpect(object.anchorX).toBe(0.5)\nexpect(object.anchorY).toBe(0.5)\nexpect(object.x).toBe(0)\nexpect(object.y).toBe(0)\nexpect(object.rotation).toBe(0)\nexpect(object.scaleX).toBe(1)\nexpect(object.scaleY).toBe(1)"
          },
          {
            "title": "constructor with options",
            "line": 28,
            "source": "const obj = new Object2D({\n    x: 10,\n    y: 20,\n    rotation: Math.PI,\n    scaleX: 2,\n    scaleY: 3,\n    opacity: 0.5,\n    depth: 5,\n    visible: false,\n    anchorX: 0.25,\n    anchorY: 0.75,\n    pivotX: 5,\n    pivotY: 10\n})\n\nexpect(obj.x).toBe(10)\nexpect(obj.y).toBe(20)\nexpect(obj.rotation).toBe(Math.PI)\nexpect(obj.scaleX).toBe(2)\nexpect(obj.scaleY).toBe(3)\nexpect(obj.opacity).toBe(0.5)\nexpect(obj.depth).toBe(5)\nexpect(obj.visible).toBe(false)\nexpect(obj.anchorX).toBe(0.25)\nexpect(obj.anchorY).toBe(0.75)\nexpect(obj.pivotX).toBe(5)\nexpect(obj.pivotY).toBe(10)"
          },
          {
            "title": "setPosition",
            "line": 59,
            "source": "const result = object.setPosition(10, 20)\n\nexpect(object.x).toBe(10)\nexpect(object.y).toBe(20)\nexpect(result).toBe(object)"
          },
          {
            "title": "setRotation",
            "line": 68,
            "source": "const result = object.setRotation(Math.PI / 2)\n\nexpect(object.rotation).toBeCloseTo(Math.PI / 2)\nexpect(result).toBe(object)"
          },
          {
            "title": "setScale with two values",
            "line": 76,
            "source": "const result = object.setScale(2, 3)\n\nexpect(object.scaleX).toBe(2)\nexpect(object.scaleY).toBe(3)\nexpect(result).toBe(object)"
          },
          {
            "title": "setScale with one value",
            "line": 85,
            "source": "const result = object.setScale(2)\n\nexpect(object.scaleX).toBe(2)\nexpect(object.scaleY).toBe(2)\nexpect(result).toBe(object)"
          },
          {
            "title": "setOpacity",
            "line": 94,
            "source": "const result = object.setOpacity(0.5)\n\nexpect(object.opacity).toBe(0.5)\nexpect(result).toBe(object)"
          },
          {
            "title": "setDepth",
            "line": 102,
            "source": "const result = object.setDepth(10)\n\nexpect(object.depth).toBe(10)\nexpect(result).toBe(object)"
          },
          {
            "title": "setAnchor with two values",
            "line": 110,
            "source": "const result = object.setAnchor(0.25, 0.75)\n\nexpect(object.anchorX).toBe(0.25)\nexpect(object.anchorY).toBe(0.75)\nexpect(result).toBe(object)"
          },
          {
            "title": "setAnchor with one value",
            "line": 119,
            "source": "const result = object.setAnchor(0.25)\n\nexpect(object.anchorX).toBe(0.25)\nexpect(object.anchorY).toBe(0.25)\nexpect(result).toBe(object)"
          },
          {
            "title": "setPivot",
            "line": 128,
            "source": "const result = object.setPivot(5, 10)\n\nexpect(object.pivotX).toBe(5)\nexpect(object.pivotY).toBe(10)\nexpect(result).toBe(object)"
          },
          {
            "title": "render does nothing by default",
            "line": 137,
            "source": "expect(() => object.render({})).not.toThrow()"
          },
          {
            "title": "fluent interface",
            "line": 142,
            "source": "const result = object\n    .setPosition(10, 20)\n    .setRotation(Math.PI)\n    .setScale(2, 3)\n    .setOpacity(0.5)\n    .setDepth(7)\n    .setAnchor(0.25, 0.75)\n    .setPivot(5, 10)\n\nexpect(result).toBe(object)\nexpect(object.x).toBe(10)\nexpect(object.y).toBe(20)\nexpect(object.rotation).toBeCloseTo(Math.PI)\nexpect(object.scaleX).toBe(2)\nexpect(object.scaleY).toBe(3)\nexpect(object.opacity).toBe(0.5)\nexpect(object.depth).toBe(7)\nexpect(object.anchorX).toBe(0.25)\nexpect(object.anchorY).toBe(0.75)\nexpect(object.pivotX).toBe(5)\nexpect(object.pivotY).toBe(10)"
          },
          {
            "title": "getBounds default",
            "line": 167,
            "source": "const bounds = object.getBounds()\n\nexpect(bounds.minX).toBe(0)\nexpect(bounds.minY).toBe(0)\nexpect(bounds.maxX).toBe(0)\nexpect(bounds.maxY).toBe(0)\nexpect(bounds.width).toBe(0)\nexpect(bounds.height).toBe(0)"
          },
          {
            "title": "getWorldBounds with translation",
            "line": 179,
            "source": "object.x = 10\nobject.y = 20\nobject.getBounds = () => ({minX: 0, minY: 0, maxX: 10, maxY: 10, width: 10, height: 10})\nobject.updateWorldMatrix()\n\nconst bounds = object.getWorldBounds()\n\nexpect(bounds.minX).toBeCloseTo(10)\nexpect(bounds.minY).toBeCloseTo(20)\nexpect(bounds.maxX).toBeCloseTo(20)\nexpect(bounds.maxY).toBeCloseTo(30)"
          },
          {
            "title": "getWorldBounds with scale",
            "line": 194,
            "source": "object.scaleX = 2\nobject.scaleY = 2\nobject.getBounds = () => ({minX: 0, minY: 0, maxX: 10, maxY: 10, width: 10, height: 10})\nobject.updateWorldMatrix()\n\nconst bounds = object.getWorldBounds()\n\nexpect(bounds.width).toBeCloseTo(20)\nexpect(bounds.height).toBeCloseTo(20)"
          },
          {
            "title": "showDebugGizmos enables debug gizmos with defaults",
            "line": 207,
            "source": "const result = object.showDebugGizmos()\n\nexpect(object.debugGizmos).toEqual({\n    bounds: true,\n    anchor: true,\n    pivot: true,\n    origin: true\n})\nexpect(result).toBe(object)"
          },
          {
            "title": "showDebugGizmos with custom options",
            "line": 220,
            "source": "object.showDebugGizmos({\n    bounds: true,\n    anchor: false,\n    pivot: false,\n    origin: true\n})\n\nexpect(object.debugGizmos).toEqual({\n    bounds: true,\n    anchor: false,\n    pivot: false,\n    origin: true\n})"
          },
          {
            "title": "hideDebugGizmos disables debug gizmos",
            "line": 237,
            "source": "object.showDebugGizmos()\n\nexpect(object.debugGizmos).not.toBeNull()\n\nconst result = object.hideDebugGizmos()\n\nexpect(object.debugGizmos).toBeNull()\nexpect(result).toBe(object)"
          },
          {
            "title": "setVisible changes visible property",
            "line": 249,
            "source": "expect(object.visible).toBe(true)\n\nconst result = object.setVisible(false)\n\nexpect(object.visible).toBe(false)\nexpect(result).toBe(object)\n\nobject.setVisible(true)\n\nexpect(object.visible).toBe(true)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/render/rectangle.doc.js": {
    "file": "/render/rectangle.test.js",
    "describes": [
      {
        "title": "Rectangle",
        "line": 6,
        "beforeEach": {
          "line": 10,
          "source": "rectangle = new Rectangle()"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor defaults",
            "line": 15,
            "source": "expect(rectangle.width).toBe(10)\nexpect(rectangle.height).toBe(10)\nexpect(rectangle.color).toBe('#000000')\nexpect(rectangle.strokeColor).toBe('#000000')\nexpect(rectangle.strokeWidth).toBe(0)"
          },
          {
            "title": "constructor with options",
            "line": 24,
            "source": "const r = new Rectangle({\n    x: 10,\n    y: 20,\n    width: 100,\n    height: 50,\n    color: '#ff0000',\n    strokeColor: '#00ff00',\n    strokeWidth: 2,\n    opacity: 0.5,\n    rotation: Math.PI / 4\n})\n\nexpect(r.x).toBe(10)\nexpect(r.y).toBe(20)\nexpect(r.width).toBe(100)\nexpect(r.height).toBe(50)\nexpect(r.color).toBe('#ff0000')\nexpect(r.strokeColor).toBe('#00ff00')\nexpect(r.strokeWidth).toBe(2)\nexpect(r.opacity).toBe(0.5)\nexpect(r.rotation).toBeCloseTo(Math.PI / 4)"
          },
          {
            "title": "getBounds",
            "line": 49,
            "source": "rectangle.width = 100\nrectangle.height = 50\nrectangle.anchorX = 0.5\nrectangle.anchorY = 0.5\n\nconst bounds = rectangle.getBounds()\n\nexpect(bounds.minX).toBe(-50)\nexpect(bounds.minY).toBe(-25)\nexpect(bounds.maxX).toBe(50)\nexpect(bounds.maxY).toBe(25)\nexpect(bounds.width).toBe(100)\nexpect(bounds.height).toBe(50)"
          }
        ],
        "describes": []
      },
      {
        "title": "CanvasRectangleRenderer",
        "line": 68,
        "beforeEach": {
          "line": 73,
          "source": "renderer = new CanvasRectangleRenderer()\nctx = {\n    fillRect: vi.fn(),\n    strokeRect: vi.fn()\n}"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "handles Rectangle class",
            "line": 82,
            "source": "expect(CanvasRectangleRenderer.handles).toContain(Rectangle)"
          },
          {
            "title": "render without stroke",
            "line": 87,
            "source": "const rect = new Rectangle({\n    width: 100,\n    height: 50,\n    color: '#ff0000',\n    anchorX: 0.5,\n    anchorY: 0.5,\n    strokeWidth: 0\n})\n\nrenderer.render(rect, ctx)\n\nexpect(ctx.fillRect).toHaveBeenCalledWith(-50, -25, 100, 50)\nexpect(ctx.strokeRect).not.toHaveBeenCalled()"
          },
          {
            "title": "render with stroke",
            "line": 104,
            "source": "const rect = new Rectangle({\n    width: 100,\n    height: 50,\n    color: '#ff0000',\n    strokeColor: '#0000ff',\n    strokeWidth: 2,\n    anchorX: 0.5,\n    anchorY: 0.5\n})\n\nrenderer.render(rect, ctx)\n\nexpect(ctx.fillRect).toHaveBeenCalledWith(-50, -25, 100, 50)\nexpect(ctx.strokeRect).toHaveBeenCalledWith(-50, -25, 100, 50)"
          },
          {
            "title": "render with custom anchor",
            "line": 122,
            "source": "const rect = new Rectangle({\n    width: 100,\n    height: 50,\n    anchorX: 0,\n    anchorY: 0\n})\n\nrenderer.render(rect, ctx)\n\nexpect(ctx.fillRect).toHaveBeenCalledWith(-0, -0, 100, 50)"
          },
          {
            "title": "render with top-left anchor",
            "line": 136,
            "source": "const rect = new Rectangle({\n    width: 100,\n    height: 50,\n    anchorX: 1,\n    anchorY: 1\n})\n\nrenderer.render(rect, ctx)\n\nexpect(ctx.fillRect).toHaveBeenCalledWith(-100, -50, 100, 50)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/render/sprite.doc.js": {
    "file": "/render/sprite.test.js",
    "describes": [
      {
        "title": "Sprite",
        "line": 7,
        "beforeEach": {
          "line": 13,
          "source": "mockImage = {\n    width: 100,\n    height: 100,\n    naturalWidth: 100,\n    naturalHeight: 100,\n    complete: true\n}\nmockFrame = {\n    filename: 'frame1',\n    frame: {x: 0, y: 0, w: 10, h: 10},\n    image: mockImage\n}\nsprite = new Sprite({\n    frame: mockFrame,\n    width: 5\n})"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "initializes with frame and converts to region",
            "line": 33,
            "source": "expect(sprite.region).toBeInstanceOf(TextureRegion)\nexpect(sprite.region.width).toBe(10)\nexpect(sprite.region.height).toBe(10)\nexpect(sprite.width).toBe(5)\nexpect(sprite.height).toBeNull()"
          },
          {
            "title": "initializes with image",
            "line": 42,
            "source": "const s = new Sprite({image: mockImage})\n\nexpect(s.region).toBeInstanceOf(TextureRegion)\nexpect(s.image).toBe(mockImage)"
          },
          {
            "title": "initializes with region",
            "line": 50,
            "source": "const region = new TextureRegion({image: mockImage, x: 0, y: 0, width: 50, height: 50})\nconst s = new Sprite({region})\n\nexpect(s.region).toBe(region)"
          },
          {
            "title": "getBounds calculates bounds from region and width",
            "line": 58,
            "source": "const bounds = sprite.getBounds()\n\nexpect(bounds.width).toBe(5)\nexpect(bounds.height).toBe(5)"
          },
          {
            "title": "getBounds calculates bounds from region and height",
            "line": 66,
            "source": "sprite = new Sprite({\n    frame: mockFrame,\n    height: 10\n})\nconst bounds = sprite.getBounds()\n\nexpect(bounds.width).toBe(10)\nexpect(bounds.height).toBe(10)"
          },
          {
            "title": "addAnimation stores animation",
            "line": 78,
            "source": "const mockAnim = {\n    play: vi.fn(),\n    stop: vi.fn()\n}\n\nsprite.addAnimation('walk', mockAnim)\nexpect(sprite.animations.get('walk')).toBe(mockAnim)"
          },
          {
            "title": "play starts animation",
            "line": 89,
            "source": "const mockAnim = {\n    play: vi.fn(),\n    stop: vi.fn()\n}\n\nsprite.addAnimation('walk', mockAnim)\nsprite.play('walk')\n\nexpect(sprite.currentAnimation).toBe(mockAnim)\nexpect(mockAnim.play).toHaveBeenCalled()"
          },
          {
            "title": "stop stops current animation",
            "line": 103,
            "source": "const mockAnim = {\n    play: vi.fn(),\n    stop: vi.fn()\n}\n\nsprite.addAnimation('walk', mockAnim)\nsprite.play('walk')\nsprite.stop()\n\nexpect(sprite.currentAnimation).toBeNull()\nexpect(mockAnim.stop).toHaveBeenCalled()"
          },
          {
            "title": "setFrame updates region from legacy frame format",
            "line": 118,
            "source": "const newFrame = {\n    filename: 'frame2',\n    frame: {x: 10, y: 0, w: 20, h: 20},\n    image: mockImage\n}\n\nsprite.setFrame(newFrame)\n\nexpect(sprite.region).toBeInstanceOf(TextureRegion)\nexpect(sprite.region.x).toBe(10)\nexpect(sprite.region.width).toBe(20)"
          },
          {
            "title": "setFrame accepts TextureRegion directly",
            "line": 133,
            "source": "const region = new TextureRegion({image: mockImage, x: 32, y: 64, width: 16, height: 16})\n\nsprite.setFrame(region)\n\nexpect(sprite.region).toBe(region)"
          },
          {
            "title": "image setter updates region",
            "line": 142,
            "source": "const newImage = {width: 200, height: 200}\nsprite.image = newImage\n\nexpect(sprite.image).toBe(newImage)\nexpect(sprite.region).toBeInstanceOf(TextureRegion)\nexpect(sprite.region.width).toBe(200)"
          },
          {
            "title": "image setter with null clears region",
            "line": 152,
            "source": "sprite.image = null\n\nexpect(sprite.image).toBeNull()\nexpect(sprite.region).toBeNull()"
          }
        ],
        "describes": []
      },
      {
        "title": "CanvasSpriteRenderer",
        "line": 162,
        "beforeEach": {
          "line": 169,
          "source": "renderer = new CanvasSpriteRenderer()\nctx = {\n    save: vi.fn(),\n    restore: vi.fn(),\n    scale: vi.fn(),\n    drawImage: vi.fn(),\n    translate: vi.fn(),\n    rotate: vi.fn()\n}\nmockImage = {\n    width: 100,\n    height: 100,\n    naturalWidth: 100,\n    naturalHeight: 100,\n    complete: true\n}\nmockFrame = {\n    filename: 'frame1',\n    frame: {x: 0, y: 0, w: 10, h: 10},\n    image: mockImage\n}"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "handles Sprite class",
            "line": 194,
            "source": "expect(CanvasSpriteRenderer.handles).toContain(Sprite)"
          },
          {
            "title": "render draws frame using region data",
            "line": 199,
            "source": "const sprite = new Sprite({\n    frame: mockFrame,\n    width: 5\n})\n\nrenderer.render(sprite, ctx)\n\nexpect(ctx.drawImage).toHaveBeenCalledWith(\n    mockImage,\n    0, 0, 10, 10,\n    expect.any(Number), expect.any(Number),\n    5, 5\n)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/render/transform.doc.js": {
    "file": "/render/transform.test.js",
    "describes": [
      {
        "title": "Transform",
        "line": 5,
        "beforeEach": {
          "line": 9,
          "source": "transform = new Transform()"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor",
            "line": 14,
            "source": "expect(transform.x).toBe(0)\nexpect(transform.y).toBe(0)\nexpect(transform.rotation).toBe(0)\nexpect(transform.scaleX).toBe(1)\nexpect(transform.scaleY).toBe(1)\nexpect(transform.pivotX).toBe(0)\nexpect(transform.pivotY).toBe(0)\nexpect(transform.parent).toBe(null)\nexpect(transform.children).toEqual([])"
          },
          {
            "title": "add child",
            "line": 27,
            "source": "const child1 = new Transform()\nconst child2 = new Transform()\n\ntransform.add(child1, child2)\n\nexpect(transform.children).toEqual([child1, child2])\nexpect(child1.parent).toBe(transform)\nexpect(child2.parent).toBe(transform)"
          },
          {
            "title": "add child removes from previous parent",
            "line": 39,
            "source": "const parent1 = new Transform()\nconst parent2 = new Transform()\nconst child = new Transform()\n\nparent1.add(child)\nexpect(parent1.children).toEqual([child])\nexpect(child.parent).toBe(parent1)\n\nparent2.add(child)\nexpect(parent1.children).toEqual([])\nexpect(parent2.children).toEqual([child])\nexpect(child.parent).toBe(parent2)"
          },
          {
            "title": "remove child",
            "line": 55,
            "source": "const child = new Transform()\n\ntransform.add(child)\nexpect(transform.children).toEqual([child])\n\ntransform.remove(child)\nexpect(transform.children).toEqual([])\nexpect(child.parent).toBe(null)"
          },
          {
            "title": "updateLocalMatrix identity",
            "line": 67,
            "source": "transform.updateLocalMatrix()\nconst m = transform.worldMatrix\n\nexpect(m[0]).toBeCloseTo(1)\nexpect(m[1]).toBeCloseTo(0)\nexpect(m[2]).toBeCloseTo(0)\nexpect(m[3]).toBeCloseTo(1)\nexpect(m[4]).toBeCloseTo(0)\nexpect(m[5]).toBeCloseTo(0)"
          },
          {
            "title": "updateLocalMatrix with translation",
            "line": 80,
            "source": "transform.x = 10\ntransform.y = 20\ntransform.updateWorldMatrix()\nconst m = transform.worldMatrix\n\nexpect(m[0]).toBeCloseTo(1)\nexpect(m[1]).toBeCloseTo(0)\nexpect(m[2]).toBeCloseTo(0)\nexpect(m[3]).toBeCloseTo(1)\nexpect(m[4]).toBeCloseTo(10)\nexpect(m[5]).toBeCloseTo(20)"
          },
          {
            "title": "updateLocalMatrix with rotation",
            "line": 95,
            "source": "transform.rotation = Math.PI / 2\ntransform.updateWorldMatrix()\nconst m = transform.worldMatrix\n\nexpect(m[0]).toBeCloseTo(0)\nexpect(m[1]).toBeCloseTo(1)\nexpect(m[2]).toBeCloseTo(-1)\nexpect(m[3]).toBeCloseTo(0)\nexpect(m[4]).toBeCloseTo(0)\nexpect(m[5]).toBeCloseTo(0)"
          },
          {
            "title": "updateLocalMatrix with scale",
            "line": 109,
            "source": "transform.scaleX = 2\ntransform.scaleY = 3\ntransform.updateWorldMatrix()\nconst m = transform.worldMatrix\n\nexpect(m[0]).toBeCloseTo(2)\nexpect(m[1]).toBeCloseTo(0)\nexpect(m[2]).toBeCloseTo(0)\nexpect(m[3]).toBeCloseTo(3)\nexpect(m[4]).toBeCloseTo(0)\nexpect(m[5]).toBeCloseTo(0)"
          },
          {
            "title": "updateWorldMatrix without parent",
            "line": 124,
            "source": "transform.x = 5\ntransform.y = 10\ntransform.updateWorldMatrix()\nconst m = transform.worldMatrix\n\nexpect(m[4]).toBeCloseTo(5)\nexpect(m[5]).toBeCloseTo(10)"
          },
          {
            "title": "updateWorldMatrix with parent",
            "line": 135,
            "source": "const parent = new Transform()\nparent.x = 10\nparent.y = 20\n\nconst child = new Transform()\nchild.x = 5\nchild.y = 5\n\nparent.add(child)\nparent.updateWorldMatrix()\n\nconst m = child.worldMatrix\nexpect(m[4]).toBeCloseTo(15)\nexpect(m[5]).toBeCloseTo(25)"
          },
          {
            "title": "markDirty propagates to children",
            "line": 153,
            "source": "const child1 = new Transform()\nconst child2 = new Transform()\n\ntransform.add(child1)\nchild1.add(child2)\n\ntransform.updateWorldMatrix()\nchild1.updateWorldMatrix()\nchild2.updateWorldMatrix()\n\ntransform.markDirty()\n\ntransform.x = 100\ntransform.updateWorldMatrix()\n\nconst m = child2.worldMatrix\nexpect(m[4]).toBeCloseTo(100)"
          },
          {
            "title": "getSortedChildren returns children sorted by depth",
            "line": 174,
            "source": "const child1 = new Transform()\nchild1.depth = 2\nconst child2 = new Transform()\nchild2.depth = 0\nconst child3 = new Transform()\nchild3.depth = 1\n\ntransform.add(child1, child2, child3)\n\nconst sorted = transform.getSortedChildren()\n\nexpect(sorted[0]).toBe(child2)\nexpect(sorted[1]).toBe(child3)\nexpect(sorted[2]).toBe(child1)"
          },
          {
            "title": "getSortedChildren caches result",
            "line": 192,
            "source": "const child1 = new Transform()\nchild1.depth = 1\nconst child2 = new Transform()\nchild2.depth = 0\n\ntransform.add(child1, child2)\n\nconst sorted1 = transform.getSortedChildren()\nconst sorted2 = transform.getSortedChildren()\n\nexpect(sorted1).toBe(sorted2)"
          },
          {
            "title": "markChildrenNeedSort invalidates cache",
            "line": 207,
            "source": "const child1 = new Transform()\nchild1.depth = 1\nconst child2 = new Transform()\nchild2.depth = 0\n\ntransform.add(child1, child2)\n\nconst sorted1 = transform.getSortedChildren()\ntransform.markChildrenNeedSort()\nconst sorted2 = transform.getSortedChildren()\n\nexpect(sorted1).not.toBe(sorted2)"
          },
          {
            "title": "add triggers re-sort on next getSortedChildren call",
            "line": 223,
            "source": "const child1 = new Transform()\nchild1.depth = 1\n\ntransform.add(child1)\ntransform.getSortedChildren()\n\nconst child2 = new Transform()\nchild2.depth = 0\ntransform.add(child2)\n\nconst sorted2 = transform.getSortedChildren()\nexpect(sorted2[0]).toBe(child2)\nexpect(sorted2[1]).toBe(child1)"
          },
          {
            "title": "remove triggers re-sort on next getSortedChildren call",
            "line": 240,
            "source": "const child1 = new Transform()\nchild1.depth = 0\nconst child2 = new Transform()\nchild2.depth = 1\n\ntransform.add(child1, child2)\nconst sorted1 = transform.getSortedChildren()\nexpect(sorted1.length).toBe(2)\n\ntransform.remove(child1)\nconst sorted2 = transform.getSortedChildren()\nexpect(sorted2.length).toBe(1)\nexpect(sorted2[0]).toBe(child2)"
          },
          {
            "title": "transformPoint with identity matrix",
            "line": 257,
            "source": "transform.updateWorldMatrix()\n\nconst result = transform.transformPoint({x: 10, y: 20})\n\nexpect(result.x).toBeCloseTo(10)\nexpect(result.y).toBeCloseTo(20)"
          },
          {
            "title": "transformPoint with translation",
            "line": 267,
            "source": "transform.x = 5\ntransform.y = 10\ntransform.updateWorldMatrix()\n\nconst result = transform.transformPoint({x: 10, y: 20})\n\nexpect(result.x).toBeCloseTo(15)\nexpect(result.y).toBeCloseTo(30)"
          },
          {
            "title": "transformPoint with scale",
            "line": 279,
            "source": "transform.scaleX = 2\ntransform.scaleY = 3\ntransform.updateWorldMatrix()\n\nconst result = transform.transformPoint({x: 10, y: 20})\n\nexpect(result.x).toBeCloseTo(20)\nexpect(result.y).toBeCloseTo(60)"
          },
          {
            "title": "transformPoint with rotation",
            "line": 291,
            "source": "transform.rotation = Math.PI / 2\ntransform.updateWorldMatrix()\n\nconst result = transform.transformPoint({x: 10, y: 0})\n\nexpect(result.x).toBeCloseTo(0)\nexpect(result.y).toBeCloseTo(10)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/render/textures/texture_atlas.doc.js": {
    "file": "/render/textures/texture_atlas.test.js",
    "describes": [
      {
        "title": "TextureAtlas",
        "line": 43,
        "beforeEach": {
          "line": 47,
          "source": "atlas = new TextureAtlas({width: 256, height: 256})"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "regionCount counts added regions",
            "line": 195,
            "source": "expect(atlas.regionCount).toBe(0)\n\natlas.add('s1', createMockImage(32, 32))\nexpect(atlas.regionCount).toBe(1)\n\natlas.add('s2', createMockImage(32, 32))\nexpect(atlas.regionCount).toBe(2)"
          },
          {
            "title": "markClean clears dirty flag",
            "line": 206,
            "source": "atlas.add('sprite1', createMockImage(32, 32))\nexpect(atlas.dirty).toBe(true)\n\natlas.markClean()\nexpect(atlas.dirty).toBe(false)"
          }
        ],
        "describes": [
          {
            "title": "constructor",
            "line": 52,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "default dimensions",
                "line": 54,
                "source": "const defaultAtlas = new TextureAtlas()\nexpect(defaultAtlas.width).toBe(2048)\nexpect(defaultAtlas.height).toBe(2048)"
              },
              {
                "title": "custom dimensions",
                "line": 61,
                "source": "expect(atlas.width).toBe(256)\nexpect(atlas.height).toBe(256)"
              },
              {
                "title": "creates canvas",
                "line": 67,
                "source": "expect(atlas.canvas).toBeDefined()\nexpect(atlas.canvas.width).toBe(256)"
              }
            ],
            "describes": []
          },
          {
            "title": "add",
            "line": 75,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "adds image and returns region",
                "line": 77,
                "source": "const image = createMockImage(32, 32)\nconst region = atlas.add('sprite1', image)\n\nexpect(region).not.toBeNull()\nexpect(region.width).toBe(32)\nexpect(region.height).toBe(32)\nexpect(region.image).toBe(atlas.canvas)"
              },
              {
                "title": "marks atlas as dirty",
                "line": 88,
                "source": "expect(atlas.dirty).toBe(false)\n\nconst image = createMockImage(32, 32)\natlas.add('sprite1', image)\n\nexpect(atlas.dirty).toBe(true)"
              },
              {
                "title": "returns existing region for duplicate id",
                "line": 98,
                "source": "const image1 = createMockImage(32, 32)\nconst image2 = createMockImage(64, 64)\n\nconst region1 = atlas.add('sprite1', image1)\nconst region2 = atlas.add('sprite1', image2)\n\nexpect(region1).toBe(region2)\nexpect(region2.width).toBe(32)"
              },
              {
                "title": "places images without overlap",
                "line": 110,
                "source": "const image1 = createMockImage(64, 64)\nconst image2 = createMockImage(64, 64)\n\nconst region1 = atlas.add('sprite1', image1)\nconst region2 = atlas.add('sprite2', image2)\n\nconst noOverlap = region1.x + region1.width <= region2.x ||\n                  region2.x + region2.width <= region1.x ||\n                  region1.y + region1.height <= region2.y ||\n                  region2.y + region2.height <= region1.y ||\n                  (region1.x === region2.x && region1.y !== region2.y) ||\n                  (region1.y === region2.y && region1.x !== region2.x)\n\nexpect(noOverlap).toBe(true)"
              },
              {
                "title": "returns null when atlas is full",
                "line": 128,
                "source": "const largeImage = createMockImage(250, 250)\natlas.add('large', largeImage)\n\nconst anotherLarge = createMockImage(200, 200)\nconst result = atlas.add('another', anotherLarge)\n\nexpect(result).toBeNull()"
              }
            ],
            "describes": []
          },
          {
            "title": "get",
            "line": 141,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns region by id",
                "line": 143,
                "source": "const image = createMockImage(32, 32)\natlas.add('sprite1', image)\n\nconst region = atlas.get('sprite1')\n\nexpect(region).not.toBeNull()\nexpect(region.width).toBe(32)"
              },
              {
                "title": "returns null for unknown id",
                "line": 154,
                "source": "expect(atlas.get('unknown')).toBeNull()"
              }
            ],
            "describes": []
          },
          {
            "title": "has",
            "line": 161,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns true for existing id",
                "line": 163,
                "source": "const image = createMockImage(32, 32)\natlas.add('sprite1', image)\n\nexpect(atlas.has('sprite1')).toBe(true)"
              },
              {
                "title": "returns false for unknown id",
                "line": 171,
                "source": "expect(atlas.has('unknown')).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "canFit",
            "line": 178,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns true when space available",
                "line": 180,
                "source": "expect(atlas.canFit(64, 64)).toBe(true)"
              },
              {
                "title": "returns false when no space",
                "line": 185,
                "source": "const largeImage = createMockImage(250, 250)\natlas.add('large', largeImage)\n\nexpect(atlas.canFit(200, 200)).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "clear",
            "line": 215,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "removes all regions",
                "line": 217,
                "source": "atlas.add('s1', createMockImage(32, 32))\natlas.add('s2', createMockImage(32, 32))\n\natlas.clear()\n\nexpect(atlas.regionCount).toBe(0)\nexpect(atlas.has('s1')).toBe(false)"
              },
              {
                "title": "allows adding new images after clear",
                "line": 228,
                "source": "const largeImage = createMockImage(250, 250)\natlas.add('large', largeImage)\n\natlas.clear()\n\nconst region = atlas.add('new', createMockImage(100, 100))\nexpect(region).not.toBeNull()"
              }
            ],
            "describes": []
          },
          {
            "title": "full",
            "line": 241,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "false initially",
                "line": 243,
                "source": "expect(atlas.full).toBe(false)"
              },
              {
                "title": "true when no more space",
                "line": 248,
                "source": "const largeImage = createMockImage(250, 250)\natlas.add('large', largeImage)\n\natlas.add('overflow', createMockImage(200, 200))\n\nexpect(atlas.full).toBe(true)"
              }
            ],
            "describes": []
          },
          {
            "title": "getAllRegions",
            "line": 260,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns map of all regions",
                "line": 262,
                "source": "atlas.add('s1', createMockImage(32, 32))\natlas.add('s2', createMockImage(48, 48))\n\nconst regions = atlas.getAllRegions()\n\nexpect(regions).toBeInstanceOf(Map)\nexpect(regions.size).toBe(2)\nexpect(regions.has('s1')).toBe(true)\nexpect(regions.has('s2')).toBe(true)"
              },
              {
                "title": "returns empty map when no regions",
                "line": 275,
                "source": "const regions = atlas.getAllRegions()\n\nexpect(regions).toBeInstanceOf(Map)\nexpect(regions.size).toBe(0)"
              }
            ],
            "describes": []
          },
          {
            "title": "static properties",
            "line": 285,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "DEFAULT_SIZE",
                "line": 287,
                "source": "expect(TextureAtlas.DEFAULT_SIZE).toBe(2048)"
              },
              {
                "title": "MAX_SIZE",
                "line": 292,
                "source": "expect(TextureAtlas.MAX_SIZE).toBe(4096)"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/render/textures/texture_region.doc.js": {
    "file": "/render/textures/texture_region.test.js",
    "describes": [
      {
        "title": "TextureRegion",
        "line": 10,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "bounds returns bounds object",
            "line": 115,
            "source": "const image = createMockImage(256, 256)\nconst region = new TextureRegion({\n    image,\n    x: 10,\n    y: 20,\n    width: 30,\n    height: 40\n})\n\nconst bounds = region.bounds\n\nexpect(bounds.x).toBe(10)\nexpect(bounds.y).toBe(20)\nexpect(bounds.width).toBe(30)\nexpect(bounds.height).toBe(40)"
          }
        ],
        "describes": [
          {
            "title": "constructor",
            "line": 12,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "default values",
                "line": 14,
                "source": "const region = new TextureRegion()\n\nexpect(region.image).toBe(null)\nexpect(region.x).toBe(0)\nexpect(region.y).toBe(0)\nexpect(region.width).toBe(0)\nexpect(region.height).toBe(0)"
              },
              {
                "title": "derives dimensions from image",
                "line": 25,
                "source": "const image = createMockImage(128, 64)\nconst region = new TextureRegion({image})\n\nexpect(region.image).toBe(image)\nexpect(region.width).toBe(128)\nexpect(region.height).toBe(64)"
              },
              {
                "title": "accepts explicit dimensions",
                "line": 35,
                "source": "const image = createMockImage(256, 256)\nconst region = new TextureRegion({\n    image,\n    x: 32,\n    y: 64,\n    width: 48,\n    height: 32\n})\n\nexpect(region.x).toBe(32)\nexpect(region.y).toBe(64)\nexpect(region.width).toBe(48)\nexpect(region.height).toBe(32)"
              }
            ],
            "describes": []
          },
          {
            "title": "UV coordinates",
            "line": 54,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "full image UVs",
                "line": 56,
                "source": "const image = createMockImage(256, 256)\nconst region = new TextureRegion({image})\n\nexpect(region.u0).toBe(0)\nexpect(region.v0).toBe(0)\nexpect(region.u1).toBe(1)\nexpect(region.v1).toBe(1)"
              },
              {
                "title": "sub-region UVs",
                "line": 67,
                "source": "const image = createMockImage(256, 256)\nconst region = new TextureRegion({\n    image,\n    x: 64,\n    y: 128,\n    width: 64,\n    height: 64\n})\n\nexpect(region.u0).toBe(0.25)\nexpect(region.v0).toBe(0.5)\nexpect(region.u1).toBe(0.5)\nexpect(region.v1).toBe(0.75)"
              },
              {
                "title": "default UVs when no image",
                "line": 84,
                "source": "const region = new TextureRegion()\n\nexpect(region.u0).toBe(0)\nexpect(region.v0).toBe(0)\nexpect(region.u1).toBe(1)\nexpect(region.v1).toBe(1)"
              },
              {
                "title": "uvs getter",
                "line": 94,
                "source": "const image = createMockImage(100, 100)\nconst region = new TextureRegion({\n    image,\n    x: 10,\n    y: 20,\n    width: 30,\n    height: 40\n})\n\nconst uvs = region.uvs\n\nexpect(uvs.u0).toBe(0.1)\nexpect(uvs.v0).toBe(0.2)\nexpect(uvs.u1).toBe(0.4)\nexpect(uvs.v1).toBe(0.6)"
              }
            ],
            "describes": []
          },
          {
            "title": "valid",
            "line": 134,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "invalid without image",
                "line": 136,
                "source": "const region = new TextureRegion({width: 10, height: 10})\nexpect(region.valid).toBe(false)"
              },
              {
                "title": "invalid with zero dimensions",
                "line": 142,
                "source": "const image = createMockImage()\nconst region = new TextureRegion({image, width: 0, height: 10})\nexpect(region.valid).toBe(false)"
              },
              {
                "title": "valid with image and dimensions",
                "line": 149,
                "source": "const image = createMockImage()\nconst region = new TextureRegion({image, width: 10, height: 10})\nexpect(region.valid).toBe(true)"
              }
            ],
            "describes": []
          },
          {
            "title": "fromImage",
            "line": 158,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates region covering full image",
                "line": 160,
                "source": "const image = createMockImage(200, 100)\nconst region = TextureRegion.fromImage(image)\n\nexpect(region.image).toBe(image)\nexpect(region.x).toBe(0)\nexpect(region.y).toBe(0)\nexpect(region.width).toBe(200)\nexpect(region.height).toBe(100)"
              },
              {
                "title": "handles null image",
                "line": 172,
                "source": "const region = TextureRegion.fromImage(null)\n\nexpect(region.image).toBe(null)\nexpect(region.width).toBe(0)\nexpect(region.height).toBe(0)"
              }
            ],
            "describes": []
          },
          {
            "title": "fromFrame",
            "line": 183,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates region from frame with w/h",
                "line": 185,
                "source": "const image = createMockImage(512, 512)\nconst frame = {x: 100, y: 200, w: 50, h: 60}\nconst region = TextureRegion.fromFrame(image, frame)\n\nexpect(region.image).toBe(image)\nexpect(region.x).toBe(100)\nexpect(region.y).toBe(200)\nexpect(region.width).toBe(50)\nexpect(region.height).toBe(60)"
              },
              {
                "title": "creates region from frame with width/height",
                "line": 198,
                "source": "const image = createMockImage(512, 512)\nconst frame = {x: 10, y: 20, width: 30, height: 40}\nconst region = TextureRegion.fromFrame(image, frame)\n\nexpect(region.width).toBe(30)\nexpect(region.height).toBe(40)"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/render/textures/texture_system.doc.js": {
    "file": "/render/textures/texture_system.test.js",
    "describes": [
      {
        "title": "TextureSystem",
        "line": 43,
        "beforeEach": {
          "line": 47,
          "source": "system = new TextureSystem({atlasSize: 256})"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor initializes with atlas manager",
            "line": 52,
            "source": "expect(system.atlasManager).toBeDefined()\nexpect(system.regionCount).toBe(0)"
          },
          {
            "title": "addRegions adds multiple images",
            "line": 80,
            "source": "const images = {\n    s1: createMockImage(32, 32),\n    s2: createMockImage(48, 48)\n}\n\nsystem.addRegions(images)\n\nexpect(system.regionCount).toBe(2)"
          },
          {
            "title": "atlases returns list of atlases",
            "line": 189,
            "source": "system.addRegion('s1', createMockImage(32, 32))\n\nexpect(system.atlases.length).toBe(1)"
          },
          {
            "title": "clear removes all regions",
            "line": 215,
            "source": "system.addRegion('s1', createMockImage(32, 32))\nsystem.registerManualAtlas('atlas', createMockImage(256, 256), {\n    frame1: {x: 0, y: 0, w: 32, h: 32}\n})\n\nsystem.clear()\n\nexpect(system.regionCount).toBe(0)\nexpect(system.hasRegion('s1')).toBe(false)\nexpect(system.hasRegion('atlas:frame1')).toBe(false)"
          },
          {
            "title": "onInstall delegates methods to host",
            "line": 229,
            "source": "const host = {}\nsystem.onInstall(host)\n\nexpect(host.getRegion).toBeDefined()\nexpect(host.hasRegion).toBeDefined()\nexpect(host.addRegion).toBeDefined()"
          },
          {
            "title": "onDispose clears all regions",
            "line": 239,
            "source": "system.addRegion('s1', createMockImage(32, 32))\nsystem.registerManualAtlas('atlas', createMockImage(256, 256), {\n    frame1: {x: 0, y: 0, w: 32, h: 32}\n})\n\nsystem.onDispose()\n\nexpect(system.regionCount).toBe(0)\nexpect(system.hasRegion('s1')).toBe(false)\nexpect(system.hasRegion('atlas:frame1')).toBe(false)"
          }
        ],
        "describes": [
          {
            "title": "addRegion",
            "line": 58,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "adds image to atlas",
                "line": 60,
                "source": "const image = createMockImage(32, 32)\nconst region = system.addRegion('sprite1', image)\n\nexpect(region).not.toBeNull()\nexpect(region.width).toBe(32)"
              },
              {
                "title": "returns existing region for duplicate",
                "line": 69,
                "source": "const image = createMockImage(32, 32)\nconst region1 = system.addRegion('sprite1', image)\nconst region2 = system.addRegion('sprite1', createMockImage(64, 64))\n\nexpect(region1).toBe(region2)"
              }
            ],
            "describes": []
          },
          {
            "title": "getRegion",
            "line": 92,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns region by id",
                "line": 94,
                "source": "system.addRegion('sprite1', createMockImage(32, 32))\nconst region = system.getRegion('sprite1')\n\nexpect(region).not.toBeNull()"
              },
              {
                "title": "returns null for unknown",
                "line": 102,
                "source": "expect(system.getRegion('unknown')).toBeNull()"
              }
            ],
            "describes": []
          },
          {
            "title": "hasRegion",
            "line": 109,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns true for existing",
                "line": 111,
                "source": "system.addRegion('sprite1', createMockImage(32, 32))\nexpect(system.hasRegion('sprite1')).toBe(true)"
              },
              {
                "title": "returns false for unknown",
                "line": 117,
                "source": "expect(system.hasRegion('unknown')).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "registerManualAtlas",
            "line": 124,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "registers frames from manual atlas",
                "line": 126,
                "source": "const atlasImage = createMockImage(256, 256)\nconst frames = {\n    idle: {x: 0, y: 0, w: 32, h: 32},\n    walk: {x: 32, y: 0, w: 32, h: 32}\n}\n\nsystem.registerManualAtlas('player', atlasImage, frames)\n\nexpect(system.hasRegion('player:idle')).toBe(true)\nexpect(system.hasRegion('player:walk')).toBe(true)"
              },
              {
                "title": "creates correct regions from frames",
                "line": 140,
                "source": "const atlasImage = createMockImage(256, 256)\nconst frames = {\n    frame1: {x: 64, y: 128, w: 32, h: 48}\n}\n\nsystem.registerManualAtlas('atlas', atlasImage, frames)\n\nconst region = system.getRegion('atlas:frame1')\n\nexpect(region.x).toBe(64)\nexpect(region.y).toBe(128)\nexpect(region.width).toBe(32)\nexpect(region.height).toBe(48)"
              }
            ],
            "describes": []
          },
          {
            "title": "buildFromAssets",
            "line": 159,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "builds atlas from image assets",
                "line": 161,
                "source": "const assets = [\n    {id: 'img1', type: 'image', source: createMockImage(32, 32)},\n    {id: 'img2', type: 'image', source: createMockImage(48, 48)},\n    {id: 'sound1', type: 'audio', source: {}}\n]\n\nsystem.buildFromAssets(assets)\n\nexpect(system.hasRegion('img1')).toBe(true)\nexpect(system.hasRegion('img2')).toBe(true)\nexpect(system.hasRegion('sound1')).toBe(false)"
              },
              {
                "title": "skips assets without source",
                "line": 176,
                "source": "const assets = [\n    {id: 'img1', type: 'image', source: null}\n]\n\nsystem.buildFromAssets(assets)\n\nexpect(system.hasRegion('img1')).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "getDirtyAtlases",
            "line": 196,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns dirty atlases",
                "line": 198,
                "source": "system.addRegion('s1', createMockImage(32, 32))\n\nexpect(system.getDirtyAtlases().length).toBe(1)"
              },
              {
                "title": "empty after markAllClean",
                "line": 205,
                "source": "system.addRegion('s1', createMockImage(32, 32))\nsystem.markAllClean()\n\nexpect(system.getDirtyAtlases().length).toBe(0)"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/input/input_system.doc.js": {
    "file": "/input/input_system.test.js",
    "describes": [
      {
        "title": "InputSystem",
        "line": 11,
        "beforeEach": {
          "line": 16,
          "source": "mockHost = new PerkyModule({name: 'mockHost'})\nmockHost.actionDispatcher = {\n    dispatchAction: vi.fn()\n}\n\ninputSystem = new InputSystem()\ninputSystem.install(mockHost)"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor creates InputBinder",
            "line": 27,
            "source": "expect(inputSystem.inputBinder).toBeInstanceOf(InputBinder)"
          },
          {
            "title": "onInstall creates keyboard and mouse devices",
            "line": 32,
            "source": "expect(inputSystem.getDevice('keyboard')).toBeInstanceOf(KeyboardDevice)\nexpect(inputSystem.getDevice('mouse')).toBeInstanceOf(MouseDevice)"
          },
          {
            "title": "onInstall registers devices with $bind",
            "line": 38,
            "source": "expect(inputSystem.getDevice('keyboard')).toBe(inputSystem.keyboard)\nexpect(inputSystem.getDevice('mouse')).toBe(inputSystem.mouse)"
          },
          {
            "title": "onInstall delegates device management methods to host",
            "line": 44,
            "source": "expect(typeof mockHost.registerDevice).toBe('function')\nexpect(typeof mockHost.getDevice).toBe('function')\nexpect(typeof mockHost.isPressed).toBe('function')\nexpect(typeof mockHost.getControl).toBe('function')"
          },
          {
            "title": "onInstall delegates InputBinder methods to host",
            "line": 52,
            "source": "expect(typeof mockHost.bindInput).toBe('function')\nexpect(typeof mockHost.unbind).toBe('function')\nexpect(typeof mockHost.getBinding).toBe('function')\nexpect(typeof mockHost.hasBinding).toBe('function')"
          },
          {
            "title": "onInstall adds convenience methods to host",
            "line": 60,
            "source": "expect(typeof mockHost.isKeyPressed).toBe('function')\nexpect(typeof mockHost.isMousePressed).toBe('function')\nexpect(typeof mockHost.isActionPressed).toBe('function')\nexpect(typeof mockHost.getActionControls).toBe('function')"
          },
          {
            "title": "registerDevice",
            "line": 70,
            "source": "const device = inputSystem.registerDevice(InputDevice, {$id: 'gamepad', $bind: 'gamepad'})\n\nexpect(inputSystem.getDevice('gamepad')).toBe(device)\nexpect(device.host).toBe(inputSystem)\nexpect(inputSystem.gamepad).toBe(device)"
          },
          {
            "title": "registerDevice with duplicate name replaces device",
            "line": 79,
            "source": "inputSystem.registerDevice(InputDevice, {$id: 'test', $bind: 'test'})\nconst device2 = inputSystem.registerDevice(InputDevice, {$id: 'test', $bind: 'test'})\n\nexpect(inputSystem.getDevice('test')).toBe(device2)\nexpect(inputSystem.test).toBe(device2)"
          },
          {
            "title": "isPressed",
            "line": 88,
            "source": "const button = inputSystem.keyboard.findOrCreateControl(ButtonControl, {name: 'TestButton'})\n\nexpect(inputSystem.isPressed('keyboard', 'TestButton')).toBe(false)\nexpect(inputSystem.isPressed('nonExistent', 'TestButton')).toBe(false)\nexpect(inputSystem.isPressed('keyboard', 'nonExistent')).toBe(false)\n\nbutton.press()\nexpect(inputSystem.isPressed('keyboard', 'TestButton')).toBe(true)\n\nbutton.release()\nexpect(inputSystem.isPressed('keyboard', 'TestButton')).toBe(false)"
          },
          {
            "title": "getValueFor",
            "line": 103,
            "source": "const button = inputSystem.mouse.findOrCreateControl(ButtonControl, {name: 'TestButton'})\nbutton.value = 0.5\n\nexpect(inputSystem.getValueFor('mouse', 'TestButton')).toBe(0.5)\nexpect(inputSystem.getValueFor('nonExistent', 'TestButton')).toBeUndefined()\nexpect(inputSystem.getValueFor('mouse', 'nonExistent')).toBeUndefined()"
          },
          {
            "title": "getControl",
            "line": 113,
            "source": "const device = inputSystem.registerDevice(InputDevice, {$id: 'gamepad', $bind: 'gamepad'})\nconst button = device.findOrCreateControl(ButtonControl, {name: 'TestButton'})\n\nexpect(inputSystem.getControl('gamepad', 'TestButton')).toBe(button)\nexpect(inputSystem.getControl('nonExistent', 'TestButton')).toBeNull()\nexpect(inputSystem.getControl('gamepad', 'nonExistent')).toBeNull()"
          },
          {
            "title": "automatic lifecycle management",
            "line": 123,
            "source": "inputSystem.start()\nconst device = inputSystem.registerDevice(InputDevice, {$id: 'auto', $bind: 'auto'})\n\nexpect(device.started).toBe(true)"
          },
          {
            "title": "event forwarding",
            "line": 131,
            "source": "const device = inputSystem.registerDevice(InputDevice, {$id: 'test', $bind: 'test'})\n\nconst pressedListener = vi.fn()\nconst releasedListener = vi.fn()\nconst updatedListener = vi.fn()\n\ninputSystem.on('control:pressed', pressedListener)\ninputSystem.on('control:released', releasedListener)\ninputSystem.on('control:updated', updatedListener)\n\nconst button = device.findOrCreateControl(ButtonControl, {name: 'TestButton'})\n\nbutton.press()\nexpect(pressedListener).toHaveBeenCalledWith(button, null, device)\n\nbutton.release()\nexpect(releasedListener).toHaveBeenCalledWith(button, null, device)\n\nbutton.setValue(0.5)\nexpect(updatedListener).toHaveBeenCalled()"
          },
          {
            "title": "isPressedAny",
            "line": 155,
            "source": "const gamepad = inputSystem.registerDevice(InputDevice, {$id: 'gamepad', $bind: 'gamepad'})\n\nconst keyW = inputSystem.keyboard.findOrCreateControl(ButtonControl, {name: 'KeyW'})\nconst buttonA = gamepad.findOrCreateControl(ButtonControl, {name: 'ButtonA'})\n\nexpect(inputSystem.isPressedAny('KeyW')).toBe(false)\nexpect(inputSystem.isPressedAny('ButtonA')).toBe(false)\nexpect(inputSystem.isPressedAny('NonExistent')).toBe(false)\n\nkeyW.press()\nexpect(inputSystem.isPressedAny('KeyW')).toBe(true)\nexpect(inputSystem.isPressedAny('ButtonA')).toBe(false)\n\nbuttonA.press()\nexpect(inputSystem.isPressedAny('ButtonA')).toBe(true)"
          },
          {
            "title": "getValueAny",
            "line": 174,
            "source": "const keyW = inputSystem.keyboard.findOrCreateControl(ButtonControl, {name: 'KeyW'})\nconst leftButton = inputSystem.mouse.findOrCreateControl(ButtonControl, {name: 'leftButton'})\n\nkeyW.setValue(0.8)\nleftButton.setValue(0.5)\n\nexpect(inputSystem.getValueAny('KeyW')).toBe(0.8)\nexpect(inputSystem.getValueAny('leftButton')).toBe(0.5)\nexpect(inputSystem.getValueAny('NonExistent')).toBeUndefined()"
          },
          {
            "title": "getControlAny",
            "line": 187,
            "source": "const keyW = inputSystem.keyboard.findOrCreateControl(ButtonControl, {name: 'KeyW'})\nconst leftButton = inputSystem.mouse.findOrCreateControl(ButtonControl, {name: 'leftButton'})\n\nexpect(inputSystem.getControlAny('KeyW')).toBe(keyW)\nexpect(inputSystem.getControlAny('leftButton')).toBe(leftButton)\nexpect(inputSystem.getControlAny('NonExistent')).toBeNull()"
          },
          {
            "title": "getAllPressed",
            "line": 197,
            "source": "const gamepad = inputSystem.registerDevice(InputDevice, {$id: 'gamepad', $bind: 'gamepad'})\n\nconst keyEnter = inputSystem.keyboard.findOrCreateControl(ButtonControl, {name: 'Enter'})\nconst gamepadEnter = gamepad.findOrCreateControl(ButtonControl, {name: 'Enter'})\n\nexpect(inputSystem.getAllPressed('Enter')).toEqual([])\n\nkeyEnter.press()\nexpect(inputSystem.getAllPressed('Enter')).toEqual([inputSystem.keyboard])\n\ngamepadEnter.press()\nexpect(inputSystem.getAllPressed('Enter')).toEqual([inputSystem.keyboard, gamepad])\n\nkeyEnter.release()\nexpect(inputSystem.getAllPressed('Enter')).toEqual([gamepad])"
          },
          {
            "title": "getAllValues",
            "line": 216,
            "source": "const device1 = inputSystem.registerDevice(InputDevice, {$id: 'device1', $bind: 'device1'})\nconst device2 = inputSystem.registerDevice(InputDevice, {$id: 'device2', $bind: 'device2'})\n\nconst control1 = device1.findOrCreateControl(ButtonControl, {name: 'SharedControl'})\nconst control2 = device2.findOrCreateControl(ButtonControl, {name: 'SharedControl'})\n\ncontrol1.setValue(0.3)\ncontrol2.setValue(0.7)\n\nconst values = inputSystem.getAllValues('SharedControl')\nexpect(values).toHaveLength(2)\nexpect(values[0]).toEqual({device: device1, value: 0.3})\nexpect(values[1]).toEqual({device: device2, value: 0.7})"
          },
          {
            "title": "addControl - explicit form",
            "line": 233,
            "source": "const control = inputSystem.addControl('keyboard', ButtonControl, {\n    name: 'TestKey',\n    pressThreshold: 0.8\n})\n\nexpect(control).toBeInstanceOf(ButtonControl)\nexpect(control.name).toBe('TestKey')\nexpect(control.pressThreshold).toBe(0.8)\nexpect(inputSystem.keyboard.getControl('TestKey')).toBe(control)"
          },
          {
            "title": "addControl - shortcut form",
            "line": 246,
            "source": "const control = inputSystem.addControl(ButtonControl, {\n    name: 'ShortcutKey',\n    pressThreshold: 0.6\n})\n\nexpect(control).toBeInstanceOf(ButtonControl)\nexpect(control.name).toBe('ShortcutKey')\nexpect(control.pressThreshold).toBe(0.6)\n\nexpect(inputSystem.keyboard.getControl('ShortcutKey')).toBe(control)\nexpect(inputSystem.mouse.getControl('ShortcutKey')).toBeUndefined()"
          },
          {
            "title": "addControl with nonexistent device",
            "line": 261,
            "source": "expect(() => {\n    inputSystem.addControl('nonexistent', ButtonControl, {name: 'test'})\n}).toThrow(\"Device 'nonexistent' not found\")"
          },
          {
            "title": "addControlToFirst",
            "line": 268,
            "source": "const control = inputSystem.addControlToFirst(ButtonControl, {\n    name: 'FirstDeviceControl'\n})\n\nexpect(control).toBeInstanceOf(ButtonControl)\nexpect(control.name).toBe('FirstDeviceControl')\n\nexpect(inputSystem.keyboard.getControl('FirstDeviceControl')).toBe(control)\nexpect(inputSystem.mouse.getControl('FirstDeviceControl')).toBeUndefined()"
          },
          {
            "title": "addControlToAll",
            "line": 281,
            "source": "const results = inputSystem.addControlToAll(ButtonControl, {\n    name: 'SharedControl'\n})\n\nexpect(results).toHaveLength(3)\nexpect(results[0].device).toBe(inputSystem.keyboard)\nexpect(results[0].control).toBeInstanceOf(ButtonControl)\nexpect(results[0].control.name).toBe('SharedControl')\nexpect(results[1].device).toBe(inputSystem.mouse)\nexpect(results[1].control).toBeInstanceOf(ButtonControl)\nexpect(results[1].control.name).toBe('SharedControl')\nexpect(results[2].device).toBe(inputSystem.touch)\nexpect(results[2].control).toBeInstanceOf(ButtonControl)\nexpect(results[2].control.name).toBe('SharedControl')\n\nexpect(inputSystem.keyboard.getControl('SharedControl')).toBe(results[0].control)\nexpect(inputSystem.mouse.getControl('SharedControl')).toBe(results[1].control)\nexpect(inputSystem.touch.getControl('SharedControl')).toBe(results[2].control)"
          },
          {
            "title": "deviceKeyFor",
            "line": 303,
            "source": "expect(inputSystem.deviceKeyFor(inputSystem.keyboard)).toBe('keyboard')\nexpect(inputSystem.deviceKeyFor(inputSystem.mouse)).toBe('mouse')\n\nconst unknownDevice = new InputDevice({name: 'Unknown'})\nexpect(inputSystem.deviceKeyFor(unknownDevice)).toBeUndefined()"
          },
          {
            "title": "bindInput creates keyboard binding (auto-detected)",
            "line": 314,
            "source": "const binding = inputSystem.bindInput({controlName: 'Space', actionName: 'jump'})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('keyboard')\nexpect(binding.controlName).toBe('Space')\nexpect(binding.actionName).toBe('jump')"
          },
          {
            "title": "bindInput creates mouse binding (auto-detected)",
            "line": 324,
            "source": "const binding = inputSystem.bindInput({controlName: 'leftButton', actionName: 'fire'})\n\nexpect(binding).toBeDefined()\nexpect(binding.deviceName).toBe('mouse')\nexpect(binding.controlName).toBe('leftButton')\nexpect(binding.actionName).toBe('fire')"
          },
          {
            "title": "isKeyPressed returns correct state",
            "line": 334,
            "source": "const spaceControl = inputSystem.keyboard.findOrCreateControl(ButtonControl, {name: 'Space'})\n\nexpect(inputSystem.isKeyPressed('Space')).toBe(false)\n\nspaceControl.press()\nexpect(inputSystem.isKeyPressed('Space')).toBe(true)\n\nspaceControl.release()\nexpect(inputSystem.isKeyPressed('Space')).toBe(false)"
          },
          {
            "title": "isMousePressed returns correct state",
            "line": 347,
            "source": "const leftButtonControl = inputSystem.mouse.findOrCreateControl(ButtonControl, {name: 'leftButton'})\n\nexpect(inputSystem.isMousePressed('leftButton')).toBe(false)\n\nleftButtonControl.press()\nexpect(inputSystem.isMousePressed('leftButton')).toBe(true)\n\nleftButtonControl.release()\nexpect(inputSystem.isMousePressed('leftButton')).toBe(false)"
          },
          {
            "title": "isTouchPressed returns correct state",
            "line": 360,
            "source": "const swipeUpControl = inputSystem.touch.getControl('swipeUp')\n\nexpect(inputSystem.isTouchPressed('swipeUp')).toBe(false)\n\nswipeUpControl.press()\nexpect(inputSystem.isTouchPressed('swipeUp')).toBe(true)\n\nswipeUpControl.release()\nexpect(inputSystem.isTouchPressed('swipeUp')).toBe(false)"
          },
          {
            "title": "getTouchValue returns touch control value",
            "line": 373,
            "source": "const positionControl = inputSystem.touch.getControl('position')\n\npositionControl.setValue({x: 150, y: 250})\nconst value = inputSystem.getTouchValue('position')\nexpect(value.x).toBe(150)\nexpect(value.y).toBe(250)"
          },
          {
            "title": "isActionPressed returns false when action not bound",
            "line": 383,
            "source": "expect(inputSystem.isActionPressed('jump')).toBe(false)"
          },
          {
            "title": "isActionPressed returns true when action is pressed",
            "line": 388,
            "source": "inputSystem.bindInput({controlName: 'Space', actionName: 'jump'})\n\nconst spaceControl = inputSystem.keyboard.findOrCreateControl(ButtonControl, {name: 'Space'})\nspaceControl.press()\n\nexpect(inputSystem.isActionPressed('jump')).toBe(true)"
          },
          {
            "title": "isActionPressed works with multiple bindings",
            "line": 398,
            "source": "inputSystem.bindInput({controlName: 'Space', actionName: 'jump', controllerName: 'player1'})\ninputSystem.bindInput({controlName: 'KeyW', actionName: 'jump', controllerName: 'player2'})\n\nconst wControl = inputSystem.keyboard.findOrCreateControl(ButtonControl, {name: 'KeyW'})\nwControl.press()\n\nexpect(inputSystem.isActionPressed('jump')).toBe(true)\nexpect(inputSystem.isActionPressed('jump', 'player2')).toBe(true)\nexpect(inputSystem.isActionPressed('jump', 'player1')).toBe(false)"
          },
          {
            "title": "getActionControls returns empty array when action not bound",
            "line": 411,
            "source": "const controls = inputSystem.getActionControls('jump')\nexpect(controls).toEqual([])"
          },
          {
            "title": "getActionControls returns controls for action",
            "line": 417,
            "source": "inputSystem.bindInput({controlName: 'Space', actionName: 'jump'})\n\nconst spaceControl = inputSystem.keyboard.findOrCreateControl(ButtonControl, {name: 'Space'})\n\nconst controls = inputSystem.getActionControls('jump')\nexpect(controls).toHaveLength(1)\nexpect(controls[0]).toBe(spaceControl)"
          },
          {
            "title": "emits input:triggered event when control is pressed",
            "line": 428,
            "source": "inputSystem.bindInput({controlName: 'Space', actionName: 'jump'})\n\nconst triggeredListener = vi.fn()\nmockHost.on('input:triggered', triggeredListener)\n\nconst spaceControl = inputSystem.keyboard.findOrCreateControl(ButtonControl, {name: 'Space'})\n\nspaceControl.press({code: 'Space'})\n\nawait new Promise(resolve => setTimeout(resolve, 0))\n\nexpect(triggeredListener).toHaveBeenCalled()\nexpect(triggeredListener).toHaveBeenCalledWith(\n    expect.objectContaining({actionName: 'jump'}),\n    expect.anything(),\n    expect.anything()\n)"
          },
          {
            "title": "emits control events",
            "line": 449,
            "source": "const pressedListener = vi.fn()\nconst releasedListener = vi.fn()\n\ninputSystem.on('control:pressed', pressedListener)\ninputSystem.on('control:released', releasedListener)\n\nconst spaceControl = inputSystem.keyboard.findOrCreateControl(ButtonControl, {name: 'Space'})\n\nspaceControl.press({code: 'Space'})\nawait new Promise(resolve => setTimeout(resolve, 0))\nexpect(pressedListener).toHaveBeenCalled()\n\nspaceControl.release({code: 'Space'})\nawait new Promise(resolve => setTimeout(resolve, 0))\nexpect(releasedListener).toHaveBeenCalled()"
          },
          {
            "title": "getInputValue returns control value",
            "line": 468,
            "source": "const spaceControl = inputSystem.keyboard.findOrCreateControl(ButtonControl, {name: 'Space'})\nspaceControl.press()\n\nexpect(inputSystem.getInputValue('keyboard', 'Space')).toBe(1)"
          },
          {
            "title": "getKeyValue returns keyboard control value",
            "line": 476,
            "source": "const spaceControl = inputSystem.keyboard.findOrCreateControl(ButtonControl, {name: 'Space'})\nspaceControl.press()\n\nexpect(inputSystem.getKeyValue('Space')).toBe(1)"
          },
          {
            "title": "getMouseValue returns mouse control value",
            "line": 484,
            "source": "const leftButtonControl = inputSystem.mouse.findOrCreateControl(ButtonControl, {name: 'leftButton'})\nleftButtonControl.press()\n\nexpect(inputSystem.getMouseValue('leftButton')).toBe(1)"
          },
          {
            "title": "constructor accepts inputBinder data",
            "line": 495,
            "source": "const bindings = [\n    {\n        deviceName: 'keyboard',\n        controlName: 'Space',\n        actionName: 'jump'\n    }\n]\n\nconst customInputSystem = new InputSystem({\n    bindings\n})\n\nexpect(customInputSystem.inputBinder.hasBinding({actionName: 'jump'})).toBe(true)"
          },
          {
            "title": "listDeviceNames returns array of device names",
            "line": 631,
            "source": "const names = inputSystem.listDeviceNames()\n\nexpect(names).toContain('keyboard')\nexpect(names).toContain('mouse')\nexpect(names).toContain('touch')"
          },
          {
            "title": "getPressedControls returns pressed controls for device",
            "line": 640,
            "source": "const button1 = inputSystem.keyboard.findOrCreateControl(ButtonControl, {name: 'KeyA'})\nconst button2 = inputSystem.keyboard.findOrCreateControl(ButtonControl, {name: 'KeyB'})\n\nexpect(inputSystem.getPressedControls('keyboard')).toEqual([])\n\nbutton1.press()\nexpect(inputSystem.getPressedControls('keyboard')).toEqual([button1])\n\nbutton2.press()\nconst pressed = inputSystem.getPressedControls('keyboard')\nexpect(pressed).toHaveLength(2)\nexpect(pressed).toContain(button1)\nexpect(pressed).toContain(button2)"
          },
          {
            "title": "getPressedControls returns empty array for nonexistent device",
            "line": 657,
            "source": "expect(inputSystem.getPressedControls('nonexistent')).toEqual([])"
          },
          {
            "title": "getInputValueAny returns value from any device",
            "line": 662,
            "source": "const keyControl = inputSystem.keyboard.findOrCreateControl(ButtonControl, {name: 'TestKey'})\nkeyControl.setValue(0.75)\n\nexpect(inputSystem.getInputValueAny('TestKey')).toBe(0.75)\nexpect(inputSystem.getInputValueAny('NonExistent')).toBeUndefined()"
          }
        ],
        "describes": [
          {
            "title": "getDirection",
            "line": 512,
            "beforeEach": {
              "line": 514,
              "source": "// Setup WASD bindings\ninputSystem.bindInput({controlName: 'KeyW', actionName: 'moveUp'})\ninputSystem.bindInput({controlName: 'KeyA', actionName: 'moveLeft'})\ninputSystem.bindInput({controlName: 'KeyS', actionName: 'moveDown'})\ninputSystem.bindInput({controlName: 'KeyD', actionName: 'moveRight'})"
            },
            "afterEach": null,
            "tests": [
              {
                "title": "returns zero vector when no keys pressed",
                "line": 523,
                "source": "const dir = inputSystem.getDirection()\n\nexpect(dir.x).toBe(0)\nexpect(dir.y).toBe(0)"
              },
              {
                "title": "returns up vector when W pressed",
                "line": 531,
                "source": "const wControl = inputSystem.keyboard.findOrCreateControl(ButtonControl, {name: 'KeyW'})\nwControl.press()\n\nconst dir = inputSystem.getDirection()\n\nexpect(dir.x).toBe(0)\nexpect(dir.y).toBe(1)"
              },
              {
                "title": "returns normalized diagonal when W+D pressed",
                "line": 542,
                "source": "const wControl = inputSystem.keyboard.findOrCreateControl(ButtonControl, {name: 'KeyW'})\nconst dControl = inputSystem.keyboard.findOrCreateControl(ButtonControl, {name: 'KeyD'})\nwControl.press()\ndControl.press()\n\nconst dir = inputSystem.getDirection()\n\n// Diagonal should be normalized (0.707, 0.707)\nexpect(dir.x).toBeCloseTo(Math.SQRT1_2, 5)\nexpect(dir.y).toBeCloseTo(Math.SQRT1_2, 5)\nexpect(dir.length()).toBeCloseTo(1, 5)"
              },
              {
                "title": "returns left vector when A pressed",
                "line": 557,
                "source": "const aControl = inputSystem.keyboard.findOrCreateControl(ButtonControl, {name: 'KeyA'})\naControl.press()\n\nconst dir = inputSystem.getDirection()\n\nexpect(dir.x).toBe(-1)\nexpect(dir.y).toBe(0)"
              },
              {
                "title": "cancels opposite directions",
                "line": 568,
                "source": "const wControl = inputSystem.keyboard.findOrCreateControl(ButtonControl, {name: 'KeyW'})\nconst sControl = inputSystem.keyboard.findOrCreateControl(ButtonControl, {name: 'KeyS'})\nwControl.press()\nsControl.press()\n\nconst dir = inputSystem.getDirection()\n\nexpect(dir.x).toBe(0)\nexpect(dir.y).toBe(0)"
              },
              {
                "title": "works with custom direction name",
                "line": 581,
                "source": "inputSystem.bindInput({controlName: 'ArrowUp', actionName: 'aimUp'})\ninputSystem.bindInput({controlName: 'ArrowDown', actionName: 'aimDown'})\ninputSystem.bindInput({controlName: 'ArrowLeft', actionName: 'aimLeft'})\ninputSystem.bindInput({controlName: 'ArrowRight', actionName: 'aimRight'})\n\nconst upControl = inputSystem.keyboard.findOrCreateControl(ButtonControl, {name: 'ArrowUp'})\nupControl.press()\n\nconst dir = inputSystem.getDirection('aim')\n\nexpect(dir.x).toBe(0)\nexpect(dir.y).toBe(1)"
              },
              {
                "title": "returns correct vector for all 8 directions",
                "line": 597,
                "source": "const testDirections = [\n    {keys: ['KeyW'], expected: {x: 0, y: 1}},\n    {keys: ['KeyD'], expected: {x: 1, y: 0}},\n    {keys: ['KeyS'], expected: {x: 0, y: -1}},\n    {keys: ['KeyA'], expected: {x: -1, y: 0}},\n    {keys: ['KeyW', 'KeyD'], expected: {x: Math.SQRT1_2, y: Math.SQRT1_2}},\n    {keys: ['KeyS', 'KeyD'], expected: {x: Math.SQRT1_2, y: -Math.SQRT1_2}},\n    {keys: ['KeyS', 'KeyA'], expected: {x: -Math.SQRT1_2, y: -Math.SQRT1_2}},\n    {keys: ['KeyW', 'KeyA'], expected: {x: -Math.SQRT1_2, y: Math.SQRT1_2}}\n]\n\ntestDirections.forEach(({keys, expected}) => {\n    ['KeyW', 'KeyA', 'KeyS', 'KeyD'].forEach(key => {\n        const control = inputSystem.keyboard.getControl(key)\n        if (control) {\n            control.release()\n        }\n    })\n\n    keys.forEach(key => {\n        const control = inputSystem.keyboard.findOrCreateControl(ButtonControl, {name: key})\n        control.press()\n    })\n\n    const dir = inputSystem.getDirection()\n    expect(dir.x).toBeCloseTo(expected.x, 5)\n    expect(dir.y).toBeCloseTo(expected.y, 5)\n})"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/input/input_control.doc.js": {
    "file": "/input/input_control.test.js",
    "describes": [
      {
        "title": "InputControl",
        "line": 6,
        "beforeEach": {
          "line": 9,
          "source": "control = new InputControl({\n    device: null,\n    name: 'testControl'\n})"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor",
            "line": 17,
            "source": "expect(control.name).toBe('testControl')\nexpect(control.device).toBeNull()\nexpect(control.value).toBe(0)"
          },
          {
            "title": "constructor with value",
            "line": 24,
            "source": "const customControl = new InputControl({\n    device: null,\n    name: 'custom',\n    value: 42\n})\n\nexpect(customControl.value).toBe(42)"
          },
          {
            "title": "getDefaultValue",
            "line": 35,
            "source": "expect(control.getDefaultValue()).toBe(0)"
          },
          {
            "title": "value property access",
            "line": 40,
            "source": "expect(control.value).toBe(0)\n\ncontrol.value = 123\nexpect(control.value).toBe(123)\n\ncontrol.value = 'test'\nexpect(control.value).toBe('test')"
          },
          {
            "title": "oldValue property access",
            "line": 51,
            "source": "expect(control.oldValue).toBeNull()\n\ncontrol.value = 123\nexpect(control.oldValue).toBe(0)\n\ncontrol.value = 456\nexpect(control.oldValue).toBe(123)\n\ncontrol.value = 'test'\nexpect(control.oldValue).toBe(456)"
          },
          {
            "title": "value change notification",
            "line": 65,
            "source": "const listener = vi.fn()\ncontrol.on('updated', listener)\n\ncontrol.value = 456\nexpect(listener).toHaveBeenCalledWith(456, 0, null)\n\ncontrol.value = 789\nexpect(listener).toHaveBeenCalledWith(789, 456, null)"
          },
          {
            "title": "no notification when value unchanged",
            "line": 77,
            "source": "const listener = vi.fn()\ncontrol.on('updated', listener)\n\ncontrol.value = 123\nexpect(listener).toHaveBeenCalledTimes(1)\n\ncontrol.value = 123\nexpect(listener).toHaveBeenCalledTimes(1)"
          },
          {
            "title": "reset",
            "line": 89,
            "source": "control.value = 456\nexpect(control.value).toBe(456)\n\ncontrol.reset()\nexpect(control.value).toBe(0)"
          },
          {
            "title": "direct symbol access",
            "line": 98,
            "source": "expect(control[VALUE]).toBe(0)\nexpect(control[OLD_VALUE]).toBeNull()\n\ncontrol.value = 123\nexpect(control[VALUE]).toBe(123)\nexpect(control[OLD_VALUE]).toBe(0)\n\ncontrol.value = 456\nexpect(control[VALUE]).toBe(456)\nexpect(control[OLD_VALUE]).toBe(123)"
          },
          {
            "title": "symbols are shared across instances",
            "line": 112,
            "source": "const control1 = new InputControl({device: null, name: 'control1'})\nconst control2 = new InputControl({device: null, name: 'control2'})\n\nexpect(VALUE).toBe(VALUE)\nexpect(OLD_VALUE).toBe(OLD_VALUE)\n\ncontrol1.value = 123\ncontrol2.value = 456\n\nexpect(control1[VALUE]).toBe(123)\nexpect(control2[VALUE]).toBe(456)"
          },
          {
            "title": "setValue updates value and returns true",
            "line": 127,
            "source": "const result = control.setValue(100)\n\nexpect(result).toBe(true)\nexpect(control.value).toBe(100)"
          },
          {
            "title": "setValue returns false when value unchanged",
            "line": 135,
            "source": "control.setValue(50)\n\nconst result = control.setValue(50)\n\nexpect(result).toBe(false)"
          },
          {
            "title": "setValue passes event to updated notification",
            "line": 144,
            "source": "const listener = vi.fn()\ncontrol.on('updated', listener)\n\nconst mockEvent = {type: 'keydown'}\ncontrol.setValue(200, mockEvent)\n\nexpect(listener).toHaveBeenCalledWith(200, 0, mockEvent)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/input/input_controls/button_control.doc.js": {
    "file": "/input/input_controls/button_control.test.js",
    "describes": [
      {
        "title": "ButtonControl",
        "line": 6,
        "beforeEach": {
          "line": 10,
          "source": "control = new ButtonControl({\n    device: null,\n    name: 'testButton'\n})"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "static defaultPressThreshold",
            "line": 18,
            "source": "expect(ButtonControl.defaultPressThreshold).toBe(0.1)"
          },
          {
            "title": "constructor",
            "line": 23,
            "source": "expect(control).toBeInstanceOf(InputControl)\nexpect(control.name).toBe('testButton')\nexpect(control.value).toBe(0)\nexpect(control.pressThreshold).toBe(0.1)"
          },
          {
            "title": "constructor with custom pressThreshold",
            "line": 31,
            "source": "const customControl = new ButtonControl({\n    device: null,\n    name: 'custom',\n    pressThreshold: 0.2\n})\n\nexpect(customControl.pressThreshold).toBe(0.2)"
          },
          {
            "title": "isPressed getter",
            "line": 42,
            "source": "expect(control.isPressed).toBe(false)\n\ncontrol.value = 0.05\nexpect(control.isPressed).toBe(false)\n\ncontrol.value = 0.1\nexpect(control.isPressed).toBe(true)\n\ncontrol.value = 0.8\nexpect(control.isPressed).toBe(true)"
          },
          {
            "title": "wasPressed getter",
            "line": 56,
            "source": "expect(control.wasPressed).toBe(false)\n\ncontrol.value = 0.15\nexpect(control.wasPressed).toBe(false)\n\ncontrol.value = 0.05\nexpect(control.wasPressed).toBe(true)"
          },
          {
            "title": "pressed event emission",
            "line": 67,
            "source": "const pressedListener = vi.fn()\ncontrol.on('pressed', pressedListener)\n\ncontrol.value = 0.15\nexpect(pressedListener).toHaveBeenCalledTimes(1)\nexpect(pressedListener).toHaveBeenCalledWith(null)\n\ncontrol.value = 0.5\nexpect(pressedListener).toHaveBeenCalledTimes(1)"
          },
          {
            "title": "released event emission",
            "line": 80,
            "source": "const releasedListener = vi.fn()\ncontrol.on('released', releasedListener)\n\ncontrol.value = 0.15\ncontrol.value = 0.05\nexpect(releasedListener).toHaveBeenCalledTimes(1)\n\ncontrol.value = 0.02\nexpect(releasedListener).toHaveBeenCalledTimes(1)"
          },
          {
            "title": "press and release cycle",
            "line": 93,
            "source": "const pressedListener = vi.fn()\nconst releasedListener = vi.fn()\n\ncontrol.on('pressed', pressedListener)\ncontrol.on('released', releasedListener)\n\ncontrol.value = 0.2\nexpect(pressedListener).toHaveBeenCalledTimes(1)\nexpect(releasedListener).toHaveBeenCalledTimes(0)\n\ncontrol.value = 0.05\nexpect(pressedListener).toHaveBeenCalledTimes(1)\nexpect(releasedListener).toHaveBeenCalledTimes(1)"
          },
          {
            "title": "setValue return value",
            "line": 110,
            "source": "expect(control.setValue(0.5)).toBe(true)\nexpect(control.setValue(0.5)).toBe(false)\nexpect(control.setValue(0.3)).toBe(true)"
          },
          {
            "title": "no events when value unchanged",
            "line": 117,
            "source": "const pressedListener = vi.fn()\nconst releasedListener = vi.fn()\n\ncontrol.on('pressed', pressedListener)\ncontrol.on('released', releasedListener)\n\ncontrol.value = 0.5\ncontrol.value = 0.5\n\nexpect(pressedListener).toHaveBeenCalledTimes(1)\nexpect(releasedListener).toHaveBeenCalledTimes(0)"
          },
          {
            "title": "custom threshold behavior",
            "line": 132,
            "source": "const customControl = new ButtonControl({\n    device: null,\n    name: 'custom',\n    pressThreshold: 0.1\n})\n\nexpect(customControl.isPressed).toBe(false)\n\ncustomControl.value = 0.05\nexpect(customControl.isPressed).toBe(false)\n\ncustomControl.value = 0.15\nexpect(customControl.isPressed).toBe(true)"
          },
          {
            "title": "press method",
            "line": 149,
            "source": "const pressedListener = vi.fn()\ncontrol.on('pressed', pressedListener)\n\ncontrol.press()\nexpect(control.value).toBe(1)\nexpect(control.isPressed).toBe(true)\nexpect(pressedListener).toHaveBeenCalledTimes(1)\nexpect(pressedListener).toHaveBeenCalledWith(null)"
          },
          {
            "title": "press method with event",
            "line": 160,
            "source": "const pressedListener = vi.fn()\ncontrol.on('pressed', pressedListener)\n\nconst mockEvent = {preventDefault: vi.fn()}\ncontrol.press(mockEvent)\n\nexpect(pressedListener).toHaveBeenCalledWith(mockEvent)"
          },
          {
            "title": "setValue with event",
            "line": 171,
            "source": "const pressedListener = vi.fn()\ncontrol.on('pressed', pressedListener)\n\nconst mockEvent = {preventDefault: vi.fn()}\ncontrol.setValue(1, mockEvent)\n\nexpect(pressedListener).toHaveBeenCalledWith(mockEvent)"
          },
          {
            "title": "updated includes event when provided",
            "line": 181,
            "source": "const updatedListener = vi.fn()\ncontrol.on('updated', updatedListener)\n\nconst mockEvent = {type: 'mock'}\ncontrol.setValue(0.2, mockEvent)\n\nexpect(updatedListener).toHaveBeenCalledWith(0.2, 0, mockEvent)"
          },
          {
            "title": "release method",
            "line": 192,
            "source": "const releasedListener = vi.fn()\ncontrol.on('released', releasedListener)\n\ncontrol.value = 0.8\nexpect(control.isPressed).toBe(true)\n\ncontrol.release()\nexpect(control.value).toBe(0)\nexpect(control.isPressed).toBe(false)\nexpect(releasedListener).toHaveBeenCalledTimes(1)"
          },
          {
            "title": "press and release methods cycle",
            "line": 206,
            "source": "const pressedListener = vi.fn()\nconst releasedListener = vi.fn()\n\ncontrol.on('pressed', pressedListener)\ncontrol.on('released', releasedListener)\n\ncontrol.press()\nexpect(pressedListener).toHaveBeenCalledTimes(1)\nexpect(releasedListener).toHaveBeenCalledTimes(0)\n\ncontrol.release()\nexpect(pressedListener).toHaveBeenCalledTimes(1)\nexpect(releasedListener).toHaveBeenCalledTimes(1)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/input/input_controls/vec2_control.doc.js": {
    "file": "/input/input_controls/vec2_control.test.js",
    "describes": [
      {
        "title": "Vec2Control",
        "line": 8,
        "beforeEach": {
          "line": 12,
          "source": "control = new Vec2Control({\n    device: null,\n    name: 'testVec2'\n})"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor",
            "line": 20,
            "source": "expect(control).toBeInstanceOf(InputControl)\nexpect(control.name).toBe('testVec2')\nexpect(control.value).toBeInstanceOf(Vec2)\nexpect(control.value.x).toBe(0)\nexpect(control.value.y).toBe(0)"
          },
          {
            "title": "constructor with Vec2 value",
            "line": 29,
            "source": "const customControl = new Vec2Control({\n    device: null,\n    name: 'custom',\n    value: new Vec2(3, 4)\n})\n\nexpect(customControl.value).toBeInstanceOf(Vec2)\nexpect(customControl.value.x).toBe(3)\nexpect(customControl.value.y).toBe(4)"
          },
          {
            "title": "getDefaultValue",
            "line": 41,
            "source": "const defaultValue = control.getDefaultValue()\nexpect(defaultValue).toBeInstanceOf(Vec2)\nexpect(defaultValue.x).toBe(0)\nexpect(defaultValue.y).toBe(0)"
          },
          {
            "title": "setValue with Vec2",
            "line": 49,
            "source": "const newVec = new Vec2(5, 6)\nexpect(control.setValue(newVec)).toBe(true)\nexpect(control.value.x).toBe(5)\nexpect(control.value.y).toBe(6)\nexpect(control.value).not.toBe(newVec) // Should be a new instance"
          },
          {
            "title": "setValue with object",
            "line": 57,
            "source": "expect(control.setValue({x: 7, y: 8})).toBe(true)\nexpect(control.value).toBeInstanceOf(Vec2)\nexpect(control.value.x).toBe(7)\nexpect(control.value.y).toBe(8)"
          },
          {
            "title": "setValue with array",
            "line": 65,
            "source": "expect(control.setValue([9, 10])).toBe(true)\nexpect(control.value).toBeInstanceOf(Vec2)\nexpect(control.value.x).toBe(9)\nexpect(control.value.y).toBe(10)"
          },
          {
            "title": "setValue with single number",
            "line": 73,
            "source": "expect(control.setValue(11)).toBe(true)\nexpect(control.value).toBeInstanceOf(Vec2)\nexpect(control.value.x).toBe(11)\nexpect(control.value.y).toBe(0)"
          },
          {
            "title": "setValue return value",
            "line": 81,
            "source": "expect(control.setValue(new Vec2(1, 2))).toBe(true)\nexpect(control.setValue(new Vec2(1, 2))).toBe(false) // Same value\nexpect(control.setValue(new Vec2(3, 4))).toBe(true)"
          },
          {
            "title": "value change notification",
            "line": 88,
            "source": "const listener = vi.fn()\ncontrol.on('updated', listener)\n\nconst newVec = new Vec2(13, 14)\ncontrol.setValue(newVec)\n\nexpect(listener).toHaveBeenCalledTimes(1)\nexpect(listener).toHaveBeenCalledWith(\n    expect.objectContaining({x: 13, y: 14}),\n    expect.objectContaining({x: 0, y: 0}),\n    null\n)"
          },
          {
            "title": "no notification when value unchanged",
            "line": 104,
            "source": "const listener = vi.fn()\ncontrol.on('updated', listener)\n\ncontrol.setValue(new Vec2(15, 16))\nexpect(listener).toHaveBeenCalledTimes(1)\n\ncontrol.setValue(new Vec2(15, 16))\nexpect(listener).toHaveBeenCalledTimes(1) // No additional call"
          },
          {
            "title": "oldValue tracking",
            "line": 116,
            "source": "control.setValue(new Vec2(17, 18))\nexpect(control.oldValue.x).toBe(0)\nexpect(control.oldValue.y).toBe(0)\n\ncontrol.setValue(new Vec2(19, 20))\nexpect(control.oldValue.x).toBe(17)\nexpect(control.oldValue.y).toBe(18)"
          },
          {
            "title": "value property setter",
            "line": 127,
            "source": "control.value = new Vec2(21, 22)\nexpect(control.value.x).toBe(21)\nexpect(control.value.y).toBe(22)"
          },
          {
            "title": "reset",
            "line": 134,
            "source": "control.setValue(new Vec2(23, 24))\nexpect(control.value.x).toBe(23)\nexpect(control.value.y).toBe(24)\n\ncontrol.reset()\nexpect(control.value.x).toBe(0)\nexpect(control.value.y).toBe(0)"
          },
          {
            "title": "direct symbol access",
            "line": 145,
            "source": "expect(control[VALUE]).toBeInstanceOf(Vec2)\nexpect(control[OLD_VALUE]).toBeNull()\n\ncontrol.setValue(new Vec2(25, 26))\nexpect(control[VALUE].x).toBe(25)\nexpect(control[VALUE].y).toBe(26)\nexpect(control[OLD_VALUE].x).toBe(0)\nexpect(control[OLD_VALUE].y).toBe(0)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/input/input_devices/keyboard_device.doc.js": {
    "file": "/input/input_devices/keyboard_device.test.js",
    "describes": [
      {
        "title": "KeyboardDevice",
        "line": 16,
        "beforeEach": {
          "line": 21,
          "source": "mockContainer = {\n    addEventListener: vi.fn(),\n    removeEventListener: vi.fn()\n}\n\ndevice = new KeyboardDevice({\n    container: mockContainer,\n    $id: 'testKeyboard'\n})"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor",
            "line": 34,
            "source": "expect(device).toBeInstanceOf(InputDevice)\nexpect(device.$id).toBe('testKeyboard')\nexpect(device.container).toBe(mockContainer)"
          },
          {
            "title": "constructor with default params",
            "line": 41,
            "source": "const defaultDevice = new KeyboardDevice()\nexpect(defaultDevice.$id).toBe('keyboard')\nexpect(defaultDevice.container).toBe(window)"
          },
          {
            "title": "start attaches event listeners",
            "line": 48,
            "source": "device.start()\n\nexpect(mockContainer.addEventListener).toHaveBeenCalledWith('keydown', expect.any(Function), true)\nexpect(mockContainer.addEventListener).toHaveBeenCalledWith('keyup', expect.any(Function), true)\nexpect(mockContainer.addEventListener).toHaveBeenCalledWith('blur', expect.any(Function))\nexpect(mockContainer.addEventListener).toHaveBeenCalledTimes(3)"
          },
          {
            "title": "stop removes event listeners",
            "line": 58,
            "source": "device.start()\ndevice.stop()\n\nexpect(mockContainer.removeEventListener).toHaveBeenCalledWith('keydown', expect.any(Function), true)\nexpect(mockContainer.removeEventListener).toHaveBeenCalledWith('keyup', expect.any(Function), true)\nexpect(mockContainer.removeEventListener).toHaveBeenCalledWith('blur', expect.any(Function))\nexpect(mockContainer.removeEventListener).toHaveBeenCalledTimes(3)"
          },
          {
            "title": "dispose calls stop",
            "line": 69,
            "source": "const stopSpy = vi.spyOn(device, 'stop')\ndevice.start()\ndevice.dispose()\nexpect(stopSpy).toHaveBeenCalled()"
          },
          {
            "title": "keydown event creates and presses control",
            "line": 78,
            "source": "device.start()\n\nconst keydownListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'keydown')[1]\n\nconst event = createKeyEvent('KeyA')\nkeydownListener(event)\n\nconst control = device.getControl('KeyA')\nexpect(control).toBeInstanceOf(ButtonControl)\nexpect(control.isPressed).toBe(true)\nexpect(device.isPressed('KeyA')).toBe(true)"
          },
          {
            "title": "keydown event does not press already pressed control",
            "line": 94,
            "source": "device.start()\n\nconst keydownListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'keydown')[1]\n\nconst event = createKeyEvent('KeyA')\nkeydownListener(event)\n\nconst control = device.getControl('KeyA')\nconst pressSpy = vi.spyOn(control, 'press')\n\nkeydownListener(event)\nexpect(pressSpy).not.toHaveBeenCalled()"
          },
          {
            "title": "keyup event releases control",
            "line": 111,
            "source": "device.start()\n\nconst keydownListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'keydown')[1]\nconst keyupListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'keyup')[1]\n\nconst event = createKeyEvent('KeyA')\nkeydownListener(event)\nexpect(device.isPressed('KeyA')).toBe(true)\n\nkeyupListener(event)\nexpect(device.isPressed('KeyA')).toBe(false)"
          },
          {
            "title": "keyup event does nothing for non-existent control",
            "line": 128,
            "source": "device.start()\n\nconst keyupListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'keyup')[1]\n\nconst event = createKeyEvent('KeyA')\nexpect(() => keyupListener(event)).not.toThrow()\nexpect(device.getControl('KeyA')).toBeUndefined()"
          },
          {
            "title": "blur event releases all pressed keys",
            "line": 140,
            "source": "device.start()\n\nconst keydownListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'keydown')[1]\nconst blurListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'blur')[1]\n\nkeydownListener(createKeyEvent('KeyA'))\nkeydownListener(createKeyEvent('KeyB'))\nexpect(device.isPressed('KeyA')).toBe(true)\nexpect(device.isPressed('KeyB')).toBe(true)\n\nblurListener()\nexpect(device.isPressed('KeyA')).toBe(false)\nexpect(device.isPressed('KeyB')).toBe(false)"
          },
          {
            "title": "integration test - full key press cycle",
            "line": 159,
            "source": "const controlPressedListener = vi.fn()\nconst controlReleasedListener = vi.fn()\n\ndevice.on('control:pressed', controlPressedListener)\ndevice.on('control:released', controlReleasedListener)\n\ndevice.start()\n\nconst keydownListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'keydown')[1]\nconst keyupListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'keyup')[1]\n\nconst event = createKeyEvent('Space')\n\nkeydownListener(event)\nexpect(controlPressedListener).toHaveBeenCalledTimes(1)\nexpect(device.isPressed('Space')).toBe(true)\n\nkeyupListener(event)\nexpect(controlReleasedListener).toHaveBeenCalledTimes(1)\nexpect(device.isPressed('Space')).toBe(false)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/input/input_devices/mouse_device.doc.js": {
    "file": "/input/input_devices/mouse_device.test.js",
    "describes": [
      {
        "title": "MouseDevice",
        "line": 16,
        "beforeEach": {
          "line": 21,
          "source": "mockContainer = {\n    addEventListener: vi.fn(),\n    removeEventListener: vi.fn()\n}\n\ndevice = new MouseDevice({\n    container: mockContainer,\n    $id: 'testMouse'\n})"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor",
            "line": 34,
            "source": "expect(device).toBeInstanceOf(InputDevice)\nexpect(device.$id).toBe('testMouse')\nexpect(device.container).toBe(mockContainer)"
          },
          {
            "title": "constructor with default params",
            "line": 41,
            "source": "const defaultDevice = new MouseDevice()\nexpect(defaultDevice.$id).toBe('mouse')\nexpect(defaultDevice.container).toBe(window)"
          },
          {
            "title": "creates all mouse controls",
            "line": 48,
            "source": "expect(device.getControl('leftButton')).toBeInstanceOf(ButtonControl)\nexpect(device.getControl('rightButton')).toBeInstanceOf(ButtonControl)\nexpect(device.getControl('middleButton')).toBeInstanceOf(ButtonControl)\nexpect(device.getControl('backButton')).toBeInstanceOf(ButtonControl)\nexpect(device.getControl('forwardButton')).toBeInstanceOf(ButtonControl)\nexpect(device.getControl('position')).toBeInstanceOf(Vec2Control)\nexpect(device.getControl('navigation')).toBeInstanceOf(NavigationControl)"
          },
          {
            "title": "start attaches event listeners",
            "line": 59,
            "source": "device.start()\n\nexpect(mockContainer.addEventListener).toHaveBeenCalledWith('mousedown', expect.any(Function))\nexpect(mockContainer.addEventListener).toHaveBeenCalledWith('mouseup', expect.any(Function))\nexpect(mockContainer.addEventListener).toHaveBeenCalledWith('mousemove', expect.any(Function))\nexpect(mockContainer.addEventListener).toHaveBeenCalledWith('contextmenu', expect.any(Function))\nexpect(mockContainer.addEventListener).toHaveBeenCalledWith('wheel', expect.any(Function), {passive: false})\nexpect(mockContainer.addEventListener).toHaveBeenCalledTimes(5)"
          },
          {
            "title": "stop removes event listeners",
            "line": 71,
            "source": "device.start()\ndevice.stop()\n\nexpect(mockContainer.removeEventListener).toHaveBeenCalledWith('mousedown', expect.any(Function))\nexpect(mockContainer.removeEventListener).toHaveBeenCalledWith('mouseup', expect.any(Function))\nexpect(mockContainer.removeEventListener).toHaveBeenCalledWith('mousemove', expect.any(Function))\nexpect(mockContainer.removeEventListener).toHaveBeenCalledWith('contextmenu', expect.any(Function))\nexpect(mockContainer.removeEventListener).toHaveBeenCalledWith('wheel', expect.any(Function), {passive: false})\nexpect(mockContainer.removeEventListener).toHaveBeenCalledTimes(5)"
          },
          {
            "title": "dispose calls stop",
            "line": 84,
            "source": "const stopSpy = vi.spyOn(device, 'stop')\ndevice.dispose()\nexpect(stopSpy).toHaveBeenCalled()"
          },
          {
            "title": "mousedown event presses correct button",
            "line": 91,
            "source": "device.start()\n\nconst mousedownListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'mousedown')[1]\n\nmousedownListener(createMockEvent({button: 0}))\nexpect(device.isPressed('leftButton')).toBe(true)\n\nmousedownListener(createMockEvent({button: 2}))\nexpect(device.isPressed('rightButton')).toBe(true)\n\nmousedownListener(createMockEvent({button: 1}))\nexpect(device.isPressed('middleButton')).toBe(true)"
          },
          {
            "title": "mouseup event releases correct button",
            "line": 108,
            "source": "device.start()\n\nconst mousedownListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'mousedown')[1]\nconst mouseupListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'mouseup')[1]\n\nmousedownListener(createMockEvent({button: 0}))\nexpect(device.isPressed('leftButton')).toBe(true)\n\nmouseupListener(createMockEvent({button: 0}))\nexpect(device.isPressed('leftButton')).toBe(false)"
          },
          {
            "title": "side buttons work correctly",
            "line": 124,
            "source": "device.start()\n\nconst mousedownListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'mousedown')[1]\n\nmousedownListener(createMockEvent({button: 3}))\nexpect(device.isPressed('backButton')).toBe(true)\n\nmousedownListener(createMockEvent({button: 4}))\nexpect(device.isPressed('forwardButton')).toBe(true)"
          },
          {
            "title": "mousemove updates position",
            "line": 138,
            "source": "device.start()\n\nconst mousemoveListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'mousemove')[1]\n\nconst positionControl = device.getControl('position')\nexpect(positionControl.value.x).toBe(0)\nexpect(positionControl.value.y).toBe(0)\n\nmousemoveListener(createMockEvent({clientX: 100, clientY: 200}))\nexpect(positionControl.value.x).toBe(100)\nexpect(positionControl.value.y).toBe(200)\n\nmousemoveListener(createMockEvent({clientX: 300, clientY: 400}))\nexpect(positionControl.value.x).toBe(300)\nexpect(positionControl.value.y).toBe(400)"
          },
          {
            "title": "mousedown does not press already pressed button",
            "line": 158,
            "source": "device.start()\n\nconst mousedownListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'mousedown')[1]\n\nmousedownListener(createMockEvent({button: 0}))\nconst leftButton = device.getControl('leftButton')\nconst pressSpy = vi.spyOn(leftButton, 'press')\n\nmousedownListener(createMockEvent({button: 0}))\nexpect(pressSpy).not.toHaveBeenCalled()"
          },
          {
            "title": "wheel event updates navigation control",
            "line": 173,
            "source": "device.start()\n\nconst wheelListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'wheel')[1]\n\nconst navigationControl = device.getControl('navigation')\nexpect(navigationControl.value).toEqual({deltaX: 0, deltaY: 0, deltaZ: 0, event: null})\n\nconst mockEvent = createMockEvent({deltaX: 10, deltaY: -50, deltaZ: 0})\nwheelListener(mockEvent)\nexpect(navigationControl.value).toEqual({deltaX: 10, deltaY: -50, deltaZ: 0, event: mockEvent})"
          },
          {
            "title": "integration test - full mouse interaction",
            "line": 188,
            "source": "const controlPressedListener = vi.fn()\nconst controlReleasedListener = vi.fn()\nconst controlUpdatedListener = vi.fn()\n\ndevice.on('control:pressed', controlPressedListener)\ndevice.on('control:released', controlReleasedListener)\ndevice.on('control:updated', controlUpdatedListener)\n\ndevice.start()\n\nconst mousedownListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'mousedown')[1]\nconst mouseupListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'mouseup')[1]\nconst mousemoveListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'mousemove')[1]\n\nmousemoveListener(createMockEvent({clientX: 50, clientY: 75}))\nexpect(controlUpdatedListener).toHaveBeenCalledTimes(1)\n\nmousedownListener(createMockEvent({button: 0}))\nexpect(controlPressedListener).toHaveBeenCalledTimes(1)\nexpect(device.isPressed('leftButton')).toBe(true)\n\nmouseupListener(createMockEvent({button: 0}))\nexpect(controlReleasedListener).toHaveBeenCalledTimes(1)\nexpect(device.isPressed('leftButton')).toBe(false)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/input/input_devices/touch_device.doc.js": {
    "file": "/input/input_devices/touch_device.test.js",
    "describes": [
      {
        "title": "TouchDevice",
        "line": 27,
        "beforeEach": {
          "line": 32,
          "source": "mockContainer = {\n    addEventListener: vi.fn(),\n    removeEventListener: vi.fn()\n}\n\ndevice = new TouchDevice({\n    container: mockContainer,\n    $id: 'testTouch',\n    swipeThreshold: 30\n})"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "constructor",
            "line": 46,
            "source": "expect(device).toBeInstanceOf(InputDevice)\nexpect(device.$id).toBe('testTouch')\nexpect(device.container).toBe(mockContainer)\nexpect(device.swipeThreshold).toBe(30)"
          },
          {
            "title": "constructor with default params",
            "line": 54,
            "source": "const defaultDevice = new TouchDevice()\nexpect(defaultDevice.$id).toBe('touch')\nexpect(defaultDevice.container).toBe(window)\nexpect(defaultDevice.swipeThreshold).toBe(30)"
          },
          {
            "title": "creates controls on construction",
            "line": 62,
            "source": "expect(device.getControl('swipeUp')).toBeInstanceOf(ButtonControl)\nexpect(device.getControl('swipeDown')).toBeInstanceOf(ButtonControl)\nexpect(device.getControl('position')).toBeInstanceOf(Vec2Control)\nexpect(device.getControl('delta')).toBeInstanceOf(Vec2Control)\nexpect(device.getControl('tap')).toBeInstanceOf(ButtonControl)"
          },
          {
            "title": "start attaches event listeners",
            "line": 71,
            "source": "device.start()\n\nexpect(mockContainer.addEventListener).toHaveBeenCalledWith('touchstart', expect.any(Function), {passive: false})\nexpect(mockContainer.addEventListener).toHaveBeenCalledWith('touchmove', expect.any(Function), {passive: false})\nexpect(mockContainer.addEventListener).toHaveBeenCalledWith('touchend', expect.any(Function))\nexpect(mockContainer.addEventListener).toHaveBeenCalledWith('touchcancel', expect.any(Function))\nexpect(mockContainer.addEventListener).toHaveBeenCalledTimes(4)"
          },
          {
            "title": "stop removes event listeners",
            "line": 82,
            "source": "device.start()\ndevice.stop()\n\nexpect(mockContainer.removeEventListener).toHaveBeenCalledWith('touchstart', expect.any(Function))\nexpect(mockContainer.removeEventListener).toHaveBeenCalledWith('touchmove', expect.any(Function))\nexpect(mockContainer.removeEventListener).toHaveBeenCalledWith('touchend', expect.any(Function))\nexpect(mockContainer.removeEventListener).toHaveBeenCalledWith('touchcancel', expect.any(Function))\nexpect(mockContainer.removeEventListener).toHaveBeenCalledTimes(4)"
          },
          {
            "title": "touchstart updates position",
            "line": 94,
            "source": "device.start()\n\nconst touchstartListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchstart')[1]\n\nconst event = createTouchEvent('touchstart', [{clientX: 100, clientY: 200}])\ntouchstartListener(event)\n\nconst position = device.getControl('position')\nexpect(position.value.x).toBe(100)\nexpect(position.value.y).toBe(200)"
          },
          {
            "title": "touchmove triggers swipeUp when moving up past threshold",
            "line": 109,
            "source": "device.start()\n\nconst touchstartListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchstart')[1]\nconst touchmoveListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchmove')[1]\n\ntouchstartListener(createTouchEvent('touchstart', [{clientY: 200}]))\ntouchmoveListener(createTouchEvent('touchmove', [{clientY: 150}]))\n\nexpect(device.isPressed('swipeUp')).toBe(true)\nexpect(device.isPressed('swipeDown')).toBe(false)"
          },
          {
            "title": "touchmove triggers swipeDown when moving down past threshold",
            "line": 125,
            "source": "device.start()\n\nconst touchstartListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchstart')[1]\nconst touchmoveListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchmove')[1]\n\ntouchstartListener(createTouchEvent('touchstart', [{clientY: 200}]))\ntouchmoveListener(createTouchEvent('touchmove', [{clientY: 250}]))\n\nexpect(device.isPressed('swipeDown')).toBe(true)\nexpect(device.isPressed('swipeUp')).toBe(false)"
          },
          {
            "title": "touchmove does not trigger swipe when below threshold",
            "line": 141,
            "source": "device.start()\n\nconst touchstartListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchstart')[1]\nconst touchmoveListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchmove')[1]\n\ntouchstartListener(createTouchEvent('touchstart', [{clientY: 200}]))\ntouchmoveListener(createTouchEvent('touchmove', [{clientY: 210}]))\n\nexpect(device.isPressed('swipeUp')).toBe(false)\nexpect(device.isPressed('swipeDown')).toBe(false)"
          },
          {
            "title": "touchend releases all swipes",
            "line": 157,
            "source": "device.start()\n\nconst touchstartListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchstart')[1]\nconst touchmoveListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchmove')[1]\nconst touchendListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchend')[1]\n\ntouchstartListener(createTouchEvent('touchstart', [{identifier: 0, clientY: 200}]))\ntouchmoveListener(createTouchEvent('touchmove', [{identifier: 0, clientY: 150}]))\nexpect(device.isPressed('swipeUp')).toBe(true)\n\ntouchendListener(createTouchEvent('touchend', [], [{identifier: 0, clientY: 150}]))\nexpect(device.isPressed('swipeUp')).toBe(false)"
          },
          {
            "title": "touchcancel releases all swipes",
            "line": 176,
            "source": "device.start()\n\nconst touchstartListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchstart')[1]\nconst touchmoveListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchmove')[1]\nconst touchcancelListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchcancel')[1]\n\ntouchstartListener(createTouchEvent('touchstart', [{identifier: 0, clientY: 200}]))\ntouchmoveListener(createTouchEvent('touchmove', [{identifier: 0, clientY: 150}]))\nexpect(device.isPressed('swipeUp')).toBe(true)\n\ntouchcancelListener(createTouchEvent('touchcancel', [], [{identifier: 0}]))\nexpect(device.isPressed('swipeUp')).toBe(false)"
          },
          {
            "title": "ignores second touch when first is active",
            "line": 195,
            "source": "device.start()\n\nconst touchstartListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchstart')[1]\n\ntouchstartListener(createTouchEvent('touchstart', [{identifier: 0, clientX: 100, clientY: 200}]))\n\nconst position = device.getControl('position')\nexpect(position.value.x).toBe(100)\n\ntouchstartListener(createTouchEvent('touchstart', [\n    {identifier: 0, clientX: 100, clientY: 200},\n    {identifier: 1, clientX: 300, clientY: 400}\n]))\n\nexpect(position.value.x).toBe(100)"
          },
          {
            "title": "updates delta on touchmove",
            "line": 215,
            "source": "device.start()\n\nconst touchstartListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchstart')[1]\nconst touchmoveListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchmove')[1]\n\ntouchstartListener(createTouchEvent('touchstart', [{clientY: 200}]))\ntouchmoveListener(createTouchEvent('touchmove', [{clientY: 180}]))\n\nconst delta = device.getControl('delta')\nexpect(delta.value.y).toBe(-20)"
          },
          {
            "title": "switching from swipeUp to swipeDown releases swipeUp",
            "line": 231,
            "source": "device.start()\n\nconst touchstartListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchstart')[1]\nconst touchmoveListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchmove')[1]\n\ntouchstartListener(createTouchEvent('touchstart', [{clientY: 200}]))\ntouchmoveListener(createTouchEvent('touchmove', [{clientY: 150}]))\nexpect(device.isPressed('swipeUp')).toBe(true)\n\ntouchmoveListener(createTouchEvent('touchmove', [{clientY: 250}]))\nexpect(device.isPressed('swipeUp')).toBe(false)\nexpect(device.isPressed('swipeDown')).toBe(true)"
          },
          {
            "title": "integration test - full swipe cycle with events",
            "line": 249,
            "source": "const controlPressedListener = vi.fn()\nconst controlReleasedListener = vi.fn()\n\ndevice.on('control:pressed', controlPressedListener)\ndevice.on('control:released', controlReleasedListener)\n\ndevice.start()\n\nconst touchstartListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchstart')[1]\nconst touchmoveListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchmove')[1]\nconst touchendListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchend')[1]\n\ntouchstartListener(createTouchEvent('touchstart', [{identifier: 0, clientY: 200}]))\ntouchmoveListener(createTouchEvent('touchmove', [{identifier: 0, clientY: 150}]))\n\nexpect(controlPressedListener).toHaveBeenCalledTimes(1)\nexpect(controlPressedListener).toHaveBeenCalledWith(\n    expect.objectContaining({name: 'swipeUp'}),\n    expect.anything(),\n    device\n)\n\ntouchendListener(createTouchEvent('touchend', [], [{identifier: 0}]))\n\nexpect(controlReleasedListener).toHaveBeenCalledWith(\n    expect.objectContaining({name: 'swipeUp'}),\n    expect.anything(),\n    device\n)"
          },
          {
            "title": "tap triggers on quick touch without movement",
            "line": 285,
            "source": "const controlPressedListener = vi.fn()\nconst controlReleasedListener = vi.fn()\n\ndevice.on('control:pressed', controlPressedListener)\ndevice.on('control:released', controlReleasedListener)\n\ndevice.start()\n\nconst touchstartListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchstart')[1]\nconst touchendListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchend')[1]\n\ntouchstartListener(createTouchEvent('touchstart', [{identifier: 0, clientX: 100, clientY: 200}]))\ntouchendListener(createTouchEvent('touchend', [], [{identifier: 0, clientX: 100, clientY: 200}]))\n\nexpect(controlPressedListener).toHaveBeenCalledWith(\n    expect.objectContaining({name: 'tap'}),\n    expect.anything(),\n    device\n)\nexpect(controlReleasedListener).toHaveBeenCalledWith(\n    expect.objectContaining({name: 'tap'}),\n    expect.anything(),\n    device\n)"
          },
          {
            "title": "tap does not trigger when movement exceeds threshold",
            "line": 315,
            "source": "const controlPressedListener = vi.fn()\n\ndevice.on('control:pressed', controlPressedListener)\n\ndevice.start()\n\nconst touchstartListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchstart')[1]\nconst touchendListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchend')[1]\n\ntouchstartListener(createTouchEvent('touchstart', [{identifier: 0, clientX: 100, clientY: 200}]))\ntouchendListener(createTouchEvent('touchend', [], [{identifier: 0, clientX: 100, clientY: 250}]))\n\nconst tapCalls = controlPressedListener.mock.calls.filter(\n    call => call[0].name === 'tap'\n)\nexpect(tapCalls).toHaveLength(0)"
          },
          {
            "title": "tap does not trigger on touchcancel",
            "line": 337,
            "source": "const controlPressedListener = vi.fn()\n\ndevice.on('control:pressed', controlPressedListener)\n\ndevice.start()\n\nconst touchstartListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchstart')[1]\nconst touchcancelListener = mockContainer.addEventListener.mock.calls\n    .find(call => call[0] === 'touchcancel')[1]\n\ntouchstartListener(createTouchEvent('touchstart', [{identifier: 0, clientX: 100, clientY: 200}]))\ntouchcancelListener(createTouchEvent('touchcancel', [], [{identifier: 0}]))\n\nconst tapCalls = controlPressedListener.mock.calls.filter(\n    call => call[0].name === 'tap'\n)\nexpect(tapCalls).toHaveLength(0)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/audio/audio_system.doc.js": {
    "file": "/audio/audio_system.test.js",
    "describes": [
      {
        "title": "AudioSystem",
        "line": 13,
        "beforeEach": {
          "line": 21,
          "source": "// Get the mocked onAudioUnlock\nconst audioUnlockModule = await import('./audio_unlock.js')\nmockOnAudioUnlock = audioUnlockModule.onAudioUnlock\nmockOnAudioUnlock.mockClear()\n\nmockContext = createMockAudioContextWithSpies()\ncleanupAudioContext = setupGlobalAudioContext(mockContext)\ncleanupFetch = setupGlobalFetch()\n\nsystem = new AudioSystem()"
        },
        "afterEach": {
          "line": 35,
          "source": "cleanupAudioContext()\ncleanupFetch()"
        },
        "tests": [
          {
            "title": "audioContext returns the audio context",
            "line": 61,
            "source": "expect(system.audioContext).toBeDefined()"
          },
          {
            "title": "unlocked starts as false",
            "line": 66,
            "source": "expect(system.unlocked).toBe(false)"
          },
          {
            "title": "currentTime returns context current time",
            "line": 71,
            "source": "expect(system.currentTime).toBe(0)"
          },
          {
            "title": "onStart registers audio unlock callback",
            "line": 107,
            "source": "system.onStart()\nexpect(mockOnAudioUnlock).toHaveBeenCalledWith(expect.any(Function))"
          },
          {
            "title": "onStop suspends audio context when unlocked",
            "line": 113,
            "source": "// Mark system as unlocked first\nawait system.unlock()\nconst suspendSpy = vi.spyOn(system.audioContext, 'suspend')\nsystem.onStop()\nexpect(suspendSpy).toHaveBeenCalled()"
          },
          {
            "title": "onStop does nothing when not unlocked",
            "line": 121,
            "source": "const suspendSpy = vi.spyOn(system.audioContext, 'suspend')\nsystem.onStop()\nexpect(suspendSpy).not.toHaveBeenCalled()"
          },
          {
            "title": "listChannels returns channel names",
            "line": 213,
            "source": "const channels = system.listChannels()\nexpect(channels).toContain('music')\nexpect(channels).toContain('sfx')\nexpect(channels).toContain('ambiance')"
          },
          {
            "title": "stopAll stops all channels",
            "line": 427,
            "source": "const musicChannel = system.getChannel('music')\nconst sfxChannel = system.getChannel('sfx')\nconst musicSpy = vi.spyOn(musicChannel, 'stopAll')\nconst sfxSpy = vi.spyOn(sfxChannel, 'stopAll')\nsystem.stopAll()\nexpect(musicSpy).toHaveBeenCalled()\nexpect(sfxSpy).toHaveBeenCalled()"
          },
          {
            "title": "getVolume returns master volume from context",
            "line": 458,
            "source": "const spy = vi.spyOn(system.audioContext, 'getMasterVolume').mockReturnValue(0.7)\nexpect(system.getVolume()).toBe(0.7)\nexpect(spy).toHaveBeenCalled()"
          }
        ],
        "describes": [
          {
            "title": "constructor",
            "line": 41,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "sets static category",
                "line": 42,
                "source": "expect(AudioSystem.$category).toBe('audioSystem')"
              },
              {
                "title": "creates default channels",
                "line": 46,
                "source": "expect(system.hasChannel('music')).toBe(true)\nexpect(system.hasChannel('sfx')).toBe(true)\nexpect(system.hasChannel('ambiance')).toBe(true)"
              },
              {
                "title": "accepts custom channels",
                "line": 52,
                "source": "const custom = new AudioSystem({channels: ['voice', 'effects']})\nexpect(custom.hasChannel('voice')).toBe(true)\nexpect(custom.hasChannel('effects')).toBe(true)\nexpect(custom.hasChannel('music')).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "masterVolume",
            "line": 76,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "get returns master volume",
                "line": 77,
                "source": "expect(system.masterVolume).toBeDefined()"
              },
              {
                "title": "set calls setMasterVolume on context",
                "line": 81,
                "source": "const spy = vi.spyOn(system.audioContext, 'setMasterVolume')\nsystem.masterVolume = 0.5\nexpect(spy).toHaveBeenCalledWith(0.5)"
              }
            ],
            "describes": []
          },
          {
            "title": "onInstall",
            "line": 89,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "delegates audio methods to host",
                "line": 90,
                "source": "const host = {emit: vi.fn()}\nsystem.onInstall(host)\nexpect(host.play).toBeDefined()\nexpect(host.stop).toBeDefined()\nexpect(host.unlock).toBeDefined()"
              },
              {
                "title": "delegates audio events to host",
                "line": 98,
                "source": "const host = {emit: vi.fn(), on: vi.fn()}\nsystem.onInstall(host)\nsystem.emit('audio:play', 'test')\nexpect(host.emit).toHaveBeenCalled()"
              }
            ],
            "describes": []
          },
          {
            "title": "onDispose",
            "line": 128,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "stops all sounds",
                "line": 129,
                "source": "const stopAllSpy = vi.spyOn(system, 'stopAll')\nsystem.onDispose()\nexpect(stopAllSpy).toHaveBeenCalled()"
              },
              {
                "title": "disposes audio context",
                "line": 135,
                "source": "const disposeSpy = vi.spyOn(system.audioContext, 'dispose')\nsystem.onDispose()\nexpect(disposeSpy).toHaveBeenCalled()"
              }
            ],
            "describes": []
          },
          {
            "title": "unlock",
            "line": 143,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "resumes audio context",
                "line": 144,
                "source": "await system.unlock()\nexpect(mockContext.resume).toHaveBeenCalled()"
              },
              {
                "title": "sets unlocked to true",
                "line": 149,
                "source": "await system.unlock()\nexpect(system.unlocked).toBe(true)"
              },
              {
                "title": "emits audio:unlocked event",
                "line": 154,
                "source": "const listener = vi.fn()\nsystem.on('audio:unlocked', listener)\nawait system.unlock()\nexpect(listener).toHaveBeenCalled()"
              },
              {
                "title": "returns true on success",
                "line": 161,
                "source": "expect(await system.unlock()).toBe(true)"
              },
              {
                "title": "returns true if already unlocked",
                "line": 165,
                "source": "await system.unlock()\nexpect(await system.unlock()).toBe(true)"
              },
              {
                "title": "returns false on error",
                "line": 170,
                "source": "mockContext.resume.mockRejectedValue(new Error('failed'))\nexpect(await system.unlock()).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "createChannel",
            "line": 177,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "creates new channel",
                "line": 178,
                "source": "const channel = system.createChannel('custom')\nexpect(channel).toBeInstanceOf(AudioChannel)"
              },
              {
                "title": "registers channel by name",
                "line": 183,
                "source": "system.createChannel('custom')\nexpect(system.hasChannel('custom')).toBe(true)"
              }
            ],
            "describes": []
          },
          {
            "title": "getChannel",
            "line": 190,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns existing channel",
                "line": 191,
                "source": "const channel = system.getChannel('sfx')\nexpect(channel).toBeInstanceOf(AudioChannel)"
              },
              {
                "title": "returns null for unknown channel",
                "line": 196,
                "source": "expect(system.getChannel('unknown')).toBeNull()"
              }
            ],
            "describes": []
          },
          {
            "title": "hasChannel",
            "line": 202,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns true for existing channel",
                "line": 203,
                "source": "expect(system.hasChannel('sfx')).toBe(true)"
              },
              {
                "title": "returns false for unknown channel",
                "line": 207,
                "source": "expect(system.hasChannel('unknown')).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "registerBuffer",
            "line": 221,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "stores buffer by id",
                "line": 222,
                "source": "const buffer = {duration: 10}\nsystem.registerBuffer('test', buffer)\nexpect(system.getBuffer('test')).toBe(buffer)"
              },
              {
                "title": "emits buffer:registered event",
                "line": 228,
                "source": "const listener = vi.fn()\nsystem.on('buffer:registered', listener)\nconst buffer = {}\nsystem.registerBuffer('test', buffer)\nexpect(listener).toHaveBeenCalledWith('test', buffer)"
              }
            ],
            "describes": []
          },
          {
            "title": "getBuffer",
            "line": 238,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns registered buffer",
                "line": 239,
                "source": "const buffer = {}\nsystem.registerBuffer('test', buffer)\nexpect(system.getBuffer('test')).toBe(buffer)"
              },
              {
                "title": "returns null for unknown buffer",
                "line": 245,
                "source": "expect(system.getBuffer('unknown')).toBeNull()"
              }
            ],
            "describes": []
          },
          {
            "title": "hasBuffer",
            "line": 251,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns true for registered buffer",
                "line": 252,
                "source": "system.registerBuffer('test', {})\nexpect(system.hasBuffer('test')).toBe(true)"
              },
              {
                "title": "returns false for unknown buffer",
                "line": 257,
                "source": "expect(system.hasBuffer('unknown')).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "loadBuffer",
            "line": 263,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "fetches and decodes audio",
                "line": 264,
                "source": "// Set context to running so decodeAudioData doesn't queue\nmockContext.state = 'running'\nconst buffer = await system.loadBuffer('test', 'http://example.com/audio.mp3')\nexpect(global.fetch).toHaveBeenCalledWith('http://example.com/audio.mp3')\nexpect(buffer).toBeDefined()"
              },
              {
                "title": "registers loaded buffer",
                "line": 272,
                "source": "// Set context to running so decodeAudioData doesn't queue\nmockContext.state = 'running'\nawait system.loadBuffer('test', 'http://example.com/audio.mp3')\nexpect(system.hasBuffer('test')).toBe(true)"
              },
              {
                "title": "returns null on error",
                "line": 279,
                "source": "global.fetch.mockRejectedValue(new Error('network error'))\nconst buffer = await system.loadBuffer('test', 'http://example.com/audio.mp3')\nexpect(buffer).toBeNull()"
              },
              {
                "title": "emits buffer:error on failure",
                "line": 285,
                "source": "const listener = vi.fn()\nsystem.on('buffer:error', listener)\nglobal.fetch.mockRejectedValue(new Error('network error'))\nawait system.loadBuffer('test', 'http://example.com/audio.mp3')\nexpect(listener).toHaveBeenCalled()"
              }
            ],
            "describes": []
          },
          {
            "title": "play",
            "line": 295,
            "beforeEach": {
              "line": 296,
              "source": "// Unlock the system so play() works\nawait system.unlock()"
            },
            "afterEach": null,
            "tests": [
              {
                "title": "returns null for unknown buffer",
                "line": 301,
                "source": "expect(system.play('unknown')).toBeNull()"
              },
              {
                "title": "creates audio source for registered buffer",
                "line": 305,
                "source": "system.registerBuffer('test', {duration: 1})\nconst source = system.play('test')\nexpect(source).not.toBeNull()"
              },
              {
                "title": "uses sfx channel by default",
                "line": 311,
                "source": "system.registerBuffer('test', {})\nconst source = system.play('test')\nexpect(source.channel).toBe(system.getChannel('sfx'))"
              },
              {
                "title": "uses specified channel",
                "line": 317,
                "source": "system.registerBuffer('test', {})\nconst source = system.play('test', {channel: 'music'})\nexpect(source.channel).toBe(system.getChannel('music'))"
              },
              {
                "title": "emits audio:play event",
                "line": 323,
                "source": "const listener = vi.fn()\nsystem.on('audio:play', listener)\nsystem.registerBuffer('test', {})\nsystem.play('test')\nexpect(listener).toHaveBeenCalled()"
              },
              {
                "title": "accepts loop option",
                "line": 331,
                "source": "system.registerBuffer('test', {})\nconst source = system.play('test', {loop: true})\nexpect(source.loop).toBe(true)"
              },
              {
                "title": "accepts volume option",
                "line": 337,
                "source": "system.registerBuffer('test', {})\nconst source = system.play('test', {volume: 0.5})\nexpect(source.volume).toBe(0.5)"
              },
              {
                "title": "accepts playbackRate option",
                "line": 343,
                "source": "system.registerBuffer('test', {})\nconst source = system.play('test', {playbackRate: 2})\nexpect(source.playbackRate).toBe(2)"
              }
            ],
            "describes": []
          },
          {
            "title": "playOscillator",
            "line": 351,
            "beforeEach": {
              "line": 352,
              "source": "// Unlock the system so playOscillator() works\nawait system.unlock()"
            },
            "afterEach": null,
            "tests": [
              {
                "title": "creates oscillator source",
                "line": 357,
                "source": "const source = system.playOscillator()\nexpect(source).not.toBeNull()"
              },
              {
                "title": "uses sfx channel by default",
                "line": 362,
                "source": "const source = system.playOscillator()\nexpect(source.channel).toBe(system.getChannel('sfx'))"
              },
              {
                "title": "accepts type option",
                "line": 367,
                "source": "const source = system.playOscillator({type: 'square'})\nexpect(source).not.toBeNull()"
              },
              {
                "title": "emits audio:play event",
                "line": 372,
                "source": "const listener = vi.fn()\nsystem.on('audio:play', listener)\nsystem.playOscillator()\nexpect(listener).toHaveBeenCalled()"
              }
            ],
            "describes": []
          },
          {
            "title": "stop",
            "line": 381,
            "beforeEach": {
              "line": 382,
              "source": "// Unlock the system so play() works\nawait system.unlock()"
            },
            "afterEach": null,
            "tests": [
              {
                "title": "returns false for unknown source",
                "line": 387,
                "source": "expect(system.stop('unknown')).toBe(false)"
              },
              {
                "title": "stops playing source",
                "line": 391,
                "source": "system.registerBuffer('test', {})\nconst source = system.play('test')\nconst result = system.stop(source.$id)\nexpect(result).toBe(true)"
              },
              {
                "title": "emits audio:stop event",
                "line": 398,
                "source": "const listener = vi.fn()\nsystem.on('audio:stop', listener)\nsystem.registerBuffer('test', {})\nconst source = system.play('test')\nsystem.stop(source.$id)\nexpect(listener).toHaveBeenCalled()"
              }
            ],
            "describes": []
          },
          {
            "title": "stopChannel",
            "line": 409,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns false for unknown channel",
                "line": 410,
                "source": "expect(system.stopChannel('unknown')).toBe(false)"
              },
              {
                "title": "stops all sources in channel",
                "line": 414,
                "source": "const channel = system.getChannel('sfx')\nconst stopAllSpy = vi.spyOn(channel, 'stopAll')\nsystem.stopChannel('sfx')\nexpect(stopAllSpy).toHaveBeenCalled()"
              },
              {
                "title": "returns true on success",
                "line": 421,
                "source": "expect(system.stopChannel('sfx')).toBe(true)"
              }
            ],
            "describes": []
          },
          {
            "title": "setVolume",
            "line": 438,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "sets master volume",
                "line": 439,
                "source": "const spy = vi.spyOn(system.audioContext, 'setMasterVolume')\nsystem.setVolume(0.5)\nexpect(spy).toHaveBeenCalledWith(0.5)"
              },
              {
                "title": "emits volume:changed event",
                "line": 445,
                "source": "const listener = vi.fn()\nsystem.on('volume:changed', listener)\nsystem.setVolume(0.5)\nexpect(listener).toHaveBeenCalledWith(0.5)"
              },
              {
                "title": "returns self for chaining",
                "line": 452,
                "source": "expect(system.setVolume(0.5)).toBe(system)"
              }
            ],
            "describes": []
          },
          {
            "title": "setChannelVolume",
            "line": 465,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "sets channel volume",
                "line": 466,
                "source": "system.setChannelVolume('sfx', 0.5)\nexpect(system.getChannel('sfx').volume).toBe(0.5)"
              },
              {
                "title": "does nothing for unknown channel",
                "line": 471,
                "source": "expect(() => system.setChannelVolume('unknown', 0.5)).not.toThrow()"
              },
              {
                "title": "returns self for chaining",
                "line": 475,
                "source": "expect(system.setChannelVolume('sfx', 0.5)).toBe(system)"
              }
            ],
            "describes": []
          },
          {
            "title": "getChannelVolume",
            "line": 481,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "returns channel volume",
                "line": 482,
                "source": "system.setChannelVolume('sfx', 0.7)\nexpect(system.getChannelVolume('sfx')).toBe(0.7)"
              },
              {
                "title": "returns 0 for unknown channel",
                "line": 487,
                "source": "expect(system.getChannelVolume('unknown')).toBe(0)"
              }
            ],
            "describes": []
          },
          {
            "title": "muteChannel",
            "line": 493,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "mutes channel",
                "line": 494,
                "source": "system.muteChannel('sfx')\nexpect(system.getChannel('sfx').muted).toBe(true)"
              },
              {
                "title": "does nothing for unknown channel",
                "line": 499,
                "source": "expect(() => system.muteChannel('unknown')).not.toThrow()"
              },
              {
                "title": "returns self for chaining",
                "line": 503,
                "source": "expect(system.muteChannel('sfx')).toBe(system)"
              }
            ],
            "describes": []
          },
          {
            "title": "unmuteChannel",
            "line": 509,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "unmutes channel",
                "line": 510,
                "source": "system.muteChannel('sfx')\nsystem.unmuteChannel('sfx')\nexpect(system.getChannel('sfx').muted).toBe(false)"
              },
              {
                "title": "does nothing for unknown channel",
                "line": 516,
                "source": "expect(() => system.unmuteChannel('unknown')).not.toThrow()"
              },
              {
                "title": "returns self for chaining",
                "line": 520,
                "source": "expect(system.unmuteChannel('sfx')).toBe(system)"
              }
            ],
            "describes": []
          },
          {
            "title": "playAt",
            "line": 526,
            "beforeEach": {
              "line": 527,
              "source": "// Unlock the system so playAt() works\nawait system.unlock()"
            },
            "afterEach": null,
            "tests": [
              {
                "title": "returns null for unknown buffer",
                "line": 532,
                "source": "expect(system.playAt('unknown', 10, 20)).toBeNull()"
              },
              {
                "title": "creates audio source",
                "line": 536,
                "source": "system.registerBuffer('test', {})\nconst source = system.playAt('test', 100, 200)\nexpect(source).not.toBeNull()"
              },
              {
                "title": "calls play with spatial options",
                "line": 542,
                "source": "system.registerBuffer('test', {})\nconst playSpy = vi.spyOn(system, 'play')\nsystem.playAt('test', 150, 250, {volume: 0.5})\nexpect(playSpy).toHaveBeenCalledWith('test', expect.objectContaining({\n    spatial: true,\n    x: 150,\n    y: 250,\n    volume: 0.5\n}))"
              },
              {
                "title": "emits audio:play event",
                "line": 554,
                "source": "const listener = vi.fn()\nsystem.on('audio:play', listener)\nsystem.registerBuffer('test', {})\nsystem.playAt('test', 10, 20)\nexpect(listener).toHaveBeenCalled()"
              }
            ],
            "describes": []
          },
          {
            "title": "playOscillatorAt",
            "line": 564,
            "beforeEach": {
              "line": 565,
              "source": "// Unlock the system so playOscillatorAt() works\nawait system.unlock()"
            },
            "afterEach": null,
            "tests": [
              {
                "title": "creates oscillator source with spatial audio enabled",
                "line": 570,
                "source": "const source = system.playOscillatorAt(100, 200)\nexpect(source).not.toBeNull()\n\n// Verify spatial audio is enabled by checking position properties\nconst pos = source.getPosition()\nexpect(pos.x).toBe(100)\nexpect(pos.y).toBe(200)"
              },
              {
                "title": "sets position coordinates",
                "line": 580,
                "source": "const source = system.playOscillatorAt(150, 250)\nconst pos = source.getPosition()\nexpect(pos.x).toBe(150)\nexpect(pos.y).toBe(250)"
              },
              {
                "title": "accepts options",
                "line": 587,
                "source": "const source = system.playOscillatorAt(10, 20, {type: 'square', frequency: 880, volume: 0.3})\nexpect(source.volume).toBe(0.3)"
              },
              {
                "title": "emits audio:play event",
                "line": 592,
                "source": "const listener = vi.fn()\nsystem.on('audio:play', listener)\nsystem.playOscillatorAt(10, 20)\nexpect(listener).toHaveBeenCalled()"
              }
            ],
            "describes": []
          },
          {
            "title": "setListenerPosition",
            "line": 601,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "sets listener position on audio context",
                "line": 602,
                "source": "const spy = vi.spyOn(system.audioContext, 'setListenerPosition')\nsystem.setListenerPosition(50, 75)\nexpect(spy).toHaveBeenCalledWith(50, 75, 0)"
              },
              {
                "title": "returns self for chaining",
                "line": 608,
                "source": "expect(system.setListenerPosition(10, 20)).toBe(system)"
              }
            ],
            "describes": []
          },
          {
            "title": "getListenerPosition",
            "line": 614,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "calls getListenerPosition on audio context",
                "line": 615,
                "source": "const spy = vi.spyOn(system.audioContext, 'getListenerPosition')\nsystem.getListenerPosition()\nexpect(spy).toHaveBeenCalled()"
              },
              {
                "title": "returns object with x and y properties",
                "line": 621,
                "source": "const pos = system.getListenerPosition()\nexpect(pos).toHaveProperty('x')\nexpect(pos).toHaveProperty('y')\nexpect(pos.z).toBeUndefined()"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/editor/perky_explorer.doc.js": {
    "file": "/editor/perky_explorer.test.js",
    "describes": [
      {
        "title": "PerkyExplorer",
        "line": 58,
        "beforeEach": {
          "line": 64,
          "source": "container = document.createElement('div')\ndocument.body.appendChild(container)\n\nexplorer = document.createElement('perky-explorer')\ncontainer.appendChild(explorer)"
        },
        "afterEach": {
          "line": 73,
          "source": "container.remove()"
        },
        "tests": [],
        "describes": [
          {
            "title": "initialization",
            "line": 78,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "should be a custom element",
                "line": 80,
                "source": "expect(explorer).toBeInstanceOf(PerkyExplorer)\nexpect(explorer).toBeInstanceOf(HTMLElement)"
              },
              {
                "title": "should have shadow DOM",
                "line": 86,
                "source": "expect(explorer.shadowRoot).not.toBeNull()"
              },
              {
                "title": "should show empty state when no module is set",
                "line": 91,
                "source": "const emptyMessage = explorer.shadowRoot.querySelector('.explorer-empty')\nexpect(emptyMessage).not.toBeNull()\nexpect(emptyMessage.textContent).toContain('No module attached')"
              },
              {
                "title": "should have a header with title",
                "line": 98,
                "source": "const title = explorer.shadowRoot.querySelector('.explorer-title')\nexpect(title).not.toBeNull()\nexpect(title.textContent).toContain('Perky Explorer')"
              }
            ],
            "describes": []
          },
          {
            "title": "setModule",
            "line": 107,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "should render the module tree",
                "line": 109,
                "source": "const module = new PerkyModule({$id: 'root', $category: 'app'})\nexplorer.setModule(module)\n\nconst rootNode = getRootNode(explorer)\nexpect(rootNode).not.toBeNull()\n\nconst id = getNodeId(rootNode)\nexpect(id.textContent).toBe('root')"
              },
              {
                "title": "should return the module via getModule",
                "line": 121,
                "source": "const module = new PerkyModule({$id: 'root'})\nexplorer.setModule(module)\n\nexpect(explorer.getModule()).toBe(module)"
              },
              {
                "title": "should expand the root node by default",
                "line": 129,
                "source": "const parent = new PerkyModule({$id: 'parent'})\nparent.create(PerkyModule, {$id: 'child'})\n\nexplorer.setModule(parent)\n\nconst rootNode = getRootNode(explorer)\nconst childrenContainer = getNodeChildren(rootNode)\nexpect(childrenContainer.classList.contains('expanded')).toBe(true)"
              },
              {
                "title": "should render children in the tree",
                "line": 141,
                "source": "const parent = new PerkyModule({$id: 'parent'})\nparent.create(PerkyModule, {$id: 'child1', $category: 'test'})\nparent.create(PerkyModule, {$id: 'child2', $category: 'test'})\n\nexplorer.setModule(parent)\n\nconst rootNode = getRootNode(explorer)\nconst nodeIds = collectAllNodeIds(rootNode)\n\nexpect(nodeIds).toContain('parent')\nexpect(nodeIds).toContain('child1')\nexpect(nodeIds).toContain('child2')"
              }
            ],
            "describes": []
          },
          {
            "title": "status indicators",
            "line": 159,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "should show stopped status when module not started",
                "line": 161,
                "source": "const module = new PerkyModule({$id: 'test'})\nexplorer.setModule(module)\n\nconst rootNode = getRootNode(explorer)\nconst status = getNodeStatus(rootNode)\nexpect(status.classList.contains('stopped')).toBe(true)"
              },
              {
                "title": "should show started status when module is running",
                "line": 171,
                "source": "const module = new PerkyModule({$id: 'test'})\nmodule.start()\nexplorer.setModule(module)\n\nconst rootNode = getRootNode(explorer)\nconst status = getNodeStatus(rootNode)\nexpect(status.classList.contains('started')).toBe(true)"
              },
              {
                "title": "should show disposed status when module is disposed",
                "line": 182,
                "source": "const module = new PerkyModule({$id: 'test'})\nmodule.dispose()\nexplorer.setModule(module)\n\nconst rootNode = getRootNode(explorer)\nconst status = getNodeStatus(rootNode)\nexpect(status.classList.contains('disposed')).toBe(true)"
              }
            ],
            "describes": []
          },
          {
            "title": "collapse/expand",
            "line": 195,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "should toggle tree visibility when clicking header",
                "line": 197,
                "source": "const module = new PerkyModule({$id: 'test'})\nexplorer.setModule(module)\n\nconst header = explorer.shadowRoot.querySelector('.explorer-header')\nconst tree = explorer.shadowRoot.querySelector('.explorer-tree')\n\nexpect(tree.classList.contains('hidden')).toBe(false)\n\nheader.click()\n\nconst treeAfter = explorer.shadowRoot.querySelector('.explorer-tree')\nexpect(treeAfter.classList.contains('hidden')).toBe(true)"
              },
              {
                "title": "should toggle child nodes when clicking arrow",
                "line": 213,
                "source": "const parent = new PerkyModule({$id: 'parent'})\nparent.create(PerkyModule, {$id: 'child'})\nexplorer.setModule(parent)\n\nconst rootNode = getRootNode(explorer)\n\nlet childContainer = getNodeChildren(rootNode)\nexpect(childContainer.classList.contains('expanded')).toBe(true)\n\nconst toggle = getNodeToggle(rootNode)\ntoggle.click()\n\nchildContainer = getNodeChildren(rootNode)\nexpect(childContainer.classList.contains('expanded')).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "selection and details",
            "line": 233,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "should show details panel when node is clicked",
                "line": 235,
                "source": "const module = new PerkyModule({\n    $id: 'test-module',\n    $name: 'TestModule',\n    $category: 'testing',\n    $tags: ['tag1', 'tag2']\n})\nexplorer.setModule(module)\n\nconst rootNode = getRootNode(explorer)\nconst nodeContent = getNodeContent(rootNode)\nnodeContent.click()\n\nconst details = getDetails(explorer)\nexpect(details).not.toBeNull()"
              },
              {
                "title": "should display module properties in details",
                "line": 253,
                "source": "const module = new PerkyModule({\n    $id: 'test-module',\n    $name: 'TestName',\n    $category: 'testing'\n})\nexplorer.setModule(module)\n\nconst rootNode = getRootNode(explorer)\nconst nodeContent = getNodeContent(rootNode)\nnodeContent.click()\n\nconst details = getDetails(explorer)\nconst detailsContent = details.shadowRoot.textContent\nexpect(detailsContent).toContain('TestName')\nexpect(detailsContent).toContain('testing')"
              },
              {
                "title": "should display tags in details",
                "line": 272,
                "source": "const module = new PerkyModule({\n    $id: 'test',\n    $tags: ['alpha', 'beta']\n})\nexplorer.setModule(module)\n\nconst rootNode = getRootNode(explorer)\nconst nodeContent = getNodeContent(rootNode)\nnodeContent.click()\n\nconst details = getDetails(explorer)\nconst tags = details.shadowRoot.querySelectorAll('.details-tag')\nconst tagTexts = [...tags].map(t => t.textContent)\n\nexpect(tagTexts).toContain('alpha')\nexpect(tagTexts).toContain('beta')"
              },
              {
                "title": "should mark selected node with selected class",
                "line": 292,
                "source": "const module = new PerkyModule({$id: 'test'})\nexplorer.setModule(module)\n\nconst rootNode = getRootNode(explorer)\nconst nodeContent = getNodeContent(rootNode)\nnodeContent.click()\n\nconst selectedContent = getNodeContent(rootNode)\nexpect(selectedContent.classList.contains('selected')).toBe(true)"
              }
            ],
            "describes": []
          },
          {
            "title": "minimize",
            "line": 307,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "should minimize when clicking minimize button",
                "line": 309,
                "source": "const module = new PerkyModule({$id: 'test'})\nexplorer.setModule(module)\n\nconst minimizeBtn = explorer.shadowRoot.querySelectorAll('.explorer-btn')[3]\nminimizeBtn.click()\n\nconst minimized = explorer.shadowRoot.querySelector('.explorer-minimized')\nexpect(minimized.classList.contains('hidden')).toBe(false)"
              },
              {
                "title": "should restore when clicking minimized icon",
                "line": 321,
                "source": "const module = new PerkyModule({$id: 'test'})\nexplorer.setModule(module)\n\nconst minimizeBtn = explorer.shadowRoot.querySelectorAll('.explorer-btn')[3]\nminimizeBtn.click()\n\nconst minimized = explorer.shadowRoot.querySelector('.explorer-minimized')\nminimized.click()\n\nconst explorerPanel = explorer.shadowRoot.querySelector('.explorer')\nexpect(explorerPanel.classList.contains('hidden')).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "live updates",
            "line": 338,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "should update when child is added",
                "line": 340,
                "source": "const parent = new PerkyModule({$id: 'parent'})\nexplorer.setModule(parent)\n\nconst rootNode = getRootNode(explorer)\nlet nodeIds = collectAllNodeIds(rootNode)\nexpect(nodeIds).not.toContain('new-child')\n\nparent.create(PerkyModule, {$id: 'new-child', $category: 'perkyModule'})\n\nnodeIds = collectAllNodeIds(rootNode)\nexpect(nodeIds).toContain('new-child')"
              },
              {
                "title": "should update when module starts",
                "line": 355,
                "source": "const module = new PerkyModule({$id: 'test'})\nexplorer.setModule(module)\n\nconst rootNode = getRootNode(explorer)\nlet status = getNodeStatus(rootNode)\nexpect(status.classList.contains('stopped')).toBe(true)\n\nmodule.start()\n\nstatus = getNodeStatus(rootNode)\nexpect(status.classList.contains('started')).toBe(true)"
              }
            ],
            "describes": []
          },
          {
            "title": "cleanup",
            "line": 372,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "should clean up listeners when disconnected",
                "line": 374,
                "source": "const module = new PerkyModule({$id: 'test'})\nexplorer.setModule(module)\n\nconst rootNode = getRootNode(explorer)\nconst offSpy = vi.spyOn(module, 'off')\n\nrootNode.remove()\n\nexpect(offSpy).toHaveBeenCalled()"
              },
              {
                "title": "should clean up listeners when setting new module",
                "line": 387,
                "source": "const module1 = new PerkyModule({$id: 'first'})\nconst module2 = new PerkyModule({$id: 'second'})\n\nexplorer.setModule(module1)\n\nconst rootNode = getRootNode(explorer)\nconst offSpy = vi.spyOn(module1, 'off')\n\nrootNode.setModule(module2)\n\nexpect(offSpy).toHaveBeenCalled()"
              }
            ],
            "describes": []
          },
          {
            "title": "focusModule",
            "line": 404,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "should change root to focused module",
                "line": 406,
                "source": "const parent = new PerkyModule({$id: 'parent'})\nconst child = parent.create(PerkyModule, {$id: 'child', $category: 'test'})\n\nexplorer.setModule(parent)\n\nconst rootNode = getRootNode(explorer)\nlet nodeIds = collectAllNodeIds(rootNode)\nexpect(nodeIds).toContain('parent')\nexpect(nodeIds).toContain('child')\n\nexplorer.focusModule(child)\n\nconst focusedRootNode = getRootNode(explorer)\nconst focusedId = getNodeId(focusedRootNode)\nexpect(focusedId.textContent).toBe('child')"
              },
              {
                "title": "should do nothing if module is null",
                "line": 425,
                "source": "const module = new PerkyModule({$id: 'test'})\nexplorer.setModule(module)\n\nconst rootNode = getRootNode(explorer)\nconst idBefore = getNodeId(rootNode).textContent\n\nexplorer.focusModule(null)\n\nconst idAfter = getNodeId(getRootNode(explorer)).textContent\nexpect(idAfter).toBe(idBefore)"
              },
              {
                "title": "should expand focused module",
                "line": 439,
                "source": "const parent = new PerkyModule({$id: 'parent'})\nconst child = parent.create(PerkyModule, {$id: 'child', $category: 'test'})\nchild.create(PerkyModule, {$id: 'grandchild', $category: 'test'})\n\nexplorer.setModule(parent)\nexplorer.focusModule(child)\n\nconst rootNode = getRootNode(explorer)\nconst childrenContainer = getNodeChildren(rootNode)\nexpect(childrenContainer.classList.contains('expanded')).toBe(true)"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/editor/perky_logger.doc.js": {
    "file": "/editor/perky_logger.test.js",
    "describes": [
      {
        "title": "PerkyLogger",
        "line": 5,
        "beforeEach": {
          "line": 10,
          "source": "logger = new PerkyLogger()\ndocument.body.appendChild(logger)"
        },
        "afterEach": {
          "line": 16,
          "source": "document.body.innerHTML = ''"
        },
        "tests": [
          {
            "title": "custom element creation",
            "line": 21,
            "source": "expect(logger).toBeInstanceOf(PerkyLogger)\nexpect(logger.tagName).toBe('PERKY-LOGGER')"
          },
          {
            "title": "constructor initializes with default options",
            "line": 27,
            "source": "expect(logger.maxEntries).toBe(50)\nexpect(logger.position).toBe('bottom')\nexpect(logger.timestamp).toBe(false)\nexpect(logger.entries).toEqual([])"
          },
          {
            "title": "constructor accepts custom attributes",
            "line": 35,
            "source": "const customLogger = new PerkyLogger()\ncustomLogger.maxEntries = 100\ncustomLogger.position = 'top'\ncustomLogger.timestamp = true\n\nexpect(customLogger.maxEntries).toBe(100)\nexpect(customLogger.position).toBe('top')\nexpect(customLogger.timestamp).toBe(true)"
          },
          {
            "title": "log creates a log entry with the specified type",
            "line": 47,
            "source": "const message = 'Test message'\nconst type = 'info'\n\nconst entry = logger.log(message, type)\n\nexpect(entry.className).toContain('logger-entry')\nexpect(entry.className).toContain('log-info')\nexpect(entry.querySelector('.logger-message').textContent).toBe(message)\nexpect(logger.entries.length).toBe(1)\nexpect(logger.entries[0]).toBe(entry)"
          },
          {
            "title": "log creates timestamp when enabled",
            "line": 61,
            "source": "logger.timestamp = true\nconst message = 'Test message with timestamp'\n\nconst entry = logger.log(message, 'info')\n\nconst timestamp = entry.querySelector('.logger-timestamp')\nexpect(timestamp).not.toBeNull()\nexpect(entry.textContent).toContain(message)"
          },
          {
            "title": "log removes oldest entries when limit is reached",
            "line": 73,
            "source": "logger.maxEntries = 3\n\nconst entry1 = logger.log('Message 1', 'info')\nconst entry2 = logger.log('Message 2', 'info')\nconst entry3 = logger.log('Message 3', 'info')\nconst entry4 = logger.log('Message 4', 'info')\n\nexpect(logger.entries.length).toBe(3)\nexpect(logger.entries).not.toContain(entry1)\nexpect(logger.entries).toContain(entry2)\nexpect(logger.entries).toContain(entry3)\nexpect(logger.entries).toContain(entry4)"
          },
          {
            "title": "info logs a message with info type",
            "line": 89,
            "source": "vi.spyOn(logger, 'log')\n\nlogger.info('Info message')\n\nexpect(logger.log).toHaveBeenCalledWith('Info message', 'info')"
          },
          {
            "title": "warn logs a message with warn type",
            "line": 98,
            "source": "vi.spyOn(logger, 'log')\n\nlogger.warn('Warning message')\n\nexpect(logger.log).toHaveBeenCalledWith('Warning message', 'warn')"
          },
          {
            "title": "error logs a message with error type",
            "line": 107,
            "source": "vi.spyOn(logger, 'log')\n\nlogger.error('Error message')\n\nexpect(logger.log).toHaveBeenCalledWith('Error message', 'error')"
          },
          {
            "title": "success logs a message with success type",
            "line": 116,
            "source": "vi.spyOn(logger, 'log')\n\nlogger.success('Success message')\n\nexpect(logger.log).toHaveBeenCalledWith('Success message', 'success')"
          },
          {
            "title": "notice logs a message with notice type",
            "line": 125,
            "source": "vi.spyOn(logger, 'log')\n\nlogger.notice('Notice message')\n\nexpect(logger.log).toHaveBeenCalledWith('Notice message', 'notice')"
          },
          {
            "title": "spacer creates a spacer entry",
            "line": 134,
            "source": "logger.spacer()\n\nexpect(logger.entries.length).toBe(1)\nexpect(logger.entries[0].className).toContain('logger-spacer')"
          },
          {
            "title": "title creates a title entry",
            "line": 142,
            "source": "logger.title('Test Title')\n\nexpect(logger.entries.length).toBe(1)\nexpect(logger.entries[0].className).toContain('logger-title-entry')\nexpect(logger.entries[0].textContent).toBe('Test Title')"
          },
          {
            "title": "clear removes all entries",
            "line": 151,
            "source": "logger.log('Message 1', 'info')\nlogger.log('Message 2', 'warn')\nlogger.log('Message 3', 'error')\n\nexpect(logger.entries.length).toBe(3)\n\nlogger.clear()\n\nexpect(logger.entries.length).toBe(0)"
          },
          {
            "title": "render displays correct structure",
            "line": 164,
            "source": "const loggerDiv = logger.shadowRoot.querySelector('.logger')\nconst content = logger.shadowRoot.querySelector('.logger-content')\n\nexpect(loggerDiv).toBeTruthy()\nexpect(content).toBeTruthy()"
          },
          {
            "title": "entries are rendered in content",
            "line": 173,
            "source": "logger.log('Test message', 'info')\n\nconst content = logger.shadowRoot.querySelector('.logger-content')\nexpect(content.children.length).toBe(1)"
          },
          {
            "title": "position updates logger classes",
            "line": 181,
            "source": "logger.position = 'top'\n\nconst loggerDiv = logger.shadowRoot.querySelector('.logger')\n\nexpect(loggerDiv.className).toContain('logger')\nexpect(loggerDiv.className).toContain('logger-top')"
          },
          {
            "title": "multiple message arguments are formatted correctly",
            "line": 191,
            "source": "logger.info('Message', 123, {key: 'value'})\n\nexpect(logger.entries.length).toBe(1)\nexpect(logger.entries[0].textContent).toContain('Message')\nexpect(logger.entries[0].textContent).toContain('123')\nexpect(logger.entries[0].textContent).toContain('key')"
          },
          {
            "title": "can be used like a DOM element",
            "line": 201,
            "source": "const container = document.createElement('div')\nconst newLogger = new PerkyLogger()\n\ncontainer.appendChild(newLogger)\n\nexpect(container.contains(newLogger)).toBe(true)\nexpect(newLogger.parentElement).toBe(container)\n\nnewLogger.info('Test message')\nexpect(newLogger.entries.length).toBe(1)"
          },
          {
            "title": "theme property works correctly",
            "line": 215,
            "source": "expect(logger.theme).toBe('')\n\nlogger.theme = 'light'\n\nexpect(logger.theme).toBe('light')\nexpect(logger.hasAttribute('theme')).toBe(true)\nexpect(logger.getAttribute('theme')).toBe('light')\n\nlogger.theme = ''\n\nexpect(logger.theme).toBe('')\nexpect(logger.hasAttribute('theme')).toBe(false)"
          }
        ],
        "describes": []
      }
    ]
  },
  "/editor/toggle_input.doc.js": {
    "file": "/editor/toggle_input.test.js",
    "describes": [
      {
        "title": "ToggleInput",
        "line": 5,
        "beforeEach": {
          "line": 11,
          "source": "container = document.createElement('div')\ndocument.body.appendChild(container)\n\ntoggle = document.createElement('toggle-input')\ncontainer.appendChild(toggle)"
        },
        "afterEach": {
          "line": 20,
          "source": "container.remove()"
        },
        "tests": [
          {
            "title": "setChecked should set checked directly",
            "line": 63,
            "source": "toggle.setChecked(true)\nexpect(toggle.checked).toBe(true)"
          },
          {
            "title": "setLabel should set label text",
            "line": 69,
            "source": "toggle.setLabel('Enabled')\nconst label = toggle.shadowRoot.querySelector('.toggle-input-label')\nexpect(label.textContent).toBe('Enabled')"
          },
          {
            "title": "observedAttributes should include expected attributes",
            "line": 76,
            "source": "const observed = toggle.constructor.observedAttributes\nexpect(observed).toContain('checked')\nexpect(observed).toContain('label')"
          }
        ],
        "describes": [
          {
            "title": "initialization",
            "line": 25,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "should extend HTMLElement",
                "line": 27,
                "source": "expect(toggle).toBeInstanceOf(HTMLElement)"
              },
              {
                "title": "should have shadow DOM",
                "line": 32,
                "source": "expect(toggle.shadowRoot).not.toBeNull()"
              },
              {
                "title": "should have default checked of false",
                "line": 37,
                "source": "expect(toggle.checked).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "checked property",
            "line": 44,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "should get and set checked",
                "line": 46,
                "source": "toggle.checked = true\nexpect(toggle.checked).toBe(true)"
              },
              {
                "title": "should coerce to boolean",
                "line": 52,
                "source": "toggle.checked = 1\nexpect(toggle.checked).toBe(true)\n\ntoggle.checked = 0\nexpect(toggle.checked).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "visual state",
            "line": 83,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "should add checked class when checked",
                "line": 85,
                "source": "toggle.setChecked(true)\nconst track = toggle.shadowRoot.querySelector('.toggle-input-track')\nexpect(track.classList.contains('checked')).toBe(true)"
              },
              {
                "title": "should remove checked class when unchecked",
                "line": 92,
                "source": "toggle.setChecked(true)\ntoggle.setChecked(false)\nconst track = toggle.shadowRoot.querySelector('.toggle-input-track')\nexpect(track.classList.contains('checked')).toBe(false)"
              }
            ],
            "describes": []
          },
          {
            "title": "click behavior",
            "line": 102,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "should toggle when track clicked",
                "line": 104,
                "source": "const track = toggle.shadowRoot.querySelector('.toggle-input-track')\ntrack.click()\nexpect(toggle.checked).toBe(true)\n\ntrack.click()\nexpect(toggle.checked).toBe(false)"
              },
              {
                "title": "should toggle when label clicked",
                "line": 114,
                "source": "toggle.setLabel('Test')\nconst label = toggle.shadowRoot.querySelector('.toggle-input-label')\nlabel.click()\nexpect(toggle.checked).toBe(true)"
              }
            ],
            "describes": []
          },
          {
            "title": "change event",
            "line": 124,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "should emit change event when toggled",
                "line": 126,
                "source": "const handler = vi.fn()\ntoggle.addEventListener('change', handler)\n\nconst track = toggle.shadowRoot.querySelector('.toggle-input-track')\ntrack.click()\n\nexpect(handler).toHaveBeenCalled()\nexpect(handler.mock.calls[0][0].detail.checked).toBe(true)"
              },
              {
                "title": "should emit correct state in change event",
                "line": 138,
                "source": "toggle.setChecked(true)\n\nconst handler = vi.fn()\ntoggle.addEventListener('change', handler)\n\nconst track = toggle.shadowRoot.querySelector('.toggle-input-track')\ntrack.click()\n\nexpect(handler.mock.calls[0][0].detail.checked).toBe(false)"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/editor/vec2_input.doc.js": {
    "file": "/editor/vec2_input.test.js",
    "describes": [
      {
        "title": "Vec2Input",
        "line": 5,
        "beforeEach": {
          "line": 11,
          "source": "container = document.createElement('div')\ndocument.body.appendChild(container)\n\nvec2Input = document.createElement('vec2-input')\ncontainer.appendChild(vec2Input)"
        },
        "afterEach": {
          "line": 20,
          "source": "container.remove()"
        },
        "tests": [
          {
            "title": "value property should get and set value",
            "line": 44,
            "source": "const vec = {x: 10, y: 20}\nvec2Input.value = vec\nexpect(vec2Input.value).toBe(vec)"
          },
          {
            "title": "setLabel should set label text",
            "line": 51,
            "source": "vec2Input.setLabel('Position')\nconst label = vec2Input.shadowRoot.querySelector('.vec2-input-label')\nexpect(label.textContent).toBe('Position')"
          },
          {
            "title": "observedAttributes should include expected attributes",
            "line": 58,
            "source": "const observed = vec2Input.constructor.observedAttributes\nexpect(observed).toContain('label')"
          }
        ],
        "describes": [
          {
            "title": "initialization",
            "line": 25,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "should extend HTMLElement",
                "line": 27,
                "source": "expect(vec2Input).toBeInstanceOf(HTMLElement)"
              },
              {
                "title": "should have shadow DOM",
                "line": 32,
                "source": "expect(vec2Input.shadowRoot).not.toBeNull()"
              },
              {
                "title": "should have null default value",
                "line": 37,
                "source": "expect(vec2Input.value).toBeNull()"
              }
            ],
            "describes": []
          },
          {
            "title": "sub-inputs",
            "line": 64,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "should have x number input",
                "line": 66,
                "source": "const inputs = vec2Input.shadowRoot.querySelectorAll('number-input')\nconst xInput = Array.from(inputs).find(i => i.getAttribute('label') === 'x')\nexpect(xInput).not.toBeNull()"
              },
              {
                "title": "should have y number input",
                "line": 73,
                "source": "const inputs = vec2Input.shadowRoot.querySelectorAll('number-input')\nconst yInput = Array.from(inputs).find(i => i.getAttribute('label') === 'y')\nexpect(yInput).not.toBeNull()"
              },
              {
                "title": "should update x input when value set",
                "line": 80,
                "source": "vec2Input.value = {x: 100, y: 200}\nconst inputs = vec2Input.shadowRoot.querySelectorAll('number-input')\nconst xInput = Array.from(inputs).find(i => i.getAttribute('label') === 'x')\nexpect(xInput.value).toBe(100)"
              },
              {
                "title": "should update y input when value set",
                "line": 88,
                "source": "vec2Input.value = {x: 100, y: 200}\nconst inputs = vec2Input.shadowRoot.querySelectorAll('number-input')\nconst yInput = Array.from(inputs).find(i => i.getAttribute('label') === 'y')\nexpect(yInput.value).toBe(200)"
              }
            ],
            "describes": []
          },
          {
            "title": "change event",
            "line": 98,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "should emit change event when x changes",
                "line": 100,
                "source": "const vec = {x: 0, y: 0}\nvec2Input.value = vec\n\nconst handler = vi.fn()\nvec2Input.addEventListener('change', handler)\n\nconst inputs = vec2Input.shadowRoot.querySelectorAll('number-input')\nconst xInput = Array.from(inputs).find(i => i.getAttribute('label') === 'x')\nxInput.dispatchEvent(new CustomEvent('change', {\n    detail: {value: 50}\n}))\n\nexpect(handler).toHaveBeenCalled()\nexpect(handler.mock.calls[0][0].detail.axis).toBe('x')\nexpect(handler.mock.calls[0][0].detail.componentValue).toBe(50)"
              },
              {
                "title": "should emit change event when y changes",
                "line": 119,
                "source": "const vec = {x: 0, y: 0}\nvec2Input.value = vec\n\nconst handler = vi.fn()\nvec2Input.addEventListener('change', handler)\n\nconst inputs = vec2Input.shadowRoot.querySelectorAll('number-input')\nconst yInput = Array.from(inputs).find(i => i.getAttribute('label') === 'y')\nyInput.dispatchEvent(new CustomEvent('change', {\n    detail: {value: 75}\n}))\n\nexpect(handler).toHaveBeenCalled()\nexpect(handler.mock.calls[0][0].detail.axis).toBe('y')\nexpect(handler.mock.calls[0][0].detail.componentValue).toBe(75)"
              },
              {
                "title": "should update vec2 object when sub-input changes",
                "line": 138,
                "source": "const vec = {x: 0, y: 0}\nvec2Input.value = vec\n\nconst inputs = vec2Input.shadowRoot.querySelectorAll('number-input')\nconst xInput = Array.from(inputs).find(i => i.getAttribute('label') === 'x')\nxInput.dispatchEvent(new CustomEvent('change', {\n    detail: {value: 123}\n}))\n\nexpect(vec.x).toBe(123)"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/editor/inspectors/action_controller_inspector.doc.js": {
    "file": "/editor/inspectors/action_controller_inspector.test.js",
    "describes": [
      {
        "title": "ActionControllerInspector",
        "line": 34,
        "beforeEach": {
          "line": 40,
          "source": "container = document.createElement('div')\ndocument.body.appendChild(container)\n\ninspector = document.createElement('action-controller-inspector')\ncontainer.appendChild(inspector)"
        },
        "afterEach": {
          "line": 49,
          "source": "container.remove()"
        },
        "tests": [
          {
            "title": "matches returns true for ActionController instances",
            "line": 73,
            "source": "const mock = new MockActionController()\nObject.setPrototypeOf(mock, {constructor: {name: 'ActionController'}})\n\nconst matches = ActionControllerInspector.matches\nexpect(typeof matches).toBe('function')"
          },
          {
            "title": "execute button calls module.execute when clicked",
            "line": 157,
            "source": "const module = new MockActionController(['jump'])\nmodule.execute = vi.fn()\ninspector.setModule(module)\n\nconst btn = inspector.shadowRoot.querySelector('.execute-btn')\nbtn.click()\n\nexpect(module.execute).toHaveBeenCalledWith('jump')"
          }
        ],
        "describes": [
          {
            "title": "initialization",
            "line": 54,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "extends HTMLElement",
                "line": 56,
                "source": "expect(inspector).toBeInstanceOf(HTMLElement)"
              },
              {
                "title": "has shadow DOM",
                "line": 61,
                "source": "expect(inspector.shadowRoot).not.toBeNull()"
              },
              {
                "title": "hides gridEl",
                "line": 66,
                "source": "expect(inspector.gridEl.style.display).toBe('none')"
              }
            ],
            "describes": []
          },
          {
            "title": "setModule",
            "line": 82,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "stores the module",
                "line": 84,
                "source": "const module = new MockActionController(['jump'])\ninspector.setModule(module)\nexpect(inspector.getModule()).toBe(module)"
              },
              {
                "title": "renders actions when module is set",
                "line": 91,
                "source": "const module = new MockActionController(['jump', 'run'])\ninspector.setModule(module)\n\nconst actionCards = inspector.shadowRoot.querySelectorAll('.action-card')\nexpect(actionCards.length).toBe(2)"
              }
            ],
            "describes": []
          },
          {
            "title": "rendering",
            "line": 102,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "shows header with action count",
                "line": 104,
                "source": "const module = new MockActionController(['a', 'b', 'c'])\ninspector.setModule(module)\n\nconst header = inspector.shadowRoot.querySelector('.actions-header')\nexpect(header).not.toBeNull()\nexpect(header.textContent).toContain('3')"
              },
              {
                "title": "shows empty message when no actions",
                "line": 114,
                "source": "const module = new MockActionController([])\ninspector.setModule(module)\n\nconst empty = inspector.shadowRoot.querySelector('.empty-message')\nexpect(empty).not.toBeNull()\nexpect(empty.textContent).toBe('No actions defined')"
              },
              {
                "title": "renders action names",
                "line": 124,
                "source": "const module = new MockActionController(['jump', 'attack'])\ninspector.setModule(module)\n\nconst names = inspector.shadowRoot.querySelectorAll('.action-name')\nexpect(names.length).toBe(2)\nexpect(names[0].textContent).toBe('jump')\nexpect(names[1].textContent).toBe('attack')"
              },
              {
                "title": "shows propagable badge for propagable actions",
                "line": 135,
                "source": "const module = new MockActionController(['jump', 'attack'], ['jump'])\ninspector.setModule(module)\n\nconst badges = inspector.shadowRoot.querySelectorAll('.action-badge.propagable')\nexpect(badges.length).toBe(1)\nexpect(badges[0].textContent).toBe('propagable')"
              },
              {
                "title": "renders execute button for each action",
                "line": 145,
                "source": "const module = new MockActionController(['jump'])\ninspector.setModule(module)\n\nconst btn = inspector.shadowRoot.querySelector('.execute-btn')\nexpect(btn).not.toBeNull()\nexpect(btn.textContent).toContain('Run')"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/editor/inspectors/action_dispatcher_inspector.doc.js": {
    "file": "/editor/inspectors/action_dispatcher_inspector.test.js",
    "describes": [
      {
        "title": "ActionDispatcherInspector",
        "line": 39,
        "beforeEach": {
          "line": 45,
          "source": "container = document.createElement('div')\ndocument.body.appendChild(container)\n\ninspector = document.createElement('action-dispatcher-inspector')\ncontainer.appendChild(inspector)"
        },
        "afterEach": {
          "line": 54,
          "source": "container.remove()"
        },
        "tests": [
          {
            "title": "matches static matches method exists",
            "line": 78,
            "source": "expect(typeof ActionDispatcherInspector.matches).toBe('function')"
          },
          {
            "title": "execute button calls module.executeTo when clicked",
            "line": 176,
            "source": "const actionsMap = new Map([\n    ['player', [{name: 'jump'}]]\n])\nconst module = new MockActionDispatcher(actionsMap, ['player'])\nmodule.executeTo = vi.fn()\ninspector.setModule(module)\n\nconst btn = inspector.shadowRoot.querySelector('.execute-btn')\nbtn.click()\n\nexpect(module.executeTo).toHaveBeenCalledWith('player', 'jump')"
          }
        ],
        "describes": [
          {
            "title": "initialization",
            "line": 59,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "extends HTMLElement",
                "line": 61,
                "source": "expect(inspector).toBeInstanceOf(HTMLElement)"
              },
              {
                "title": "has shadow DOM",
                "line": 66,
                "source": "expect(inspector.shadowRoot).not.toBeNull()"
              },
              {
                "title": "hides gridEl",
                "line": 71,
                "source": "expect(inspector.gridEl.style.display).toBe('none')"
              }
            ],
            "describes": []
          },
          {
            "title": "setModule",
            "line": 83,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "stores the module",
                "line": 85,
                "source": "const module = new MockActionDispatcher()\ninspector.setModule(module)\nexpect(inspector.getModule()).toBe(module)"
              },
              {
                "title": "renders controller groups when module is set",
                "line": 92,
                "source": "const actionsMap = new Map([\n    ['player', [{name: 'jump'}, {name: 'run'}]],\n    ['enemy', [{name: 'attack'}]]\n])\nconst module = new MockActionDispatcher(actionsMap)\ninspector.setModule(module)\n\nconst groups = inspector.shadowRoot.querySelectorAll('.controller-group')\nexpect(groups.length).toBe(2)"
              }
            ],
            "describes": []
          },
          {
            "title": "rendering",
            "line": 107,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "shows header with total action and controller count",
                "line": 109,
                "source": "const actionsMap = new Map([\n    ['player', [{name: 'jump'}, {name: 'run'}]],\n    ['enemy', [{name: 'attack'}]]\n])\nconst module = new MockActionDispatcher(actionsMap)\ninspector.setModule(module)\n\nconst header = inspector.shadowRoot.querySelector('.actions-header')\nexpect(header).not.toBeNull()\nexpect(header.textContent).toContain('3')\nexpect(header.textContent).toContain('2')"
              },
              {
                "title": "shows empty message when no controllers",
                "line": 124,
                "source": "const module = new MockActionDispatcher(new Map())\ninspector.setModule(module)\n\nconst empty = inspector.shadowRoot.querySelector('.empty-message')\nexpect(empty).not.toBeNull()\nexpect(empty.textContent).toBe('No controllers registered')"
              },
              {
                "title": "renders controller group headers",
                "line": 134,
                "source": "const actionsMap = new Map([\n    ['player', [{name: 'jump'}]]\n])\nconst module = new MockActionDispatcher(actionsMap)\ninspector.setModule(module)\n\nconst groupName = inspector.shadowRoot.querySelector('.group-name')\nexpect(groupName).not.toBeNull()\nexpect(groupName.textContent).toBe('player')"
              },
              {
                "title": "renders action cards with names",
                "line": 147,
                "source": "const actionsMap = new Map([\n    ['player', [{name: 'jump'}, {name: 'attack'}]]\n])\nconst module = new MockActionDispatcher(actionsMap)\ninspector.setModule(module)\n\nconst names = inspector.shadowRoot.querySelectorAll('.action-name')\nexpect(names.length).toBe(2)\nexpect(names[0].textContent).toBe('jump')\nexpect(names[1].textContent).toBe('attack')"
              },
              {
                "title": "shows empty message in group when controller has no actions",
                "line": 161,
                "source": "const actionsMap = new Map([\n    ['player', []]\n])\nconst module = new MockActionDispatcher(actionsMap)\ninspector.setModule(module)\n\nconst empty = inspector.shadowRoot.querySelector('.controller-group .empty-message')\nexpect(empty).not.toBeNull()\nexpect(empty.textContent).toBe('No actions')"
              }
            ],
            "describes": []
          },
          {
            "title": "active controller toggle",
            "line": 191,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "renders toggle for each controller group",
                "line": 193,
                "source": "const actionsMap = new Map([\n    ['player', [{name: 'jump'}]],\n    ['enemy', [{name: 'attack'}]]\n])\nconst module = new MockActionDispatcher(actionsMap, ['player'])\ninspector.setModule(module)\n\nconst toggles = inspector.shadowRoot.querySelectorAll('toggle-input')\nexpect(toggles.length).toBe(2)"
              },
              {
                "title": "toggle is checked when controller is active",
                "line": 206,
                "source": "const actionsMap = new Map([\n    ['player', [{name: 'jump'}]]\n])\nconst module = new MockActionDispatcher(actionsMap, ['player'])\ninspector.setModule(module)\n\nconst toggle = inspector.shadowRoot.querySelector('toggle-input')\nexpect(toggle.checked).toBe(true)"
              },
              {
                "title": "toggle is unchecked when controller is inactive",
                "line": 218,
                "source": "const actionsMap = new Map([\n    ['player', [{name: 'jump'}]]\n])\nconst module = new MockActionDispatcher(actionsMap, [])\ninspector.setModule(module)\n\nconst toggle = inspector.shadowRoot.querySelector('toggle-input')\nexpect(toggle.checked).toBe(false)"
              },
              {
                "title": "inactive controller group has group-inactive class",
                "line": 230,
                "source": "const actionsMap = new Map([\n    ['player', [{name: 'jump'}]]\n])\nconst module = new MockActionDispatcher(actionsMap, [])\ninspector.setModule(module)\n\nconst group = inspector.shadowRoot.querySelector('.controller-group')\nexpect(group.classList.contains('group-inactive')).toBe(true)"
              },
              {
                "title": "active controller group does not have group-inactive class",
                "line": 242,
                "source": "const actionsMap = new Map([\n    ['player', [{name: 'jump'}]]\n])\nconst module = new MockActionDispatcher(actionsMap, ['player'])\ninspector.setModule(module)\n\nconst group = inspector.shadowRoot.querySelector('.controller-group')\nexpect(group.classList.contains('group-inactive')).toBe(false)"
              },
              {
                "title": "clicking toggle activates inactive controller",
                "line": 254,
                "source": "const actionsMap = new Map([\n    ['player', [{name: 'jump'}]]\n])\nconst module = new MockActionDispatcher(actionsMap, [])\nmodule.setActive = vi.fn()\ninspector.setModule(module)\n\nconst toggle = inspector.shadowRoot.querySelector('toggle-input')\ntoggle.dispatchEvent(new CustomEvent('change', {detail: {checked: true}}))\n\nexpect(module.setActive).toHaveBeenCalledWith(['player'])"
              },
              {
                "title": "clicking toggle deactivates active controller",
                "line": 269,
                "source": "const actionsMap = new Map([\n    ['player', [{name: 'jump'}]],\n    ['enemy', [{name: 'attack'}]]\n])\nconst module = new MockActionDispatcher(actionsMap, ['player', 'enemy'])\nmodule.setActive = vi.fn()\ninspector.setModule(module)\n\nconst toggle = inspector.shadowRoot.querySelector('toggle-input')\ntoggle.dispatchEvent(new CustomEvent('change', {detail: {checked: false}}))\n\nexpect(module.setActive).toHaveBeenCalledWith(['enemy'])"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/doc/doc_page.doc.js": {
    "file": "/doc/doc_page.test.js",
    "describes": [
      {
        "title": "doc_page",
        "line": 30,
        "beforeEach": {
          "line": 34,
          "source": "if (!globalThis.customElements) {\n    globalThis.customElements = {\n        define: vi.fn(),\n        get: vi.fn()\n    }\n}\n\nif (!globalThis.HTMLElement) {\n    globalThis.HTMLElement = class {\n        attachShadow () {\n            return {\n                appendChild: vi.fn(),\n                querySelector: vi.fn(() => ({innerHTML: '', appendChild: vi.fn()})),\n                querySelectorAll: vi.fn(() => []),\n                getElementById: vi.fn(),\n                addEventListener: vi.fn()\n            }\n        }\n    }\n}\n\nconst module = await import('./doc_page.js')\nDocPage = module.default"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "exports DocPage class",
            "line": 61,
            "source": "expect(DocPage).toBeDefined()\nexpect(typeof DocPage).toBe('function')"
          },
          {
            "title": "DocPage extends HTMLElement",
            "line": 67,
            "source": "expect(DocPage.prototype).toBeInstanceOf(HTMLElement)"
          },
          {
            "title": "renderBlock handles see block type",
            "line": 123,
            "source": "const page = new DocPage()\nconst seeBlock = {\n    type: 'see',\n    name: 'ActionController',\n    pageType: 'doc',\n    section: null\n}\n\npage.doc = {\n    title: 'Test',\n    blocks: [seeBlock]\n}"
          }
        ],
        "describes": [
          {
            "title": "properties",
            "line": 72,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "doc getter and setter",
                "line": 74,
                "source": "const page = new DocPage()\nexpect(page.doc).toBeNull()\n\nconst docData = {title: 'Test', blocks: []}\npage.doc = docData\nexpect(page.doc).toBe(docData)"
              },
              {
                "title": "api getter and setter",
                "line": 84,
                "source": "const page = new DocPage()\nexpect(page.api).toBeNull()\n\nconst apiData = {type: 'class', name: 'Test'}\npage.api = apiData\nexpect(page.api).toBe(apiData)"
              },
              {
                "title": "sources getter and setter",
                "line": 94,
                "source": "const page = new DocPage()\nexpect(page.sources).toBeNull()\n\nconst sources = [{type: 'code', title: 'Example', source: 'code'}]\npage.sources = sources\nexpect(page.sources).toBe(sources)"
              },
              {
                "title": "tests getter and setter",
                "line": 104,
                "source": "const page = new DocPage()\nexpect(page.tests).toBeNull()\n\nconst tests = {describes: []}\npage.tests = tests\nexpect(page.tests).toBe(tests)"
              },
              {
                "title": "initialTab setter validates values",
                "line": 114,
                "source": "const page = new DocPage()\npage.initialTab = 'api'\npage.initialTab = 'invalid'"
              }
            ],
            "describes": []
          },
          {
            "title": "inline see links in text",
            "line": 139,
            "beforeEach": null,
            "afterEach": null,
            "tests": [
              {
                "title": "parses [[Name]] as doc link",
                "line": 141,
                "source": "const page = new DocPage()\npage.doc = {\n    title: 'Test',\n    blocks: [{\n        type: 'text',\n        content: 'See [[ActionController]] for more.'\n    }]\n}"
              },
              {
                "title": "parses [[Name#Section]] as doc link with section",
                "line": 153,
                "source": "const page = new DocPage()\npage.doc = {\n    title: 'Test',\n    blocks: [{\n        type: 'text',\n        content: 'See [[ActionController#Propagation]] for details.'\n    }]\n}"
              },
              {
                "title": "parses [[Name:api]] as API link",
                "line": 165,
                "source": "const page = new DocPage()\npage.doc = {\n    title: 'Test',\n    blocks: [{\n        type: 'text',\n        content: 'Check [[ActionController:api]] for methods.'\n    }]\n}"
              },
              {
                "title": "parses [[Name:api#Section]] as API link with section",
                "line": 177,
                "source": "const page = new DocPage()\npage.doc = {\n    title: 'Test',\n    blocks: [{\n        type: 'text',\n        content: 'See [[ActionController:api#methods]] for the full list.'\n    }]\n}"
              },
              {
                "title": "parses [[Name:guide]] as guide link",
                "line": 189,
                "source": "const page = new DocPage()\npage.doc = {\n    title: 'Test',\n    blocks: [{\n        type: 'text',\n        content: 'Read [[philosophy:guide]] for the overview.'\n    }]\n}"
              },
              {
                "title": "parses multiple inline links in same text",
                "line": 201,
                "source": "const page = new DocPage()\npage.doc = {\n    title: 'Test',\n    blocks: [{\n        type: 'text',\n        content: 'See [[ActionController]] and [[ActionDispatcher#Stack]].'\n    }]\n}"
              }
            ],
            "describes": []
          }
        ]
      }
    ]
  },
  "/doc/runtime.doc.js": {
    "file": "/doc/runtime.test.js",
    "describes": [
      {
        "title": "doc",
        "line": 19,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "creates doc with title and blocks",
            "line": 21,
            "source": "const result = doc('My Doc', () => {\n    text('Hello')\n})\n\nexpect(result.title).toBe('My Doc')\nexpect(result.blocks).toHaveLength(1)\nexpect(result.blocks[0].type).toBe('text')"
          },
          {
            "title": "accepts options object",
            "line": 32,
            "source": "const result = doc('My Doc', {foo: 'bar'}, () => {\n    text('Hello')\n})\n\nexpect(result.title).toBe('My Doc')\nexpect(result.options.foo).toBe('bar')"
          },
          {
            "title": "options defaults to empty object when callback is second arg",
            "line": 42,
            "source": "const result = doc('My Doc', () => {})\n\nexpect(result.options).toEqual({})"
          }
        ],
        "describes": []
      },
      {
        "title": "section",
        "line": 51,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "creates section block",
            "line": 53,
            "source": "const result = doc('Test', () => {\n    section('Section 1', () => {\n        text('Content')\n    })\n})\n\nexpect(result.blocks).toHaveLength(1)\nexpect(result.blocks[0].type).toBe('section')\nexpect(result.blocks[0].title).toBe('Section 1')\nexpect(result.blocks[0].blocks).toHaveLength(1)"
          },
          {
            "title": "throws when called outside doc",
            "line": 67,
            "source": "expect(() => {\n    section('Test', () => {})\n}).toThrow('section() must be called inside doc()')"
          },
          {
            "title": "captures setup from within section",
            "line": 74,
            "source": "const setupFn = () => {}\n\nconst result = doc('Test', () => {\n    section('With Setup', () => {\n        setup(setupFn)\n        text('Content')\n    })\n})\n\nexpect(result.blocks[0].setup).not.toBeNull()\nexpect(result.blocks[0].setup.fn).toBe(setupFn)"
          }
        ],
        "describes": []
      },
      {
        "title": "text",
        "line": 91,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "creates text block",
            "line": 93,
            "source": "const result = doc('Test', () => {\n    text('Hello world')\n})\n\nexpect(result.blocks[0].type).toBe('text')\nexpect(result.blocks[0].content).toBe('Hello world')"
          },
          {
            "title": "throws when called outside doc",
            "line": 103,
            "source": "expect(() => {\n    text('Hello')\n}).toThrow('text() must be called inside doc()')"
          },
          {
            "title": "dedents content",
            "line": 110,
            "source": "const result = doc('Test', () => {\n    text(`\n        First line\n        Second line\n    `)\n})\n\nexpect(result.blocks[0].content).toBe('First line\\nSecond line')"
          }
        ],
        "describes": []
      },
      {
        "title": "code",
        "line": 124,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "creates code block",
            "line": 126,
            "source": "const result = doc('Test', () => {\n    code('Example', () => {\n        const x = 1\n        return x\n    })\n})\n\nexpect(result.blocks[0].type).toBe('code')\nexpect(result.blocks[0].title).toBe('Example')\nexpect(result.blocks[0].source).toContain('const x = 1')"
          },
          {
            "title": "throws when called outside doc",
            "line": 140,
            "source": "expect(() => {\n    code('Test', () => {})\n}).toThrow('code() must be called inside doc()')"
          }
        ],
        "describes": []
      },
      {
        "title": "action",
        "line": 149,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "creates action block with fn",
            "line": 151,
            "source": "const fn = () => console.log('action')\n\nconst result = doc('Test', () => {\n    action('Run', fn)\n})\n\nexpect(result.blocks[0].type).toBe('action')\nexpect(result.blocks[0].title).toBe('Run')\nexpect(result.blocks[0].fn).toBe(fn)"
          },
          {
            "title": "throws when called outside doc",
            "line": 164,
            "source": "expect(() => {\n    action('Test', () => {})\n}).toThrow('action() must be called inside doc()')"
          }
        ],
        "describes": []
      },
      {
        "title": "container",
        "line": 173,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "creates container with default height",
            "line": 175,
            "source": "const result = doc('Test', () => {\n    container(() => {})\n})\n\nexpect(result.blocks[0].type).toBe('container')\nexpect(result.blocks[0].height).toBe(300)\nexpect(result.blocks[0].width).toBeNull()"
          },
          {
            "title": "creates container with options",
            "line": 186,
            "source": "const result = doc('Test', () => {\n    container({width: 400, height: 500, title: 'Demo'}, () => {})\n})\n\nexpect(result.blocks[0].width).toBe(400)\nexpect(result.blocks[0].height).toBe(500)\nexpect(result.blocks[0].title).toBe('Demo')"
          },
          {
            "title": "supports preset option",
            "line": 197,
            "source": "const result = doc('Test', () => {\n    container({preset: 'interactive'}, () => {})\n})\n\nexpect(result.blocks[0].preset).toBe('interactive')"
          },
          {
            "title": "supports scrollable option",
            "line": 206,
            "source": "const result = doc('Test', () => {\n    container({scrollable: true}, () => {})\n})\n\nexpect(result.blocks[0].scrollable).toBe(true)"
          },
          {
            "title": "throws when called outside doc",
            "line": 215,
            "source": "expect(() => {\n    container(() => {})\n}).toThrow('container() must be called inside doc()')"
          }
        ],
        "describes": []
      },
      {
        "title": "see",
        "line": 224,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "creates see block with defaults",
            "line": 226,
            "source": "const result = doc('Test', () => {\n    see('ActionController')\n})\n\nexpect(result.blocks[0].type).toBe('see')\nexpect(result.blocks[0].name).toBe('ActionController')\nexpect(result.blocks[0].pageType).toBe('doc')\nexpect(result.blocks[0].section).toBeNull()"
          },
          {
            "title": "creates see block with section",
            "line": 238,
            "source": "const result = doc('Test', () => {\n    see('ActionController', {section: 'Propagation'})\n})\n\nexpect(result.blocks[0].name).toBe('ActionController')\nexpect(result.blocks[0].section).toBe('Propagation')"
          },
          {
            "title": "creates see block with type",
            "line": 248,
            "source": "const result = doc('Test', () => {\n    see('ActionController', {type: 'api'})\n})\n\nexpect(result.blocks[0].pageType).toBe('api')"
          },
          {
            "title": "creates see block with type and section",
            "line": 257,
            "source": "const result = doc('Test', () => {\n    see('ActionController', {type: 'api', section: 'methods'})\n})\n\nexpect(result.blocks[0].pageType).toBe('api')\nexpect(result.blocks[0].section).toBe('methods')"
          },
          {
            "title": "throws when called outside doc",
            "line": 267,
            "source": "expect(() => {\n    see('ActionController')\n}).toThrow('see() must be called inside doc()')"
          },
          {
            "title": "creates see block with category",
            "line": 274,
            "source": "const result = doc('Test', () => {\n    see('Application', {category: 'application'})\n})\n\nexpect(result.blocks[0].name).toBe('Application')\nexpect(result.blocks[0].category).toBe('application')"
          },
          {
            "title": "creates see block with category and type",
            "line": 284,
            "source": "const result = doc('Test', () => {\n    see('GameLoop', {category: 'game', type: 'api'})\n})\n\nexpect(result.blocks[0].name).toBe('GameLoop')\nexpect(result.blocks[0].category).toBe('game')\nexpect(result.blocks[0].pageType).toBe('api')"
          },
          {
            "title": "category defaults to null",
            "line": 295,
            "source": "const result = doc('Test', () => {\n    see('PerkyModule')\n})\n\nexpect(result.blocks[0].category).toBeNull()"
          }
        ],
        "describes": []
      },
      {
        "title": "disclaimer",
        "line": 306,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "creates disclaimer block",
            "line": 308,
            "source": "const result = doc('Test', () => {\n    disclaimer('This is a disclaimer')\n})\n\nexpect(result.blocks[0].type).toBe('disclaimer')\nexpect(result.blocks[0].content).toBe('This is a disclaimer')"
          },
          {
            "title": "dedents content",
            "line": 318,
            "source": "const result = doc('Test', () => {\n    disclaimer(`\n        First line\n        Second line\n    `)\n})\n\nexpect(result.blocks[0].content).toBe('First line\\nSecond line')"
          },
          {
            "title": "throws when called outside doc",
            "line": 330,
            "source": "expect(() => {\n    disclaimer('Test')\n}).toThrow('disclaimer() must be called inside doc()')"
          }
        ],
        "describes": []
      },
      {
        "title": "applyContainerPreset",
        "line": 339,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "applies interactive preset",
            "line": 341,
            "source": "const element = {\n    style: {},\n    tabIndex: -1\n}\n\napplyContainerPreset(element, 'interactive')\n\nexpect(element.tabIndex).toBe(0)\nexpect(element.style.outline).toBe('none')\nexpect(element.style.background).toBe('#1a1a2e')"
          },
          {
            "title": "applies interactive-alt preset",
            "line": 355,
            "source": "const element = {\n    style: {},\n    tabIndex: -1\n}\n\napplyContainerPreset(element, 'interactive-alt')\n\nexpect(element.style.background).toBe('#16213e')"
          },
          {
            "title": "applies inspector preset",
            "line": 367,
            "source": "const element = {style: {}}\n\napplyContainerPreset(element, 'inspector')\n\nexpect(element.style.padding).toBe('12px')\nexpect(element.style.overflow).toBe('auto')"
          },
          {
            "title": "applies centered preset",
            "line": 377,
            "source": "const element = {style: {}}\n\napplyContainerPreset(element, 'centered')\n\nexpect(element.style.display).toBe('flex')\nexpect(element.style.alignItems).toBe('center')\nexpect(element.style.justifyContent).toBe('center')"
          },
          {
            "title": "ignores unknown preset",
            "line": 388,
            "source": "const element = {style: {}}\n\napplyContainerPreset(element, 'unknown')\n\nexpect(Object.keys(element.style)).toHaveLength(0)"
          }
        ],
        "describes": []
      },
      {
        "title": "addSpacerIfNeeded",
        "line": 399,
        "beforeEach": {
          "line": 401,
          "source": "logger.history.length = 0\nvi.clearAllMocks()"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "adds spacer when history has logs and no trailing spacer",
            "line": 407,
            "source": "logger.history.push({event: 'log'})\n\naddSpacerIfNeeded()\n\nexpect(logger.spacer).toHaveBeenCalled()"
          },
          {
            "title": "does not add spacer when history is empty",
            "line": 416,
            "source": "addSpacerIfNeeded()\n\nexpect(logger.spacer).not.toHaveBeenCalled()"
          },
          {
            "title": "does not add spacer when last entry is already spacer",
            "line": 423,
            "source": "logger.history.push({event: 'log'}, {event: 'spacer'})\n\naddSpacerIfNeeded()\n\nexpect(logger.spacer).not.toHaveBeenCalled()"
          }
        ],
        "describes": []
      },
      {
        "title": "executeAction",
        "line": 434,
        "beforeEach": {
          "line": 436,
          "source": "logger.history.length = 0\nvi.clearAllMocks()"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "executes block function",
            "line": 442,
            "source": "const fn = vi.fn()\nconst block = {fn}\n\nawait executeAction(block)\n\nexpect(fn).toHaveBeenCalledWith({})"
          },
          {
            "title": "executes setup function before block",
            "line": 452,
            "source": "const order = []\nconst setupFn = vi.fn(() => order.push('setup'))\nconst blockFn = vi.fn(() => order.push('block'))\nconst block = {fn: blockFn}\nconst sectionSetup = {fn: setupFn}\n\nawait executeAction(block, sectionSetup)\n\nexpect(order).toEqual(['setup', 'block'])"
          },
          {
            "title": "logs error on failure",
            "line": 465,
            "source": "const block = {fn: () => {\n    throw new Error('Test error')\n}}\n\nawait executeAction(block)\n\nexpect(logger.error).toHaveBeenCalledWith('Action error:', 'Test error')"
          }
        ],
        "describes": []
      },
      {
        "title": "executeContainer",
        "line": 478,
        "beforeEach": {
          "line": 480,
          "source": "logger.history.length = 0\nvi.clearAllMocks()"
        },
        "afterEach": null,
        "tests": [
          {
            "title": "clears container before execution",
            "line": 486,
            "source": "const containerEl = {\n    innerHTML: '<div>old</div>',\n    _currentApp: null,\n    style: {},\n    tabIndex: -1\n}\nconst block = {fn: vi.fn()}\n\nawait executeContainer(block, containerEl)\n\nexpect(containerEl.innerHTML).toBe('')"
          },
          {
            "title": "disposes previous app",
            "line": 501,
            "source": "const dispose = vi.fn()\nconst containerEl = {\n    innerHTML: '',\n    _currentApp: {dispose},\n    style: {},\n    tabIndex: -1\n}\nconst block = {fn: vi.fn()}\n\nawait executeContainer(block, containerEl)\n\nexpect(dispose).toHaveBeenCalled()"
          },
          {
            "title": "applies preset when specified",
            "line": 517,
            "source": "const containerEl = {\n    innerHTML: '',\n    _currentApp: null,\n    style: {},\n    tabIndex: -1\n}\nconst block = {preset: 'interactive', fn: vi.fn()}\n\nawait executeContainer(block, containerEl)\n\nexpect(containerEl.tabIndex).toBe(0)"
          },
          {
            "title": "sets overflow when scrollable",
            "line": 532,
            "source": "const containerEl = {\n    innerHTML: '',\n    _currentApp: null,\n    style: {},\n    tabIndex: -1\n}\nconst block = {scrollable: true, fn: vi.fn()}\n\nawait executeContainer(block, containerEl)\n\nexpect(containerEl.style.overflow).toBe('auto')"
          },
          {
            "title": "logs error on failure",
            "line": 547,
            "source": "const containerEl = {\n    innerHTML: '',\n    _currentApp: null,\n    style: {},\n    tabIndex: -1\n}\nconst block = {fn: () => {\n    throw new Error('Container error')\n}}\n\nawait executeContainer(block, containerEl)\n\nexpect(logger.error).toHaveBeenCalledWith('Container error:', 'Container error')"
          }
        ],
        "describes": []
      },
      {
        "title": "renderAction",
        "line": 566,
        "beforeEach": null,
        "afterEach": null,
        "tests": [
          {
            "title": "creates action block wrapper",
            "line": 568,
            "source": "const block = {title: 'Run Test', source: 'console.log(\"test\")'}\n\nconst el = renderAction(block)\n\nexpect(el.className).toBe('doc-action-block')"
          },
          {
            "title": "creates perky-code element with title",
            "line": 577,
            "source": "const block = {title: 'Example', source: 'const x = 1'}\n\nconst el = renderAction(block)\nconst codeEl = el.querySelector('perky-code')\n\nexpect(codeEl.getAttribute('title')).toBe('Example')"
          },
          {
            "title": "uses extracted source when provided",
            "line": 587,
            "source": "const block = {title: 'Test', source: 'original'}\n\nconst el = renderAction(block, null, 'extracted')\nconst codeEl = el.querySelector('perky-code')\n\nexpect(codeEl.code).toBe('extracted')"
          },
          {
            "title": "creates run button",
            "line": 597,
            "source": "const block = {title: 'Test', source: ''}\n\nconst el = renderAction(block)\nconst button = el.querySelector('.doc-action-btn')\n\nexpect(button).toBeTruthy()\nexpect(button.textContent).toContain('Run')"
          }
        ],
        "describes": []
      }
    ]
  }
}