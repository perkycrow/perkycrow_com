{
  "/core/perky_module.doc.js": {
    "type": "class",
    "file": "/core/perky_module.js",
    "name": "PerkyModule",
    "line": 8,
    "extends": "Notifier",
    "statics": [
      {
        "name": "$category",
        "line": 30,
        "source": "static $category = 'perkyModule'",
        "kind": "property",
        "value": "'perkyModule'"
      },
      {
        "name": "$name",
        "line": 31,
        "source": "static $name = null",
        "kind": "property",
        "value": "null"
      },
      {
        "name": "$lifecycle",
        "line": 32,
        "source": "static $lifecycle = true",
        "kind": "property",
        "value": "true"
      },
      {
        "name": "$eagerStart",
        "line": 33,
        "source": "static $eagerStart = true",
        "kind": "property",
        "value": "true"
      },
      {
        "name": "$tags",
        "line": 34,
        "source": "static $tags = []",
        "kind": "property",
        "value": "[]"
      },
      {
        "name": "perkyModuleMethods",
        "line": 533,
        "source": "static perkyModuleMethods = Notifier.notifierMethods.concat([\n    'start',\n    'stop',\n    'dispose',\n    'install',\n    'uninstall',\n    'create',\n    'addChild',\n    'getChild',\n    'hasChild',\n    'removeChild',\n    'listNamesFor',\n    'lookup',\n    'childrenByCategory',\n    'hasTag',\n    'addTag',\n    'removeTag',\n    'hasTags',\n    'childrenByTags',\n    'addTagsIndex',\n    'removeTagsIndex',\n    'delegateTo',\n    'cleanDelegations',\n    'delegateEventsTo',\n    'cleanEventDelegations',\n    'query',\n    'queryAll'\n])",
        "kind": "property",
        "value": "Notifier.notifierMethods.concat([\n    'start',\n    'stop',\n    'dispose',\n    'install',\n    'uninstall',\n    'create',\n    'addChild',\n    'getChild',\n    'hasChild',\n    'removeChild',\n    'listNamesFor',\n    'lookup',\n    'childrenByCategory',\n    'hasTag',\n    'addTag',\n    'removeTag',\n    'hasTags',\n    'childrenByTags',\n    'addTagsIndex',\n    'removeTagsIndex',\n    'delegateTo',\n    'cleanDelegations',\n    'delegateEventsTo',\n    'cleanEventDelegations',\n    'query',\n    'queryAll'\n])"
      }
    ],
    "methods": [
      {
        "name": "start",
        "line": 169,
        "source": "start () {\n    if (this.#started) {\n        return false\n    }\n\n    this.#started = true\n    this.onStart?.()\n    this.emit('start')\n\n    return true\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "stop",
        "line": 182,
        "source": "stop () {\n    if (!this.#started) {\n        return false\n    }\n\n    this.#started = false\n    this.onStop?.()\n    this.emit('stop')\n\n    return true\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "dispose",
        "line": 195,
        "source": "dispose () {\n    if (this.#disposed) {\n        return false\n    }\n\n    this.#disposed = true\n    this.stop()\n\n    this.cleanExternalListeners()\n\n    this.#childrenRegistry.forEach(child => {\n        if (child && !child.disposed) {\n            child.dispose()\n        }\n    })\n    this.#childrenRegistry.clear()\n\n    this.onDispose?.()\n    this.emit('dispose')\n    this.removeListeners()\n\n    return true\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "install",
        "line": 220,
        "source": "install (host, options) {\n    if (this.#installed) {\n        return this.uninstall()\n    }\n\n    this.#host = host\n    if (this.$bind) {\n        host[this.$bind] = this\n    }\n    this.#installed = true\n\n    this.onInstall?.(host, options)\n\n    return true\n}",
        "kind": "method",
        "params": [
          "host",
          "options"
        ]
      },
      {
        "name": "uninstall",
        "line": 237,
        "source": "uninstall () {\n    if (!this.#installed) {\n        return false\n    }\n\n    this.cleanDelegations()\n    this.cleanEventDelegations()\n    this.onUninstall?.(this.#host)\n    this.#installed = false\n    this.#host = null\n\n    return true\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "create",
        "line": 262,
        "source": "create (Child, options = {}) {\n    options.$category ||= Child.$category\n    options.$name ||= Child.$name || options.$category\n    options.$lifecycle = options.$lifecycle ?? Child.$lifecycle ?? true\n    options.$eagerStart = options.$eagerStart ?? Child.$eagerStart ?? true\n\n    const hasExplicitId = '$id' in options\n\n    if (hasExplicitId) {\n        unregisterExisting(this, options.$id)\n    }\n\n    return this.addChild(new Child(options))\n}",
        "kind": "method",
        "params": [
          "Child",
          "options = ..."
        ]
      },
      {
        "name": "addChild",
        "line": 278,
        "source": "addChild (child) {\n    if (!(child instanceof PerkyModule)) {\n        throw new Error('addChild expects a PerkyModule instance')\n    }\n\n    if (child.installed) {\n        throw new Error('Module is already installed in another parent')\n    }\n\n    if (this.#childrenRegistry.has(child.$id)) {\n        child.$id = this.#findUniqueId(child.$name)\n    }\n\n    return this.#addChild(child, child.options)\n}",
        "kind": "method",
        "params": [
          "child"
        ]
      },
      {
        "name": "getChild",
        "line": 317,
        "source": "getChild (name) {\n    return this.#childrenRegistry.get(name) || null\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "hasChild",
        "line": 322,
        "source": "hasChild (name) {\n    return this.#childrenRegistry.has(name)\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "removeChild",
        "line": 327,
        "source": "removeChild (name) {\n    const child = this.#childrenRegistry.get(name)\n\n    if (!child) {\n        return false\n    }\n\n    unregisterChild(this, child)\n\n    return true\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "listNamesFor",
        "line": 340,
        "source": "listNamesFor (key, indexName = '$category') {\n    return this.#childrenRegistry.lookupKeys(indexName, key)\n}",
        "kind": "method",
        "params": [
          "key",
          "indexName = ..."
        ]
      },
      {
        "name": "lookup",
        "line": 345,
        "source": "lookup (indexName, key) {\n    return this.#childrenRegistry.lookup(indexName, key)\n}",
        "kind": "method",
        "params": [
          "indexName",
          "key"
        ]
      },
      {
        "name": "childrenByCategory",
        "line": 350,
        "source": "childrenByCategory (category) {\n    return this.lookup('$category', category)\n}",
        "kind": "method",
        "params": [
          "category"
        ]
      },
      {
        "name": "hasTag",
        "line": 373,
        "source": "hasTag (tag) {\n    return this.#tags.has(tag)\n}",
        "kind": "method",
        "params": [
          "tag"
        ]
      },
      {
        "name": "addTag",
        "line": 378,
        "source": "addTag (tag) {\n    if (this.#tags.has(tag)) {\n        return false\n    }\n    this.#tags.add(tag)\n    return true\n}",
        "kind": "method",
        "params": [
          "tag"
        ]
      },
      {
        "name": "removeTag",
        "line": 387,
        "source": "removeTag (tag) {\n    return this.#tags.delete(tag)\n}",
        "kind": "method",
        "params": [
          "tag"
        ]
      },
      {
        "name": "hasTags",
        "line": 392,
        "source": "hasTags (tags) {\n    if (typeof tags === 'string') {\n        return this.hasTag(tags)\n    }\n\n    return Array.isArray(tags) && tags.every(tag => this.#tags.has(tag))\n}",
        "kind": "method",
        "params": [
          "tags"
        ]
      },
      {
        "name": "childrenByTags",
        "line": 401,
        "source": "childrenByTags (tags) {\n    const tagArray = Array.isArray(tags) ? tags : [tags]\n\n    if (tagArray.length === 0) {\n        return []\n    }\n\n    const indexKey = getTagIndexKey(tagArray)\n\n    if (this.#tagIndexes.has(indexKey)) {\n        return this.#childrenRegistry.lookup(indexKey, indexKey)\n    }\n\n    return this.#childrenRegistry.all.filter(\n        child => tagArray.every(tag => child.$tags?.includes(tag))\n    )\n}",
        "kind": "method",
        "params": [
          "tags"
        ]
      },
      {
        "name": "addTagsIndex",
        "line": 420,
        "source": "addTagsIndex (tags) {\n    if (!Array.isArray(tags) || tags.length === 0) {\n        return false\n    }\n\n    const indexKey = getTagIndexKey(tags)\n\n    if (this.#tagIndexes.has(indexKey)) {\n        return false\n    }\n\n    this.#childrenRegistry.addIndex(indexKey, child => {\n        const hasAllTags = tags.every(tag => child.tags?.has(tag))\n        return hasAllTags ? indexKey : null\n    })\n\n    this.#tagIndexes.set(indexKey, tags)\n\n    this.#childrenRegistry.forEach(child => {\n        if (child.tags) {\n            this.#setupTagIndexListeners(child)\n        }\n    })\n\n    return true\n}",
        "kind": "method",
        "params": [
          "tags"
        ]
      },
      {
        "name": "removeTagsIndex",
        "line": 448,
        "source": "removeTagsIndex (tags) {\n    const indexKey = getTagIndexKey(tags)\n\n    if (!this.#tagIndexes.has(indexKey)) {\n        return false\n    }\n\n    this.#childrenRegistry.removeIndex(indexKey)\n    this.#tagIndexes.delete(indexKey)\n    return true\n}",
        "kind": "method",
        "params": [
          "tags"
        ]
      },
      {
        "name": "delegateTo",
        "line": 478,
        "source": "delegateTo (host, names) {\n    delegateProperties(host, this, names)\n\n    const propertyNames = Array.isArray(names)\n        ? names\n        : Object.values(names)\n\n    this.#delegations.push({host, propertyNames})\n}",
        "kind": "method",
        "params": [
          "host",
          "names"
        ]
      },
      {
        "name": "cleanDelegations",
        "line": 489,
        "source": "cleanDelegations () {\n    for (const {host, propertyNames} of this.#delegations) {\n        for (const name of propertyNames) {\n            delete host[name]\n        }\n    }\n    this.#delegations.length = 0\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "delegateEventsTo",
        "line": 499,
        "source": "delegateEventsTo (host, events, namespace) {\n    const eventArray = Array.isArray(events) ? events : Object.keys(events)\n    const callbacks = []\n\n    for (const event of eventArray) {\n        const prefixedEvent = namespace ? `${namespace}:${event}` : event\n        const callback = (...args) => host.emit(prefixedEvent, ...args)\n        this.on(event, callback)\n        callbacks.push({event, callback})\n    }\n\n    this.#eventDelegations.push({callbacks})\n}",
        "kind": "method",
        "params": [
          "host",
          "events",
          "namespace"
        ]
      },
      {
        "name": "cleanEventDelegations",
        "line": 514,
        "source": "cleanEventDelegations () {\n    for (const {callbacks} of this.#eventDelegations) {\n        for (const {event, callback} of callbacks) {\n            this.off(event, callback)\n        }\n    }\n    this.#eventDelegations.length = 0\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "query",
        "line": 524,
        "source": "query (selector) {\n    return perkyQuery(this, selector)\n}",
        "kind": "method",
        "params": [
          "selector"
        ]
      },
      {
        "name": "queryAll",
        "line": 529,
        "source": "queryAll (selector) {\n    return perkyQueryAll(this, selector)\n}",
        "kind": "method",
        "params": [
          "selector"
        ]
      }
    ],
    "getters": [
      {
        "name": "$id",
        "line": 57,
        "source": "get $id () {\n    return this.#id\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "$name",
        "line": 72,
        "source": "get $name () {\n    return this.#name\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "$category",
        "line": 87,
        "source": "get $category () {\n    return this.#category\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "$bind",
        "line": 102,
        "source": "get $bind () {\n    return this.#bind\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "host",
        "line": 117,
        "source": "get host () {\n    return this.#host\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "started",
        "line": 122,
        "source": "get started () {\n    return this.#started\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "disposed",
        "line": 127,
        "source": "get disposed () {\n    return this.#disposed\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "installed",
        "line": 132,
        "source": "get installed () {\n    return this.#installed\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "$eagerStart",
        "line": 137,
        "source": "get $eagerStart () {\n    return this.#eagerStart\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "$lifecycle",
        "line": 142,
        "source": "get $lifecycle () {\n    return this.#lifecycle\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "$status",
        "line": 147,
        "source": "get $status () {\n    if (!this.#lifecycle) {\n        return 'static'\n    }\n\n    if (this.#disposed) {\n        return 'disposed'\n    }\n\n    if (this.#started) {\n        return 'started'\n    }\n\n    return 'stopped'\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "running",
        "line": 164,
        "source": "get running () {\n    return this.#started\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "children",
        "line": 252,
        "source": "get children () {\n    return this.#childrenRegistry.all\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "childrenRegistry",
        "line": 257,
        "source": "get childrenRegistry () {\n    return this.#childrenRegistry\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "$tags",
        "line": 355,
        "source": "get $tags () {\n    return this.#tags.toArray()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "tags",
        "line": 368,
        "source": "get tags () {\n    return this.#tags\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "$id",
        "line": 62,
        "source": "set $id (newId) {\n    const oldId = this.#id\n\n    if (oldId !== newId) {\n        this.#id = newId\n        this.emit('$id:changed', newId, oldId)\n    }\n}",
        "kind": "method",
        "params": [
          "newId"
        ]
      },
      {
        "name": "$name",
        "line": 77,
        "source": "set $name (newName) {\n    const oldName = this.#name\n\n    if (oldName !== newName) {\n        this.#name = newName\n        this.emit('$name:changed', newName, oldName)\n    }\n}",
        "kind": "method",
        "params": [
          "newName"
        ]
      },
      {
        "name": "$category",
        "line": 92,
        "source": "set $category (newCategory) {\n    const oldCategory = this.#category\n\n    if (oldCategory !== newCategory) {\n        this.#category = newCategory\n        this.emit('$category:changed', newCategory, oldCategory)\n    }\n}",
        "kind": "method",
        "params": [
          "newCategory"
        ]
      },
      {
        "name": "$bind",
        "line": 107,
        "source": "set $bind (newBind) {\n    const oldBind = this.#bind\n\n    if (oldBind !== newBind) {\n        this.#bind = newBind\n        this.emit('$bind:changed', newBind, oldBind)\n    }\n}",
        "kind": "method",
        "params": [
          "newBind"
        ]
      },
      {
        "name": "$tags",
        "line": 360,
        "source": "set $tags (newTags) {\n    this.#tags.clear()\n    if (Array.isArray(newTags)) {\n        newTags.forEach(tag => this.#tags.add(tag))\n    }\n}",
        "kind": "method",
        "params": [
          "newTags"
        ]
      }
    ],
    "constructor": {
      "name": "constructor",
      "line": 36,
      "source": "constructor (options = {}) {\n    super()\n\n    this.options = {...options}\n    this.#name = options.$name || this.constructor.$name || this.constructor.name\n    this.#id = options.$id || this.#name\n    this.#category = options.$category || this.constructor.$category\n    this.#bind = options.$bind\n    this.#eagerStart = (options.$eagerStart ?? this.constructor.$eagerStart) !== false\n    this.#lifecycle = (options.$lifecycle ?? this.constructor.$lifecycle) !== false\n\n    this.#tags = new ObservableSet([\n        ...this.constructor.$tags,\n        ...(options.$tags || [])\n    ])\n\n    this.#childrenRegistry = new Registry()\n    this.#childrenRegistry.addIndex('$category')\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/core/utils.doc.js": {
    "type": "module",
    "file": "/core/utils.js",
    "functions": [
      {
        "name": "toCamelCase",
        "line": 7,
        "params": [
          "string"
        ],
        "source": "function toCamelCase (string) {\n    return inflector.toCamelCase(string)\n}"
      },
      {
        "name": "toPascalCase",
        "line": 12,
        "params": [
          "string"
        ],
        "source": "function toPascalCase (string) {\n    return inflector.toPascalCase(string)\n}"
      },
      {
        "name": "toSnakeCase",
        "line": 17,
        "params": [
          "string"
        ],
        "source": "function toSnakeCase (string) {\n    return inflector.toSnakeCase(string)\n}"
      },
      {
        "name": "toKebabCase",
        "line": 22,
        "params": [
          "string"
        ],
        "source": "function toKebabCase (string) {\n    return inflector.toKebabCase(string)\n}"
      },
      {
        "name": "toHumanCase",
        "line": 27,
        "params": [
          "string"
        ],
        "source": "function toHumanCase (string) {\n    return inflector.toHumanCase(string)\n}"
      },
      {
        "name": "uniqueId",
        "line": 34,
        "params": [
          "collection",
          "prefix"
        ],
        "source": "function uniqueId (collection, prefix) {\n    if (!prefix) {\n        prefix = collection\n        collection = 'default'\n    }\n\n    if (!idCounter[collection]) {\n        idCounter[collection] = {}\n    }\n\n    if (!idCounter[collection][prefix]) {\n        idCounter[collection][prefix] = 0\n    }\n\n    const current = idCounter[collection][prefix]\n    idCounter[collection][prefix]++\n\n    return current === 0 ? prefix : `${prefix}_${current}`\n}"
      },
      {
        "name": "resetUniqueId",
        "line": 55,
        "params": [
          "collection",
          "prefix"
        ],
        "source": "function resetUniqueId (collection, prefix) {\n    if (prefix) {\n        if (idCounter[collection]) {\n            idCounter[collection][prefix] = 0\n        }\n    } else {\n        idCounter[collection] = {}\n    }\n}"
      },
      {
        "name": "singularize",
        "line": 66,
        "params": [
          "word"
        ],
        "source": "function singularize (word) {\n    return inflector.singular(word)\n}"
      },
      {
        "name": "pluralize",
        "line": 71,
        "params": [
          "word",
          "count",
          "inclusive"
        ],
        "source": "function pluralize (word, count, inclusive) {\n    return inflector.pluralize(word, count, inclusive)\n}"
      },
      {
        "name": "plural",
        "line": 76,
        "params": [
          "word"
        ],
        "source": "function plural (word) {\n    return inflector.plural(word)\n}"
      },
      {
        "name": "isPlural",
        "line": 81,
        "params": [
          "word"
        ],
        "source": "function isPlural (word) {\n    return inflector.isPlural(word)\n}"
      },
      {
        "name": "isSingular",
        "line": 86,
        "params": [
          "word"
        ],
        "source": "function isSingular (word) {\n    return inflector.isSingular(word)\n}"
      },
      {
        "name": "setDefaults",
        "line": 91,
        "params": [
          "data",
          "defaults"
        ],
        "source": "function setDefaults (data, defaults) {\n    return deepMerge(defaults, data)\n}"
      },
      {
        "name": "getNestedValue",
        "line": 96,
        "params": [
          "obj",
          "path"
        ],
        "source": "function getNestedValue (obj, path) {\n    if (!path) {\n        return obj\n    }\n\n    const parts = path.split('.')\n    let current = obj\n\n    for (const part of parts) {\n        if (current === undefined || current === null) {\n            return undefined\n        }\n        current = current[part]\n    }\n\n    return current\n}"
      },
      {
        "name": "setNestedValue",
        "line": 115,
        "params": [
          "obj",
          "path",
          "value"
        ],
        "source": "function setNestedValue (obj, path, value) {\n    const parts = path.split('.')\n    let current = obj\n\n    for (let i = 0; i < parts.length - 1; i++) {\n        const part = parts[i]\n        if (!current[part]) {\n            current[part] = {}\n        }\n        current = current[part]\n    }\n\n    current[parts[parts.length - 1]] = value\n    return obj\n}"
      },
      {
        "name": "deepMerge",
        "line": 132,
        "params": [
          "target",
          "source"
        ],
        "source": "function deepMerge (target, source) {\n    return deepMergeInternal(target, source, new WeakSet())\n}"
      },
      {
        "name": "deepMergeInternal",
        "line": 137,
        "params": [
          "target",
          "source",
          "seen"
        ],
        "source": "function deepMergeInternal (target, source, seen) {\n    if (!source) {\n        return target\n    }\n\n    if (typeof source === 'object' && source !== null) {\n        if (seen.has(source)) {\n            return source\n        }\n        seen.add(source)\n    }\n\n    const sourceIsArray = Array.isArray(source)\n    const targetIsArray = Array.isArray(target)\n\n    if (sourceIsArray !== targetIsArray) {\n        return cloneIfNeeded(source, seen)\n    }\n\n    if (sourceIsArray) {\n        return mergeArrays(target, source, seen)\n    }\n\n    return mergeObject(target, source, seen)\n}"
      },
      {
        "name": "exportValue",
        "line": 164,
        "params": [
          "value"
        ],
        "source": "function exportValue (value) {\n\n    if (value && typeof value === 'object') {\n        if (typeof value.export === 'function') {\n            return value.export()\n        }\n\n        if (Array.isArray(value)) {\n            return value.map(item => exportValue(item))\n        }\n\n        const result = {}\n        for (const key in value) {\n            if (Object.hasOwn(value, key)) {\n                result[key] = exportValue(value[key])\n            }\n        }\n        return result\n    }\n\n    return value\n}"
      },
      {
        "name": "isNonNullObject",
        "line": 188,
        "params": [
          "value"
        ],
        "source": "function isNonNullObject (value) {\n    return Boolean(value) && typeof value === 'object'\n}"
      },
      {
        "name": "isSpecial",
        "line": 193,
        "params": [
          "value"
        ],
        "source": "function isSpecial (value) {\n    const stringValue = Object.prototype.toString.call(value)\n    return stringValue === '[object RegExp]' || stringValue === '[object Date]'\n}"
      },
      {
        "name": "isMergeableObject",
        "line": 199,
        "params": [
          "value"
        ],
        "source": "function isMergeableObject (value) {\n    return isNonNullObject(value) && !isSpecial(value)\n}"
      },
      {
        "name": "emptyTarget",
        "line": 204,
        "params": [
          "value"
        ],
        "source": "function emptyTarget (value) {\n    return Array.isArray(value) ? [] : {}\n}"
      },
      {
        "name": "cloneIfNeeded",
        "line": 209,
        "params": [
          "value",
          "seen"
        ],
        "source": "function cloneIfNeeded (value, seen) {\n    return isMergeableObject(value) ? deepMergeInternal(emptyTarget(value), value, seen) : value\n}"
      },
      {
        "name": "mergeArrays",
        "line": 214,
        "params": [
          "target",
          "source",
          "seen"
        ],
        "source": "function mergeArrays (target, source, seen) {\n    return target.concat(source).map(element => cloneIfNeeded(element, seen))\n}"
      },
      {
        "name": "getKeys",
        "line": 219,
        "params": [
          "target"
        ],
        "source": "function getKeys (target) {\n    const symbols = Object.getOwnPropertySymbols\n        ? Object.getOwnPropertySymbols(target).filter(symbol =>\n            Object.propertyIsEnumerable.call(target, symbol))\n        : []\n    return Object.keys(target).concat(symbols)\n}"
      },
      {
        "name": "mergeObject",
        "line": 228,
        "params": [
          "target",
          "source",
          "seen"
        ],
        "source": "function mergeObject (target, source, seen) {\n    const destination = {}\n\n    if (isMergeableObject(target)) {\n        getKeys(target).forEach(key => {\n            destination[key] = cloneIfNeeded(target[key], seen)\n        })\n    }\n\n    getKeys(source).forEach(key => {\n        if ((key in target) && isMergeableObject(source[key])) {\n            destination[key] = deepMergeInternal(target[key], source[key], seen)\n        } else {\n            destination[key] = cloneIfNeeded(source[key], seen)\n        }\n    })\n\n    return destination\n}"
      },
      {
        "name": "formatNumber",
        "line": 249,
        "params": [
          "n"
        ],
        "source": "function formatNumber (n) {\n    if (typeof n !== 'number') {\n        return String(n)\n    }\n    return Number.isInteger(n) ? String(n) : n.toFixed(2)\n}"
      },
      {
        "name": "formatBytes",
        "line": 257,
        "params": [
          "bytes"
        ],
        "source": "function formatBytes (bytes) {\n    if (bytes === 0) {\n        return '0 B'\n    }\n\n    const units = ['B', 'KB', 'MB', 'GB']\n    const i = Math.floor(Math.log(bytes) / Math.log(1024))\n    const value = bytes / Math.pow(1024, i)\n\n    return `${value.toFixed(i > 1 ? 2 : 0)} ${units[i]}`\n}"
      },
      {
        "name": "delegateProperties",
        "line": 270,
        "params": [
          "receiver",
          "source",
          "names"
        ],
        "source": "function delegateProperties (receiver, source, names) {\n    if (Array.isArray(names)) {\n        names.forEach(name => delegateProperty(receiver, source, name, name))\n    } else if (typeof names === 'object') {\n        Object.entries(names).forEach(([sourceName, receiverName]) => {\n            delegateProperty(receiver, source, sourceName, receiverName)\n        })\n    }\n}"
      },
      {
        "name": "delegateProperty",
        "line": 281,
        "params": [
          "receiver",
          "source",
          "sourceName",
          "receiverName"
        ],
        "source": "function delegateProperty (receiver, source, sourceName, receiverName) {\n    const descriptor = Object.getOwnPropertyDescriptor(source, sourceName)\n\n    if (descriptor && (descriptor.get || descriptor.set)) {\n        Object.defineProperty(receiver, receiverName, {\n            get: descriptor.get ? descriptor.get.bind(source) : undefined,\n            set: descriptor.set ? descriptor.set.bind(source) : undefined,\n            enumerable: true,\n            configurable: true\n        })\n    } else if (typeof source[sourceName] === 'function') {\n        receiver[receiverName] = source[sourceName].bind(source)\n    } else {\n        Object.defineProperty(receiver, receiverName, {\n            get: () => source[sourceName],\n            set: (value) => {\n                source[sourceName] = value\n            },\n            enumerable: true,\n            configurable: true\n        })\n    }\n}"
      }
    ],
    "exports": []
  },
  "/core/action_controller.doc.js": {
    "type": "class",
    "file": "/core/action_controller.js",
    "name": "ActionController",
    "line": 5,
    "extends": "PerkyModule",
    "statics": [
      {
        "name": "propagable",
        "line": 7,
        "source": "static propagable = []",
        "kind": "property",
        "value": "[]"
      },
      {
        "name": "bindings",
        "line": 8,
        "source": "static bindings = {}",
        "kind": "property",
        "value": "{}"
      },
      {
        "name": "$category",
        "line": 9,
        "source": "static $category = 'actionController'",
        "kind": "property",
        "value": "'actionController'"
      },
      {
        "name": "normalizeBindings",
        "line": 82,
        "source": "static normalizeBindings (controllerName) {\n    const bindings = this.bindings\n    const normalized = []\n\n    for (const [actionName, bindingDef] of Object.entries(bindings)) {\n        const bindingConfigs = normalizeBindingDefinition(bindingDef)\n\n        for (const config of bindingConfigs) {\n            normalized.push({\n                action: actionName,\n                key: config.key,\n                scoped: config.scoped ?? false,\n                eventType: config.eventType ?? 'pressed',\n                controllerName: config.scoped ? controllerName : null\n            })\n        }\n    }\n\n    return normalized\n}",
        "kind": "method",
        "params": [
          "controllerName"
        ]
      },
      {
        "name": "actionControllerMethods",
        "line": 103,
        "source": "static actionControllerMethods = this.perkyModuleMethods.concat([\n    'addAction',\n    'getAction',\n    'removeAction',\n    'hasAction',\n    'shouldPropagate',\n    'listActions',\n    'listActionsWithParams',\n    'execute',\n    'context'\n])",
        "kind": "property",
        "value": "this.perkyModuleMethods.concat([\n    'addAction',\n    'getAction',\n    'removeAction',\n    'hasAction',\n    'shouldPropagate',\n    'listActions',\n    'listActionsWithParams',\n    'execute',\n    'context'\n])"
      }
    ],
    "methods": [
      {
        "name": "addAction",
        "line": 21,
        "source": "addAction (actionName, action) {\n    if (!this.#actionList.includes(actionName)) {\n        this.#actionList.push(actionName)\n    }\n    return this.#actions.set(actionName, action)\n}",
        "kind": "method",
        "params": [
          "actionName",
          "action"
        ]
      },
      {
        "name": "getAction",
        "line": 29,
        "source": "getAction (actionName) {\n    return this.#actions.get(actionName)\n}",
        "kind": "method",
        "params": [
          "actionName"
        ]
      },
      {
        "name": "removeAction",
        "line": 34,
        "source": "removeAction (actionName) {\n    return this.#actions.delete(actionName)\n}",
        "kind": "method",
        "params": [
          "actionName"
        ]
      },
      {
        "name": "hasAction",
        "line": 39,
        "source": "hasAction (actionName) {\n    return this.getAction(actionName) !== undefined || typeof this[actionName] === 'function'\n}",
        "kind": "method",
        "params": [
          "actionName"
        ]
      },
      {
        "name": "shouldPropagate",
        "line": 44,
        "source": "shouldPropagate (actionName) {\n    const ControllerClass = this.constructor\n    return ControllerClass.propagable && Array.isArray(ControllerClass.propagable)\n        ? ControllerClass.propagable.includes(actionName)\n        : false\n}",
        "kind": "method",
        "params": [
          "actionName"
        ]
      },
      {
        "name": "listActions",
        "line": 52,
        "source": "listActions () {\n    return [...this.#actionList]\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "listActionsWithParams",
        "line": 57,
        "source": "listActionsWithParams () {\n    const result = []\n\n    for (const actionName of this.#actionList) {\n        const action = this.getAction(actionName) || this[actionName]\n        const params = typeof action === 'function' ? extractFunctionParams(action) : []\n        result.push({name: actionName, params})\n    }\n\n    return result\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "execute",
        "line": 70,
        "source": "execute (actionName, ...args) {\n    const action = this.getAction(actionName) || this[actionName]\n\n    if (typeof action === 'function') {\n        action.call(this, ...args)\n    }\n\n    this.emit(actionName, ...args)\n    this.emit('action', actionName, ...args)\n}",
        "kind": "method",
        "params": [
          "actionName",
          "...args"
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 14,
      "source": "constructor (options = {}) {\n    super(options)\n    this.context = {}\n    this.#actionList = extractPrototypeMethods(this)\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/core/action_dispatcher.doc.js": {
    "type": "class",
    "file": "/core/action_dispatcher.js",
    "name": "ActionDispatcher",
    "line": 6,
    "extends": "PerkyModule",
    "statics": [
      {
        "name": "$category",
        "line": 8,
        "source": "static $category = 'actionDispatcher'",
        "kind": "property",
        "value": "'actionDispatcher'"
      }
    ],
    "methods": [
      {
        "name": "onInstall",
        "line": 13,
        "source": "onInstall (host, options) {\n    this.#setupMainController(options)\n\n    this.listenTo(host, 'input:triggered', this.dispatchAction.bind(this))\n\n    this.delegateTo(host, {\n        register: 'registerController',\n        unregister: 'unregisterController',\n        getController: 'getController',\n        list: 'listControllers',\n        setActive: 'setActiveControllers',\n        getActive: 'getActiveControllers',\n        pushActive: 'pushActiveController',\n        popActive: 'popActiveController',\n        clearActive: 'clearActiveControllers',\n        execute: 'execute',\n        executeTo: 'executeTo',\n        dispatchAction: 'dispatchAction',\n        listActions: 'listAllActions',\n        mainController: 'mainController',\n        addAction: 'addAction',\n        removeAction: 'removeAction'\n    })\n}",
        "kind": "method",
        "params": [
          "host",
          "options"
        ]
      },
      {
        "name": "addAction",
        "line": 62,
        "source": "addAction (actionName, action) {\n    if (!this.mainController) {\n        logger.warn('No main controller available. Cannot add action.')\n        return false\n    }\n    return this.mainController.addAction(actionName, action)\n}",
        "kind": "method",
        "params": [
          "actionName",
          "action"
        ]
      },
      {
        "name": "removeAction",
        "line": 71,
        "source": "removeAction (actionName) {\n    if (!this.mainController) {\n        logger.warn('No main controller available. Cannot remove action.')\n        return false\n    }\n    return this.mainController.removeAction(actionName)\n}",
        "kind": "method",
        "params": [
          "actionName"
        ]
      },
      {
        "name": "register",
        "line": 80,
        "source": "register (name, Controller = ActionController) {\n    return this.create(Controller, {\n        $id: name,\n        $category: 'controller'\n    })\n}",
        "kind": "method",
        "params": [
          "name",
          "Controller = ..."
        ]
      },
      {
        "name": "unregister",
        "line": 88,
        "source": "unregister (name) {\n    const controller = this.getChild(name)\n\n    if (!controller) {\n        return false\n    }\n\n    const stackIndex = this.#activeControllers.indexOf(name)\n    if (stackIndex !== -1) {\n        this.#activeControllers.splice(stackIndex, 1)\n    }\n\n    return this.removeChild(name)\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "getController",
        "line": 104,
        "source": "getController (name) {\n    return this.getChild(name)\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "setActive",
        "line": 109,
        "source": "setActive (names) {\n    const nameArray = Array.isArray(names) ? names : [names]\n\n    for (const name of nameArray) {\n        if (!this.hasChild(name)) {\n            logger.warn(`Controller \"${name}\" not found. Cannot set as active controller.`)\n            return false\n        }\n    }\n\n    this.#activeControllers = [...nameArray]\n    this.emit('controllers:activated', nameArray)\n\n    return true\n}",
        "kind": "method",
        "params": [
          "names"
        ]
      },
      {
        "name": "getActive",
        "line": 126,
        "source": "getActive () {\n    return [...this.#activeControllers]\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "pushActive",
        "line": 131,
        "source": "pushActive (name) {\n    if (!this.hasChild(name)) {\n        logger.warn(`Controller \"${name}\" not found`)\n        return false\n    }\n\n    if (this.#activeControllers.includes(name)) {\n        return false\n    }\n\n    this.#activeControllers.push(name)\n    this.emit('controller:pushed', name, this.#activeControllers.length)\n\n    return true\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "popActive",
        "line": 148,
        "source": "popActive () {\n    if (this.#activeControllers.length === 0) {\n        logger.warn('Active controllers stack is empty')\n        return null\n    }\n\n    const popped = this.#activeControllers.pop()\n    this.emit('controller:popped', popped, this.#activeControllers.length)\n\n    return popped\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "clearActive",
        "line": 161,
        "source": "clearActive () {\n    this.#activeControllers = []\n    this.emit('controllers:cleared')\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "execute",
        "line": 167,
        "source": "execute (actionName, ...args) {\n    if (this.#activeControllers.length === 0) {\n        logger.warn('No active controllers')\n        return\n    }\n\n    const registry = this.childrenRegistry\n\n    for (let i = this.#activeControllers.length - 1; i >= 0; i--) {\n        const controllerName = this.#activeControllers[i]\n        const controller = registry.get(controllerName)\n\n        if (!controller) {\n            logger.warn(`Controller \"${controllerName}\" not found in registry but present in active stack`)\n            continue\n        }\n\n        const hasAction = controller.hasAction(actionName)\n\n        controller.execute(actionName, ...args)\n\n        if (hasAction && !controller.shouldPropagate(actionName)) {\n            return\n        }\n    }\n}",
        "kind": "method",
        "params": [
          "actionName",
          "...args"
        ]
      },
      {
        "name": "executeTo",
        "line": 195,
        "source": "executeTo (name, actionName, ...args) {\n    const controller = this.getController(name)\n\n    if (controller && this.#isControllerActive(name)) {\n        if (typeof controller.execute === 'function') {\n            controller.execute(actionName, ...args)\n        } else if (typeof controller[actionName] === 'function') {\n            controller[actionName](...args)\n        }\n    }\n}",
        "kind": "method",
        "params": [
          "name",
          "actionName",
          "...args"
        ]
      },
      {
        "name": "dispatchAction",
        "line": 208,
        "source": "dispatchAction (binding, ...args) {\n    if (binding.controllerName) {\n        this.executeTo(binding.controllerName, binding.actionName, ...args)\n    } else {\n        this.execute(binding.actionName, ...args)\n    }\n}",
        "kind": "method",
        "params": [
          "binding",
          "...args"
        ]
      },
      {
        "name": "listControllers",
        "line": 222,
        "source": "listControllers () {\n    return this.listNamesFor('controller')\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "listAllActions",
        "line": 227,
        "source": "listAllActions () {\n    const allActions = new Map()\n    const registry = this.childrenRegistry\n\n    for (const [name, controller] of registry.entries) {\n        if (typeof controller.listActionsWithParams === 'function') {\n            allActions.set(name, controller.listActionsWithParams())\n        } else if (typeof controller.listActions === 'function') {\n            allActions.set(name, controller.listActions().map(n => ({name: n, params: []})))\n        }\n    }\n\n    return allActions\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "engine",
        "line": 39,
        "source": "get engine () {\n    return this.host\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "mainController",
        "line": 57,
        "source": "get mainController () {\n    return this.getController(this.mainControllerName)\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [],
    "constructor": null,
    "isDefault": true
  },
  "/core/inflector.doc.js": {
    "type": "class",
    "file": "/core/inflector.js",
    "name": "Inflector",
    "line": 48,
    "extends": null,
    "statics": [],
    "methods": [
      {
        "name": "plural",
        "line": 64,
        "source": "plural (word) {\n    return this.#replaceWord(\n        this.#irregularSingles,\n        this.#irregularPlurals,\n        this.#pluralRules\n    )(word)\n}",
        "kind": "method",
        "params": [
          "word"
        ]
      },
      {
        "name": "singular",
        "line": 73,
        "source": "singular (word) {\n    return this.#replaceWord(\n        this.#irregularPlurals,\n        this.#irregularSingles,\n        this.#singularRules\n    )(word)\n}",
        "kind": "method",
        "params": [
          "word"
        ]
      },
      {
        "name": "isPlural",
        "line": 82,
        "source": "isPlural (word) {\n    return this.#checkWord(\n        this.#irregularSingles,\n        this.#irregularPlurals,\n        this.#pluralRules\n    )(word)\n}",
        "kind": "method",
        "params": [
          "word"
        ]
      },
      {
        "name": "isSingular",
        "line": 91,
        "source": "isSingular (word) {\n    return this.#checkWord(\n        this.#irregularPlurals,\n        this.#irregularSingles,\n        this.#singularRules\n    )(word)\n}",
        "kind": "method",
        "params": [
          "word"
        ]
      },
      {
        "name": "pluralize",
        "line": 100,
        "source": "pluralize (word, count, inclusive) {\n    const pluralized = count === 1 ? this.singular(word) : this.plural(word)\n    return (inclusive ? count + ' ' : '') + pluralized\n}",
        "kind": "method",
        "params": [
          "word",
          "count",
          "inclusive"
        ]
      },
      {
        "name": "toCamelCase",
        "line": 106,
        "source": "toCamelCase (string) { // eslint-disable-line local/class-methods-use-this -- clean\n    return string\n        .replace(/[-_\\s]([a-z])/g, (match, letter) => letter.toUpperCase())\n        .replace(/^[A-Z]/, letter => letter.toLowerCase())\n}",
        "kind": "method",
        "params": [
          "string"
        ]
      },
      {
        "name": "toPascalCase",
        "line": 113,
        "source": "toPascalCase (string) {\n    return this.toCamelCase(string).replace(/^[a-z]/, letter => letter.toUpperCase())\n}",
        "kind": "method",
        "params": [
          "string"
        ]
      },
      {
        "name": "toSnakeCase",
        "line": 118,
        "source": "toSnakeCase (string) { // eslint-disable-line local/class-methods-use-this -- clean\n    return string\n        .replace(/[-\\s]/g, '_')\n        .replace(/([A-Z])([A-Z][a-z])/g, '$1_$2')\n        .replace(/([a-z])([A-Z])/g, '$1_$2')\n        .toLowerCase()\n        .replace(/^_/, '')\n}",
        "kind": "method",
        "params": [
          "string"
        ]
      },
      {
        "name": "toKebabCase",
        "line": 128,
        "source": "toKebabCase (string) { // eslint-disable-line local/class-methods-use-this -- clean\n    return string\n        .replace(/[_\\s]/g, '-')\n        .replace(/([A-Z])([A-Z][a-z])/g, '$1-$2')\n        .replace(/([a-z])([A-Z])/g, '$1-$2')\n        .toLowerCase()\n        .replace(/^-/, '')\n}",
        "kind": "method",
        "params": [
          "string"
        ]
      },
      {
        "name": "toHumanCase",
        "line": 138,
        "source": "toHumanCase (string) { // eslint-disable-line local/class-methods-use-this -- clean\n    return string\n        .replace(/[-_]/g, ' ')\n        .replace(/([A-Z])([A-Z][a-z])/g, '$1 $2')\n        .replace(/([a-z])([A-Z])/g, '$1 $2')\n        .replace(/^\\s+/, '')\n        .replace(/\\s+/g, ' ')\n}",
        "kind": "method",
        "params": [
          "string"
        ]
      },
      {
        "name": "addPluralRule",
        "line": 148,
        "source": "addPluralRule (rule, replacement) {\n    this.#pluralRules.push([sanitizeRule(rule), replacement])\n}",
        "kind": "method",
        "params": [
          "rule",
          "replacement"
        ]
      },
      {
        "name": "addSingularRule",
        "line": 153,
        "source": "addSingularRule (rule, replacement) {\n    this.#singularRules.push([sanitizeRule(rule), replacement])\n}",
        "kind": "method",
        "params": [
          "rule",
          "replacement"
        ]
      },
      {
        "name": "addUncountableRule",
        "line": 158,
        "source": "addUncountableRule (word) {\n    if (typeof word === 'string') {\n        this.#uncountables[word.toLowerCase()] = true\n        return\n    }\n\n    this.addPluralRule(word, '$0')\n    this.addSingularRule(word, '$0')\n}",
        "kind": "method",
        "params": [
          "word"
        ]
      },
      {
        "name": "addIrregularRule",
        "line": 169,
        "source": "addIrregularRule (single, pluralForm) {\n    const s = single.toLowerCase()\n    const p = pluralForm.toLowerCase()\n\n    this.#irregularSingles[s] = p\n    this.#irregularPlurals[p] = s\n}",
        "kind": "method",
        "params": [
          "single",
          "pluralForm"
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 56,
      "source": "constructor () {\n    this.#loadIrregulars()\n    this.#loadPlurals()\n    this.#loadSingulars()\n    this.#loadUncountables()\n}",
      "kind": "constructor",
      "params": []
    },
    "isDefault": true
  },
  "/core/logger.doc.js": {
    "type": "class",
    "file": "/core/logger.js",
    "name": "Logger",
    "line": 13,
    "extends": "Notifier",
    "statics": [],
    "methods": [
      {
        "name": "log",
        "line": 70,
        "source": "log (...items) {\n    this.#emit('notice', ...items)\n}",
        "kind": "method",
        "params": [
          "...items"
        ]
      },
      {
        "name": "info",
        "line": 75,
        "source": "info (...items) {\n    this.#emit('info', ...items)\n}",
        "kind": "method",
        "params": [
          "...items"
        ]
      },
      {
        "name": "notice",
        "line": 80,
        "source": "notice (...items) {\n    this.#emit('notice', ...items)\n}",
        "kind": "method",
        "params": [
          "...items"
        ]
      },
      {
        "name": "warn",
        "line": 85,
        "source": "warn (...items) {\n    this.#emit('warn', ...items)\n}",
        "kind": "method",
        "params": [
          "...items"
        ]
      },
      {
        "name": "error",
        "line": 90,
        "source": "error (...items) {\n    this.#emit('error', ...items)\n}",
        "kind": "method",
        "params": [
          "...items"
        ]
      },
      {
        "name": "success",
        "line": 95,
        "source": "success (...items) {\n    this.#emit('success', ...items)\n}",
        "kind": "method",
        "params": [
          "...items"
        ]
      },
      {
        "name": "clear",
        "line": 100,
        "source": "clear () {\n    const entry = {event: 'clear', timestamp: Date.now()}\n    this.#record(entry)\n    this.emit('clear', entry)\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "spacer",
        "line": 107,
        "source": "spacer () {\n    const entry = {event: 'spacer', timestamp: Date.now()}\n    this.#record(entry)\n    this.emit('spacer', entry)\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "title",
        "line": 114,
        "source": "title (title) {\n    const entry = {event: 'title', title, timestamp: Date.now()}\n    this.#record(entry)\n    this.emit('title', entry)\n}",
        "kind": "method",
        "params": [
          "title"
        ]
      },
      {
        "name": "clearHistory",
        "line": 121,
        "source": "clearHistory () {\n    this.#history = []\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "history",
        "line": 19,
        "source": "get history () {\n    return this.#history\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "maxHistory",
        "line": 24,
        "source": "get maxHistory () {\n    return this.#maxHistory\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "consoleOutput",
        "line": 35,
        "source": "get consoleOutput () {\n    return this.#consoleOutput\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "maxHistory",
        "line": 29,
        "source": "set maxHistory (value) {\n    this.#maxHistory = value\n    this.#trimHistory()\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "consoleOutput",
        "line": 40,
        "source": "set consoleOutput (value) {\n    this.#consoleOutput = value\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      }
    ],
    "constructor": null
  },
  "/core/notifier.doc.js": {
    "type": "class",
    "file": "/core/notifier.js",
    "name": "Notifier",
    "line": 2,
    "extends": null,
    "statics": [
      {
        "name": "notifierMethods",
        "line": 143,
        "source": "static notifierMethods = [\n    'getListenersFor',\n    'on',\n    'once',\n    'off',\n    'emit',\n    'emitter',\n    'listenTo',\n    'listenToOnce',\n    'cleanExternalListeners',\n    'removeListeners',\n    'removeListenersFor',\n    'delegateEvents'\n]",
        "kind": "property",
        "value": "[\n    'getListenersFor',\n    'on',\n    'once',\n    'off',\n    'emit',\n    'emitter',\n    'listenTo',\n    'listenToOnce',\n    'cleanExternalListeners',\n    'removeListeners',\n    'removeListenersFor',\n    'delegateEvents'\n]"
      }
    ],
    "methods": [
      {
        "name": "getListenersFor",
        "line": 7,
        "source": "getListenersFor (name) {\n    return this.#listenersFor[name]\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "on",
        "line": 12,
        "source": "on (name, listener) {\n    if (typeof listener !== 'function') {\n        throw new TypeError('Listener must be a function')\n    }\n\n    if (!this.#listenersFor[name]) {\n        this.#listenersFor[name] = []\n    }\n\n    this.#listenersFor[name].push(listener)\n\n    return listener\n}",
        "kind": "method",
        "params": [
          "name",
          "listener"
        ]
      },
      {
        "name": "once",
        "line": 27,
        "source": "once (name, listener) {\n    if (typeof listener !== 'function') {\n        throw new TypeError('Listener must be a function')\n    }\n\n    const onceWrapper = (...args) => {\n        listener(...args)\n        this.off(name, onceWrapper)\n    }\n\n    return this.on(name, onceWrapper)\n}",
        "kind": "method",
        "params": [
          "name",
          "listener"
        ]
      },
      {
        "name": "off",
        "line": 41,
        "source": "off (name, listener) {\n    const listeners = this.getListenersFor(name)\n\n    if (typeof listener === 'undefined') {\n        return this.removeListenersFor(name)\n    } else if (Array.isArray(listeners)) {\n        const index = listeners.indexOf(listener)\n\n        if (index !== -1) {\n            listeners.splice(index, 1)\n            return true\n        }\n    }\n\n    return false\n}",
        "kind": "method",
        "params": [
          "name",
          "listener"
        ]
      },
      {
        "name": "emit",
        "line": 59,
        "source": "emit (name, ...args) {\n    const listeners = this.getListenersFor(name)\n    if (!listeners) {\n        return\n    }\n\n    const listenersCopy = [...listeners]\n\n    for (const listener of listenersCopy) {\n        listener.call(this, ...args)\n    }\n}",
        "kind": "method",
        "params": [
          "name",
          "...args"
        ]
      },
      {
        "name": "emitter",
        "line": 73,
        "source": "emitter (name) {\n    return (...args) => this.emit(name, ...args)\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "listenTo",
        "line": 78,
        "source": "listenTo (target, eventName, callback) {\n    target.on(eventName, callback)\n    this.#externalListeners.push({target, eventName, callback})\n}",
        "kind": "method",
        "params": [
          "target",
          "eventName",
          "callback"
        ]
      },
      {
        "name": "listenToOnce",
        "line": 84,
        "source": "listenToOnce (target, eventName, callback) {\n    const onceWrapper = (...args) => {\n        callback(...args)\n\n        target.off(eventName, onceWrapper)\n\n        const index = this.#externalListeners.findIndex(\n            l => l.target === target && l.eventName === eventName && l.callback === onceWrapper\n        )\n        if (index !== -1) {\n            this.#externalListeners.splice(index, 1)\n        }\n    }\n\n    target.on(eventName, onceWrapper)\n    this.#externalListeners.push({target, eventName, callback: onceWrapper})\n}",
        "kind": "method",
        "params": [
          "target",
          "eventName",
          "callback"
        ]
      },
      {
        "name": "cleanExternalListeners",
        "line": 103,
        "source": "cleanExternalListeners () {\n    this.#externalListeners.forEach(({target, eventName, callback}) => {\n        target.off(eventName, callback)\n    })\n    this.#externalListeners = []\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "removeListeners",
        "line": 111,
        "source": "removeListeners () {\n    Object.keys(this.#listenersFor).forEach(name => this.removeListenersFor(name))\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "removeListenersFor",
        "line": 116,
        "source": "removeListenersFor (name) {\n    const listeners = this.getListenersFor(name)\n\n    if (listeners) {\n        listeners.length = 0\n        delete this.#listenersFor[name]\n        return true\n    }\n\n    return false\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "delegateEvents",
        "line": 129,
        "source": "delegateEvents (target, events, namespace) {\n    if (!target || (!Array.isArray(events) && typeof events !== 'object')) {\n        return\n    }\n\n    const eventArray = Array.isArray(events) ? events : Object.keys(events)\n    eventArray.forEach((event) => {\n        this.listenTo(target, event, (...args) => {\n            const prefixedEvent = namespace ? `${namespace}:${event}` : event\n            this.emit(prefixedEvent, ...args)\n        })\n    })\n}",
        "kind": "method",
        "params": [
          "target",
          "events",
          "namespace"
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": null,
    "isDefault": true
  },
  "/core/observable_map.doc.js": {
    "type": "class",
    "file": "/core/observable_map.js",
    "name": "ObservableMap",
    "line": 4,
    "extends": "Notifier",
    "statics": [],
    "methods": [
      {
        "name": "get",
        "line": 49,
        "source": "get (key) {\n    return this.#map.get(key)\n}",
        "kind": "method",
        "params": [
          "key"
        ]
      },
      {
        "name": "has",
        "line": 54,
        "source": "has (key) {\n    return this.#map.has(key)\n}",
        "kind": "method",
        "params": [
          "key"
        ]
      },
      {
        "name": "hasValue",
        "line": 59,
        "source": "hasValue (value) {\n    return this.#values.has(value)\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "keyFor",
        "line": 64,
        "source": "keyFor (value) {\n    return this.#keyByValue.get(value)\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "hasEntry",
        "line": 69,
        "source": "hasEntry (key, value) {\n    return this.get(key) === value\n}",
        "kind": "method",
        "params": [
          "key",
          "value"
        ]
      },
      {
        "name": "isKeyOf",
        "line": 74,
        "source": "isKeyOf (key, value) {\n    return this.keyFor(value) === key\n}",
        "kind": "method",
        "params": [
          "key",
          "value"
        ]
      },
      {
        "name": "forEach",
        "line": 79,
        "source": "forEach (callbackFn, thisArg) {\n    this.#map.forEach(callbackFn, thisArg)\n}",
        "kind": "method",
        "params": [
          "callbackFn",
          "thisArg"
        ]
      },
      {
        "name": "set",
        "line": 84,
        "source": "set (key, value) {\n    const exists = this.#map.has(key)\n    const oldValue = exists ? this.#map.get(key) : undefined\n    const isReplacing = exists && oldValue !== value\n\n    this.#map.set(key, value)\n    this.#values.add(value)\n    this.#keyByValue.set(value, key)\n\n    if (isReplacing) {\n        this.#removeFromValues(oldValue)\n        this.emit('delete', key, oldValue)\n    }\n\n    this.emit('set', key, value, oldValue)\n\n    return true\n}",
        "kind": "method",
        "params": [
          "key",
          "value"
        ]
      },
      {
        "name": "delete",
        "line": 104,
        "source": "delete (key) {\n    const exists = this.#map.has(key)\n\n    if (!exists) {\n        return false\n    }\n\n    const value = this.#map.get(key)\n    const deleted = this.#map.delete(key)\n\n    if (deleted) {\n        this.#removeFromValues(value)\n        this.emit('delete', key, value)\n    }\n\n    return deleted\n}",
        "kind": "method",
        "params": [
          "key"
        ]
      },
      {
        "name": "updateKey",
        "line": 123,
        "source": "updateKey (oldKey, newKey, item) {\n    if (!this.has(oldKey)) {\n        return false\n    }\n\n    if (oldKey === newKey) {\n        return false\n    }\n\n    const value = this.get(oldKey)\n\n    if (item !== undefined && value !== item) {\n        return false\n    }\n\n    this.#map.delete(oldKey)\n    this.#map.set(newKey, value)\n\n    this.emit('key:updated', oldKey, newKey, value)\n\n    return true\n}",
        "kind": "method",
        "params": [
          "oldKey",
          "newKey",
          "item"
        ]
      },
      {
        "name": "clear",
        "line": 147,
        "source": "clear () {\n    if (this.#map.size > 0) {\n        const itemsToDelete = Array.from(this.#map.entries())\n        itemsToDelete.forEach(([key, value]) => {\n            this.emit('delete', key, value)\n        })\n\n        this.#map.clear()\n        this.#values.clear()\n        this.#keyByValue.clear()\n\n        this.emit('clear')\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "addCollection",
        "line": 174,
        "source": "addCollection (collection) {\n    if (!collection || typeof collection !== 'object') {\n        return false\n    }\n\n    if (typeof collection.forEach === 'function') {\n        collection.forEach((value, key) => {\n            this.set(key, value)\n        })\n    } else {\n        for (const key in collection) {\n            if (Object.prototype.hasOwnProperty.call(collection, key)) {\n                this.set(key, collection[key])\n            }\n        }\n    }\n\n    return true\n}",
        "kind": "method",
        "params": [
          "collection"
        ]
      },
      {
        "name": "toObject",
        "line": 195,
        "source": "toObject () {\n    const object = {}\n    this.#map.forEach((value, key) => {\n        object[key] = value\n    })\n    return object\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "size",
        "line": 19,
        "source": "get size () {\n    return this.#map.size\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "entries",
        "line": 24,
        "source": "get entries () {\n    return Array.from(this.#map.entries())\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "keys",
        "line": 29,
        "source": "get keys () {\n    return this.#map.keys()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "values",
        "line": 34,
        "source": "get values () {\n    return this.#map.values()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "all",
        "line": 39,
        "source": "get all () {\n    return Array.from(this.#map.values())\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "map",
        "line": 44,
        "source": "get map () {\n    return this.#map\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 10,
      "source": "constructor (collection) {\n    super()\n\n    if (collection) {\n        this.addCollection(collection)\n    }\n}",
      "kind": "constructor",
      "params": [
        "collection"
      ]
    },
    "isDefault": true
  },
  "/core/observable_set.doc.js": {
    "type": "class",
    "file": "/core/observable_set.js",
    "name": "ObservableSet",
    "line": 4,
    "extends": "Notifier",
    "statics": [],
    "methods": [
      {
        "name": "add",
        "line": 24,
        "source": "add (value) {\n    if (!this.#set.has(value)) {\n        this.#set.add(value)\n        this.emit('add', value)\n    }\n    return this\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "delete",
        "line": 33,
        "source": "delete (value) {\n    const deleted = this.#set.delete(value)\n    if (deleted) {\n        this.emit('delete', value)\n    }\n    return deleted\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "clear",
        "line": 42,
        "source": "clear () {\n    if (this.#set.size > 0) {\n        const values = Array.from(this.#set)\n        this.#set.clear()\n        this.emit('clear', values)\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "has",
        "line": 51,
        "source": "has (value) {\n    return this.#set.has(value)\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "values",
        "line": 56,
        "source": "values () {\n    return this.#set.values()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "keys",
        "line": 61,
        "source": "keys () {\n    return this.#set.keys()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "entries",
        "line": 66,
        "source": "entries () {\n    return this.#set.entries()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "forEach",
        "line": 71,
        "source": "forEach (callbackFn, thisArg) {\n    this.#set.forEach(callbackFn, thisArg)\n}",
        "kind": "method",
        "params": [
          "callbackFn",
          "thisArg"
        ]
      },
      {
        "name": "toArray",
        "line": 81,
        "source": "toArray () {\n    return Array.from(this.#set)\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "size",
        "line": 19,
        "source": "get size () {\n    return this.#set.size\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 8,
      "source": "constructor (values) {\n    super()\n\n    if (values) {\n        for (const value of values) {\n            this.#set.add(value)\n        }\n    }\n}",
      "kind": "constructor",
      "params": [
        "values"
      ]
    },
    "isDefault": true
  },
  "/core/perky_query.doc.js": {
    "type": "module",
    "file": "/core/perky_query.js",
    "functions": [
      {
        "name": "parseSelector",
        "line": 18,
        "params": [
          "selector"
        ],
        "source": "function parseSelector (selector) {\n    const segments = selector.trim().split(/\\s+/)\n\n    return segments.map(segment => {\n        const conditions = []\n        let match\n\n        SELECTOR_REGEX.lastIndex = 0\n\n        while ((match = SELECTOR_REGEX.exec(segment)) !== null) {\n            const [, prefix, value] = match\n\n            conditions.push({\n                type: PREFIX_TO_TYPE[prefix],\n                value\n            })\n        }\n\n        return conditions\n    }).filter(segment => segment.length > 0)\n}"
      },
      {
        "name": "matchesConditions",
        "line": 41,
        "params": [
          "module",
          "conditions"
        ],
        "source": "function matchesConditions (module, conditions) {\n    return conditions.every(({type, value}) => {\n        const matcher = TYPE_MATCHERS[type]\n        return matcher ? matcher(module, value) : false\n    })\n}"
      },
      {
        "name": "findMatchingChildren",
        "line": 49,
        "params": [
          "candidates",
          "conditions"
        ],
        "source": "function findMatchingChildren (candidates, conditions) {\n    return candidates.flatMap(candidate => {\n        const children = candidate.children || []\n        return children.filter(child => matchesConditions(child, conditions))\n    })\n}"
      },
      {
        "name": "query",
        "line": 57,
        "params": [
          "root",
          "selector"
        ],
        "source": "function query (root, selector) {\n    const segments = parseSelector(selector)\n\n    if (segments.length === 0) {\n        return null\n    }\n\n    let candidates = [root]\n\n    for (const conditions of segments) {\n        candidates = findMatchingChildren(candidates, conditions)\n\n        if (candidates.length === 0) {\n            return null\n        }\n    }\n\n    return candidates[0] || null\n}"
      },
      {
        "name": "queryAll",
        "line": 78,
        "params": [
          "root",
          "selector"
        ],
        "source": "function queryAll (root, selector) {\n    const segments = parseSelector(selector)\n\n    if (segments.length === 0) {\n        return []\n    }\n\n    let candidates = [root]\n\n    for (const conditions of segments) {\n        candidates = findMatchingChildren(candidates, conditions)\n\n        if (candidates.length === 0) {\n            return []\n        }\n    }\n\n    return candidates\n}"
      }
    ],
    "exports": []
  },
  "/core/registry.doc.js": {
    "type": "class",
    "file": "/core/registry.js",
    "name": "Registry",
    "line": 4,
    "extends": "ObservableMap",
    "statics": [],
    "methods": [
      {
        "name": "addIndex",
        "line": 16,
        "source": "addIndex (name, keyFunction) {\n    if (keyFunction === undefined) {\n        keyFunction = name\n    }\n\n    if (typeof keyFunction === 'string') {\n        const propertyName = keyFunction\n        keyFunction = (item) => item[propertyName]\n    }\n\n    if (typeof keyFunction !== 'function') {\n        return false\n    }\n\n    const index = {\n        keyFn: keyFunction,\n        data: new Map()\n    }\n\n    this.#indexes.set(name, index)\n\n    for (const value of this.map.values()) {\n        this.#addToIndex(name, value)\n    }\n\n    return true\n}",
        "kind": "method",
        "params": [
          "name",
          "keyFunction"
        ]
      },
      {
        "name": "lookup",
        "line": 45,
        "source": "lookup (indexName, key) {\n    const index = this.#indexes.get(indexName)\n\n    if (!index) {\n        throw new Error(`Index '${indexName}' does not exist`)\n    }\n\n    const items = index.data.get(key)\n    return items ? Array.from(items) : []\n}",
        "kind": "method",
        "params": [
          "indexName",
          "key"
        ]
      },
      {
        "name": "lookupKeys",
        "line": 57,
        "source": "lookupKeys (indexName, key) {\n    const itemsSet = new Set(this.lookup(indexName, key))\n\n    if (itemsSet.size === 0) {\n        return []\n    }\n\n    const keys = []\n    for (const [k, v] of this.map.entries()) {\n        if (itemsSet.has(v)) {\n            keys.push(k)\n        }\n    }\n\n    return keys\n}",
        "kind": "method",
        "params": [
          "indexName",
          "key"
        ]
      },
      {
        "name": "hasIndex",
        "line": 75,
        "source": "hasIndex (name) {\n    return this.#indexes.has(name)\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "removeIndex",
        "line": 80,
        "source": "removeIndex (name) {\n    return this.#indexes.delete(name)\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "updateIndexFor",
        "line": 85,
        "source": "updateIndexFor (item, indexName, oldKeys, newKeys) {\n    if (!this.hasValue(item)) {\n        return false\n    }\n\n    const index = this.#indexes.get(indexName)\n    if (!index) {\n        return false\n    }\n\n    const oldKeysArray = Array.isArray(oldKeys) ? oldKeys : [oldKeys]\n    const newKeysArray = Array.isArray(newKeys) ? newKeys : [newKeys]\n\n    for (const oldKey of oldKeysArray) {\n        const items = index.data.get(oldKey)\n        if (items) {\n            items.delete(item)\n            if (items.size === 0) {\n                index.data.delete(oldKey)\n            }\n        }\n    }\n\n    for (const newKey of newKeysArray) {\n        if (!index.data.has(newKey)) {\n            index.data.set(newKey, new Set())\n        }\n        index.data.get(newKey).add(item)\n    }\n\n    return true\n}",
        "kind": "method",
        "params": [
          "item",
          "indexName",
          "oldKeys",
          "newKeys"
        ]
      },
      {
        "name": "refreshIndexFor",
        "line": 119,
        "source": "refreshIndexFor (value, indexName) {\n    if (!this.hasValue(value)) {\n        return false\n    }\n\n    const index = this.#indexes.get(indexName)\n    if (!index) {\n        return false\n    }\n\n    for (const [key, items] of index.data.entries()) {\n        if (items.has(value)) {\n            items.delete(value)\n            if (items.size === 0) {\n                index.data.delete(key)\n            }\n        }\n    }\n\n    this.#addToIndex(indexName, value)\n\n    return true\n}",
        "kind": "method",
        "params": [
          "value",
          "indexName"
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 8,
      "source": "constructor (collection) {\n    super(collection)\n\n    this.on('set', this.#handleSet)\n    this.on('delete', this.#handleDelete)\n}",
      "kind": "constructor",
      "params": [
        "collection"
      ]
    },
    "isDefault": true
  },
  "/application/application.doc.js": {
    "type": "class",
    "file": "/application/application.js",
    "name": "Application",
    "line": 11,
    "extends": "PerkyModule",
    "statics": [
      {
        "name": "$category",
        "line": 13,
        "source": "static $category = 'application'",
        "kind": "property",
        "value": "'application'"
      },
      {
        "name": "$eagerStart",
        "line": 15,
        "source": "static $eagerStart = false",
        "kind": "property",
        "value": "false"
      }
    ],
    "methods": [
      {
        "name": "preload",
        "line": 53,
        "source": "async preload () {\n    return this.loadTag('preload')\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 17,
      "source": "constructor (options = {}) {\n    super(options)\n\n    const manifestData = options.manifest || this.constructor.manifest || {}\n\n    this.create(Manifest, {\n        $bind: 'manifest',\n        data: manifestData.export ? manifestData.export() : manifestData\n    })\n\n    this.create(ActionDispatcher, {\n        $bind: 'actionDispatcher'\n    })\n\n    this.create(PerkyView, {\n        $bind: 'perkyView',\n        className: 'perky-application'\n    })\n\n    this.create(SourceManager, {\n        $bind: 'sourceManager',\n        loaders: new Registry(loaders),\n        manifest: this.manifest\n    })\n\n    this.create(InputSystem, {\n        $bind: 'inputSystem',\n        bindings: options.bindings\n    })\n\n    this.actionDispatcher.on('controller:set', this.#autoRegisterBindings.bind(this))\n\n    this.configureApplication?.(options)\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/application/asset.doc.js": {
    "type": "class",
    "file": "/application/asset.js",
    "name": "Asset",
    "line": 4,
    "extends": null,
    "statics": [],
    "methods": [
      {
        "name": "hasTag",
        "line": 24,
        "source": "hasTag (tag) {\n    return Array.isArray(this.tags) && this.tags.includes(tag)\n}",
        "kind": "method",
        "params": [
          "tag"
        ]
      },
      {
        "name": "export",
        "line": 29,
        "source": "export () {\n    const exported = {\n        type: this.type,\n        id: this.id,\n        name: this.name,\n        tags: this.tags,\n        config: this.config\n    }\n\n    if (this.url) {\n        exported.url = this.url\n    } else if (this.source) {\n        exported.source = this.source\n    }\n\n    return exported\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "loaded",
        "line": 19,
        "source": "get loaded () {\n    return Boolean(this.source)\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 6,
      "source": "constructor (params = {}) {\n    this.type    = params.type\n    this.name    = params.name\n    this.id      = params.id || guessId(params)\n    this.name ??= this.id\n\n    this.url     = params.url || params.path\n    this.source  = params.source\n    this.tags    = params.tags  || []\n    this.config  = params.config || {}\n}",
      "kind": "constructor",
      "params": [
        "params = ..."
      ]
    },
    "isDefault": true
  },
  "/application/manifest.doc.js": {
    "type": "class",
    "file": "/application/manifest.js",
    "name": "Manifest",
    "line": 7,
    "extends": "PerkyModule",
    "statics": [
      {
        "name": "$category",
        "line": 9,
        "source": "static $category = 'manifest'",
        "kind": "property",
        "value": "'manifest'"
      },
      {
        "name": "$lifecycle",
        "line": 10,
        "source": "static $lifecycle = false",
        "kind": "property",
        "value": "false"
      }
    ],
    "methods": [
      {
        "name": "onInstall",
        "line": 32,
        "source": "onInstall (host) {\n    this.delegateTo(host, [\n        'getConfig',\n        'setConfig',\n        'addAsset',\n        'getAsset',\n        'getAssets',\n        'getAssetsByType',\n        'getAssetsByTag',\n        'getSource',\n        'getAllAssets'\n    ])\n\n    this.delegateTo(host, {\n        export: 'exportManifest',\n        import: 'importManifest'\n    })\n}",
        "kind": "method",
        "params": [
          "host"
        ]
      },
      {
        "name": "import",
        "line": 52,
        "source": "import (jsonData) {\n    if (typeof jsonData === 'string') {\n        try {\n            this.#data = JSON.parse(jsonData)\n        } catch (error) {\n            throw new Error(`Failed to parse manifest JSON: ${error.message}`)\n        }\n    } else if (jsonData && typeof jsonData === 'object') {\n        this.#data = jsonData\n    } else {\n        throw new Error('Invalid manifest data: must be a JSON string or object')\n    }\n\n    this.assets.clear()\n    this.#initAssets()\n\n    return this\n}",
        "kind": "method",
        "params": [
          "jsonData"
        ]
      },
      {
        "name": "export",
        "line": 72,
        "source": "export () {\n    return deepMerge({}, {\n        config: this.#data.config,\n        assets: this.#exportAssets()\n    })\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "getConfig",
        "line": 80,
        "source": "getConfig (path) {\n    if (path === undefined) {\n        return this.#data.config\n    }\n\n    return getNestedValue(this.#data.config, path)\n}",
        "kind": "method",
        "params": [
          "path"
        ]
      },
      {
        "name": "setConfig",
        "line": 89,
        "source": "setConfig (path, value) {\n    setNestedValue(this.#data.config, path, value)\n    return this\n}",
        "kind": "method",
        "params": [
          "path",
          "value"
        ]
      },
      {
        "name": "addAsset",
        "line": 95,
        "source": "addAsset (assetData) {\n    validateAssetInput(assetData)\n\n    const asset = prepareAsset(assetData)\n\n    this.assets.set(asset.id, asset)\n\n    return asset\n}",
        "kind": "method",
        "params": [
          "assetData"
        ]
      },
      {
        "name": "getAsset",
        "line": 106,
        "source": "getAsset (id) {\n    return this.assets.get(id) || null\n}",
        "kind": "method",
        "params": [
          "id"
        ]
      },
      {
        "name": "getSource",
        "line": 111,
        "source": "getSource (id) {\n    const asset = this.getAsset(id)\n\n    if (!asset) {\n        return null\n    }\n\n    return asset.source\n}",
        "kind": "method",
        "params": [
          "id"
        ]
      },
      {
        "name": "getAssetsByType",
        "line": 122,
        "source": "getAssetsByType (type) {\n    return this.assets.lookup('type', type)\n}",
        "kind": "method",
        "params": [
          "type"
        ]
      },
      {
        "name": "getAssetsByTag",
        "line": 127,
        "source": "getAssetsByTag (tag) {\n    if (!tag || typeof tag !== 'string') {\n        return []\n    }\n\n    return this.assets.lookup('tags', tag)\n}",
        "kind": "method",
        "params": [
          "tag"
        ]
      },
      {
        "name": "getAssets",
        "line": 136,
        "source": "getAssets () {\n    return this.assets.all\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "getAllAssets",
        "line": 141,
        "source": "getAllAssets () {\n    return this.assets.all\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "hasAsset",
        "line": 146,
        "source": "hasAsset (id) {\n    return this.assets.has(id)\n}",
        "kind": "method",
        "params": [
          "id"
        ]
      },
      {
        "name": "removeAsset",
        "line": 151,
        "source": "removeAsset (id) {\n    return this.assets.delete(id)\n}",
        "kind": "method",
        "params": [
          "id"
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 14,
      "source": "constructor (params = {}) {\n    const {data = {}, ...moduleParams} = params\n\n    super(moduleParams)\n\n    this.#data = setDefaults(data, {\n        config: {},\n        assets: {}\n    })\n\n    this.assets = new Registry()\n    this.assets.addIndex('type', asset => asset.type)\n    this.assets.addIndex('tags', asset => asset.tags)\n\n    this.#initAssets()\n}",
      "kind": "constructor",
      "params": [
        "params = ..."
      ]
    },
    "isDefault": true
  },
  "/application/perky_view.doc.js": {
    "type": "class",
    "file": "/application/perky_view.js",
    "name": "PerkyView",
    "line": 5,
    "extends": "PerkyModule",
    "statics": [
      {
        "name": "$category",
        "line": 7,
        "source": "static $category = 'perkyView'",
        "kind": "property",
        "value": "'perkyView'"
      },
      {
        "name": "defaultElement",
        "line": 158,
        "source": "static defaultElement (params) {\n    const element = document.createElement('div')\n\n    element.id = params.id || uniqueId('perky_view', 'perky_view')\n\n    element.className = params.className || 'perky-view'\n\n    const styles = {\n        display: 'block',\n        overflow: 'hidden',\n        position: 'relative',\n        width: '100%',\n        height: '100%',\n        ...this.defaultStyles(params)\n    }\n\n    Object.assign(element.style, styles)\n\n    return element\n}",
        "kind": "method",
        "params": [
          "params"
        ]
      },
      {
        "name": "defaultStyles",
        "line": 180,
        "source": "static defaultStyles () {\n    return {}\n}",
        "kind": "method",
        "params": []
      }
    ],
    "methods": [
      {
        "name": "onInstall",
        "line": 38,
        "source": "onInstall (host) {\n    this.delegateTo(host, [\n        'element',\n        'mount',\n        'dismount',\n        'mounted',\n        'displayMode',\n        'setDisplayMode',\n        'enterFullscreenMode',\n        'exitFullscreenMode',\n        'toggleFullscreen'\n    ])\n\n    this.delegateEventsTo(host, [\n        'resize',\n        'mount',\n        'dismount',\n        'displayMode:changed'\n    ])\n}",
        "kind": "method",
        "params": [
          "host"
        ]
      },
      {
        "name": "addClass",
        "line": 90,
        "source": "addClass (className) {\n    this.element.classList.add(className)\n}",
        "kind": "method",
        "params": [
          "className"
        ]
      },
      {
        "name": "removeClass",
        "line": 95,
        "source": "removeClass (className) {\n    this.element.classList.remove(className)\n}",
        "kind": "method",
        "params": [
          "className"
        ]
      },
      {
        "name": "hasClass",
        "line": 100,
        "source": "hasClass (className) {\n    return this.element.classList.contains(className)\n}",
        "kind": "method",
        "params": [
          "className"
        ]
      },
      {
        "name": "setSize",
        "line": 105,
        "source": "setSize ({width, height, unit = 'px'}) {\n    Object.assign(this.element.style, {\n        width: `${width}${unit}`,\n        height: `${height}${unit}`\n    })\n\n    this.emit('resize', {width, height})\n}",
        "kind": "method",
        "params": [
          "{...}"
        ]
      },
      {
        "name": "fit",
        "line": 115,
        "source": "fit (element = this.container) {\n    const {width, height} = element.getBoundingClientRect()\n\n    this.setSize({width, height})\n}",
        "kind": "method",
        "params": [
          "element = ..."
        ]
      },
      {
        "name": "mount",
        "line": 122,
        "source": "mount (container) {\n    if (!container) {\n        throw new Error('Container element is required')\n    }\n\n    if (this.container && this.container !== container) {\n        this.container.removeChild(this.element)\n    }\n\n    container.appendChild(this.element)\n\n    this.emit('mount', {container})\n\n    if (this.#resizeObserver) {\n        this.#resizeObserver.observe(this.element)\n    }\n}",
        "kind": "method",
        "params": [
          "container"
        ]
      },
      {
        "name": "dismount",
        "line": 141,
        "source": "dismount () {\n    if (this.container) {\n        this.container.removeChild(this.element)\n        this.emit('dismount', {container: this.container})\n    }\n\n    if (this.#resizeObserver) {\n        this.#resizeObserver.disconnect()\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "isVisible",
        "line": 185,
        "source": "isVisible () {\n    return this.element.style.display !== 'none'\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "onDispose",
        "line": 190,
        "source": "onDispose () {\n    this.exitFullscreenMode()\n\n    if (this.#resizeObserver) {\n        this.#resizeObserver.disconnect()\n        this.#resizeObserver = null\n    }\n\n    if (this.#onFullscreenChange) {\n        document.removeEventListener('fullscreenchange', this.#onFullscreenChange)\n    }\n\n    this.dismount()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "hide",
        "line": 221,
        "source": "hide () {\n    if (this.display && this.display !== 'none') {\n        this.#previousDisplay = this.display\n    }\n\n    this.display = 'none'\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "show",
        "line": 230,
        "source": "show () {\n    if (this.#previousDisplay) {\n        this.display = this.#previousDisplay\n        this.#previousDisplay = null\n    } else {\n        this.display = ''\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "setDisplayMode",
        "line": 240,
        "source": "setDisplayMode (mode) {\n    const modes = {\n        normal: () => this.exitFullscreenMode(),\n        fullscreen: () => this.enterFullscreenMode()\n    }\n\n    if (modes[mode]) {\n        modes[mode]()\n    }\n}",
        "kind": "method",
        "params": [
          "mode"
        ]
      },
      {
        "name": "enterFullscreenMode",
        "line": 252,
        "source": "enterFullscreenMode () {\n    if (this.displayMode === 'fullscreen') {\n        return\n    }\n\n    this.displayMode = 'fullscreen'\n\n    document.body.classList.add('fullscreen-mode')\n\n    this.#previousStyles = {\n        position: this.element.style.position,\n        top: this.element.style.top,\n        left: this.element.style.left,\n        width: this.element.style.width,\n        height: this.element.style.height,\n        zIndex: this.element.style.zIndex\n    }\n\n    Object.assign(this.element.style, {\n        position: 'fixed',\n        top: '0',\n        left: '0',\n        width: '100vw',\n        height: '100vh',\n        zIndex: '10000'\n    })\n\n    this.#requestFullscreen()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "exitFullscreenMode",
        "line": 283,
        "source": "exitFullscreenMode () {\n    if (this.displayMode === 'normal') {\n        return\n    }\n\n    if (document.fullscreenElement) {\n        document.exitFullscreen()\n    }\n\n    this.displayMode = 'normal'\n\n    document.body.style.overflow = ''\n    document.body.classList.remove('fullscreen-mode')\n\n    Object.assign(this.element.style, this.#previousStyles)\n    this.#previousStyles = {}\n\n    this.#dispatchDisplayModeChanged('normal')\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "toggleFullscreen",
        "line": 304,
        "source": "toggleFullscreen () {\n    const mode = this.displayMode\n\n    if (mode === 'fullscreen') {\n        this.exitFullscreenMode()\n    } else {\n        this.enterFullscreenMode()\n    }\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "container",
        "line": 60,
        "source": "get container () {\n    return this.element.parentElement\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "width",
        "line": 65,
        "source": "get width () {\n    return this.element.offsetWidth\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "height",
        "line": 70,
        "source": "get height () {\n    return this.element.offsetHeight\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "size",
        "line": 75,
        "source": "get size () {\n    return {\n        width: this.width,\n        height: this.height\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "aspectRatio",
        "line": 83,
        "source": "get aspectRatio () {\n    const {width, height} = this.size\n\n    return height > 0 ? width / height : 0\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "mounted",
        "line": 153,
        "source": "get mounted () {\n    return Boolean(this.container && this.container.contains(this.element))\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "html",
        "line": 206,
        "source": "get html () {\n    return this.element.innerHTML\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "display",
        "line": 211,
        "source": "get display () {\n    return this.element.style.display\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "display",
        "line": 216,
        "source": "set display (display) {\n    this.element.style.display = display\n}",
        "kind": "method",
        "params": [
          "display"
        ]
      }
    ],
    "constructor": {
      "name": "constructor",
      "line": 15,
      "source": "constructor (params = {}) {\n    super(params)\n\n    this.element = params.element ? params.element : this.constructor.defaultElement(params)\n\n    if (params.position) {\n        applyPositionStyle(this.element, params.position)\n    }\n\n    if (params.container) {\n        this.mount(params.container)\n    }\n\n    if (params.className) {\n        this.addClass(params.className)\n    }\n\n\n    this.#setupResizeObserver()\n    this.#setupFullscreenEvents()\n}",
      "kind": "constructor",
      "params": [
        "params = ..."
      ]
    },
    "isDefault": true
  },
  "/application/source_manager.doc.js": {
    "type": "class",
    "file": "/application/source_manager.js",
    "name": "SourceManager",
    "line": 5,
    "extends": "PerkyModule",
    "statics": [
      {
        "name": "$category",
        "line": 7,
        "source": "static $category = 'sourceManager'",
        "kind": "property",
        "value": "'sourceManager'"
      }
    ],
    "methods": [
      {
        "name": "onInstall",
        "line": 17,
        "source": "onInstall (host) {\n    this.delegateTo(host, ['loadAsset', 'loadTag', 'loadAll', 'loaders'])\n\n    this.delegateEventsTo(host, [\n        'loader:progress',\n        'loader:complete',\n        'loader:error'\n    ])\n}",
        "kind": "method",
        "params": [
          "host"
        ]
      },
      {
        "name": "loadAsset",
        "line": 28,
        "source": "async loadAsset (id) {\n    const asset = this.manifest.getAsset(id)\n\n    if (!asset) {\n        throw new Error(`Asset not found: ${id}`)\n    }\n\n    const sourceLoader = new SourceLoader([asset], this.loaders)\n    this.#setupLoaderEvents(sourceLoader)\n\n    await sourceLoader.load()\n\n    return sourceLoader\n}",
        "kind": "method",
        "params": [
          "id"
        ]
      },
      {
        "name": "loadTag",
        "line": 44,
        "source": "async loadTag (tag) {\n    const assets = this.manifest.getAssetsByTag(tag)\n\n    const sourceLoader = new SourceLoader(assets, this.loaders)\n    this.#setupLoaderEvents(sourceLoader)\n\n    await sourceLoader.load()\n\n    return sourceLoader\n}",
        "kind": "method",
        "params": [
          "tag"
        ]
      },
      {
        "name": "loadAll",
        "line": 56,
        "source": "async loadAll () {\n    const assets = this.manifest.getAllAssets()\n\n    const sourceLoader = new SourceLoader(assets, this.loaders)\n    this.#setupLoaderEvents(sourceLoader)\n\n    await sourceLoader.load()\n\n    return sourceLoader\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 9,
      "source": "constructor (options = {}) {\n    super(options)\n\n    this.loaders = options.loaders\n    this.manifest = options.manifest\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/game/game.doc.js": {
    "type": "class",
    "file": "/game/game.js",
    "name": "Game",
    "line": 7,
    "extends": "Application",
    "statics": [],
    "methods": [],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 9,
      "source": "constructor (params = {}) {\n    super(params)\n\n    this.create(GameLoop, {$bind: 'gameLoop'})\n    this.create(RenderSystem, {\n        $bind: 'renderSystem',\n        ...params.renderSystem\n    })\n    this.create(TextureSystem, {\n        $bind: 'textureSystem',\n        fallback: (id) => this.getSource(id),\n        ...params.textureSystem\n    })\n\n    this.on('update', this.#updateActiveControllers)\n\n    this.configureGame?.(params)\n}",
      "kind": "constructor",
      "params": [
        "params = ..."
      ]
    },
    "isDefault": true
  },
  "/game/entity.doc.js": {
    "type": "class",
    "file": "/game/entity.js",
    "name": "Entity",
    "line": 5,
    "extends": "PerkyModule",
    "statics": [
      {
        "name": "$category",
        "line": 7,
        "source": "static $category = 'entity'",
        "kind": "property",
        "value": "'entity'"
      }
    ],
    "methods": [
      {
        "name": "update",
        "line": 39,
        "source": "update () {\n\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "x",
        "line": 19,
        "source": "get x () {\n    return this.position.x\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "y",
        "line": 29,
        "source": "get y () {\n    return this.position.y\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "x",
        "line": 24,
        "source": "set x (value) {\n    this.position.x = value\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "y",
        "line": 34,
        "source": "set y (value) {\n    this.position.y = value\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      }
    ],
    "constructor": {
      "name": "constructor",
      "line": 9,
      "source": "constructor (options = {}) {\n    super(options)\n\n    const {x = 0, y = 0} = options\n\n    this.position = new Vec2(x, y)\n    this.velocity = new Vec2(0, 0)\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/game/entity_view.doc.js": {
    "type": "class",
    "file": "/game/entity_view.js",
    "name": "EntityView",
    "line": 1,
    "extends": null,
    "statics": [],
    "methods": [
      {
        "name": "sync",
        "line": 10,
        "source": "sync () {\n    if (this.root) {\n        this.root.x = this.entity.x\n        this.root.y = this.entity.y\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "dispose",
        "line": 18,
        "source": "dispose () {\n    if (this.root && this.context.group) {\n        this.context.group.remove(this.root)\n    }\n    this.root = null\n    this.entity = null\n    this.context = null\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 3,
      "source": "constructor (entity, context) {\n    this.entity = entity\n    this.context = context\n    this.root = null\n}",
      "kind": "constructor",
      "params": [
        "entity",
        "context"
      ]
    },
    "isDefault": true
  },
  "/game/game_loop.doc.js": {
    "type": "class",
    "file": "/game/game_loop.js",
    "name": "GameLoop",
    "line": 4,
    "extends": "PerkyModule",
    "statics": [
      {
        "name": "$category",
        "line": 6,
        "source": "static $category = 'gameLoop'",
        "kind": "property",
        "value": "'gameLoop'"
      }
    ],
    "methods": [
      {
        "name": "onInstall",
        "line": 27,
        "source": "onInstall (host) {\n    this.delegateTo(host, [\n        'paused',\n        'pause',\n        'resume',\n        'setFps',\n        'getFps',\n        'getCurrentFps',\n        'getScreenFps',\n        'fpsLimited',\n        'setFpsLimited'\n    ])\n\n    this.delegateEventsTo(host, [\n        'update',\n        'render',\n        'pause',\n        'resume',\n        'changed:fps',\n        'changed:fpsLimited'\n    ])\n}",
        "kind": "method",
        "params": [
          "host"
        ]
      },
      {
        "name": "onStart",
        "line": 66,
        "source": "onStart () {\n    this.#paused = false\n    this.lastTime = performance.now()\n    this.accumulator = 0\n    this.frameCount = 0\n    this.lastFpsUpdate = this.lastTime\n\n    requestAnimationFrame(time => update(this, time))\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "pause",
        "line": 77,
        "source": "pause (...args) {\n    if (!this.started || this.#paused) {\n        return false\n    }\n\n    this.#paused = true\n    this.emit('pause', ...args)\n\n    return true\n}",
        "kind": "method",
        "params": [
          "...args"
        ]
      },
      {
        "name": "resume",
        "line": 89,
        "source": "resume (...args) {\n    if (!this.started || !this.#paused) {\n        return false\n    }\n\n    this.#paused = false\n    this.lastTime = performance.now()\n    this.emit('resume', ...args)\n\n    requestAnimationFrame(time => update(this, time))\n\n    return true\n}",
        "kind": "method",
        "params": [
          "...args"
        ]
      },
      {
        "name": "getFps",
        "line": 104,
        "source": "getFps () {\n    return this.fps\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "setFps",
        "line": 109,
        "source": "setFps (fps) {\n    this.fps = fps\n    this.frameInterval = 1000 / fps\n    this.emit('changed:fps', fps)\n}",
        "kind": "method",
        "params": [
          "fps"
        ]
      },
      {
        "name": "getCurrentFps",
        "line": 116,
        "source": "getCurrentFps () {\n    return this.currentFps || 0\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "getScreenFps",
        "line": 121,
        "source": "getScreenFps () {\n    return this.screenFps || 0\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "setFpsLimited",
        "line": 131,
        "source": "setFpsLimited (value) {\n    this.#fpsLimited = value\n    this.emit('changed:fpsLimited', value)\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      }
    ],
    "getters": [
      {
        "name": "paused",
        "line": 51,
        "source": "get paused () {\n    return this.#paused\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "running",
        "line": 61,
        "source": "get running () {\n    return super.running && !this.#paused\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "fpsLimited",
        "line": 126,
        "source": "get fpsLimited () {\n    return this.#fpsLimited\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "paused",
        "line": 56,
        "source": "set paused (value) {\n    this.#paused = value\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      }
    ],
    "constructor": {
      "name": "constructor",
      "line": 11,
      "source": "constructor (params = {}) {\n    super(params)\n\n    this.lastTime = 0\n    this.accumulator = 0\n    this.maxFrameSkip = params.maxFrameSkip || 5\n    this.frameCount = 0\n    this.screenFrameCount = 0\n    this.lastFpsUpdate = 0\n\n    this.fps = params.fps ?? 60\n    this.frameInterval = 1000 / this.fps\n    this.#fpsLimited = params.fpsLimited ?? false\n}",
      "kind": "constructor",
      "params": [
        "params = ..."
      ]
    },
    "isDefault": true
  },
  "/game/world.doc.js": {
    "type": "class",
    "file": "/game/world.js",
    "name": "World",
    "line": 4,
    "extends": "PerkyModule",
    "statics": [
      {
        "name": "$category",
        "line": 6,
        "source": "static $category = 'world'",
        "kind": "property",
        "value": "'world'"
      }
    ],
    "methods": [
      {
        "name": "update",
        "line": 13,
        "source": "update (deltaTime, context) {\n    if (!this.started) {\n        return\n    }\n\n    this.preUpdate(deltaTime, context)\n\n    for (const entity of this.entities) {\n        if (entity.started) {\n            entity.update(deltaTime)\n        }\n    }\n\n    this.postUpdate(deltaTime, context)\n}",
        "kind": "method",
        "params": [
          "deltaTime",
          "context"
        ]
      },
      {
        "name": "preUpdate",
        "line": 30,
        "source": "preUpdate () {\n\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "postUpdate",
        "line": 35,
        "source": "postUpdate () {\n\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "entities",
        "line": 8,
        "source": "get entities () {\n    return this.childrenByCategory('entity')\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [],
    "constructor": null,
    "isDefault": true
  },
  "/game/world_view.doc.js": {
    "type": "class",
    "file": "/game/world_view.js",
    "name": "WorldView",
    "line": 23,
    "extends": "PerkyModule",
    "statics": [
      {
        "name": "$category",
        "line": 25,
        "source": "static $category = 'worldView'",
        "kind": "property",
        "value": "'worldView'"
      }
    ],
    "methods": [
      {
        "name": "register",
        "line": 40,
        "source": "register (classOrMatcher, View, config = null) {\n    const isObject2D = isObject2DClass(View)\n    const registration = isObject2D\n        ? {View: AutoView, config, ObjectClass: View}\n        : {View, config}\n\n    if (typeof classOrMatcher === 'function' && classOrMatcher.prototype) {\n        const isClass = classOrMatcher.toString().startsWith('class ') ||\n            Object.getOwnPropertyNames(classOrMatcher.prototype).length > 1\n\n        if (isClass) {\n            this.#classRegistry.set(classOrMatcher, registration)\n            return this\n        }\n    }\n\n    this.#matcherRegistry.push({matcher: classOrMatcher, ...registration})\n    return this\n}",
        "kind": "method",
        "params": [
          "classOrMatcher",
          "View",
          "config = ..."
        ]
      },
      {
        "name": "unregister",
        "line": 61,
        "source": "unregister (classOrMatcher) {\n    if (this.#classRegistry.has(classOrMatcher)) {\n        this.#classRegistry.delete(classOrMatcher)\n        return true\n    }\n\n    const index = this.#matcherRegistry.findIndex(entry => entry.matcher === classOrMatcher)\n    if (index !== -1) {\n        this.#matcherRegistry.splice(index, 1)\n        return true\n    }\n\n    return false\n}",
        "kind": "method",
        "params": [
          "classOrMatcher"
        ]
      },
      {
        "name": "clearRegistry",
        "line": 77,
        "source": "clearRegistry () {\n    this.#classRegistry.clear()\n    this.#matcherRegistry.length = 0\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "onStart",
        "line": 84,
        "source": "onStart () {\n    if (!this.world) {\n        return\n    }\n\n    this.listenTo(this.world, 'entity:set', (id, entity) => this.#handleEntitySet(entity))\n    this.listenTo(this.world, 'entity:delete', (id) => this.#handleEntityDelete(id))\n\n    for (const entity of this.world.entities) {\n        this.#handleEntitySet(entity)\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "onStop",
        "line": 98,
        "source": "onStop () {\n    this.#disposeAllViews()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "sync",
        "line": 103,
        "source": "sync (deltaTime = 0) {\n    for (const views of this.#views.values()) {\n        for (const view of views) {\n            view.sync(deltaTime)\n        }\n    }\n}",
        "kind": "method",
        "params": [
          "deltaTime = ..."
        ]
      },
      {
        "name": "getViews",
        "line": 112,
        "source": "getViews (entityId) {\n    return this.#views.get(entityId) || []\n}",
        "kind": "method",
        "params": [
          "entityId"
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 31,
      "source": "constructor (options = {}) {\n    super(options)\n\n    this.world = options.world\n    this.game = options.game\n    this.rootGroup = new Group2D({name: 'world'})\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/math/random.doc.js": {
    "type": "class",
    "file": "/math/random.js",
    "name": "Random",
    "line": 5,
    "extends": null,
    "statics": [
      {
        "name": "generateSeed",
        "line": 135,
        "source": "static generateSeed (length = 10) {\n    let result = ''\n\n    for (let i = 0; i < length; i++) {\n        result += CHARACTERS.charAt(Math.floor(Math.random() * CHARACTERS.length))\n    }\n\n    return result\n}",
        "kind": "method",
        "params": [
          "length = ..."
        ]
      }
    ],
    "methods": [
      {
        "name": "setSeed",
        "line": 48,
        "source": "setSeed (seed) {\n    this.#seed = seed\n    this.#initSeed(seed)\n\n    return this\n}",
        "kind": "method",
        "params": [
          "seed"
        ]
      },
      {
        "name": "getSeed",
        "line": 56,
        "source": "getSeed () {\n    return this.#seed\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "setState",
        "line": 61,
        "source": "setState (state) {\n    this.#c = state.c\n    this.#s0 = state.s0\n    this.#s1 = state.s1\n    this.#s2 = state.s2\n\n    return this\n}",
        "kind": "method",
        "params": [
          "state"
        ]
      },
      {
        "name": "getState",
        "line": 71,
        "source": "getState () {\n    return {\n        c: this.#c,\n        s0: this.#s0,\n        s1: this.#s1,\n        s2: this.#s2\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "fork",
        "line": 81,
        "source": "fork () {\n    const forked = new Random(this.#seed)\n    forked.setState(this.getState())\n\n    return forked\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "between",
        "line": 89,
        "source": "between (min, max) {\n    return this.#next() * (max - min) + min\n}",
        "kind": "method",
        "params": [
          "min",
          "max"
        ]
      },
      {
        "name": "intBetween",
        "line": 94,
        "source": "intBetween (min, max) {\n    return Math.floor(this.between(min, max))\n}",
        "kind": "method",
        "params": [
          "min",
          "max"
        ]
      },
      {
        "name": "pick",
        "line": 99,
        "source": "pick (array) {\n    return array[this.intBetween(0, array.length)]\n}",
        "kind": "method",
        "params": [
          "array"
        ]
      },
      {
        "name": "oneChanceIn",
        "line": 104,
        "source": "oneChanceIn (chances) {\n    return this.#next() < 1 / chances\n}",
        "kind": "method",
        "params": [
          "chances"
        ]
      },
      {
        "name": "coinToss",
        "line": 109,
        "source": "coinToss () {\n    return this.#next() < 0.5\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "weightedChoice",
        "line": 114,
        "source": "weightedChoice (choices) {\n    if (!choices || choices.length === 0) {\n        return undefined\n    }\n\n    const totalWeight = choices.reduce((total, choice) => total + choice.weight, 0)\n\n    let randomValue = this.#next() * totalWeight\n\n    for (const choice of choices) {\n        randomValue -= choice.weight\n\n        if (randomValue <= 0) {\n            return choice.value\n        }\n    }\n\n    return choices[choices.length - 1].value\n}",
        "kind": "method",
        "params": [
          "choices"
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 13,
      "source": "constructor (seed = Random.generateSeed()) {\n    this.#seed = seed\n    this.#initSeed(seed)\n}",
      "kind": "constructor",
      "params": [
        "seed = ..."
      ]
    },
    "isDefault": true
  },
  "/math/vec2.doc.js": {
    "type": "class",
    "file": "/math/vec2.js",
    "name": "Vec2",
    "line": 1,
    "extends": null,
    "statics": [],
    "methods": [
      {
        "name": "set",
        "line": 19,
        "source": "set (x, y) {\n    this.x = x\n    this.y = y\n    return this\n}",
        "kind": "method",
        "params": [
          "x",
          "y"
        ]
      },
      {
        "name": "setX",
        "line": 26,
        "source": "setX (x) {\n    this.x = x\n    return this\n}",
        "kind": "method",
        "params": [
          "x"
        ]
      },
      {
        "name": "setY",
        "line": 32,
        "source": "setY (y) {\n    this.y = y\n    return this\n}",
        "kind": "method",
        "params": [
          "y"
        ]
      },
      {
        "name": "setScalar",
        "line": 38,
        "source": "setScalar (scalar) {\n    this.x = scalar\n    this.y = scalar\n    return this\n}",
        "kind": "method",
        "params": [
          "scalar"
        ]
      },
      {
        "name": "copy",
        "line": 45,
        "source": "copy (v) {\n    this.x = v.x\n    this.y = v.y\n    return this\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "clone",
        "line": 52,
        "source": "clone () {\n    return new Vec2(this.x, this.y)\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "add",
        "line": 57,
        "source": "add (v) {\n    this.x += v.x\n    this.y += v.y\n    return this\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "addScalar",
        "line": 64,
        "source": "addScalar (s) {\n    this.x += s\n    this.y += s\n    return this\n}",
        "kind": "method",
        "params": [
          "s"
        ]
      },
      {
        "name": "addVectors",
        "line": 71,
        "source": "addVectors (a, b) {\n    this.x = a.x + b.x\n    this.y = a.y + b.y\n    return this\n}",
        "kind": "method",
        "params": [
          "a",
          "b"
        ]
      },
      {
        "name": "addScaledVector",
        "line": 78,
        "source": "addScaledVector (v, s) {\n    this.x += v.x * s\n    this.y += v.y * s\n    return this\n}",
        "kind": "method",
        "params": [
          "v",
          "s"
        ]
      },
      {
        "name": "sub",
        "line": 85,
        "source": "sub (v) {\n    this.x -= v.x\n    this.y -= v.y\n    return this\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "subScalar",
        "line": 92,
        "source": "subScalar (s) {\n    this.x -= s\n    this.y -= s\n    return this\n}",
        "kind": "method",
        "params": [
          "s"
        ]
      },
      {
        "name": "subVectors",
        "line": 99,
        "source": "subVectors (a, b) {\n    this.x = a.x - b.x\n    this.y = a.y - b.y\n    return this\n}",
        "kind": "method",
        "params": [
          "a",
          "b"
        ]
      },
      {
        "name": "multiply",
        "line": 106,
        "source": "multiply (v) {\n    this.x *= v.x\n    this.y *= v.y\n    return this\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "multiplyScalar",
        "line": 113,
        "source": "multiplyScalar (scalar) {\n    this.x *= scalar\n    this.y *= scalar\n    return this\n}",
        "kind": "method",
        "params": [
          "scalar"
        ]
      },
      {
        "name": "divide",
        "line": 120,
        "source": "divide (v) {\n    this.x /= v.x\n    this.y /= v.y\n    return this\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "divideScalar",
        "line": 127,
        "source": "divideScalar (scalar) {\n    return this.multiplyScalar(1 / scalar)\n}",
        "kind": "method",
        "params": [
          "scalar"
        ]
      },
      {
        "name": "dot",
        "line": 132,
        "source": "dot (v) {\n    return this.x * v.x + this.y * v.y\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "cross",
        "line": 137,
        "source": "cross (v) {\n    return this.x * v.y - this.y * v.x\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "lengthSq",
        "line": 142,
        "source": "lengthSq () {\n    return this.x * this.x + this.y * this.y\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "length",
        "line": 147,
        "source": "length () {\n    return Math.sqrt(this.lengthSq())\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "manhattanLength",
        "line": 152,
        "source": "manhattanLength () {\n    return Math.abs(this.x) + Math.abs(this.y)\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "normalize",
        "line": 157,
        "source": "normalize () {\n    return this.divideScalar(this.length() || 1)\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "angle",
        "line": 162,
        "source": "angle () {\n    return Math.atan2(-this.y, -this.x) + Math.PI\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "angleTo",
        "line": 167,
        "source": "angleTo (v) {\n    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq())\n    if (denominator === 0) {\n        return Math.PI / 2\n    }\n    const theta = this.dot(v) / denominator\n    return Math.acos(Math.max(-1, Math.min(1, theta)))\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "distanceTo",
        "line": 177,
        "source": "distanceTo (v) {\n    return Math.sqrt(this.distanceToSquared(v))\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "distanceToSquared",
        "line": 182,
        "source": "distanceToSquared (v) {\n    const dx = this.x - v.x\n    const dy = this.y - v.y\n    return dx * dx + dy * dy\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "manhattanDistanceTo",
        "line": 189,
        "source": "manhattanDistanceTo (v) {\n    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y)\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "setLength",
        "line": 194,
        "source": "setLength (length) {\n    return this.normalize().multiplyScalar(length)\n}",
        "kind": "method",
        "params": [
          "length"
        ]
      },
      {
        "name": "lerp",
        "line": 199,
        "source": "lerp (v, alpha) {\n    this.x += (v.x - this.x) * alpha\n    this.y += (v.y - this.y) * alpha\n    return this\n}",
        "kind": "method",
        "params": [
          "v",
          "alpha"
        ]
      },
      {
        "name": "lerpVectors",
        "line": 206,
        "source": "lerpVectors (v1, v2, alpha) {\n    this.x = v1.x + (v2.x - v1.x) * alpha\n    this.y = v1.y + (v2.y - v1.y) * alpha\n    return this\n}",
        "kind": "method",
        "params": [
          "v1",
          "v2",
          "alpha"
        ]
      },
      {
        "name": "equals",
        "line": 213,
        "source": "equals (v) {\n    return v.x === this.x && v.y === this.y\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "fromArray",
        "line": 218,
        "source": "fromArray (array, offset = 0) {\n    this.x = array[offset]\n    this.y = array[offset + 1]\n    return this\n}",
        "kind": "method",
        "params": [
          "array",
          "offset = ..."
        ]
      },
      {
        "name": "toArray",
        "line": 225,
        "source": "toArray (array = [], offset = 0) {\n    array[offset] = this.x\n    array[offset + 1] = this.y\n    return array\n}",
        "kind": "method",
        "params": [
          "array = ...",
          "offset = ..."
        ]
      },
      {
        "name": "negate",
        "line": 232,
        "source": "negate () {\n    this.x = -this.x\n    this.y = -this.y\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "min",
        "line": 239,
        "source": "min (v) {\n    this.x = Math.min(this.x, v.x)\n    this.y = Math.min(this.y, v.y)\n    return this\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "max",
        "line": 246,
        "source": "max (v) {\n    this.x = Math.max(this.x, v.x)\n    this.y = Math.max(this.y, v.y)\n    return this\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "clamp",
        "line": 253,
        "source": "clamp (min, max) {\n    this.x = Math.max(min.x, Math.min(max.x, this.x))\n    this.y = Math.max(min.y, Math.min(max.y, this.y))\n    return this\n}",
        "kind": "method",
        "params": [
          "min",
          "max"
        ]
      },
      {
        "name": "clampScalar",
        "line": 260,
        "source": "clampScalar (minVal, maxVal) {\n    this.x = Math.max(minVal, Math.min(maxVal, this.x))\n    this.y = Math.max(minVal, Math.min(maxVal, this.y))\n    return this\n}",
        "kind": "method",
        "params": [
          "minVal",
          "maxVal"
        ]
      },
      {
        "name": "clampLength",
        "line": 267,
        "source": "clampLength (min, max) {\n    const length = this.length()\n    return this.divideScalar(length || 1).multiplyScalar(\n        Math.max(min, Math.min(max, length))\n    )\n}",
        "kind": "method",
        "params": [
          "min",
          "max"
        ]
      },
      {
        "name": "floor",
        "line": 275,
        "source": "floor () {\n    this.x = Math.floor(this.x)\n    this.y = Math.floor(this.y)\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "ceil",
        "line": 282,
        "source": "ceil () {\n    this.x = Math.ceil(this.x)\n    this.y = Math.ceil(this.y)\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "round",
        "line": 289,
        "source": "round () {\n    this.x = Math.round(this.x)\n    this.y = Math.round(this.y)\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "roundToZero",
        "line": 296,
        "source": "roundToZero () {\n    this.x = Math.trunc(this.x)\n    this.y = Math.trunc(this.y)\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "rotateAround",
        "line": 303,
        "source": "rotateAround (center, angle) {\n    const c = Math.cos(angle)\n    const s = Math.sin(angle)\n\n    const x = this.x - center.x\n    const y = this.y - center.y\n\n    this.x = x * c - y * s + center.x\n    this.y = x * s + y * c + center.y\n\n    return this\n}",
        "kind": "method",
        "params": [
          "center",
          "angle"
        ]
      },
      {
        "name": "random",
        "line": 317,
        "source": "random () {\n    this.x = Math.random()\n    this.y = Math.random()\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "getComponent",
        "line": 324,
        "source": "getComponent (index) {\n    if (index === 0) {\n        return this.x\n    } else if (index === 1) {\n        return this.y\n    }\n    throw new Error(`index out of range: ${index}`)\n}",
        "kind": "method",
        "params": [
          "index"
        ]
      },
      {
        "name": "setComponent",
        "line": 334,
        "source": "setComponent (index, value) {\n    if (index === 0) {\n        this.x = value\n    } else if (index === 1) {\n        this.y = value\n    } else {\n        throw new Error(`index out of range: ${index}`)\n    }\n    return this\n}",
        "kind": "method",
        "params": [
          "index",
          "value"
        ]
      }
    ],
    "getters": [
      {
        "name": "width",
        "line": 346,
        "source": "get width () {\n    return this.x\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "height",
        "line": 356,
        "source": "get height () {\n    return this.y\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "isVector2",
        "line": 366,
        "source": "get isVector2 () { // eslint-disable-line local/class-methods-use-this -- clean\n    return true\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "width",
        "line": 351,
        "source": "set width (value) {\n    this.x = value\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "height",
        "line": 361,
        "source": "set height (value) {\n    this.y = value\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      }
    ],
    "constructor": {
      "name": "constructor",
      "line": 3,
      "source": "constructor (x = 0, y = 0) {\n    if (typeof x === 'object') {\n        if (Array.isArray(x)) {\n            this.x = x[0] ?? 0\n            this.y = x[1] ?? 0\n        } else {\n            this.x = x.x ?? 0\n            this.y = x.y ?? 0\n        }\n    } else {\n        this.x = x\n        this.y = y\n    }\n}",
      "kind": "constructor",
      "params": [
        "x = ...",
        "y = ..."
      ]
    },
    "isDefault": true
  },
  "/render/canvas_renderer.doc.js": {
    "type": "class",
    "file": "/render/canvas_renderer.js",
    "name": "CanvasRenderer",
    "line": 10,
    "extends": "BaseRenderer",
    "statics": [
      {
        "name": "$name",
        "line": 12,
        "source": "static $name = 'canvasRenderer'",
        "kind": "property",
        "value": "'canvasRenderer'"
      }
    ],
    "methods": [
      {
        "name": "registerRenderer",
        "line": 48,
        "source": "registerRenderer (renderer) {\n    renderer.init({ctx: this.ctx, canvas: this.canvas})\n\n    for (const ObjectClass of renderer.constructor.handles) {\n        this.#rendererRegistry.set(ObjectClass, renderer)\n    }\n\n    if (!this.#renderers.includes(renderer)) {\n        this.#renderers.push(renderer)\n    }\n\n    return this\n}",
        "kind": "method",
        "params": [
          "renderer"
        ]
      },
      {
        "name": "unregisterRenderer",
        "line": 63,
        "source": "unregisterRenderer (renderer) {\n    for (const ObjectClass of renderer.constructor.handles) {\n        if (this.#rendererRegistry.get(ObjectClass) === renderer) {\n            this.#rendererRegistry.delete(ObjectClass)\n        }\n    }\n\n    const index = this.#renderers.indexOf(renderer)\n    if (index !== -1) {\n        this.#renderers.splice(index, 1)\n    }\n\n    renderer.dispose()\n    return this\n}",
        "kind": "method",
        "params": [
          "renderer"
        ]
      },
      {
        "name": "onDispose",
        "line": 80,
        "source": "onDispose () {\n    for (const renderer of this.#renderers) {\n        renderer.dispose()\n    }\n    this.#renderers = []\n    this.#rendererRegistry.clear()\n\n    if (this.#debugGizmoRenderer) {\n        this.#debugGizmoRenderer.dispose()\n        this.#debugGizmoRenderer = null\n    }\n\n    super.onDispose()\n    this.ctx = null\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "render",
        "line": 97,
        "source": "render (scene) {\n    const ctx = this.ctx\n\n    this.stats.totalObjects = 0\n    this.stats.renderedObjects = 0\n    this.stats.culledObjects = 0\n\n    ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\n\n    if (this.backgroundColor && this.backgroundColor !== 'transparent') {\n        ctx.fillStyle = this.backgroundColor\n        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height)\n    }\n\n    this.camera.update()\n\n    ctx.save()\n    this.camera.applyToContext(ctx, this.pixelRatio)\n\n    scene.updateWorldMatrix(false)\n\n    for (const renderer of this.#renderers) {\n        renderer.reset()\n    }\n\n    const debugGizmoRenderer = this.enableDebugGizmos ? this.#debugGizmoRenderer : null\n    if (debugGizmoRenderer) {\n        debugGizmoRenderer.reset()\n    }\n\n    traverseAndCollect(scene, this.#rendererRegistry, {\n        camera: this.camera,\n        enableCulling: this.enableCulling,\n        stats: this.stats,\n        debugGizmoRenderer\n    })\n\n    for (const renderer of this.#renderers) {\n        renderer.flush()\n    }\n\n    if (debugGizmoRenderer) {\n        debugGizmoRenderer.flush()\n    }\n\n    ctx.restore()\n}",
        "kind": "method",
        "params": [
          "scene"
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 18,
      "source": "constructor (options = {}) {\n    super(options)\n\n    this.ctx = this.canvas.getContext('2d')\n\n    this.#setupDefaultRenderers()\n    this.applyPixelRatio()\n\n    this.backgroundColor = options.backgroundColor ?? null\n    this.enableCulling = options.enableCulling ?? false\n    this.enableDebugGizmos = options.enableDebugGizmos ?? true\n\n    this.stats = {\n        totalObjects: 0,\n        renderedObjects: 0,\n        culledObjects: 0\n    }\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/render/webgl_renderer.doc.js": {
    "type": "class",
    "file": "/render/webgl_renderer.js",
    "name": "WebGLRenderer",
    "line": 19,
    "extends": "BaseRenderer",
    "statics": [
      {
        "name": "$name",
        "line": 21,
        "source": "static $name = 'webGLRenderer'",
        "kind": "property",
        "value": "'webGLRenderer'"
      }
    ],
    "methods": [
      {
        "name": "registerRenderer",
        "line": 118,
        "source": "registerRenderer (renderer) {\n    const context = {\n        gl: this.gl,\n        spriteProgram: this.spriteProgram,\n        primitiveProgram: this.primitiveProgram,\n        textureManager: this.textureManager,\n        shaderEffectRegistry: this.#shaderEffectRegistry\n    }\n\n    renderer.init(context)\n\n    for (const ObjectClass of renderer.constructor.handles) {\n        this.#rendererRegistry.set(ObjectClass, renderer)\n    }\n\n    if (!this.#renderers.includes(renderer)) {\n        this.#renderers.push(renderer)\n    }\n\n    return this\n}",
        "kind": "method",
        "params": [
          "renderer"
        ]
      },
      {
        "name": "unregisterRenderer",
        "line": 141,
        "source": "unregisterRenderer (renderer) {\n    for (const ObjectClass of renderer.constructor.handles) {\n        if (this.#rendererRegistry.get(ObjectClass) === renderer) {\n            this.#rendererRegistry.delete(ObjectClass)\n        }\n    }\n\n    const index = this.#renderers.indexOf(renderer)\n    if (index !== -1) {\n        this.#renderers.splice(index, 1)\n    }\n\n    renderer.dispose()\n    return this\n}",
        "kind": "method",
        "params": [
          "renderer"
        ]
      },
      {
        "name": "applyPixelRatio",
        "line": 158,
        "source": "applyPixelRatio () {\n    super.applyPixelRatio()\n\n    if (this.gl) {\n        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height)\n    }\n\n    if (this.#postProcessor) {\n        this.#postProcessor.resize(this.canvas.width, this.canvas.height)\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "registerShaderEffect",
        "line": 181,
        "source": "registerShaderEffect (EffectClass) {\n    return this.#shaderEffectRegistry.register(EffectClass)\n}",
        "kind": "method",
        "params": [
          "EffectClass"
        ]
      },
      {
        "name": "setUniform",
        "line": 186,
        "source": "setUniform (name, value, type = null) {\n    this.#shaderEffectRegistry.setUniform(name, value, type)\n    return this\n}",
        "kind": "method",
        "params": [
          "name",
          "value",
          "type = ..."
        ]
      },
      {
        "name": "getUniform",
        "line": 192,
        "source": "getUniform (name) {\n    return this.#shaderEffectRegistry.getUniform(name)\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "registerShader",
        "line": 197,
        "source": "registerShader (id, definition) {\n    return this.#shaderRegistry.register(id, definition)\n}",
        "kind": "method",
        "params": [
          "id",
          "definition"
        ]
      },
      {
        "name": "getShader",
        "line": 202,
        "source": "getShader (id) {\n    return this.#shaderRegistry.get(id)\n}",
        "kind": "method",
        "params": [
          "id"
        ]
      },
      {
        "name": "addPostPass",
        "line": 212,
        "source": "addPostPass (pass) {\n    this.#postProcessor.addPass(pass)\n    return this\n}",
        "kind": "method",
        "params": [
          "pass"
        ]
      },
      {
        "name": "removePostPass",
        "line": 218,
        "source": "removePostPass (pass) {\n    this.#postProcessor.removePass(pass)\n    return this\n}",
        "kind": "method",
        "params": [
          "pass"
        ]
      },
      {
        "name": "setRenderGroups",
        "line": 224,
        "source": "setRenderGroups (configs) {\n    this.clearRenderGroups()\n\n    if (!this.#compositeProgram) {\n        this.#setupCompositeShader()\n    }\n    if (!this.#compositeQuad) {\n        this.#compositeQuad = new FullscreenQuad(this.gl)\n    }\n\n    for (const config of configs) {\n        this.create(RenderGroup, config)\n    }\n\n    return this\n}",
        "kind": "method",
        "params": [
          "configs"
        ]
      },
      {
        "name": "clearRenderGroups",
        "line": 242,
        "source": "clearRenderGroups () {\n    const groups = this.renderGroups\n    for (const group of groups) {\n        this.removeChild(group.$id)\n    }\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "onDispose",
        "line": 288,
        "source": "onDispose () {\n    for (const renderer of this.#renderers) {\n        renderer.dispose()\n    }\n    this.#renderers = []\n    this.#rendererRegistry.clear()\n\n    if (this.#debugGizmoRenderer) {\n        this.#debugGizmoRenderer.dispose()\n        this.#debugGizmoRenderer = null\n    }\n\n    this.clearRenderGroups()\n\n    if (this.#compositeQuad) {\n        this.#compositeQuad.dispose(this.gl)\n        this.#compositeQuad = null\n    }\n\n    if (this.#postProcessor) {\n        this.#postProcessor.dispose()\n        this.#postProcessor = null\n    }\n\n    if (this.#shaderEffectRegistry) {\n        this.#shaderEffectRegistry.dispose()\n        this.#shaderEffectRegistry = null\n    }\n\n    if (this.#shaderRegistry) {\n        this.#shaderRegistry.dispose()\n        this.#shaderRegistry = null\n    }\n\n    super.onDispose()\n    this.gl = null\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "render",
        "line": 348,
        "source": "render (scene) {\n    if (this.renderGroups.length > 0 && !scene) {\n        return this.#renderWithGroups()\n    }\n    return this.#renderSingleScene(scene)\n}",
        "kind": "method",
        "params": [
          "scene"
        ]
      }
    ],
    "getters": [
      {
        "name": "shaderRegistry",
        "line": 171,
        "source": "get shaderRegistry () {\n    return this.#shaderRegistry\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "shaderEffectRegistry",
        "line": 176,
        "source": "get shaderEffectRegistry () {\n    return this.#shaderEffectRegistry\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "postProcessor",
        "line": 207,
        "source": "get postProcessor () {\n    return this.#postProcessor\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "renderGroups",
        "line": 251,
        "source": "get renderGroups () {\n    return this.childrenByCategory('renderGroup')\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 33,
      "source": "constructor (options = {}) {\n    const {autoFit, ...parentOptions} = options\n    super(parentOptions)\n\n    this.#setupWebGL()\n    this.#setupDefaultRenderers()\n    this.applyPixelRatio()\n\n    this.backgroundColor = options.backgroundColor ?? null\n    this.enableCulling = options.enableCulling ?? false\n    this.enableDebugGizmos = options.enableDebugGizmos ?? true\n\n    this.stats = {\n        totalObjects: 0,\n        renderedObjects: 0,\n        culledObjects: 0,\n        drawCalls: 0\n    }\n\n    if (autoFit) {\n        this.autoFitEnabled = true\n    }\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/render/circle.doc.js": {
    "type": "class",
    "file": "/render/circle.js",
    "name": "Circle",
    "line": 4,
    "extends": "Object2D",
    "statics": [],
    "methods": [
      {
        "name": "setRadius",
        "line": 16,
        "source": "setRadius (radius) {\n    this.radius = radius\n    return this\n}",
        "kind": "method",
        "params": [
          "radius"
        ]
      },
      {
        "name": "getBounds",
        "line": 22,
        "source": "getBounds () {\n    const size = this.radius * 2\n    const offsetX = -size * this.anchorX\n    const offsetY = -size * this.anchorY\n\n    return {\n        minX: offsetX,\n        minY: offsetY,\n        maxX: offsetX + size,\n        maxY: offsetY + size,\n        width: size,\n        height: size\n    }\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 6,
      "source": "constructor (options = {}) {\n    super(options)\n\n    this.radius = options.radius ?? 10\n    this.color = options.color ?? '#000000'\n    this.strokeColor = options.strokeColor ?? '#000000'\n    this.strokeWidth = options.strokeWidth ?? 0\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/render/group_2d.doc.js": {
    "type": "class",
    "file": "/render/group_2d.js",
    "name": "Group2D",
    "line": 4,
    "extends": "Object2D",
    "statics": [],
    "methods": [
      {
        "name": "addChild",
        "line": 11,
        "source": "addChild (...objects) {\n    return this.add(...objects)\n}",
        "kind": "method",
        "params": [
          "...objects"
        ]
      },
      {
        "name": "getBounds",
        "line": 16,
        "source": "getBounds () {\n    if (this.children.length === 0) {\n        return {\n            minX: 0,\n            minY: 0,\n            maxX: 0,\n            maxY: 0,\n            width: 0,\n            height: 0\n        }\n    }\n\n    let minX = Infinity\n    let minY = Infinity\n    let maxX = -Infinity\n    let maxY = -Infinity\n\n    this.children.forEach(child => {\n        const bounds = child.getBounds()\n\n        if (bounds.width === 0 && bounds.height === 0) {\n            return\n        }\n\n        const m = child.worldMatrix\n        const corners = [\n            {x: bounds.minX, y: bounds.minY},\n            {x: bounds.maxX, y: bounds.minY},\n            {x: bounds.minX, y: bounds.maxY},\n            {x: bounds.maxX, y: bounds.maxY}\n        ]\n\n        corners.forEach(corner => {\n            const x = m[0] * corner.x + m[2] * corner.y + m[4]\n            const y = m[1] * corner.x + m[3] * corner.y + m[5]\n\n            minX = Math.min(minX, x)\n            minY = Math.min(minY, y)\n            maxX = Math.max(maxX, x)\n            maxY = Math.max(maxY, y)\n        })\n    })\n\n    if (minX === Infinity) {\n        return {\n            minX: 0,\n            minY: 0,\n            maxX: 0,\n            maxY: 0,\n            width: 0,\n            height: 0\n        }\n    }\n\n    return {\n        minX,\n        minY,\n        maxX,\n        maxY,\n        width: maxX - minX,\n        height: maxY - minY\n    }\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 6,
      "source": "constructor (options = {}) {\n    super(options)\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/render/object_2d.doc.js": {
    "type": "class",
    "file": "/render/object_2d.js",
    "name": "Object2D",
    "line": 5,
    "extends": "Transform",
    "statics": [],
    "methods": [
      {
        "name": "showDebugGizmos",
        "line": 80,
        "source": "showDebugGizmos (options = {}) {\n    this.#debugGizmos = {\n        bounds: options.bounds ?? true,\n        anchor: options.anchor ?? true,\n        pivot: options.pivot ?? true,\n        origin: options.origin ?? true\n    }\n    return this\n}",
        "kind": "method",
        "params": [
          "options = ..."
        ]
      },
      {
        "name": "hideDebugGizmos",
        "line": 91,
        "source": "hideDebugGizmos () {\n    this.#debugGizmos = null\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "setPosition",
        "line": 97,
        "source": "setPosition (x, y) {\n    this.x = x\n    this.y = y\n    this.markDirty()\n    return this\n}",
        "kind": "method",
        "params": [
          "x",
          "y"
        ]
      },
      {
        "name": "setRotation",
        "line": 105,
        "source": "setRotation (rotation) {\n    this.rotation = rotation\n    this.markDirty()\n    return this\n}",
        "kind": "method",
        "params": [
          "rotation"
        ]
      },
      {
        "name": "setScale",
        "line": 112,
        "source": "setScale (scaleX, scaleY = scaleX) {\n    this.scaleX = scaleX\n    this.scaleY = scaleY\n    this.markDirty()\n    return this\n}",
        "kind": "method",
        "params": [
          "scaleX",
          "scaleY = ..."
        ]
      },
      {
        "name": "setOpacity",
        "line": 120,
        "source": "setOpacity (opacity) {\n    this.opacity = opacity\n    this.markDirty()\n    return this\n}",
        "kind": "method",
        "params": [
          "opacity"
        ]
      },
      {
        "name": "setVisible",
        "line": 127,
        "source": "setVisible (visible) {\n    this.visible = visible\n    this.markDirty()\n    return this\n}",
        "kind": "method",
        "params": [
          "visible"
        ]
      },
      {
        "name": "setDepth",
        "line": 134,
        "source": "setDepth (depth) {\n    if (this.depth !== depth) {\n        this.depth = depth\n        if (this.parent) {\n            this.parent.markChildrenNeedSort()\n        }\n        this.markDirty()\n    }\n    return this\n}",
        "kind": "method",
        "params": [
          "depth"
        ]
      },
      {
        "name": "setAnchor",
        "line": 146,
        "source": "setAnchor (x, y = x) {\n    this.anchorX = x\n    this.anchorY = y\n    this.markDirty()\n    return this\n}",
        "kind": "method",
        "params": [
          "x",
          "y = ..."
        ]
      },
      {
        "name": "setPivot",
        "line": 154,
        "source": "setPivot (x, y) {\n    this.pivotX = x\n    this.pivotY = y\n    this.markDirty()\n    return this\n}",
        "kind": "method",
        "params": [
          "x",
          "y"
        ]
      },
      {
        "name": "getBounds",
        "line": 162,
        "source": "getBounds () { // eslint-disable-line local/class-methods-use-this -- clean\n    return {\n        minX: 0,\n        minY: 0,\n        maxX: 0,\n        maxY: 0,\n        width: 0,\n        height: 0\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "getWorldBounds",
        "line": 174,
        "source": "getWorldBounds () {\n    const localBounds = this.getBounds()\n\n    if (localBounds.width === 0 && localBounds.height === 0) {\n        return localBounds\n    }\n\n    const corners = [\n        {x: localBounds.minX, y: localBounds.minY},\n        {x: localBounds.maxX, y: localBounds.minY},\n        {x: localBounds.minX, y: localBounds.maxY},\n        {x: localBounds.maxX, y: localBounds.maxY}\n    ]\n\n    const transformedCorners = corners.map(corner => this.transformPoint(corner))\n\n    const xs = transformedCorners.map(c => c.x)\n    const ys = transformedCorners.map(c => c.y)\n\n    const minX = Math.min(...xs)\n    const minY = Math.min(...ys)\n    const maxX = Math.max(...xs)\n    const maxY = Math.max(...ys)\n\n    return {\n        minX,\n        minY,\n        maxX,\n        maxY,\n        width: maxX - minX,\n        height: maxY - minY\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "render",
        "line": 240,
        "source": "render () {\n\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "tint",
        "line": 52,
        "source": "get tint () {\n    return this.#tint\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "effects",
        "line": 62,
        "source": "get effects () {\n    if (!this.#effects) {\n        this.#effects = new SpriteEffectStack()\n    }\n    return this.#effects\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "debugGizmos",
        "line": 70,
        "source": "get debugGizmos () {\n    return this.#debugGizmos\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "renderHints",
        "line": 209,
        "source": "get renderHints () {\n    const hasTint = this.#tint !== null\n    const hasEffects = this.#effects !== null && this.#effects.count > 0\n\n    if (!hasTint && !hasEffects) {\n        return null\n    }\n\n    const hints = {}\n\n    if (hasTint) {\n        hints.tint = this.#tint\n    }\n\n    if (hasEffects) {\n        const effectHints = this.#effects.getHints()\n        if (effectHints) {\n            hints.effects = effectHints\n        }\n\n        const shaderEffectTypes = this.#effects.getShaderEffectTypes()\n        if (shaderEffectTypes.length > 0) {\n            hints.shaderEffectTypes = shaderEffectTypes\n            hints.effectParams = this.#effects.getShaderEffectParams()\n        }\n    }\n\n    return hints\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "tint",
        "line": 57,
        "source": "set tint (value) {\n    this.#tint = value\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "debugGizmos",
        "line": 75,
        "source": "set debugGizmos (value) {\n    this.#debugGizmos = value\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      }
    ],
    "constructor": {
      "name": "constructor",
      "line": 11,
      "source": "constructor (options = {}) { // eslint-disable-line complexity -- clean\n    super()\n\n    this.visible = options.visible ?? true\n    this.opacity = options.opacity ?? 1\n    this.depth = options.depth ?? 0\n    this.anchorX = options.anchorX ?? 0.5\n    this.anchorY = options.anchorY ?? 0.5\n\n    if (options.debugGizmos !== undefined) {\n        this.#debugGizmos = options.debugGizmos\n    }\n\n    if (options.tint !== undefined) {\n        this.#tint = options.tint\n    }\n\n    if (options.x !== undefined) {\n        this.x = options.x\n    }\n    if (options.y !== undefined) {\n        this.y = options.y\n    }\n    if (options.rotation !== undefined) {\n        this.rotation = options.rotation\n    }\n    if (options.scaleX !== undefined) {\n        this.scaleX = options.scaleX\n    }\n    if (options.scaleY !== undefined) {\n        this.scaleY = options.scaleY\n    }\n    if (options.pivotX !== undefined) {\n        this.pivotX = options.pivotX\n    }\n    if (options.pivotY !== undefined) {\n        this.pivotY = options.pivotY\n    }\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/render/rectangle.doc.js": {
    "type": "class",
    "file": "/render/rectangle.js",
    "name": "Rectangle",
    "line": 4,
    "extends": "Object2D",
    "statics": [],
    "methods": [
      {
        "name": "getBounds",
        "line": 17,
        "source": "getBounds () {\n    const offsetX = -this.width * this.anchorX\n    const offsetY = -this.height * this.anchorY\n\n    return {\n        minX: offsetX,\n        minY: offsetY,\n        maxX: offsetX + this.width,\n        maxY: offsetY + this.height,\n        width: this.width,\n        height: this.height\n    }\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 6,
      "source": "constructor (options = {}) {\n    super(options)\n\n    this.width = options.width ?? 10\n    this.height = options.height ?? 10\n    this.color = options.color ?? '#000000'\n    this.strokeColor = options.strokeColor ?? '#000000'\n    this.strokeWidth = options.strokeWidth ?? 0\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/render/sprite.doc.js": {
    "type": "class",
    "file": "/render/sprite.js",
    "name": "Sprite",
    "line": 5,
    "extends": "Object2D",
    "statics": [],
    "methods": [
      {
        "name": "setFrame",
        "line": 57,
        "source": "setFrame (frame) {\n    if (frame instanceof TextureRegion) {\n        this.#region = frame\n    } else if (frame && frame.frame) {\n        const image = frame.image\n        this.#region = TextureRegion.fromFrame(image, frame.frame)\n    } else {\n        this.#region = null\n    }\n}",
        "kind": "method",
        "params": [
          "frame"
        ]
      },
      {
        "name": "addAnimation",
        "line": 69,
        "source": "addAnimation (name, animation) {\n    this.animations.set(name, animation)\n}",
        "kind": "method",
        "params": [
          "name",
          "animation"
        ]
      },
      {
        "name": "play",
        "line": 74,
        "source": "play (name) {\n    const animation = this.animations.get(name)\n    if (animation) {\n        if (this.currentAnimation && this.currentAnimation !== animation) {\n            this.currentAnimation.stop()\n        }\n        this.currentAnimation = animation\n        this.currentAnimation.play()\n    }\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "stop",
        "line": 86,
        "source": "stop () {\n    if (this.currentAnimation) {\n        this.currentAnimation.stop()\n        this.currentAnimation = null\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "getBounds",
        "line": 94,
        "source": "getBounds () {\n    const region = this.#region\n    const hasWidth = this.width !== null\n    const hasHeight = this.height !== null\n\n    if (!region) {\n        const renderW = hasWidth ? this.width : 10\n        const renderH = hasHeight ? this.height : 10\n        const offsetX = -renderW * this.anchorX\n        const offsetY = -renderH * this.anchorY\n\n        return {\n            minX: offsetX,\n            minY: offsetY,\n            maxX: offsetX + renderW,\n            maxY: offsetY + renderH,\n            width: renderW,\n            height: renderH\n        }\n    }\n\n    const w = region.width\n    const h = region.height\n\n    let renderW\n    let renderH\n\n    if (hasWidth && hasHeight) {\n        renderW = this.width\n        renderH = this.height\n    } else if (hasWidth) {\n        renderW = this.width\n        renderH = (h / w) * renderW\n    } else if (hasHeight) {\n        renderH = this.height\n        renderW = (w / h) * renderH\n    } else {\n        renderW = w\n        renderH = h\n    }\n\n    const offsetX = -renderW * this.anchorX\n    const offsetY = -renderH * this.anchorY\n\n    return {\n        minX: offsetX,\n        minY: offsetY,\n        maxX: offsetX + renderW,\n        maxY: offsetY + renderH,\n        width: renderW,\n        height: renderH\n    }\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "region",
        "line": 28,
        "source": "get region () {\n    return this.#region\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "image",
        "line": 38,
        "source": "get image () {\n    return this.#region?.image ?? null\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "currentFrame",
        "line": 52,
        "source": "get currentFrame () {\n    return this.#region\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "region",
        "line": 33,
        "source": "set region (value) {\n    this.#region = value\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "image",
        "line": 43,
        "source": "set image (value) {\n    if (value) {\n        this.#region = TextureRegion.fromImage(value)\n    } else {\n        this.#region = null\n    }\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      }
    ],
    "constructor": {
      "name": "constructor",
      "line": 9,
      "source": "constructor (options = {}) {\n    super(options)\n\n    this.width = options.width ?? null\n    this.height = options.height ?? null\n\n    this.animations = new Map()\n    this.currentAnimation = null\n\n    if (options.region) {\n        this.#region = options.region\n    } else if (options.frame) {\n        this.setFrame(options.frame)\n    } else if (options.image) {\n        this.#region = TextureRegion.fromImage(options.image)\n    }\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/render/transform.doc.js": {
    "type": "class",
    "file": "/render/transform.js",
    "name": "Transform",
    "line": 1,
    "extends": null,
    "statics": [],
    "methods": [
      {
        "name": "add",
        "line": 124,
        "source": "add (...children) {\n    children.forEach(child => {\n        if (child.parent) {\n            child.parent.remove(child)\n        }\n        this.children.push(child)\n        child.parent = this\n        child.markDirty()\n    })\n    this.markChildrenNeedSort()\n    return this\n}",
        "kind": "method",
        "params": [
          "...children"
        ]
      },
      {
        "name": "remove",
        "line": 138,
        "source": "remove (child) {\n    const index = this.children.indexOf(child)\n    if (index !== -1) {\n        this.children.splice(index, 1)\n        child.parent = null\n        child.markDirty()\n    }\n    this.markChildrenNeedSort()\n    return this\n}",
        "kind": "method",
        "params": [
          "child"
        ]
      },
      {
        "name": "markChildrenNeedSort",
        "line": 150,
        "source": "markChildrenNeedSort () {\n    this.#childrenNeedSort = true\n    this.#sortedChildren = null\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "getSortedChildren",
        "line": 156,
        "source": "getSortedChildren () {\n    if (this.#childrenNeedSort || !this.#sortedChildren) {\n        this.#sortedChildren = this.children.slice().sort((a, b) => (a.depth ?? 0) - (b.depth ?? 0))\n        this.#childrenNeedSort = false\n    }\n    return this.#sortedChildren\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "markDirty",
        "line": 165,
        "source": "markDirty () {\n    this.#dirty = true\n    this.children.forEach(child => child.markDirty())\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "updateLocalMatrix",
        "line": 171,
        "source": "updateLocalMatrix () {\n    const cos = Math.cos(this.rotation)\n    const sin = Math.sin(this.rotation)\n\n    const px = -this.pivotX\n    const py = -this.pivotY\n\n    const a = cos * this.scaleX\n    const b = sin * this.scaleX\n    const c = -sin * this.scaleY\n    const d = cos * this.scaleY\n\n    this.#localMatrix[0] = a\n    this.#localMatrix[1] = b\n    this.#localMatrix[2] = c\n    this.#localMatrix[3] = d\n    this.#localMatrix[4] = this.x + (px * a + py * c)\n    this.#localMatrix[5] = this.y + (px * b + py * d)\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "updateWorldMatrix",
        "line": 192,
        "source": "updateWorldMatrix (force = false) {\n    if (this.#dirty || force) {\n        this.updateLocalMatrix()\n\n        if (this.parent) {\n            multiplyMatrices(this.parent.#worldMatrix, this.#localMatrix, this.#worldMatrix)\n        } else {\n            this.#worldMatrix = [...this.#localMatrix]\n        }\n\n        this.#dirty = false\n    }\n\n    this.children.forEach(child => child.updateWorldMatrix(force))\n}",
        "kind": "method",
        "params": [
          "force = ..."
        ]
      },
      {
        "name": "transformPoint",
        "line": 209,
        "source": "transformPoint (point, matrix = this.#worldMatrix) {\n    return {\n        x: matrix[0] * point.x + matrix[2] * point.y + matrix[4],\n        y: matrix[1] * point.x + matrix[3] * point.y + matrix[5]\n    }\n}",
        "kind": "method",
        "params": [
          "point",
          "matrix = ..."
        ]
      }
    ],
    "getters": [
      {
        "name": "x",
        "line": 28,
        "source": "get x () {\n    return this.#x\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "y",
        "line": 41,
        "source": "get y () {\n    return this.#y\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "rotation",
        "line": 54,
        "source": "get rotation () {\n    return this.#rotation\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "scaleX",
        "line": 67,
        "source": "get scaleX () {\n    return this.#scaleX\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "scaleY",
        "line": 80,
        "source": "get scaleY () {\n    return this.#scaleY\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "pivotX",
        "line": 93,
        "source": "get pivotX () {\n    return this.#pivotX\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "pivotY",
        "line": 106,
        "source": "get pivotY () {\n    return this.#pivotY\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "worldMatrix",
        "line": 119,
        "source": "get worldMatrix () {\n    return this.#worldMatrix\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "x",
        "line": 33,
        "source": "set x (value) {\n    if (this.#x !== value) {\n        this.#x = value\n        this.markDirty()\n    }\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "y",
        "line": 46,
        "source": "set y (value) {\n    if (this.#y !== value) {\n        this.#y = value\n        this.markDirty()\n    }\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "rotation",
        "line": 59,
        "source": "set rotation (value) {\n    if (this.#rotation !== value) {\n        this.#rotation = value\n        this.markDirty()\n    }\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "scaleX",
        "line": 72,
        "source": "set scaleX (value) {\n    if (this.#scaleX !== value) {\n        this.#scaleX = value\n        this.markDirty()\n    }\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "scaleY",
        "line": 85,
        "source": "set scaleY (value) {\n    if (this.#scaleY !== value) {\n        this.#scaleY = value\n        this.markDirty()\n    }\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "pivotX",
        "line": 98,
        "source": "set pivotX (value) {\n    if (this.#pivotX !== value) {\n        this.#pivotX = value\n        this.markDirty()\n    }\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "pivotY",
        "line": 111,
        "source": "set pivotY (value) {\n    if (this.#pivotY !== value) {\n        this.#pivotY = value\n        this.markDirty()\n    }\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      }
    ],
    "constructor": {
      "name": "constructor",
      "line": 16,
      "source": "constructor () {\n    this.parent = null\n    this.children = []\n    this.#sortedChildren = null\n    this.#childrenNeedSort = false\n\n    this.#localMatrix = [1, 0, 0, 1, 0, 0]\n    this.#worldMatrix = [1, 0, 0, 1, 0, 0]\n    this.#dirty = true\n}",
      "kind": "constructor",
      "params": []
    },
    "isDefault": true
  },
  "/render/textures/texture_atlas.doc.js": {
    "type": "class",
    "file": "/render/textures/texture_atlas.js",
    "name": "TextureAtlas",
    "line": 10,
    "extends": null,
    "statics": [
      {
        "name": "DEFAULT_SIZE",
        "line": 118,
        "source": "static get DEFAULT_SIZE () {\n    return DEFAULT_SIZE\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "MAX_SIZE",
        "line": 123,
        "source": "static get MAX_SIZE () {\n    return MAX_SIZE\n}",
        "kind": "method",
        "params": []
      }
    ],
    "methods": [
      {
        "name": "markClean",
        "line": 49,
        "source": "markClean () {\n    this.#dirty = false\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "add",
        "line": 54,
        "source": "add (id, image) {\n    if (this.#regions.has(id)) {\n        return this.#regions.get(id)\n    }\n\n    const slot = this.#packer.pack(image.width, image.height)\n\n    if (!slot) {\n        return null\n    }\n\n    this.#ctx.drawImage(image, slot.x, slot.y)\n\n    const region = new TextureRegion({\n        image: this.#canvas,\n        x: slot.x,\n        y: slot.y,\n        width: image.width,\n        height: image.height\n    })\n\n    this.#regions.set(id, region)\n    this.#dirty = true\n\n    return region\n}",
        "kind": "method",
        "params": [
          "id",
          "image"
        ]
      },
      {
        "name": "get",
        "line": 82,
        "source": "get (id) {\n    return this.#regions.get(id) || null\n}",
        "kind": "method",
        "params": [
          "id"
        ]
      },
      {
        "name": "has",
        "line": 87,
        "source": "has (id) {\n    return this.#regions.has(id)\n}",
        "kind": "method",
        "params": [
          "id"
        ]
      },
      {
        "name": "getAllRegions",
        "line": 92,
        "source": "getAllRegions () {\n    return this.#regions\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "canFit",
        "line": 97,
        "source": "canFit (width, height) {\n    return this.#packer.canFit(width, height)\n}",
        "kind": "method",
        "params": [
          "width",
          "height"
        ]
      },
      {
        "name": "clear",
        "line": 102,
        "source": "clear () {\n    this.#ctx.clearRect(0, 0, this.width, this.height)\n    this.#packer = new ShelfPacker(this.width, this.height, this.padding)\n    this.#regions.clear()\n    this.#dirty = true\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "dispose",
        "line": 110,
        "source": "dispose () {\n    this.#canvas = null\n    this.#ctx = null\n    this.#packer = null\n    this.#regions.clear()\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "canvas",
        "line": 29,
        "source": "get canvas () {\n    return this.#canvas\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "dirty",
        "line": 34,
        "source": "get dirty () {\n    return this.#dirty\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "full",
        "line": 39,
        "source": "get full () {\n    return this.#packer.full\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "regionCount",
        "line": 44,
        "source": "get regionCount () {\n    return this.#regions.size\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 18,
      "source": "constructor (options = {}) {\n    this.width = options.width ?? DEFAULT_SIZE\n    this.height = options.height ?? DEFAULT_SIZE\n    this.padding = options.padding ?? PADDING\n\n    this.#canvas = createCanvas(this.width, this.height)\n    this.#ctx = this.#canvas.getContext('2d')\n    this.#packer = new ShelfPacker(this.width, this.height, this.padding)\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/render/textures/texture_region.doc.js": {
    "type": "class",
    "file": "/render/textures/texture_region.js",
    "name": "TextureRegion",
    "line": 1,
    "extends": null,
    "statics": [
      {
        "name": "fromImage",
        "line": 69,
        "source": "static fromImage (image) {\n    return new TextureRegion({\n        image,\n        x: 0,\n        y: 0,\n        width: image?.width || 0,\n        height: image?.height || 0\n    })\n}",
        "kind": "method",
        "params": [
          "image"
        ]
      },
      {
        "name": "fromFrame",
        "line": 80,
        "source": "static fromFrame (image, frame) {\n    return new TextureRegion({\n        image,\n        x: frame.x,\n        y: frame.y,\n        width: frame.w ?? frame.width,\n        height: frame.h ?? frame.height\n    })\n}",
        "kind": "method",
        "params": [
          "image",
          "frame"
        ]
      }
    ],
    "methods": [],
    "getters": [
      {
        "name": "u0",
        "line": 12,
        "source": "get u0 () {\n    if (!this.image || !this.image.width) {\n        return 0\n    }\n    return this.x / this.image.width\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "v0",
        "line": 20,
        "source": "get v0 () {\n    if (!this.image || !this.image.height) {\n        return 0\n    }\n    return this.y / this.image.height\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "u1",
        "line": 28,
        "source": "get u1 () {\n    if (!this.image || !this.image.width) {\n        return 1\n    }\n    return (this.x + this.width) / this.image.width\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "v1",
        "line": 36,
        "source": "get v1 () {\n    if (!this.image || !this.image.height) {\n        return 1\n    }\n    return (this.y + this.height) / this.image.height\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "uvs",
        "line": 44,
        "source": "get uvs () {\n    return {\n        u0: this.u0,\n        v0: this.v0,\n        u1: this.u1,\n        v1: this.v1\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "bounds",
        "line": 54,
        "source": "get bounds () {\n    return {\n        x: this.x,\n        y: this.y,\n        width: this.width,\n        height: this.height\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "valid",
        "line": 64,
        "source": "get valid () {\n    return this.image !== null && this.width > 0 && this.height > 0\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 3,
      "source": "constructor (options = {}) {\n    this.image = options.image || null\n    this.x = options.x ?? 0\n    this.y = options.y ?? 0\n    this.width = options.width ?? getImageWidth(this.image)\n    this.height = options.height ?? getImageHeight(this.image)\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/render/textures/texture_system.doc.js": {
    "type": "class",
    "file": "/render/textures/texture_system.js",
    "name": "TextureSystem",
    "line": 6,
    "extends": "PerkyModule",
    "statics": [
      {
        "name": "$category",
        "line": 8,
        "source": "static $category = 'textureSystem'",
        "kind": "property",
        "value": "'textureSystem'"
      }
    ],
    "methods": [
      {
        "name": "onInstall",
        "line": 22,
        "source": "onInstall (host) {\n    this.delegateTo(host, [\n        'getRegion',\n        'hasRegion',\n        'addRegion',\n        'addRegions',\n        'registerManualAtlas'\n    ])\n}",
        "kind": "method",
        "params": [
          "host"
        ]
      },
      {
        "name": "getRegion",
        "line": 48,
        "source": "getRegion (id) {\n    const region = this.#manualRegions.get(id) || this.#atlasManager.get(id)\n    if (region) {\n        return region\n    }\n\n    const source = this.fallback?.(id)\n    if (source) {\n        return TextureRegion.fromImage(source)\n    }\n\n    return null\n}",
        "kind": "method",
        "params": [
          "id"
        ]
      },
      {
        "name": "hasRegion",
        "line": 63,
        "source": "hasRegion (id) {\n    return this.#manualRegions.has(id) || this.#atlasManager.has(id)\n}",
        "kind": "method",
        "params": [
          "id"
        ]
      },
      {
        "name": "addRegion",
        "line": 68,
        "source": "addRegion (id, image) {\n    if (this.hasRegion(id)) {\n        return this.getRegion(id)\n    }\n\n    return this.#atlasManager.add(id, image)\n}",
        "kind": "method",
        "params": [
          "id",
          "image"
        ]
      },
      {
        "name": "addRegions",
        "line": 77,
        "source": "addRegions (images) {\n    return this.#atlasManager.addBatch(images)\n}",
        "kind": "method",
        "params": [
          "images"
        ]
      },
      {
        "name": "registerManualAtlas",
        "line": 82,
        "source": "registerManualAtlas (id, image, frames) {\n    for (const [frameName, frameData] of Object.entries(frames)) {\n        const regionId = `${id}:${frameName}`\n        const region = TextureRegion.fromFrame(image, frameData)\n        this.#manualRegions.set(regionId, region)\n    }\n}",
        "kind": "method",
        "params": [
          "id",
          "image",
          "frames"
        ]
      },
      {
        "name": "buildFromAssets",
        "line": 91,
        "source": "buildFromAssets (assets) {\n    const images = {}\n\n    for (const asset of assets) {\n        if (isImageAsset(asset) && asset.source) {\n            images[asset.id] = asset.source\n        }\n    }\n\n    return this.addRegions(images)\n}",
        "kind": "method",
        "params": [
          "assets"
        ]
      },
      {
        "name": "getDirtyAtlases",
        "line": 104,
        "source": "getDirtyAtlases () {\n    return this.#atlasManager.getDirtyAtlases()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "markAllClean",
        "line": 109,
        "source": "markAllClean () {\n    this.#atlasManager.markAllClean()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "clear",
        "line": 114,
        "source": "clear () {\n    this.#atlasManager.clear()\n    this.#manualRegions.clear()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "onDispose",
        "line": 120,
        "source": "onDispose () {\n    this.clear()\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "atlasManager",
        "line": 33,
        "source": "get atlasManager () {\n    return this.#atlasManager\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "atlases",
        "line": 38,
        "source": "get atlases () {\n    return this.#atlasManager.atlases\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "regionCount",
        "line": 43,
        "source": "get regionCount () {\n    return this.#atlasManager.regionCount + this.#manualRegions.size\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 13,
      "source": "constructor (options = {}) {\n    super(options)\n    this.#atlasManager = new TextureAtlasManager({\n        atlasSize: options.atlasSize\n    })\n    this.fallback = options.fallback ?? null\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/input/input_system.doc.js": {
    "type": "class",
    "file": "/input/input_system.js",
    "name": "InputSystem",
    "line": 9,
    "extends": "PerkyModule",
    "statics": [
      {
        "name": "$category",
        "line": 11,
        "source": "static $category = 'inputSystem'",
        "kind": "property",
        "value": "'inputSystem'"
      }
    ],
    "methods": [
      {
        "name": "onInstall",
        "line": 26,
        "source": "onInstall (host) {\n    this.registerDevice(KeyboardDevice, {\n        $id: 'keyboard',\n        $bind: 'keyboard'\n    })\n\n    this.registerDevice(MouseDevice, {\n        $id: 'mouse',\n        $bind: 'mouse',\n        container: host.element\n    })\n\n    this.registerDevice(TouchDevice, {\n        $id: 'touch',\n        $bind: 'touch',\n        container: host.element\n    })\n\n    this.delegateTo(host, [\n        'registerDevice',\n        'unregisterDevice',\n        'getDevice',\n        'isPressed',\n        'isPressedAny',\n        'getAllPressed',\n        'getValueFor',\n        'getValueAny',\n        'addControl',\n        'getControl',\n        'getControlAny',\n        'getPressedControls'\n    ])\n\n    this.delegateTo(host, [\n        'inputBinder',\n        'bindInput',\n        'unbind',\n        'getBinding',\n        'hasBinding',\n        'getBindingsForInput',\n        'getBindingsForAction',\n        'getAllBindings',\n        'clearBindings',\n        'bindCombo'\n    ])\n\n    this.delegateTo(host, [\n        'isKeyPressed',\n        'isMousePressed',\n        'isTouchPressed',\n        'getKeyValue',\n        'getMouseValue',\n        'getTouchValue',\n        'isActionPressed',\n        'getActionControls',\n        'getInputValue',\n        'getInputValueAny',\n        'getDirection'\n    ])\n\n    this.delegateEventsTo(host, ['input:triggered'])\n}",
        "kind": "method",
        "params": [
          "host"
        ]
      },
      {
        "name": "registerDevice",
        "line": 90,
        "source": "registerDevice (DeviceClass, options = {}) {\n    return this.create(DeviceClass, options)\n}",
        "kind": "method",
        "params": [
          "DeviceClass",
          "options = ..."
        ]
      },
      {
        "name": "getDevice",
        "line": 95,
        "source": "getDevice (name) {\n    return this.getChild(name)\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "isPressed",
        "line": 100,
        "source": "isPressed (deviceName, controlName) {\n    const device = this.getDevice(deviceName)\n    return device ? device.isPressed(controlName) : false\n}",
        "kind": "method",
        "params": [
          "deviceName",
          "controlName"
        ]
      },
      {
        "name": "getValueFor",
        "line": 106,
        "source": "getValueFor (deviceName, controlName) {\n    const device = this.getDevice(deviceName)\n    return device ? device.getValueFor(controlName) : undefined\n}",
        "kind": "method",
        "params": [
          "deviceName",
          "controlName"
        ]
      },
      {
        "name": "getControl",
        "line": 112,
        "source": "getControl (deviceName, controlName) {\n    const device = this.getDevice(deviceName)\n    return device ? (device.getControl(controlName) ?? null) : null\n}",
        "kind": "method",
        "params": [
          "deviceName",
          "controlName"
        ]
      },
      {
        "name": "listDeviceNames",
        "line": 118,
        "source": "listDeviceNames () {\n    return this.listNamesFor('inputDevice')\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "isPressedAny",
        "line": 123,
        "source": "isPressedAny (controlName) {\n    const deviceNames = this.listDeviceNames()\n    for (const name of deviceNames) {\n        const device = this.getChild(name)\n        if (device && device.isPressed(controlName)) {\n            return true\n        }\n    }\n    return false\n}",
        "kind": "method",
        "params": [
          "controlName"
        ]
      },
      {
        "name": "getValueAny",
        "line": 135,
        "source": "getValueAny (controlName) {\n    const deviceNames = this.listDeviceNames()\n    for (const name of deviceNames) {\n        const device = this.getChild(name)\n        if (device) {\n            const value = device.getValueFor(controlName)\n            if (value !== undefined) {\n                return value\n            }\n        }\n    }\n    return undefined\n}",
        "kind": "method",
        "params": [
          "controlName"
        ]
      },
      {
        "name": "getControlAny",
        "line": 150,
        "source": "getControlAny (controlName) {\n    const deviceNames = this.listDeviceNames()\n    for (const name of deviceNames) {\n        const device = this.getChild(name)\n        if (device) {\n            const control = device.getControl(controlName)\n            if (control) {\n                return control\n            }\n        }\n    }\n    return null\n}",
        "kind": "method",
        "params": [
          "controlName"
        ]
      },
      {
        "name": "getAllPressed",
        "line": 165,
        "source": "getAllPressed (controlName) {\n    const results = []\n    const deviceNames = this.listDeviceNames()\n    for (const name of deviceNames) {\n        const device = this.getChild(name)\n        if (device && device.isPressed(controlName)) {\n            results.push(device)\n        }\n    }\n    return results\n}",
        "kind": "method",
        "params": [
          "controlName"
        ]
      },
      {
        "name": "getPressedControls",
        "line": 178,
        "source": "getPressedControls (deviceName) {\n    const device = this.getDevice(deviceName)\n    return device ? device.getPressedControls() : []\n}",
        "kind": "method",
        "params": [
          "deviceName"
        ]
      },
      {
        "name": "getAllValues",
        "line": 184,
        "source": "getAllValues (controlName) {\n    const results = []\n    const deviceNames = this.listDeviceNames()\n    for (const name of deviceNames) {\n        const device = this.getChild(name)\n        if (device) {\n            const value = device.getValueFor(controlName)\n            if (value !== undefined) {\n                results.push({device, value})\n            }\n        }\n    }\n    return results\n}",
        "kind": "method",
        "params": [
          "controlName"
        ]
      },
      {
        "name": "addControl",
        "line": 200,
        "source": "addControl (deviceNameOrControl, ControlOrParams = {}, params = {}) {\n\n    if (typeof deviceNameOrControl === 'string') {\n        const device = this.getDevice(deviceNameOrControl)\n\n        if (!device) {\n            throw new Error(`Device '${deviceNameOrControl}' not found`)\n        }\n\n        return device.findOrCreateControl(ControlOrParams, params)\n\n    } else if (typeof deviceNameOrControl === 'function') {\n\n        return this.addControlToFirst(deviceNameOrControl, ControlOrParams)\n    }\n\n    return null\n}",
        "kind": "method",
        "params": [
          "deviceNameOrControl",
          "ControlOrParams = ...",
          "params = ..."
        ]
      },
      {
        "name": "addControlToFirst",
        "line": 220,
        "source": "addControlToFirst (Control, params = {}) {\n    const deviceNames = this.listDeviceNames()\n    const firstDevice = deviceNames.length > 0 ? this.getChild(deviceNames[0]) : null\n    if (!firstDevice) {\n        throw new Error('No devices available')\n    }\n    return firstDevice.findOrCreateControl(Control, params)\n}",
        "kind": "method",
        "params": [
          "Control",
          "params = ..."
        ]
      },
      {
        "name": "addControlToAll",
        "line": 230,
        "source": "addControlToAll (Control, params = {}) {\n    const results = []\n    const deviceNames = this.listDeviceNames()\n    for (const name of deviceNames) {\n        const device = this.getChild(name)\n        if (device) {\n            const control = device.findOrCreateControl(Control, params)\n            results.push({device, control})\n        }\n    }\n    return results\n}",
        "kind": "method",
        "params": [
          "Control",
          "params = ..."
        ]
      },
      {
        "name": "deviceKeyFor",
        "line": 244,
        "source": "deviceKeyFor (device) {\n    return this.childrenRegistry.keyFor(device)\n}",
        "kind": "method",
        "params": [
          "device"
        ]
      },
      {
        "name": "getInputValue",
        "line": 249,
        "source": "getInputValue (deviceName, controlName) {\n    return this.getValueFor(deviceName, controlName)\n}",
        "kind": "method",
        "params": [
          "deviceName",
          "controlName"
        ]
      },
      {
        "name": "getInputValueAny",
        "line": 254,
        "source": "getInputValueAny (controlName) {\n    return this.getValueAny(controlName)\n}",
        "kind": "method",
        "params": [
          "controlName"
        ]
      },
      {
        "name": "isKeyPressed",
        "line": 259,
        "source": "isKeyPressed (keyName) {\n    return this.isPressed('keyboard', keyName)\n}",
        "kind": "method",
        "params": [
          "keyName"
        ]
      },
      {
        "name": "isMousePressed",
        "line": 264,
        "source": "isMousePressed (buttonName) {\n    return this.isPressed('mouse', buttonName)\n}",
        "kind": "method",
        "params": [
          "buttonName"
        ]
      },
      {
        "name": "getKeyValue",
        "line": 269,
        "source": "getKeyValue (keyName) {\n    return this.getInputValue('keyboard', keyName)\n}",
        "kind": "method",
        "params": [
          "keyName"
        ]
      },
      {
        "name": "getMouseValue",
        "line": 274,
        "source": "getMouseValue (buttonName) {\n    return this.getInputValue('mouse', buttonName)\n}",
        "kind": "method",
        "params": [
          "buttonName"
        ]
      },
      {
        "name": "isTouchPressed",
        "line": 279,
        "source": "isTouchPressed (controlName) {\n    return this.isPressed('touch', controlName)\n}",
        "kind": "method",
        "params": [
          "controlName"
        ]
      },
      {
        "name": "getTouchValue",
        "line": 284,
        "source": "getTouchValue (controlName) {\n    return this.getInputValue('touch', controlName)\n}",
        "kind": "method",
        "params": [
          "controlName"
        ]
      },
      {
        "name": "isActionPressed",
        "line": 289,
        "source": "isActionPressed (actionName, controllerName = null) {\n    const bindings = this.inputBinder.getBindingsForAction(actionName, controllerName, 'pressed')\n\n    for (const binding of bindings) {\n        if (typeof binding.shouldTrigger === 'function') {\n            if (binding.shouldTrigger(this)) {\n                return true\n            }\n        } else if (this.isPressed(binding.deviceName, binding.controlName)) {\n            return true\n        }\n    }\n\n    return false\n}",
        "kind": "method",
        "params": [
          "actionName",
          "controllerName = ..."
        ]
      },
      {
        "name": "getActionControls",
        "line": 306,
        "source": "getActionControls (actionName, controllerName = null) {\n    const bindings = this.inputBinder.getBindingsForAction(actionName, controllerName, 'pressed')\n    const controls = []\n\n    for (const binding of bindings) {\n        controls.push(...this.#getControlsFromBinding(binding))\n    }\n\n    return controls\n}",
        "kind": "method",
        "params": [
          "actionName",
          "controllerName = ..."
        ]
      },
      {
        "name": "getDirection",
        "line": 318,
        "source": "getDirection (name = 'move') {\n    const up = name + 'Up'\n    const down = name + 'Down'\n    const left = name + 'Left'\n    const right = name + 'Right'\n\n    const x = (this.isActionPressed(right) ? 1 : 0)\n        - (this.isActionPressed(left) ? 1 : 0)\n    const y = (this.isActionPressed(up) ? 1 : 0)\n        - (this.isActionPressed(down) ? 1 : 0)\n\n    const vec = new Vec2(x, y)\n\n    return vec.length() > 0 ? vec.clone().normalize() : vec\n}",
        "kind": "method",
        "params": [
          "name = ..."
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 13,
      "source": "constructor (options = {}) {\n    const {bindings = []} = options\n    super(options)\n\n    this.create(InputBinder, {\n        $bind: 'inputBinder',\n        bindings\n    })\n\n    this.#initEvents()\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/input/input_control.doc.js": {
    "type": "class",
    "file": "/input/input_control.js",
    "name": "InputControl",
    "line": 8,
    "extends": "Notifier",
    "statics": [
      {
        "name": "VALUE",
        "line": 10,
        "source": "static VALUE = VALUE",
        "kind": "property",
        "value": "VALUE"
      },
      {
        "name": "OLD_VALUE",
        "line": 11,
        "source": "static OLD_VALUE = OLD_VALUE",
        "kind": "property",
        "value": "OLD_VALUE"
      }
    ],
    "methods": [
      {
        "name": "setValue",
        "line": 27,
        "source": "setValue (value, event = null) {\n    if (value === this[VALUE]) {\n        return false\n    }\n\n    this[OLD_VALUE] = this[VALUE]\n    this[VALUE] = value\n\n    this.emit('updated', this[VALUE], this[OLD_VALUE], event)\n\n    return true\n}",
        "kind": "method",
        "params": [
          "value",
          "event = ..."
        ]
      },
      {
        "name": "getDefaultValue",
        "line": 51,
        "source": "getDefaultValue () { // eslint-disable-line local/class-methods-use-this -- clean\n    return 0\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "reset",
        "line": 56,
        "source": "reset () {\n    this.value = this.getDefaultValue()\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "value",
        "line": 41,
        "source": "get value () {\n    return this[VALUE]\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "oldValue",
        "line": 46,
        "source": "get oldValue () {\n    return this[OLD_VALUE]\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "value",
        "line": 22,
        "source": "set value (value) {\n    this.setValue(value)\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      }
    ],
    "constructor": {
      "name": "constructor",
      "line": 13,
      "source": "constructor ({device, name, value}) {\n    super()\n    this.device     = device\n    this.name       = name\n    this[OLD_VALUE] = null\n    this[VALUE]     = value ?? this.getDefaultValue()\n}",
      "kind": "constructor",
      "params": [
        "{...}"
      ]
    },
    "isDefault": true
  },
  "/input/input_controls/button_control.doc.js": {
    "type": "class",
    "file": "/input/input_controls/button_control.js",
    "name": "ButtonControl",
    "line": 4,
    "extends": "InputControl",
    "statics": [
      {
        "name": "defaultPressThreshold",
        "line": 6,
        "source": "static defaultPressThreshold = 0.1",
        "kind": "property",
        "value": "0.1"
      }
    ],
    "methods": [
      {
        "name": "setValue",
        "line": 15,
        "source": "setValue (value, event = null) {\n    this.lastEvent = event\n\n    if (super.setValue(value, event)) {\n\n        if (this.isPressed && !this.wasPressed) {\n            this.emit('pressed', this.lastEvent)\n        }\n\n        if (!this.isPressed && this.wasPressed) {\n            this.emit('released', this.lastEvent)\n        }\n\n        return true\n    }\n\n    return false\n}",
        "kind": "method",
        "params": [
          "value",
          "event = ..."
        ]
      },
      {
        "name": "press",
        "line": 45,
        "source": "press (event = null) {\n    this.setValue(1, event)\n}",
        "kind": "method",
        "params": [
          "event = ..."
        ]
      },
      {
        "name": "release",
        "line": 50,
        "source": "release (event = null) {\n    this.setValue(0, event)\n}",
        "kind": "method",
        "params": [
          "event = ..."
        ]
      }
    ],
    "getters": [
      {
        "name": "isPressed",
        "line": 35,
        "source": "get isPressed () {\n    return this.value >= this.pressThreshold\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "wasPressed",
        "line": 40,
        "source": "get wasPressed () {\n    return this.oldValue >= this.pressThreshold\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 8,
      "source": "constructor (params = {}) {\n    super(params)\n\n    this.pressThreshold = params.pressThreshold ?? this.constructor.defaultPressThreshold\n}",
      "kind": "constructor",
      "params": [
        "params = ..."
      ]
    },
    "isDefault": true
  },
  "/input/input_controls/vec2_control.doc.js": {
    "type": "class",
    "file": "/input/input_controls/vec2_control.js",
    "name": "Vec2Control",
    "line": 7,
    "extends": "InputControl",
    "statics": [],
    "methods": [
      {
        "name": "getDefaultValue",
        "line": 9,
        "source": "getDefaultValue () { // eslint-disable-line local/class-methods-use-this -- clean\n    return new Vec2()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "setValue",
        "line": 14,
        "source": "setValue (value, event = null) {\n    if (!(value instanceof Vec2)) {\n        value = new Vec2(value)\n    }\n\n    if (this[VALUE] && this[VALUE].equals(value)) {\n        return false\n    }\n\n    this[OLD_VALUE] = this[VALUE]\n    this[VALUE] = new Vec2(value)\n\n    this.emit('updated', this[VALUE], this[OLD_VALUE], event)\n\n    return true\n}",
        "kind": "method",
        "params": [
          "value",
          "event = ..."
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": null,
    "isDefault": true
  },
  "/input/input_devices/keyboard_device.doc.js": {
    "type": "class",
    "file": "/input/input_devices/keyboard_device.js",
    "name": "KeyboardDevice",
    "line": 5,
    "extends": "InputDevice",
    "statics": [
      {
        "name": "$name",
        "line": 7,
        "source": "static $name = 'keyboard'",
        "kind": "property",
        "value": "'keyboard'"
      }
    ],
    "methods": [
      {
        "name": "onStart",
        "line": 24,
        "source": "onStart () {\n    this.container.addEventListener('keydown', this.#keydownListener, true)\n    this.container.addEventListener('keyup', this.#keyupListener, true)\n    this.container.addEventListener('blur', this.#blurListener)\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "onStop",
        "line": 31,
        "source": "onStop () {\n    this.container.removeEventListener('keydown', this.#keydownListener, true)\n    this.container.removeEventListener('keyup', this.#keyupListener, true)\n    this.container.removeEventListener('blur', this.#blurListener)\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 13,
      "source": "constructor (params = {}) {\n    super(params)\n\n    this.shouldPreventDefault = params.shouldPreventDefault\n\n    this.#keydownListener = this.#handleKeydown.bind(this)\n    this.#keyupListener = this.#handleKeyup.bind(this)\n    this.#blurListener = this.#handleBlur.bind(this)\n}",
      "kind": "constructor",
      "params": [
        "params = ..."
      ]
    },
    "isDefault": true
  },
  "/input/input_devices/mouse_device.doc.js": {
    "type": "class",
    "file": "/input/input_devices/mouse_device.js",
    "name": "MouseDevice",
    "line": 7,
    "extends": "InputDevice",
    "statics": [
      {
        "name": "$name",
        "line": 9,
        "source": "static $name = 'mouse'",
        "kind": "property",
        "value": "'mouse'"
      }
    ],
    "methods": [
      {
        "name": "onStart",
        "line": 32,
        "source": "onStart () {\n    this.container.addEventListener('mousedown', this.#mousedownListener)\n    this.container.addEventListener('mouseup', this.#mouseupListener)\n    this.container.addEventListener('mousemove', this.#mousemoveListener)\n    this.container.addEventListener('contextmenu', this.#contextmenuListener)\n    this.container.addEventListener('wheel', this.#wheelListener, {passive: false})\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "onStop",
        "line": 41,
        "source": "onStop () {\n    this.container.removeEventListener('mousedown', this.#mousedownListener)\n    this.container.removeEventListener('mouseup', this.#mouseupListener)\n    this.container.removeEventListener('mousemove', this.#mousemoveListener)\n    this.container.removeEventListener('contextmenu', this.#contextmenuListener)\n    this.container.removeEventListener('wheel', this.#wheelListener, {passive: false})\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 17,
      "source": "constructor (params = {}) {\n    super(params)\n\n    this.shouldPreventDefault = params.shouldPreventDefault\n\n    this.#createControls()\n\n    this.#mousedownListener = this.#handleMousedown.bind(this)\n    this.#mouseupListener = this.#handleMouseup.bind(this)\n    this.#mousemoveListener = this.#handleMousemove.bind(this)\n    this.#contextmenuListener = this.#handleContextmenu.bind(this)\n    this.#wheelListener = this.#handleWheel.bind(this)\n}",
      "kind": "constructor",
      "params": [
        "params = ..."
      ]
    },
    "isDefault": true
  },
  "/input/input_devices/touch_device.doc.js": {
    "type": "class",
    "file": "/input/input_devices/touch_device.js",
    "name": "TouchDevice",
    "line": 6,
    "extends": "InputDevice",
    "statics": [
      {
        "name": "$name",
        "line": 8,
        "source": "static $name = 'touch'",
        "kind": "property",
        "value": "'touch'"
      }
    ],
    "methods": [
      {
        "name": "onStart",
        "line": 39,
        "source": "onStart () {\n    this.container.addEventListener('touchstart', this.#touchstartListener, {passive: false})\n    this.container.addEventListener('touchmove', this.#touchmoveListener, {passive: false})\n    this.container.addEventListener('touchend', this.#touchendListener)\n    this.container.addEventListener('touchcancel', this.#touchcancelListener)\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "onStop",
        "line": 47,
        "source": "onStop () {\n    this.container.removeEventListener('touchstart', this.#touchstartListener)\n    this.container.removeEventListener('touchmove', this.#touchmoveListener)\n    this.container.removeEventListener('touchend', this.#touchendListener)\n    this.container.removeEventListener('touchcancel', this.#touchcancelListener)\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 22,
      "source": "constructor (params = {}) {\n    super(params)\n\n    this.swipeThreshold = params.swipeThreshold ?? 30\n    this.tapThreshold = params.tapThreshold ?? 20\n    this.tapMaxDuration = params.tapMaxDuration ?? 300\n    this.shouldPreventDefault = params.shouldPreventDefault\n\n    this.#createControls()\n\n    this.#touchstartListener = this.#handleTouchstart.bind(this)\n    this.#touchmoveListener = this.#handleTouchmove.bind(this)\n    this.#touchendListener = this.#handleTouchend.bind(this)\n    this.#touchcancelListener = this.#handleTouchcancel.bind(this)\n}",
      "kind": "constructor",
      "params": [
        "params = ..."
      ]
    },
    "isDefault": true
  },
  "/audio/audio_system.doc.js": {
    "type": "class",
    "file": "/audio/audio_system.js",
    "name": "AudioSystem",
    "line": 9,
    "extends": "PerkyModule",
    "statics": [
      {
        "name": "$category",
        "line": 11,
        "source": "static $category = 'audioSystem'",
        "kind": "property",
        "value": "'audioSystem'"
      }
    ],
    "methods": [
      {
        "name": "onInstall",
        "line": 56,
        "source": "onInstall (host) {\n    this.delegateTo(host, [\n        'play',\n        'playAt',\n        'playOscillator',\n        'playOscillatorAt',\n        'stop',\n        'stopChannel',\n        'stopAll',\n        'setVolume',\n        'getVolume',\n        'setChannelVolume',\n        'getChannelVolume',\n        'muteChannel',\n        'unmuteChannel',\n        'getChannel',\n        'hasChannel',\n        'unlock',\n        'setListenerPosition',\n        'getListenerPosition'\n    ])\n\n    this.delegateEventsTo(host, [\n        'audio:play',\n        'audio:stop',\n        'audio:unlocked'\n    ], 'audio')\n\n    if (host.sourceManager) {\n        this.listenTo(host.sourceManager, 'loader:progress', (_progress, {asset, source}) => {\n            if (asset.type === 'audio' && source?.type === 'deferred_audio') {\n                this.#pendingAudio.set(asset.id, source.url)\n            }\n        })\n    }\n\n    this.#applyConfig()\n}",
        "kind": "method",
        "params": [
          "host"
        ]
      },
      {
        "name": "onStart",
        "line": 96,
        "source": "onStart () {\n    onAudioUnlock(() => this.unlock())\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "onStop",
        "line": 101,
        "source": "onStop () {\n    if (this.#unlocked) {\n        this.#audioContext.suspend()\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "onDispose",
        "line": 108,
        "source": "onDispose () {\n    this.stopAll()\n    this.#buffers.clear()\n    this.#audioContext.dispose()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "unlock",
        "line": 115,
        "source": "async unlock () {\n    if (this.#unlocked) {\n        return true\n    }\n\n    try {\n        await this.#audioContext.resume()\n        this.#unlocked = true\n        await this.#loadPendingAudio()\n        this.emit('audio:unlocked')\n        return true\n    } catch {\n        return false\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "createChannel",
        "line": 144,
        "source": "createChannel (name, options = {}) {\n    return this.create(AudioChannel, {\n        $id: name,\n        $bind: name,\n        audioContext: this.#audioContext,\n        ...options\n    })\n}",
        "kind": "method",
        "params": [
          "name",
          "options = ..."
        ]
      },
      {
        "name": "getChannel",
        "line": 154,
        "source": "getChannel (name) {\n    return this.getChild(name)\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "hasChannel",
        "line": 159,
        "source": "hasChannel (name) {\n    return this.hasChild(name)\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "listChannels",
        "line": 164,
        "source": "listChannels () {\n    return this.listNamesFor('audioChannel')\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "registerBuffer",
        "line": 169,
        "source": "registerBuffer (id, buffer) {\n    this.#buffers.set(id, buffer)\n    this.emit('buffer:registered', id, buffer)\n}",
        "kind": "method",
        "params": [
          "id",
          "buffer"
        ]
      },
      {
        "name": "registerArrayBuffer",
        "line": 175,
        "source": "async registerArrayBuffer (id, arrayBuffer) {\n    try {\n        const audioBuffer = await this.#audioContext.decodeAudioData(arrayBuffer)\n        this.registerBuffer(id, audioBuffer)\n        return audioBuffer\n    } catch (e) {\n        this.emit('buffer:error', id, e)\n        return null\n    }\n}",
        "kind": "method",
        "params": [
          "id",
          "arrayBuffer"
        ]
      },
      {
        "name": "getBuffer",
        "line": 187,
        "source": "getBuffer (id) {\n    return this.#buffers.get(id) || null\n}",
        "kind": "method",
        "params": [
          "id"
        ]
      },
      {
        "name": "hasBuffer",
        "line": 192,
        "source": "hasBuffer (id) {\n    return this.#buffers.has(id)\n}",
        "kind": "method",
        "params": [
          "id"
        ]
      },
      {
        "name": "loadBuffer",
        "line": 197,
        "source": "async loadBuffer (id, url) {\n    try {\n        const response = await fetch(url)\n        const arrayBuffer = await response.arrayBuffer()\n        return this.registerArrayBuffer(id, arrayBuffer)\n    } catch (e) {\n        this.emit('buffer:error', id, e)\n        return null\n    }\n}",
        "kind": "method",
        "params": [
          "id",
          "url"
        ]
      },
      {
        "name": "play",
        "line": 209,
        "source": "play (bufferId, options = {}) {\n    if (!this.#unlocked) {\n        return null\n    }\n\n    const buffer = this.#buffers.get(bufferId)\n\n    if (!buffer) {\n        return null\n    }\n\n    const channelName = options.channel ?? 'sfx'\n    const channel = this.getChannel(channelName)\n\n    const sourceId = options.$id ?? uniqueId(this.childrenRegistry, bufferId)\n\n    const source = new AudioSource({\n        $id: sourceId,\n        audioContext: this.#audioContext,\n        channel,\n        loop: options.loop ?? false,\n        volume: options.volume ?? 1,\n        playbackRate: options.playbackRate ?? 1\n    })\n\n    source.playBuffer(buffer, options.offset ?? 0)\n\n    this.emit('audio:play', sourceId, bufferId, options)\n\n    return source\n}",
        "kind": "method",
        "params": [
          "bufferId",
          "options = ..."
        ]
      },
      {
        "name": "playAt",
        "line": 242,
        "source": "playAt (bufferId, x, y, options = {}) {\n    return this.play(bufferId, {\n        ...options,\n        spatial: true,\n        x,\n        y\n    })\n}",
        "kind": "method",
        "params": [
          "bufferId",
          "x",
          "y",
          "options = ..."
        ]
      },
      {
        "name": "playOscillator",
        "line": 252,
        "source": "playOscillator (options = {}) {\n    if (!this.#unlocked) {\n        return null\n    }\n\n    const channel = this.getChannel(options.channel ?? 'sfx')\n    const sourceId = options.$id ?? uniqueId(this.childrenRegistry, 'oscillator')\n\n    const source = new AudioSource({\n        ...options,\n        $id: sourceId,\n        audioContext: this.#audioContext,\n        channel\n    })\n\n    source.playOscillator(options.type, options.frequency, options.duration)\n    this.emit('audio:play', sourceId, 'oscillator', options)\n\n    return source\n}",
        "kind": "method",
        "params": [
          "options = ..."
        ]
      },
      {
        "name": "playOscillatorAt",
        "line": 274,
        "source": "playOscillatorAt (x, y, options = {}) {\n    return this.playOscillator({\n        ...options,\n        spatial: true,\n        x,\n        y\n    })\n}",
        "kind": "method",
        "params": [
          "x",
          "y",
          "options = ..."
        ]
      },
      {
        "name": "stop",
        "line": 284,
        "source": "stop (sourceId) {\n    for (const channelName of this.listChannels()) {\n        const channel = this.getChannel(channelName)\n        const source = channel?.getSource(sourceId)\n        if (source) {\n            source.stop()\n            this.emit('audio:stop', sourceId)\n            return true\n        }\n    }\n    return false\n}",
        "kind": "method",
        "params": [
          "sourceId"
        ]
      },
      {
        "name": "stopChannel",
        "line": 298,
        "source": "stopChannel (channelName) {\n    const channel = this.getChannel(channelName)\n    if (channel) {\n        channel.stopAll()\n        return true\n    }\n    return false\n}",
        "kind": "method",
        "params": [
          "channelName"
        ]
      },
      {
        "name": "stopAll",
        "line": 308,
        "source": "stopAll () {\n    for (const channelName of this.listChannels()) {\n        this.stopChannel(channelName)\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "setVolume",
        "line": 315,
        "source": "setVolume (value) {\n    this.masterVolume = value\n    this.emit('volume:changed', value)\n    return this\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "getVolume",
        "line": 322,
        "source": "getVolume () {\n    return this.masterVolume\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "setChannelVolume",
        "line": 327,
        "source": "setChannelVolume (channelName, value) {\n    const channel = this.getChannel(channelName)\n    if (channel) {\n        channel.setVolume(value)\n    }\n    return this\n}",
        "kind": "method",
        "params": [
          "channelName",
          "value"
        ]
      },
      {
        "name": "getChannelVolume",
        "line": 336,
        "source": "getChannelVolume (channelName) {\n    const channel = this.getChannel(channelName)\n    return channel ? channel.getVolume() : 0\n}",
        "kind": "method",
        "params": [
          "channelName"
        ]
      },
      {
        "name": "muteChannel",
        "line": 342,
        "source": "muteChannel (channelName) {\n    const channel = this.getChannel(channelName)\n    if (channel) {\n        channel.mute()\n    }\n    return this\n}",
        "kind": "method",
        "params": [
          "channelName"
        ]
      },
      {
        "name": "unmuteChannel",
        "line": 351,
        "source": "unmuteChannel (channelName) {\n    const channel = this.getChannel(channelName)\n    if (channel) {\n        channel.unmute()\n    }\n    return this\n}",
        "kind": "method",
        "params": [
          "channelName"
        ]
      },
      {
        "name": "setListenerPosition",
        "line": 360,
        "source": "setListenerPosition (x, y) {\n    this.#audioContext.setListenerPosition(x, y, 0)\n    return this\n}",
        "kind": "method",
        "params": [
          "x",
          "y"
        ]
      },
      {
        "name": "getListenerPosition",
        "line": 366,
        "source": "getListenerPosition () {\n    const pos = this.#audioContext.getListenerPosition()\n    return {x: pos.x, y: pos.y}\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "audioContext",
        "line": 31,
        "source": "get audioContext () {\n    return this.#audioContext\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "unlocked",
        "line": 36,
        "source": "get unlocked () {\n    return this.#unlocked\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "currentTime",
        "line": 41,
        "source": "get currentTime () {\n    return this.#audioContext.currentTime\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "masterVolume",
        "line": 46,
        "source": "get masterVolume () {\n    return this.#audioContext.getMasterVolume()\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "masterVolume",
        "line": 51,
        "source": "set masterVolume (value) {\n    this.#audioContext.setMasterVolume(value)\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      }
    ],
    "constructor": {
      "name": "constructor",
      "line": 18,
      "source": "constructor (options = {}) {\n    super(options)\n\n    this.#audioContext = new AudioContext()\n\n    const defaultChannels = options.channels ?? ['music', 'sfx', 'ambiance']\n\n    for (const channelName of defaultChannels) {\n        this.createChannel(channelName)\n    }\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/editor/perky_explorer.doc.js": {
    "type": "class",
    "file": "/editor/perky_explorer.js",
    "name": "PerkyExplorer",
    "line": 24,
    "extends": "BaseEditorComponent",
    "statics": [
      {
        "name": "observedAttributes",
        "line": 26,
        "source": "static observedAttributes = ['embedded']",
        "kind": "property",
        "value": "['embedded']"
      }
    ],
    "methods": [
      {
        "name": "connectedCallback",
        "line": 53,
        "source": "connectedCallback () {\n    this.#buildDOM()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "disconnectedCallback",
        "line": 58,
        "source": "disconnectedCallback () {\n    if (this.#contextMenuEl && this.#contextMenuEl.parentNode) {\n        this.#contextMenuEl.parentNode.removeChild(this.#contextMenuEl)\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "attributeChangedCallback",
        "line": 65,
        "source": "attributeChangedCallback (name, oldValue, newValue) {\n    if (oldValue === newValue) {\n        return\n    }\n\n    if (name === 'embedded') {\n        this.#embedded = newValue !== null\n        this.#updateEmbeddedMode()\n    }\n}",
        "kind": "method",
        "params": [
          "name",
          "oldValue",
          "newValue"
        ]
      },
      {
        "name": "isSystemModule",
        "line": 119,
        "source": "isSystemModule (module) {\n    return module && this.#systemCategories.includes(module.$category)\n}",
        "kind": "method",
        "params": [
          "module"
        ]
      },
      {
        "name": "setModule",
        "line": 124,
        "source": "setModule (module) {\n    this.#module = module\n    this.#rootModule = module\n    this.#selectedModule = null\n\n    if (this.#rootNode) {\n        this.#rootNode.setModule(module, 0)\n        if (module) {\n            this.#rootNode.setExpanded(true)\n        }\n    }\n\n    this.#updateTreeVisibility()\n    this.#updateDetails()\n    this.#updateHeaderControls()\n    this.#closeSceneTree()\n}",
        "kind": "method",
        "params": [
          "module"
        ]
      },
      {
        "name": "getModule",
        "line": 143,
        "source": "getModule () {\n    return this.#module\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "focusModule",
        "line": 550,
        "source": "focusModule (module) {\n    if (!module) {\n        return\n    }\n\n    this.#rootModule = module\n    this.#rootNode.setModule(module, 0)\n    this.#rootNode.setExpanded(true)\n    this.#updateHeaderControls()\n\n\n    if (this.#selectedModule) {\n        const node = this.#rootNode.findNode(n => n.getModule() === this.#selectedModule)\n        if (node) {\n            node.setSelected(true)\n        } else {\n\n\n            this.#handleNodeSelect(module)\n        }\n    }\n}",
        "kind": "method",
        "params": [
          "module"
        ]
      }
    ],
    "getters": [
      {
        "name": "embedded",
        "line": 77,
        "source": "get embedded () {\n    return this.#embedded\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "systemCategories",
        "line": 93,
        "source": "get systemCategories () {\n    return this.#systemCategories\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "showSystemModules",
        "line": 104,
        "source": "get showSystemModules () {\n    return this.#showSystemModules\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "embedded",
        "line": 82,
        "source": "set embedded (value) {\n    this.#embedded = value\n    if (value) {\n        this.setAttribute('embedded', '')\n    } else {\n        this.removeAttribute('embedded')\n    }\n    this.#updateEmbeddedMode()\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "systemCategories",
        "line": 98,
        "source": "set systemCategories (value) {\n    this.#systemCategories = value\n    this.#refresh()\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "showSystemModules",
        "line": 109,
        "source": "set showSystemModules (value) {\n    this.#showSystemModules = value\n    this.#updateLayersButton()\n    this.#refresh()\n    this.dispatchEvent(new CustomEvent('showSystemModules:change', {\n        detail: {showSystemModules: value}\n    }))\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      }
    ],
    "constructor": null,
    "isDefault": true
  },
  "/editor/perky_logger.doc.js": {
    "type": "class",
    "file": "/editor/perky_logger.js",
    "name": "PerkyLogger",
    "line": 17,
    "extends": "HTMLElement",
    "statics": [
      {
        "name": "observedAttributes",
        "line": 19,
        "source": "static observedAttributes = ['max-entries', 'position', 'timestamp', 'theme']",
        "kind": "property",
        "value": "['max-entries', 'position', 'timestamp', 'theme']"
      }
    ],
    "methods": [
      {
        "name": "connectedCallback",
        "line": 44,
        "source": "connectedCallback () {\n    this.#buildDOM()\n    this.#bindLoggerEvents()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "disconnectedCallback",
        "line": 50,
        "source": "disconnectedCallback () {\n    this.#unbindLoggerEvents()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "attributeChangedCallback",
        "line": 55,
        "source": "attributeChangedCallback (name, oldValue, newValue) {\n    if (oldValue === newValue) {\n        return\n    }\n\n    this.#handleAttributeChange(name, newValue)\n}",
        "kind": "method",
        "params": [
          "name",
          "oldValue",
          "newValue"
        ]
      },
      {
        "name": "log",
        "line": 322,
        "source": "log (message, type = 'info', format = 'text', timestamp = null) {\n    const entry = document.createElement('div')\n    entry.className = `logger-entry log-${type}`\n\n    const indicator = document.createElement('span')\n    indicator.className = 'logger-indicator'\n    entry.appendChild(indicator)\n\n    const messageElement = document.createElement('span')\n    messageElement.className = 'logger-message'\n\n    processMessage(messageElement, message, format)\n\n    entry.appendChild(messageElement)\n\n    const time = timestamp ? new Date(timestamp) : new Date()\n    const timestampEl = document.createElement('span')\n    timestampEl.className = 'logger-timestamp'\n    timestampEl.textContent = time.toLocaleTimeString()\n    entry.appendChild(timestampEl)\n\n    const copyBtn = document.createElement('button')\n    copyBtn.className = 'logger-copy-btn'\n    copyBtn.innerHTML = COPY_ICON\n    copyBtn.title = 'Copy log entry'\n    copyBtn.addEventListener('click', (e) => {\n        e.stopPropagation()\n        const text = extractFormattedText(messageElement)\n        copyToClipboard(`[${timestampEl.textContent}] ${text}`)\n    })\n    entry.appendChild(copyBtn)\n\n    this.#entries.push(entry)\n\n    while (this.#entries.length > this.#maxEntries) {\n        const removed = this.#entries.shift()\n        if (removed.parentNode) {\n            removed.parentNode.removeChild(removed)\n        }\n    }\n\n    if (this.#contentEl) {\n        this.#contentEl.appendChild(entry)\n        this.#contentEl.scrollTop = this.#contentEl.scrollHeight\n    }\n\n    this.#updateControlsVisibility()\n\n    return entry\n}",
        "kind": "method",
        "params": [
          "message",
          "type = ...",
          "format = ...",
          "timestamp = ..."
        ]
      },
      {
        "name": "info",
        "line": 374,
        "source": "info (...messages) {\n    return this.log(formatMessage(...messages), 'info')\n}",
        "kind": "method",
        "params": [
          "...messages"
        ]
      },
      {
        "name": "notice",
        "line": 379,
        "source": "notice (...messages) {\n    return this.log(formatMessage(...messages), 'notice')\n}",
        "kind": "method",
        "params": [
          "...messages"
        ]
      },
      {
        "name": "warn",
        "line": 384,
        "source": "warn (...messages) {\n    return this.log(formatMessage(...messages), 'warn')\n}",
        "kind": "method",
        "params": [
          "...messages"
        ]
      },
      {
        "name": "error",
        "line": 389,
        "source": "error (...messages) {\n    return this.log(formatMessage(...messages), 'error')\n}",
        "kind": "method",
        "params": [
          "...messages"
        ]
      },
      {
        "name": "success",
        "line": 394,
        "source": "success (...messages) {\n    return this.log(formatMessage(...messages), 'success')\n}",
        "kind": "method",
        "params": [
          "...messages"
        ]
      },
      {
        "name": "spacer",
        "line": 399,
        "source": "spacer () {\n    const entry = document.createElement('div')\n    entry.className = 'logger-entry logger-spacer'\n    this.#entries.push(entry)\n\n    if (this.#contentEl) {\n        this.#contentEl.appendChild(entry)\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "title",
        "line": 410,
        "source": "title (title) {\n    const entry = document.createElement('div')\n    entry.className = 'logger-entry logger-title-entry'\n    entry.textContent = title\n    this.#entries.push(entry)\n\n    if (this.#contentEl) {\n        this.#contentEl.appendChild(entry)\n    }\n}",
        "kind": "method",
        "params": [
          "title"
        ]
      },
      {
        "name": "clear",
        "line": 422,
        "source": "clear () {\n    this.#entries = []\n    if (this.#contentEl) {\n        this.#contentEl.innerHTML = ''\n    }\n    this.#updateControlsVisibility()\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "maxEntries",
        "line": 97,
        "source": "get maxEntries () {\n    return this.#maxEntries\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "position",
        "line": 108,
        "source": "get position () {\n    return this.#position\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "timestamp",
        "line": 120,
        "source": "get timestamp () {\n    return this.#timestamp\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "theme",
        "line": 135,
        "source": "get theme () {\n    return this.#theme\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "entries",
        "line": 150,
        "source": "get entries () {\n    return this.#entries\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "maxEntries",
        "line": 102,
        "source": "set maxEntries (value) {\n    this.#maxEntries = value\n    this.setAttribute('max-entries', value)\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "position",
        "line": 113,
        "source": "set position (value) {\n    this.#position = value\n    this.setAttribute('position', value)\n    this.#updateClasses()\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "timestamp",
        "line": 125,
        "source": "set timestamp (value) {\n    this.#timestamp = value\n    if (value) {\n        this.setAttribute('timestamp', '')\n    } else {\n        this.removeAttribute('timestamp')\n    }\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "theme",
        "line": 140,
        "source": "set theme (value) {\n    this.#theme = value\n    if (value) {\n        this.setAttribute('theme', value)\n    } else {\n        this.removeAttribute('theme')\n    }\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      }
    ],
    "constructor": {
      "name": "constructor",
      "line": 38,
      "source": "constructor () {\n    super()\n    this.attachShadow({mode: 'open'})\n}",
      "kind": "constructor",
      "params": []
    },
    "isDefault": true
  },
  "/editor/toggle_input.doc.js": {
    "type": "class",
    "file": "/editor/toggle_input.js",
    "name": "ToggleInput",
    "line": 67,
    "extends": "HTMLElement",
    "statics": [
      {
        "name": "observedAttributes",
        "line": 75,
        "source": "static get observedAttributes () {\n    return ['checked', 'label']\n}",
        "kind": "method",
        "params": []
      }
    ],
    "methods": [
      {
        "name": "connectedCallback",
        "line": 87,
        "source": "connectedCallback () {\n    this.#updateDisplay()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "attributeChangedCallback",
        "line": 92,
        "source": "attributeChangedCallback (name, oldValue, newValue) {\n    handleAttributeChange(this, name, oldValue, newValue)\n}",
        "kind": "method",
        "params": [
          "name",
          "oldValue",
          "newValue"
        ]
      },
      {
        "name": "setChecked",
        "line": 111,
        "source": "setChecked (val) {\n    this.#checked = val\n    this.#updateDisplay()\n}",
        "kind": "method",
        "params": [
          "val"
        ]
      },
      {
        "name": "setLabel",
        "line": 117,
        "source": "setLabel (val) {\n    this.#label = val\n    if (this.#labelEl) {\n        this.#labelEl.textContent = this.#label\n    }\n}",
        "kind": "method",
        "params": [
          "val"
        ]
      }
    ],
    "getters": [
      {
        "name": "checked",
        "line": 97,
        "source": "get checked () {\n    return this.#checked\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "checked",
        "line": 102,
        "source": "set checked (val) {\n    const newChecked = Boolean(val)\n    if (this.#checked !== newChecked) {\n        this.#checked = newChecked\n        this.#updateDisplay()\n    }\n}",
        "kind": "method",
        "params": [
          "val"
        ]
      }
    ],
    "constructor": {
      "name": "constructor",
      "line": 80,
      "source": "constructor () {\n    super()\n    this.attachShadow({mode: 'open'})\n    this.#buildDOM()\n}",
      "kind": "constructor",
      "params": []
    },
    "isDefault": true
  },
  "/editor/vec2_input.doc.js": {
    "type": "class",
    "file": "/editor/vec2_input.js",
    "name": "Vec2Input",
    "line": 43,
    "extends": "HTMLElement",
    "statics": [
      {
        "name": "observedAttributes",
        "line": 51,
        "source": "static get observedAttributes () {\n    return ['label']\n}",
        "kind": "method",
        "params": []
      }
    ],
    "methods": [
      {
        "name": "connectedCallback",
        "line": 63,
        "source": "connectedCallback () {\n    this.#updateDisplay()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "attributeChangedCallback",
        "line": 68,
        "source": "attributeChangedCallback (name, oldValue, newValue) {\n    handleAttributeChange(this, name, oldValue, newValue)\n}",
        "kind": "method",
        "params": [
          "name",
          "oldValue",
          "newValue"
        ]
      },
      {
        "name": "setLabel",
        "line": 84,
        "source": "setLabel (val) {\n    this.#label = val\n    if (this.#labelEl) {\n        this.#labelEl.textContent = this.#label\n    }\n}",
        "kind": "method",
        "params": [
          "val"
        ]
      }
    ],
    "getters": [
      {
        "name": "value",
        "line": 73,
        "source": "get value () {\n    return this.#vec2\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "value",
        "line": 78,
        "source": "set value (vec2) {\n    this.#vec2 = vec2\n    this.#updateDisplay()\n}",
        "kind": "method",
        "params": [
          "vec2"
        ]
      }
    ],
    "constructor": {
      "name": "constructor",
      "line": 56,
      "source": "constructor () {\n    super()\n    this.attachShadow({mode: 'open'})\n    this.#buildDOM()\n}",
      "kind": "constructor",
      "params": []
    },
    "isDefault": true
  },
  "/editor/inspectors/action_controller_inspector.doc.js": {
    "type": "class",
    "file": "/editor/inspectors/action_controller_inspector.js",
    "name": "ActionControllerInspector",
    "line": 87,
    "extends": "BaseInspector",
    "statics": [
      {
        "name": "matches",
        "line": 89,
        "source": "static matches (module) {\n    return module instanceof ActionController\n}",
        "kind": "method",
        "params": [
          "module"
        ]
      }
    ],
    "methods": [
      {
        "name": "buildDOM",
        "line": 101,
        "source": "buildDOM () {\n    super.buildDOM()\n\n    this.#containerEl = document.createElement('div')\n    this.shadowRoot.insertBefore(this.#containerEl, this.gridEl)\n    this.gridEl.style.display = 'none'\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "onModuleSet",
        "line": 110,
        "source": "onModuleSet (module) {\n    if (module) {\n        this.#update()\n    }\n}",
        "kind": "method",
        "params": [
          "module"
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 95,
      "source": "constructor () {\n    super(customStyles)\n    this.buildDOM()\n}",
      "kind": "constructor",
      "params": []
    },
    "isDefault": true
  },
  "/editor/inspectors/action_dispatcher_inspector.doc.js": {
    "type": "class",
    "file": "/editor/inspectors/action_dispatcher_inspector.js",
    "name": "ActionDispatcherInspector",
    "line": 105,
    "extends": "BaseInspector",
    "statics": [
      {
        "name": "matches",
        "line": 107,
        "source": "static matches (module) {\n    return module instanceof ActionDispatcher\n}",
        "kind": "method",
        "params": [
          "module"
        ]
      }
    ],
    "methods": [
      {
        "name": "buildDOM",
        "line": 119,
        "source": "buildDOM () {\n    super.buildDOM()\n\n    this.#containerEl = document.createElement('div')\n    this.shadowRoot.insertBefore(this.#containerEl, this.gridEl)\n    this.gridEl.style.display = 'none'\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "onModuleSet",
        "line": 128,
        "source": "onModuleSet (module) {\n    if (module) {\n        this.#update()\n    }\n}",
        "kind": "method",
        "params": [
          "module"
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 113,
      "source": "constructor () {\n    super(customStyles)\n    this.buildDOM()\n}",
      "kind": "constructor",
      "params": []
    },
    "isDefault": true
  },
  "/editor/log_renderers/vec2_log_renderer.doc.js": {
    "type": "module",
    "file": "/editor/log_renderers/vec2_log_renderer.js",
    "functions": [
      {
        "name": "formatNumber",
        "line": 5,
        "params": [
          "n"
        ],
        "source": "function formatNumber (n) {\n    if (Number.isInteger(n)) {\n        return String(n)\n    }\n    return n.toFixed(2)\n}"
      }
    ],
    "exports": []
  },
  "/doc/doc_page.doc.js": {
    "type": "class",
    "file": "/doc/doc_page.js",
    "name": "DocPage",
    "line": 11,
    "extends": "HTMLElement",
    "statics": [],
    "methods": [
      {
        "name": "connectedCallback",
        "line": 31,
        "source": "connectedCallback () {\n    this.#buildDOM()\n    this.#setupAnchorNavigation()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "disconnectedCallback",
        "line": 56,
        "source": "disconnectedCallback () {\n    this.#disposeAll()\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "doc",
        "line": 80,
        "source": "get doc () {\n    return this.#doc\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "api",
        "line": 93,
        "source": "get api () {\n    return this.#api\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "sources",
        "line": 103,
        "source": "get sources () {\n    return this.#sources\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "tests",
        "line": 113,
        "source": "get tests () {\n    return this.#tests\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "activeTab",
        "line": 125,
        "source": "get activeTab () {\n    return this.#activeTab\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "availableTabs",
        "line": 130,
        "source": "get availableTabs () {\n    const tabs = ['doc']\n    if (this.#api) {\n        tabs.push('api')\n    }\n    if (this.#tests) {\n        tabs.push('test')\n    }\n    return tabs\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "doc",
        "line": 72,
        "source": "set doc (value) {\n    this.#doc = value\n    if (this.isConnected) {\n        this.#render()\n    }\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "api",
        "line": 85,
        "source": "set api (value) {\n    this.#api = value\n    if (this.isConnected) {\n        this.#render()\n    }\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "sources",
        "line": 98,
        "source": "set sources (value) {\n    this.#sources = value\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "tests",
        "line": 108,
        "source": "set tests (value) {\n    this.#tests = value\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "initialTab",
        "line": 118,
        "source": "set initialTab (value) {\n    if (value === 'api' || value === 'doc' || value === 'test') {\n        this.#activeTab = value\n    }\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      }
    ],
    "constructor": {
      "name": "constructor",
      "line": 25,
      "source": "constructor () {\n    super()\n    this.attachShadow({mode: 'open'})\n}",
      "kind": "constructor",
      "params": []
    },
    "isDefault": true
  },
  "/doc/runtime.doc.js": {
    "type": "module",
    "file": "/doc/runtime.js",
    "functions": [
      {
        "name": "doc",
        "line": 9,
        "params": [
          "title",
          "options",
          "fn"
        ],
        "source": "function doc (title, options, fn) {\n    const opts = typeof options === 'function' ? {} : options\n    const callback = typeof options === 'function' ? options : fn\n\n    const docData = {\n        title,\n        options: opts,\n        blocks: []\n    }\n\n    currentBlocks = docData.blocks\n    currentSetup = null\n    callback()\n    currentBlocks = null\n    currentSetup = null\n\n    return docData\n}"
      },
      {
        "name": "section",
        "line": 29,
        "params": [
          "title",
          "fn"
        ],
        "source": "function section (title, fn) {\n    if (!currentBlocks) {\n        throw new Error('section() must be called inside doc()')\n    }\n\n    const sectionData = {\n        type: 'section',\n        title,\n        blocks: [],\n        setup: null\n    }\n\n    const parentBlocks = currentBlocks\n    const parentSetup = currentSetup\n\n    currentBlocks = sectionData.blocks\n    currentSetup = null\n    fn()\n    sectionData.setup = currentSetup\n\n    currentBlocks = parentBlocks\n    currentSetup = parentSetup\n\n    currentBlocks.push(sectionData)\n}"
      },
      {
        "name": "setup",
        "line": 56,
        "params": [
          "fn"
        ],
        "source": "function setup (fn) {\n    if (!currentBlocks) {\n        throw new Error('setup() must be called inside doc() or section()')\n    }\n\n    currentSetup = {\n        source: extractFunctionBody(fn),\n        fn\n    }\n}"
      },
      {
        "name": "text",
        "line": 68,
        "params": [
          "content"
        ],
        "source": "function text (content) {\n    if (!currentBlocks) {\n        throw new Error('text() must be called inside doc()')\n    }\n\n    currentBlocks.push({\n        type: 'text',\n        content: dedent(content)\n    })\n}"
      },
      {
        "name": "code",
        "line": 80,
        "params": [
          "title",
          "fn"
        ],
        "source": "function code (title, fn) {\n    if (!currentBlocks) {\n        throw new Error('code() must be called inside doc()')\n    }\n\n    currentBlocks.push({\n        type: 'code',\n        title,\n        source: extractFunctionBody(fn)\n    })\n}"
      },
      {
        "name": "action",
        "line": 93,
        "params": [
          "title",
          "fn"
        ],
        "source": "function action (title, fn) {\n    if (!currentBlocks) {\n        throw new Error('action() must be called inside doc()')\n    }\n\n    currentBlocks.push({\n        type: 'action',\n        title,\n        source: extractFunctionBody(fn),\n        fn\n    })\n}"
      },
      {
        "name": "see",
        "line": 107,
        "params": [
          "name",
          "options = ..."
        ],
        "source": "function see (name, options = {}) {\n    if (!currentBlocks) {\n        throw new Error('see() must be called inside doc()')\n    }\n\n    currentBlocks.push({\n        type: 'see',\n        name,\n        pageType: options.type || 'doc',\n        section: options.section || null,\n        category: options.category || null\n    })\n}"
      },
      {
        "name": "disclaimer",
        "line": 122,
        "params": [
          "content"
        ],
        "source": "function disclaimer (content) {\n    if (!currentBlocks) {\n        throw new Error('disclaimer() must be called inside doc()')\n    }\n\n    currentBlocks.push({\n        type: 'disclaimer',\n        content: dedent(content)\n    })\n}"
      },
      {
        "name": "container",
        "line": 181,
        "params": [
          "options",
          "fn"
        ],
        "source": "function container (options, fn) {\n    if (!currentBlocks) {\n        throw new Error('container() must be called inside doc()')\n    }\n\n    const opts = typeof options === 'function' ? {} : options\n    const callback = typeof options === 'function' ? options : fn\n\n    currentBlocks.push({\n        type: 'container',\n        width: opts.width || null,\n        height: opts.height || 300,\n        title: opts.title || null,\n        preset: opts.preset || null,\n        scrollable: opts.scrollable || false,\n        source: extractFunctionBody(callback),\n        fn: callback\n    })\n}"
      },
      {
        "name": "applyContainerPreset",
        "line": 202,
        "params": [
          "element",
          "presetName"
        ],
        "source": "function applyContainerPreset (element, presetName) {\n    const preset = CONTAINER_PRESETS[presetName]\n    if (!preset) {\n        return\n    }\n\n    if (preset.tabIndex !== undefined) {\n        element.tabIndex = preset.tabIndex\n    }\n\n    if (preset.style) {\n        Object.assign(element.style, preset.style)\n    }\n}"
      },
      {
        "name": "extractFunctionBody",
        "line": 218,
        "params": [
          "fn"
        ],
        "source": "function extractFunctionBody (fn) {\n    const source = fn.toString()\n\n    let body = null\n\n    const arrowMatch = source.match(/^\\s*\\(?[^)]*\\)?\\s*=>\\s*\\{([\\s\\S]*)\\}\\s*$/)\n    if (arrowMatch) {\n        body = arrowMatch[1]\n    }\n\n    if (!body) {\n        const functionMatch = source.match(/^function\\s*\\w*\\s*\\([^)]*\\)\\s*\\{([\\s\\S]*)\\}\\s*$/)\n        if (functionMatch) {\n            body = functionMatch[1]\n        }\n    }\n\n    if (!body) {\n        const arrowExpressionMatch = source.match(/^\\s*\\(?[^)]*\\)?\\s*=>\\s*(.+)$/)\n        if (arrowExpressionMatch) {\n            return arrowExpressionMatch[1].trim()\n        }\n    }\n\n    if (!body) {\n        return source\n    }\n\n    body = body.split('\\n')\n        .filter(line => !line.trim().startsWith('ctx.setApp('))\n        .join('\\n')\n\n    return dedent(body)\n}"
      },
      {
        "name": "addSpacerIfNeeded",
        "line": 254,
        "params": [],
        "source": "function addSpacerIfNeeded () {\n    const hasVisibleLogs = logger.history.some(e => e.event === 'log')\n    const lastEntry = logger.history[logger.history.length - 1]\n    const lastIsSpacer = lastEntry?.event === 'spacer'\n\n    if (hasVisibleLogs && !lastIsSpacer) {\n        logger.spacer()\n    }\n}"
      },
      {
        "name": "executeAction",
        "line": 265,
        "params": [
          "block",
          "sectionSetup = ..."
        ],
        "source": "async function executeAction (block, sectionSetup = null) {\n    try {\n        addSpacerIfNeeded()\n        const ctx = {}\n\n        if (sectionSetup?.fn) {\n            await sectionSetup.fn(ctx)\n        }\n        await block.fn(ctx)\n    } catch (error) {\n        logger.error('Action error:', error.message)\n    }\n}"
      },
      {
        "name": "executeContainer",
        "line": 280,
        "params": [
          "block",
          "containerEl",
          "sectionSetup = ..."
        ],
        "source": "async function executeContainer (block, containerEl, sectionSetup = null) {\n    addSpacerIfNeeded()\n\n    const prevApp = containerEl._currentApp\n    if (prevApp?.dispose) {\n        prevApp.dispose()\n    }\n    containerEl.innerHTML = ''\n\n    if (block.preset) {\n        applyContainerPreset(containerEl, block.preset)\n    }\n\n    if (block.scrollable) {\n        containerEl.style.overflow = 'auto'\n    }\n\n    try {\n        let actionsBar = null\n        let slidersBar = null\n        let infoBar = null\n\n        const ctx = {\n            container: containerEl,\n            setApp: (app, ...args) => {\n                containerEl._currentApp = app\n                const [scene] = args\n                if (scene && app.autoFitEnabled && app.render) {\n                    app.on('resize', () => app.render(scene))\n                }\n            },\n            action: (label, callback) => {\n                if (!actionsBar) {\n                    actionsBar = document.createElement('div')\n                    actionsBar.className = 'doc-actions-bar'\n                    containerEl.appendChild(actionsBar)\n                }\n\n                const isFirst = actionsBar.children.length === 0\n                const btn = document.createElement('button')\n                btn.className = 'doc-actions-btn'\n                if (isFirst) {\n                    btn.classList.add('doc-actions-btn--active')\n                }\n                btn.textContent = label\n                btn.addEventListener('click', () => {\n                    actionsBar.querySelectorAll('.doc-actions-btn').forEach(b => b.classList.remove('doc-actions-btn--active'))\n                    btn.classList.add('doc-actions-btn--active')\n                    callback()\n                })\n                actionsBar.appendChild(btn)\n\n                if (isFirst) {\n                    callback()\n                }\n            },\n            slider: (label, opts, onChange) => {\n                if (!slidersBar) {\n                    slidersBar = document.createElement('div')\n                    slidersBar.className = 'doc-sliders-bar'\n                    containerEl.appendChild(slidersBar)\n                }\n\n                const wrapper = document.createElement('div')\n                wrapper.className = 'doc-slider-wrapper'\n\n                const labelEl = document.createElement('span')\n                labelEl.className = 'doc-slider-label'\n                labelEl.textContent = label\n\n                const valueEl = document.createElement('span')\n                valueEl.className = 'doc-slider-value'\n                valueEl.textContent = opts.default ?? opts.min\n\n                const input = document.createElement('input')\n                input.type = 'range'\n                input.className = 'doc-slider'\n                input.min = opts.min\n                input.max = opts.max\n                input.step = opts.step ?? (opts.max - opts.min) / 100\n                input.value = opts.default ?? opts.min\n\n                input.addEventListener('input', () => {\n                    const value = parseFloat(input.value)\n                    valueEl.textContent = Number.isInteger(value) ? value : value.toFixed(2)\n                    onChange(value)\n                })\n\n                wrapper.appendChild(labelEl)\n                wrapper.appendChild(input)\n                wrapper.appendChild(valueEl)\n                slidersBar.appendChild(wrapper)\n\n                onChange(parseFloat(input.value))\n            },\n            info: (formatter) => {\n                if (!infoBar) {\n                    infoBar = document.createElement('div')\n                    infoBar.className = 'doc-info-bar'\n                    containerEl.appendChild(infoBar)\n                }\n\n                const el = document.createElement('div')\n                el.className = 'doc-info'\n                infoBar.appendChild(el)\n                const update = (...args) => {\n                    el.textContent = formatter(...args)\n                }\n                update()\n                return update\n            },\n            hint: (message) => {\n                const el = document.createElement('div')\n                el.className = 'doc-hint'\n                el.textContent = message\n                containerEl.appendChild(el)\n            },\n            display: (formatter) => {\n                const el = document.createElement('div')\n                el.className = 'doc-display'\n                containerEl.appendChild(el)\n                const update = (...args) => {\n                    const result = formatter(...args)\n                    if (result instanceof HTMLElement) {\n                        el.innerHTML = ''\n                        el.appendChild(result)\n                    } else if (Array.isArray(result)) {\n                        el.innerHTML = result.map(item => `<span class=\"doc-display-tag\">${item}</span>`).join('')\n                    } else {\n                        el.innerHTML = result\n                    }\n                }\n                update()\n                return update\n            },\n            box: (opts = {}) => {\n                const size = opts.size || 40\n                const color = opts.color || '#4a9eff'\n                const el = document.createElement('div')\n                el.style.cssText = `width:${size}px;height:${size}px;background:${color};position:absolute;border-radius:4px;left:50%;top:50%;transform:translate(-50%,-50%)`\n                containerEl.appendChild(el)\n                return el\n            },\n            marker: (x = 0, y = 0, opts = {}) => {\n                const size = opts.size || 20\n                const color = opts.color || '#4a9eff'\n                const el = document.createElement('div')\n                el.style.cssText = `width:${size}px;height:${size}px;background:${color};position:absolute;border-radius:50%;transform:translate(-50%,-50%);left:${x}px;top:${y}px`\n                containerEl.appendChild(el)\n                return el\n            },\n            column: (opts = {}) => {\n                const gap = opts.gap || 4\n                const el = document.createElement('div')\n                el.style.cssText = `display:flex;flex-direction:column;align-items:center;gap:${gap}px;`\n                if (opts.parent) {\n                    opts.parent.appendChild(el)\n                } else {\n                    containerEl.appendChild(el)\n                }\n                return el\n            },\n            row: (opts = {}) => {\n                const gap = opts.gap || 8\n                const el = document.createElement('div')\n                el.style.cssText = `display:flex;flex-direction:row;align-items:center;gap:${gap}px;flex-wrap:wrap;justify-content:center;`\n                if (opts.parent) {\n                    opts.parent.appendChild(el)\n                } else {\n                    containerEl.appendChild(el)\n                }\n                return el\n            },\n            label: (content, opts = {}) => {\n                const el = document.createElement('div')\n                el.style.cssText = 'color:#666;font-family:monospace;font-size:11px;'\n                el.textContent = content\n                if (opts.parent) {\n                    opts.parent.appendChild(el)\n                } else {\n                    containerEl.appendChild(el)\n                }\n                return el\n            },\n            checkerBoard: (opts = {}) => {\n                const size = opts.size || 8\n                const color1 = opts.color1 || '#222'\n                const color2 = opts.color2 || '#1a1a1a'\n                const el = document.createElement('div')\n                el.style.cssText = `background:repeating-conic-gradient(${color1} 0% 25%, ${color2} 0% 50%) 50% / ${size * 2}px ${size * 2}px;border:1px solid #333;overflow:hidden;`\n                if (opts.width) {\n                    el.style.width = opts.width + 'px'\n                }\n                if (opts.height) {\n                    el.style.height = opts.height + 'px'\n                }\n                if (opts.parent) {\n                    opts.parent.appendChild(el)\n                } else {\n                    containerEl.appendChild(el)\n                }\n                return el\n            },\n            canvas: (source, opts = {}) => {\n                const wrapper = document.createElement('div')\n                const size = opts.checkerSize || 8\n                wrapper.style.cssText = `background:repeating-conic-gradient(#222 0% 25%, #1a1a1a 0% 50%) 50% / ${size * 2}px ${size * 2}px;border:1px solid #333;display:inline-block;`\n                if (opts.parent) {\n                    opts.parent.appendChild(wrapper)\n                } else {\n                    containerEl.appendChild(wrapper)\n                }\n\n                const displayCanvas = document.createElement('canvas')\n                displayCanvas.style.cssText = 'display:block;'\n                if (opts.maxWidth) {\n                    displayCanvas.style.maxWidth = opts.maxWidth + 'px'\n                    displayCanvas.style.height = 'auto'\n                }\n                wrapper.appendChild(displayCanvas)\n\n                const update = (src) => {\n                    const canvas = src || source\n                    displayCanvas.width = canvas.width\n                    displayCanvas.height = canvas.height\n                    const dctx = displayCanvas.getContext('2d')\n                    dctx.clearRect(0, 0, canvas.width, canvas.height)\n                    dctx.drawImage(canvas, 0, 0)\n                }\n\n                if (source) {\n                    update(source)\n                }\n\n                return {element: wrapper, canvas: displayCanvas, update}\n            }\n        }\n\n        if (sectionSetup?.fn) {\n            await sectionSetup.fn(ctx)\n        }\n        await block.fn(ctx)\n\n        if (containerEl.tabIndex >= 0) {\n            containerEl.focus()\n        }\n    } catch (error) {\n        logger.error('Container error:', error.message)\n    }\n}"
      },
      {
        "name": "renderAction",
        "line": 532,
        "params": [
          "block",
          "sectionSetup = ...",
          "extractedSource = ..."
        ],
        "source": "function renderAction (block, sectionSetup = null, extractedSource = null) {\n    const wrapper = document.createElement('div')\n    wrapper.className = 'doc-action-block'\n\n    const codeEl = document.createElement('perky-code')\n    codeEl.setAttribute('title', block.title)\n    codeEl.code = extractedSource || block.source\n    wrapper.appendChild(codeEl)\n\n    const button = document.createElement('button')\n    button.className = 'doc-action-btn'\n    button.innerHTML = `\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n            <path d=\"M8 5v14l11-7z\"/>\n        </svg>\n        Run\n    `\n    button.addEventListener('click', () => executeAction(block, sectionSetup))\n    wrapper.appendChild(button)\n\n    return wrapper\n}"
      }
    ],
    "exports": []
  }
}