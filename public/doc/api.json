{
  "/core/perky_module.doc.js": {
    "type": "class",
    "file": "/core/perky_module.js",
    "name": "PerkyModule",
    "line": 8,
    "extends": "Notifier",
    "statics": [
      {
        "name": "$category",
        "line": 31,
        "source": "static $category = 'perkyModule'",
        "kind": "property",
        "value": "'perkyModule'"
      },
      {
        "name": "$name",
        "line": 32,
        "source": "static $name = null",
        "kind": "property",
        "value": "null"
      },
      {
        "name": "$lifecycle",
        "line": 33,
        "source": "static $lifecycle = true",
        "kind": "property",
        "value": "true"
      },
      {
        "name": "$eagerStart",
        "line": 34,
        "source": "static $eagerStart = true",
        "kind": "property",
        "value": "true"
      },
      {
        "name": "$tags",
        "line": 35,
        "source": "static $tags = []",
        "kind": "property",
        "value": "[]"
      },
      {
        "name": "perkyModuleMethods",
        "line": 606,
        "source": "static perkyModuleMethods = Notifier.notifierMethods.concat([\n    'start',\n    'stop',\n    'dispose',\n    'install',\n    'uninstall',\n    'create',\n    'addChild',\n    'getChild',\n    'hasChild',\n    'removeChild',\n    'listNamesFor',\n    'lookup',\n    'childrenByCategory',\n    'hasTag',\n    'addTag',\n    'removeTag',\n    'hasTags',\n    'childrenByTags',\n    'addTagsIndex',\n    'removeTagsIndex',\n    'delegateTo',\n    'cleanDelegations',\n    'delegateEventsTo',\n    'cleanEventDelegations',\n    'query',\n    'queryAll',\n    'link',\n    'unlink',\n    'getLinked',\n    'hasLinked',\n    'unlinkAll'\n])",
        "kind": "property",
        "value": "Notifier.notifierMethods.concat([\n    'start',\n    'stop',\n    'dispose',\n    'install',\n    'uninstall',\n    'create',\n    'addChild',\n    'getChild',\n    'hasChild',\n    'removeChild',\n    'listNamesFor',\n    'lookup',\n    'childrenByCategory',\n    'hasTag',\n    'addTag',\n    'removeTag',\n    'hasTags',\n    'childrenByTags',\n    'addTagsIndex',\n    'removeTagsIndex',\n    'delegateTo',\n    'cleanDelegations',\n    'delegateEventsTo',\n    'cleanEventDelegations',\n    'query',\n    'queryAll',\n    'link',\n    'unlink',\n    'getLinked',\n    'hasLinked',\n    'unlinkAll'\n])"
      }
    ],
    "methods": [
      {
        "name": "start",
        "line": 172,
        "source": "start () {\n    if (this.#started) {\n        return false\n    }\n\n    this.#started = true\n    this.onStart?.()\n    this.emit('start')\n\n    return true\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "stop",
        "line": 185,
        "source": "stop () {\n    if (!this.#started) {\n        return false\n    }\n\n    this.#started = false\n    this.onStop?.()\n    this.emit('stop')\n\n    return true\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "dispose",
        "line": 198,
        "source": "dispose () {\n    if (this.#disposed) {\n        return false\n    }\n\n    this.#disposed = true\n    this.stop()\n\n    this.unlinkAll()\n    this.cleanExternalListeners()\n\n    this.#childrenRegistry.forEach(child => {\n        if (child && !child.disposed) {\n            child.dispose()\n        }\n    })\n    this.#childrenRegistry.clear()\n\n    this.onDispose?.()\n    this.emit('dispose')\n    this.removeListeners()\n\n    return true\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "install",
        "line": 224,
        "source": "install (host, options) {\n    if (this.#installed) {\n        return this.uninstall()\n    }\n\n    this.#host = host\n    if (this.$bind) {\n        host[this.$bind] = this\n    }\n    this.#installed = true\n\n    this.onInstall?.(host, options)\n\n    return true\n}",
        "kind": "method",
        "params": [
          "host",
          "options"
        ]
      },
      {
        "name": "uninstall",
        "line": 241,
        "source": "uninstall () {\n    if (!this.#installed) {\n        return false\n    }\n\n    this.cleanDelegations()\n    this.cleanEventDelegations()\n    this.onUninstall?.(this.#host)\n    this.#installed = false\n    this.#host = null\n\n    return true\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "create",
        "line": 266,
        "source": "create (Child, options = {}) {\n    options.$category ||= Child.$category\n    options.$name ||= Child.$name || options.$category\n    options.$lifecycle = options.$lifecycle ?? Child.$lifecycle ?? true\n    options.$eagerStart = options.$eagerStart ?? Child.$eagerStart ?? true\n\n    const hasExplicitId = '$id' in options\n\n    if (hasExplicitId) {\n        unregisterExisting(this, options.$id)\n    }\n\n    return this.addChild(new Child(options))\n}",
        "kind": "method",
        "params": [
          "Child",
          "options = ..."
        ]
      },
      {
        "name": "addChild",
        "line": 282,
        "source": "addChild (child) {\n    if (!(child instanceof PerkyModule)) {\n        throw new Error('addChild expects a PerkyModule instance')\n    }\n\n    if (child.installed) {\n        throw new Error('Module is already installed in another parent')\n    }\n\n    if (this.#childrenRegistry.has(child.$id)) {\n        child.$id = this.#findUniqueId(child.$name)\n    }\n\n    return this.#addChild(child, child.options)\n}",
        "kind": "method",
        "params": [
          "child"
        ]
      },
      {
        "name": "getChild",
        "line": 321,
        "source": "getChild (name) {\n    return this.#childrenRegistry.get(name) || null\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "hasChild",
        "line": 326,
        "source": "hasChild (name) {\n    return this.#childrenRegistry.has(name)\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "removeChild",
        "line": 331,
        "source": "removeChild (name) {\n    const child = this.#childrenRegistry.get(name)\n\n    if (!child) {\n        return false\n    }\n\n    unregisterChild(this, child)\n\n    return true\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "listNamesFor",
        "line": 344,
        "source": "listNamesFor (key, indexName = '$category') {\n    return this.#childrenRegistry.lookupKeys(indexName, key)\n}",
        "kind": "method",
        "params": [
          "key",
          "indexName = ..."
        ]
      },
      {
        "name": "lookup",
        "line": 349,
        "source": "lookup (indexName, key) {\n    return this.#childrenRegistry.lookup(indexName, key)\n}",
        "kind": "method",
        "params": [
          "indexName",
          "key"
        ]
      },
      {
        "name": "childrenByCategory",
        "line": 354,
        "source": "childrenByCategory (category) {\n    return this.lookup('$category', category)\n}",
        "kind": "method",
        "params": [
          "category"
        ]
      },
      {
        "name": "hasTag",
        "line": 377,
        "source": "hasTag (tag) {\n    return this.#tags.has(tag)\n}",
        "kind": "method",
        "params": [
          "tag"
        ]
      },
      {
        "name": "addTag",
        "line": 382,
        "source": "addTag (tag) {\n    if (this.#tags.has(tag)) {\n        return false\n    }\n    this.#tags.add(tag)\n    return true\n}",
        "kind": "method",
        "params": [
          "tag"
        ]
      },
      {
        "name": "removeTag",
        "line": 391,
        "source": "removeTag (tag) {\n    return this.#tags.delete(tag)\n}",
        "kind": "method",
        "params": [
          "tag"
        ]
      },
      {
        "name": "hasTags",
        "line": 396,
        "source": "hasTags (tags) {\n    if (typeof tags === 'string') {\n        return this.hasTag(tags)\n    }\n\n    return Array.isArray(tags) && tags.every(tag => this.#tags.has(tag))\n}",
        "kind": "method",
        "params": [
          "tags"
        ]
      },
      {
        "name": "childrenByTags",
        "line": 405,
        "source": "childrenByTags (tags) {\n    const tagArray = Array.isArray(tags) ? tags : [tags]\n\n    if (tagArray.length === 0) {\n        return []\n    }\n\n    const indexKey = getTagIndexKey(tagArray)\n\n    if (this.#tagIndexes.has(indexKey)) {\n        return this.#childrenRegistry.lookup(indexKey, indexKey)\n    }\n\n    return this.#childrenRegistry.all.filter(\n        child => tagArray.every(tag => child.$tags?.includes(tag))\n    )\n}",
        "kind": "method",
        "params": [
          "tags"
        ]
      },
      {
        "name": "addTagsIndex",
        "line": 424,
        "source": "addTagsIndex (tags) {\n    if (!Array.isArray(tags) || tags.length === 0) {\n        return false\n    }\n\n    const indexKey = getTagIndexKey(tags)\n\n    if (this.#tagIndexes.has(indexKey)) {\n        return false\n    }\n\n    this.#childrenRegistry.addIndex(indexKey, child => {\n        const hasAllTags = tags.every(tag => child.tags?.has(tag))\n        return hasAllTags ? indexKey : null\n    })\n\n    this.#tagIndexes.set(indexKey, tags)\n\n    this.#childrenRegistry.forEach(child => {\n        if (child.tags) {\n            this.#setupTagIndexListeners(child)\n        }\n    })\n\n    return true\n}",
        "kind": "method",
        "params": [
          "tags"
        ]
      },
      {
        "name": "removeTagsIndex",
        "line": 452,
        "source": "removeTagsIndex (tags) {\n    const indexKey = getTagIndexKey(tags)\n\n    if (!this.#tagIndexes.has(indexKey)) {\n        return false\n    }\n\n    this.#childrenRegistry.removeIndex(indexKey)\n    this.#tagIndexes.delete(indexKey)\n    return true\n}",
        "kind": "method",
        "params": [
          "tags"
        ]
      },
      {
        "name": "delegateTo",
        "line": 482,
        "source": "delegateTo (host, names) {\n    delegateProperties(host, this, names)\n\n    const propertyNames = Array.isArray(names)\n        ? names\n        : Object.values(names)\n\n    this.#delegations.push({host, propertyNames})\n}",
        "kind": "method",
        "params": [
          "host",
          "names"
        ]
      },
      {
        "name": "cleanDelegations",
        "line": 493,
        "source": "cleanDelegations () {\n    for (const {host, propertyNames} of this.#delegations) {\n        for (const name of propertyNames) {\n            delete host[name]\n        }\n    }\n    this.#delegations.length = 0\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "delegateEventsTo",
        "line": 503,
        "source": "delegateEventsTo (host, events, namespace) {\n    const eventArray = Array.isArray(events) ? events : Object.keys(events)\n    const callbacks = []\n\n    for (const event of eventArray) {\n        const prefixedEvent = namespace ? `${namespace}:${event}` : event\n        const callback = (...args) => host.emit(prefixedEvent, ...args)\n        this.on(event, callback)\n        callbacks.push({event, callback})\n    }\n\n    this.#eventDelegations.push({callbacks})\n}",
        "kind": "method",
        "params": [
          "host",
          "events",
          "namespace"
        ]
      },
      {
        "name": "cleanEventDelegations",
        "line": 518,
        "source": "cleanEventDelegations () {\n    for (const {callbacks} of this.#eventDelegations) {\n        for (const {event, callback} of callbacks) {\n            this.off(event, callback)\n        }\n    }\n    this.#eventDelegations.length = 0\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "query",
        "line": 528,
        "source": "query (selector) {\n    return perkyQuery(this, selector)\n}",
        "kind": "method",
        "params": [
          "selector"
        ]
      },
      {
        "name": "queryAll",
        "line": 533,
        "source": "queryAll (selector) {\n    return perkyQueryAll(this, selector)\n}",
        "kind": "method",
        "params": [
          "selector"
        ]
      },
      {
        "name": "link",
        "line": 538,
        "source": "link (module, alias) {\n    if (!(module instanceof PerkyModule)) {\n        throw new Error('link expects a PerkyModule instance')\n    }\n\n    const key = alias || module.$id\n    const shouldBind = alias !== false\n\n    if (this.#linked.has(key)) {\n        this.unlink(key)\n    }\n\n    this.#linked.set(key, module)\n\n    if (shouldBind) {\n        this[key] = module\n    }\n\n    this.listenTo(module, 'dispose', () => {\n        this.unlink(key)\n    })\n\n    this.emit('link', key, module)\n\n    return module\n}",
        "kind": "method",
        "params": [
          "module",
          "alias"
        ]
      },
      {
        "name": "unlink",
        "line": 566,
        "source": "unlink (key) {\n    const module = this.#linked.get(key)\n\n    if (!module) {\n        return false\n    }\n\n    this.#linked.delete(key)\n\n    if (this[key] === module) {\n        delete this[key]\n    }\n\n    this.emit('unlink', key, module)\n\n    return true\n}",
        "kind": "method",
        "params": [
          "key"
        ]
      },
      {
        "name": "getLinked",
        "line": 585,
        "source": "getLinked (key) {\n    return this.#linked.get(key) || null\n}",
        "kind": "method",
        "params": [
          "key"
        ]
      },
      {
        "name": "hasLinked",
        "line": 595,
        "source": "hasLinked (key) {\n    return this.#linked.has(key)\n}",
        "kind": "method",
        "params": [
          "key"
        ]
      },
      {
        "name": "unlinkAll",
        "line": 600,
        "source": "unlinkAll () {\n    for (const key of this.#linked.keys()) {\n        this.unlink(key)\n    }\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "$id",
        "line": 60,
        "source": "get $id () {\n    return this.#id\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "$name",
        "line": 75,
        "source": "get $name () {\n    return this.#name\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "$category",
        "line": 90,
        "source": "get $category () {\n    return this.#category\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "$bind",
        "line": 105,
        "source": "get $bind () {\n    return this.#bind\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "host",
        "line": 120,
        "source": "get host () {\n    return this.#host\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "started",
        "line": 125,
        "source": "get started () {\n    return this.#started\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "disposed",
        "line": 130,
        "source": "get disposed () {\n    return this.#disposed\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "installed",
        "line": 135,
        "source": "get installed () {\n    return this.#installed\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "$eagerStart",
        "line": 140,
        "source": "get $eagerStart () {\n    return this.#eagerStart\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "$lifecycle",
        "line": 145,
        "source": "get $lifecycle () {\n    return this.#lifecycle\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "$status",
        "line": 150,
        "source": "get $status () {\n    if (!this.#lifecycle) {\n        return 'static'\n    }\n\n    if (this.#disposed) {\n        return 'disposed'\n    }\n\n    if (this.#started) {\n        return 'started'\n    }\n\n    return 'stopped'\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "running",
        "line": 167,
        "source": "get running () {\n    return this.#started\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "children",
        "line": 256,
        "source": "get children () {\n    return this.#childrenRegistry.all\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "childrenRegistry",
        "line": 261,
        "source": "get childrenRegistry () {\n    return this.#childrenRegistry\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "$tags",
        "line": 359,
        "source": "get $tags () {\n    return this.#tags.toArray()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "tags",
        "line": 372,
        "source": "get tags () {\n    return this.#tags\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "linked",
        "line": 590,
        "source": "get linked () {\n    return Array.from(this.#linked.values())\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "$id",
        "line": 65,
        "source": "set $id (newId) {\n    const oldId = this.#id\n\n    if (oldId !== newId) {\n        this.#id = newId\n        this.emit('$id:changed', newId, oldId)\n    }\n}",
        "kind": "method",
        "params": [
          "newId"
        ]
      },
      {
        "name": "$name",
        "line": 80,
        "source": "set $name (newName) {\n    const oldName = this.#name\n\n    if (oldName !== newName) {\n        this.#name = newName\n        this.emit('$name:changed', newName, oldName)\n    }\n}",
        "kind": "method",
        "params": [
          "newName"
        ]
      },
      {
        "name": "$category",
        "line": 95,
        "source": "set $category (newCategory) {\n    const oldCategory = this.#category\n\n    if (oldCategory !== newCategory) {\n        this.#category = newCategory\n        this.emit('$category:changed', newCategory, oldCategory)\n    }\n}",
        "kind": "method",
        "params": [
          "newCategory"
        ]
      },
      {
        "name": "$bind",
        "line": 110,
        "source": "set $bind (newBind) {\n    const oldBind = this.#bind\n\n    if (oldBind !== newBind) {\n        this.#bind = newBind\n        this.emit('$bind:changed', newBind, oldBind)\n    }\n}",
        "kind": "method",
        "params": [
          "newBind"
        ]
      },
      {
        "name": "$tags",
        "line": 364,
        "source": "set $tags (newTags) {\n    this.#tags.clear()\n    if (Array.isArray(newTags)) {\n        newTags.forEach(tag => this.#tags.add(tag))\n    }\n}",
        "kind": "method",
        "params": [
          "newTags"
        ]
      }
    ],
    "constructor": {
      "name": "constructor",
      "line": 37,
      "source": "constructor (options = {}) { // eslint-disable-line complexity -- clean\n    super()\n\n    this.options = {...options}\n    this.#name = options.$name || this.constructor.$name || this.constructor.name\n    this.#id = options.$id || this.#name\n    this.#category = options.$category || this.constructor.$category\n\n    const bindOption = options.$bind ?? this.constructor.$bind\n    this.#bind = bindOption === true ? this.#name : bindOption\n    this.#eagerStart = (options.$eagerStart ?? this.constructor.$eagerStart) !== false\n    this.#lifecycle = (options.$lifecycle ?? this.constructor.$lifecycle) !== false\n\n    this.#tags = new ObservableSet([\n        ...this.constructor.$tags,\n        ...(options.$tags || [])\n    ])\n\n    this.#childrenRegistry = new Registry()\n    this.#childrenRegistry.addIndex('$category')\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/core/utils.doc.js": {
    "type": "module",
    "file": "/core/utils.js",
    "functions": [
      {
        "name": "toCamelCase",
        "line": 7,
        "params": [
          "string"
        ],
        "source": "function toCamelCase (string) {\n    return inflector.toCamelCase(string)\n}"
      },
      {
        "name": "toPascalCase",
        "line": 12,
        "params": [
          "string"
        ],
        "source": "function toPascalCase (string) {\n    return inflector.toPascalCase(string)\n}"
      },
      {
        "name": "toSnakeCase",
        "line": 17,
        "params": [
          "string"
        ],
        "source": "function toSnakeCase (string) {\n    return inflector.toSnakeCase(string)\n}"
      },
      {
        "name": "toKebabCase",
        "line": 22,
        "params": [
          "string"
        ],
        "source": "function toKebabCase (string) {\n    return inflector.toKebabCase(string)\n}"
      },
      {
        "name": "toHumanCase",
        "line": 27,
        "params": [
          "string"
        ],
        "source": "function toHumanCase (string) {\n    return inflector.toHumanCase(string)\n}"
      },
      {
        "name": "uniqueId",
        "line": 34,
        "params": [
          "collection",
          "prefix"
        ],
        "source": "function uniqueId (collection, prefix) {\n    if (!prefix) {\n        prefix = collection\n        collection = 'default'\n    }\n\n    if (!idCounter[collection]) {\n        idCounter[collection] = {}\n    }\n\n    if (!idCounter[collection][prefix]) {\n        idCounter[collection][prefix] = 0\n    }\n\n    const current = idCounter[collection][prefix]\n    idCounter[collection][prefix]++\n\n    return current === 0 ? prefix : `${prefix}_${current}`\n}"
      },
      {
        "name": "resetUniqueId",
        "line": 55,
        "params": [
          "collection",
          "prefix"
        ],
        "source": "function resetUniqueId (collection, prefix) {\n    if (prefix) {\n        if (idCounter[collection]) {\n            idCounter[collection][prefix] = 0\n        }\n    } else {\n        idCounter[collection] = {}\n    }\n}"
      },
      {
        "name": "singularize",
        "line": 66,
        "params": [
          "word"
        ],
        "source": "function singularize (word) {\n    return inflector.singular(word)\n}"
      },
      {
        "name": "pluralize",
        "line": 71,
        "params": [
          "word",
          "count",
          "inclusive"
        ],
        "source": "function pluralize (word, count, inclusive) {\n    return inflector.pluralize(word, count, inclusive)\n}"
      },
      {
        "name": "plural",
        "line": 76,
        "params": [
          "word"
        ],
        "source": "function plural (word) {\n    return inflector.plural(word)\n}"
      },
      {
        "name": "isPlural",
        "line": 81,
        "params": [
          "word"
        ],
        "source": "function isPlural (word) {\n    return inflector.isPlural(word)\n}"
      },
      {
        "name": "isSingular",
        "line": 86,
        "params": [
          "word"
        ],
        "source": "function isSingular (word) {\n    return inflector.isSingular(word)\n}"
      },
      {
        "name": "setDefaults",
        "line": 91,
        "params": [
          "data",
          "defaults"
        ],
        "source": "function setDefaults (data, defaults) {\n    return deepMerge(defaults, data)\n}"
      },
      {
        "name": "getNestedValue",
        "line": 96,
        "params": [
          "obj",
          "path"
        ],
        "source": "function getNestedValue (obj, path) {\n    if (!path) {\n        return obj\n    }\n\n    const parts = path.split('.')\n    let current = obj\n\n    for (const part of parts) {\n        if (current === undefined || current === null) {\n            return undefined\n        }\n        current = current[part]\n    }\n\n    return current\n}"
      },
      {
        "name": "setNestedValue",
        "line": 115,
        "params": [
          "obj",
          "path",
          "value"
        ],
        "source": "function setNestedValue (obj, path, value) {\n    const parts = path.split('.')\n    let current = obj\n\n    for (let i = 0; i < parts.length - 1; i++) {\n        const part = parts[i]\n        if (!current[part]) {\n            current[part] = {}\n        }\n        current = current[part]\n    }\n\n    current[parts[parts.length - 1]] = value\n    return obj\n}"
      },
      {
        "name": "deepMerge",
        "line": 132,
        "params": [
          "target",
          "source"
        ],
        "source": "function deepMerge (target, source) {\n    return deepMergeInternal(target, source, new WeakSet())\n}"
      },
      {
        "name": "deepMergeInternal",
        "line": 137,
        "params": [
          "target",
          "source",
          "seen"
        ],
        "source": "function deepMergeInternal (target, source, seen) {\n    if (!source) {\n        return target\n    }\n\n    if (typeof source === 'object' && source !== null) {\n        if (seen.has(source)) {\n            return source\n        }\n        seen.add(source)\n    }\n\n    const sourceIsArray = Array.isArray(source)\n    const targetIsArray = Array.isArray(target)\n\n    if (sourceIsArray !== targetIsArray) {\n        return cloneIfNeeded(source, seen)\n    }\n\n    if (sourceIsArray) {\n        return mergeArrays(target, source, seen)\n    }\n\n    return mergeObject(target, source, seen)\n}"
      },
      {
        "name": "exportValue",
        "line": 164,
        "params": [
          "value"
        ],
        "source": "function exportValue (value) {\n\n    if (value && typeof value === 'object') {\n        if (typeof value.export === 'function') {\n            return value.export()\n        }\n\n        if (Array.isArray(value)) {\n            return value.map(item => exportValue(item))\n        }\n\n        const result = {}\n        for (const key in value) {\n            if (Object.hasOwn(value, key)) {\n                result[key] = exportValue(value[key])\n            }\n        }\n        return result\n    }\n\n    return value\n}"
      },
      {
        "name": "isNonNullObject",
        "line": 188,
        "params": [
          "value"
        ],
        "source": "function isNonNullObject (value) {\n    return Boolean(value) && typeof value === 'object'\n}"
      },
      {
        "name": "isSpecial",
        "line": 193,
        "params": [
          "value"
        ],
        "source": "function isSpecial (value) {\n    const stringValue = Object.prototype.toString.call(value)\n    return stringValue === '[object RegExp]' || stringValue === '[object Date]'\n}"
      },
      {
        "name": "isMergeableObject",
        "line": 199,
        "params": [
          "value"
        ],
        "source": "function isMergeableObject (value) {\n    if (!isNonNullObject(value) || isSpecial(value)) {\n        return false\n    }\n    if (Array.isArray(value)) {\n        return true\n    }\n    const proto = Object.getPrototypeOf(value)\n    return proto === null || proto === Object.prototype\n}"
      },
      {
        "name": "emptyTarget",
        "line": 211,
        "params": [
          "value"
        ],
        "source": "function emptyTarget (value) {\n    return Array.isArray(value) ? [] : {}\n}"
      },
      {
        "name": "cloneIfNeeded",
        "line": 216,
        "params": [
          "value",
          "seen"
        ],
        "source": "function cloneIfNeeded (value, seen) {\n    return isMergeableObject(value) ? deepMergeInternal(emptyTarget(value), value, seen) : value\n}"
      },
      {
        "name": "mergeArrays",
        "line": 221,
        "params": [
          "target",
          "source",
          "seen"
        ],
        "source": "function mergeArrays (target, source, seen) {\n    return target.concat(source).map(element => cloneIfNeeded(element, seen))\n}"
      },
      {
        "name": "getKeys",
        "line": 226,
        "params": [
          "target"
        ],
        "source": "function getKeys (target) {\n    const symbols = Object.getOwnPropertySymbols\n        ? Object.getOwnPropertySymbols(target).filter(symbol =>\n            Object.propertyIsEnumerable.call(target, symbol))\n        : []\n    return Object.keys(target).concat(symbols)\n}"
      },
      {
        "name": "mergeObject",
        "line": 235,
        "params": [
          "target",
          "source",
          "seen"
        ],
        "source": "function mergeObject (target, source, seen) {\n    const destination = {}\n\n    if (isMergeableObject(target)) {\n        getKeys(target).forEach(key => {\n            destination[key] = cloneIfNeeded(target[key], seen)\n        })\n    }\n\n    getKeys(source).forEach(key => {\n        if ((key in target) && isMergeableObject(source[key])) {\n            destination[key] = deepMergeInternal(target[key], source[key], seen)\n        } else {\n            destination[key] = cloneIfNeeded(source[key], seen)\n        }\n    })\n\n    return destination\n}"
      },
      {
        "name": "formatNumber",
        "line": 256,
        "params": [
          "n"
        ],
        "source": "function formatNumber (n) {\n    if (typeof n !== 'number') {\n        return String(n)\n    }\n    return Number.isInteger(n) ? String(n) : n.toFixed(2)\n}"
      },
      {
        "name": "formatBytes",
        "line": 264,
        "params": [
          "bytes"
        ],
        "source": "function formatBytes (bytes) {\n    if (bytes === 0) {\n        return '0 B'\n    }\n\n    const units = ['B', 'KB', 'MB', 'GB']\n    const i = Math.floor(Math.log(bytes) / Math.log(1024))\n    const value = bytes / Math.pow(1024, i)\n\n    return `${value.toFixed(i > 1 ? 2 : 0)} ${units[i]}`\n}"
      },
      {
        "name": "delegateProperties",
        "line": 277,
        "params": [
          "receiver",
          "source",
          "names"
        ],
        "source": "function delegateProperties (receiver, source, names) {\n    if (Array.isArray(names)) {\n        names.forEach(name => delegateProperty(receiver, source, name, name))\n    } else if (typeof names === 'object') {\n        Object.entries(names).forEach(([sourceName, receiverName]) => {\n            delegateProperty(receiver, source, sourceName, receiverName)\n        })\n    }\n}"
      },
      {
        "name": "delegateProperty",
        "line": 288,
        "params": [
          "receiver",
          "source",
          "sourceName",
          "receiverName"
        ],
        "source": "function delegateProperty (receiver, source, sourceName, receiverName) {\n    const descriptor = Object.getOwnPropertyDescriptor(source, sourceName)\n\n    if (descriptor && (descriptor.get || descriptor.set)) {\n        Object.defineProperty(receiver, receiverName, {\n            get: descriptor.get ? descriptor.get.bind(source) : undefined,\n            set: descriptor.set ? descriptor.set.bind(source) : undefined,\n            enumerable: true,\n            configurable: true\n        })\n    } else if (typeof source[sourceName] === 'function') {\n        receiver[receiverName] = source[sourceName].bind(source)\n    } else {\n        Object.defineProperty(receiver, receiverName, {\n            get: () => source[sourceName],\n            set: (value) => {\n                source[sourceName] = value\n            },\n            enumerable: true,\n            configurable: true\n        })\n    }\n}"
      }
    ],
    "exports": []
  },
  "/core/action_controller.doc.js": {
    "type": "class",
    "file": "/core/action_controller.js",
    "name": "ActionController",
    "line": 5,
    "extends": "PerkyModule",
    "statics": [
      {
        "name": "propagable",
        "line": 7,
        "source": "static propagable = []",
        "kind": "property",
        "value": "[]"
      },
      {
        "name": "bindings",
        "line": 8,
        "source": "static bindings = {}",
        "kind": "property",
        "value": "{}"
      },
      {
        "name": "resources",
        "line": 9,
        "source": "static resources = []",
        "kind": "property",
        "value": "[]"
      },
      {
        "name": "$category",
        "line": 10,
        "source": "static $category = 'actionController'",
        "kind": "property",
        "value": "'actionController'"
      },
      {
        "name": "normalizeBindings",
        "line": 112,
        "source": "static normalizeBindings (controllerName) {\n    const bindings = this.bindings\n    const normalized = []\n\n    for (const [actionName, bindingDef] of Object.entries(bindings)) {\n        const bindingConfigs = normalizeBindingDefinition(bindingDef)\n\n        for (const config of bindingConfigs) {\n            normalized.push({\n                action: actionName,\n                key: config.key,\n                scoped: config.scoped ?? false,\n                eventType: config.eventType ?? 'pressed',\n                controllerName: config.scoped ? controllerName : null\n            })\n        }\n    }\n\n    return normalized\n}",
        "kind": "method",
        "params": [
          "controllerName"
        ]
      },
      {
        "name": "actionControllerMethods",
        "line": 133,
        "source": "static actionControllerMethods = this.perkyModuleMethods.concat([\n    'addAction',\n    'getAction',\n    'removeAction',\n    'hasAction',\n    'shouldPropagate',\n    'listActions',\n    'listActionsWithParams',\n    'execute',\n    'engine'\n])",
        "kind": "property",
        "value": "this.perkyModuleMethods.concat([\n    'addAction',\n    'getAction',\n    'removeAction',\n    'hasAction',\n    'shouldPropagate',\n    'listActions',\n    'listActionsWithParams',\n    'execute',\n    'engine'\n])"
      }
    ],
    "methods": [
      {
        "name": "addAction",
        "line": 51,
        "source": "addAction (actionName, action) {\n    if (!this.#actionList.includes(actionName)) {\n        this.#actionList.push(actionName)\n    }\n    return this.#actions.set(actionName, action)\n}",
        "kind": "method",
        "params": [
          "actionName",
          "action"
        ]
      },
      {
        "name": "getAction",
        "line": 59,
        "source": "getAction (actionName) {\n    return this.#actions.get(actionName)\n}",
        "kind": "method",
        "params": [
          "actionName"
        ]
      },
      {
        "name": "removeAction",
        "line": 64,
        "source": "removeAction (actionName) {\n    return this.#actions.delete(actionName)\n}",
        "kind": "method",
        "params": [
          "actionName"
        ]
      },
      {
        "name": "hasAction",
        "line": 69,
        "source": "hasAction (actionName) {\n    return this.getAction(actionName) !== undefined || typeof this[actionName] === 'function'\n}",
        "kind": "method",
        "params": [
          "actionName"
        ]
      },
      {
        "name": "shouldPropagate",
        "line": 74,
        "source": "shouldPropagate (actionName) {\n    const ControllerClass = this.constructor\n    return ControllerClass.propagable && Array.isArray(ControllerClass.propagable)\n        ? ControllerClass.propagable.includes(actionName)\n        : false\n}",
        "kind": "method",
        "params": [
          "actionName"
        ]
      },
      {
        "name": "listActions",
        "line": 82,
        "source": "listActions () {\n    return [...this.#actionList]\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "listActionsWithParams",
        "line": 87,
        "source": "listActionsWithParams () {\n    const result = []\n\n    for (const actionName of this.#actionList) {\n        const action = this.getAction(actionName) || this[actionName]\n        const params = typeof action === 'function' ? extractFunctionParams(action) : []\n        result.push({name: actionName, params})\n    }\n\n    return result\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "execute",
        "line": 100,
        "source": "execute (actionName, ...args) {\n    const action = this.getAction(actionName) || this[actionName]\n\n    if (typeof action === 'function') {\n        action.call(this, ...args)\n    }\n\n    this.emit(actionName, ...args)\n    this.emit('action', actionName, ...args)\n}",
        "kind": "method",
        "params": [
          "actionName",
          "...args"
        ]
      }
    ],
    "getters": [
      {
        "name": "engine",
        "line": 23,
        "source": "get engine () {\n    return this.#engine ?? this.host?.engine ?? this.host?.host ?? this.host\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "engine",
        "line": 28,
        "source": "set engine (value) {\n    this.#engine = value\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      }
    ],
    "constructor": {
      "name": "constructor",
      "line": 16,
      "source": "constructor (options = {}) {\n    super(options)\n    this.#actionList = extractPrototypeMethods(this)\n    this.#defineResourceGetters()\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/core/action_dispatcher.doc.js": {
    "type": "class",
    "file": "/core/action_dispatcher.js",
    "name": "ActionDispatcher",
    "line": 6,
    "extends": "PerkyModule",
    "statics": [
      {
        "name": "$category",
        "line": 8,
        "source": "static $category = 'actionDispatcher'",
        "kind": "property",
        "value": "'actionDispatcher'"
      }
    ],
    "methods": [
      {
        "name": "onInstall",
        "line": 12,
        "source": "onInstall (host) {\n    this.listenTo(host, 'input:triggered', this.dispatchAction.bind(this))\n\n    this.delegateTo(host, {\n        register: 'registerController',\n        unregister: 'unregisterController',\n        getController: 'getController',\n        list: 'listControllers',\n        setActive: 'setActiveControllers',\n        getActive: 'getActiveControllers',\n        pushActive: 'pushActiveController',\n        popActive: 'popActiveController',\n        clearActive: 'clearActiveControllers',\n        execute: 'execute',\n        executeTo: 'executeTo',\n        dispatchAction: 'dispatchAction',\n        listActions: 'listAllActions',\n        mainController: 'mainController',\n        addAction: 'addAction',\n        removeAction: 'removeAction'\n    })\n}",
        "kind": "method",
        "params": [
          "host"
        ]
      },
      {
        "name": "addAction",
        "line": 47,
        "source": "addAction (actionName, action) {\n    if (!this.mainController) {\n        logger.warn('No main controller available. Cannot add action.')\n        return false\n    }\n    return this.mainController.addAction(actionName, action)\n}",
        "kind": "method",
        "params": [
          "actionName",
          "action"
        ]
      },
      {
        "name": "removeAction",
        "line": 56,
        "source": "removeAction (actionName) {\n    if (!this.mainController) {\n        logger.warn('No main controller available. Cannot remove action.')\n        return false\n    }\n    return this.mainController.removeAction(actionName)\n}",
        "kind": "method",
        "params": [
          "actionName"
        ]
      },
      {
        "name": "register",
        "line": 65,
        "source": "register (nameOrController, ControllerOrOptions = ActionController, maybeOptions = {}) {\n    let name\n    let Controller\n    let options\n\n    if (typeof nameOrController === 'string') {\n        name = nameOrController\n        Controller = ControllerOrOptions\n        options = maybeOptions\n    } else if (typeof nameOrController === 'function') {\n        Controller = nameOrController\n        options = typeof ControllerOrOptions === 'object' ? ControllerOrOptions : {}\n        name = options.name || Controller.$name || resolveControllerName(Controller)\n    } else {\n        return null\n    }\n\n    const controller = this.create(Controller, {\n        $id: name,\n        $category: 'controller'\n    })\n\n    if (options.active !== false && this.#activeControllers.length === 1) {\n        this.pushActive(name)\n    }\n\n    this.emit('controller:set', name, controller)\n\n    return controller\n}",
        "kind": "method",
        "params": [
          "nameOrController",
          "ControllerOrOptions = ...",
          "maybeOptions = ..."
        ]
      },
      {
        "name": "unregister",
        "line": 97,
        "source": "unregister (name) {\n    const controller = this.getChild(name)\n\n    if (!controller) {\n        return false\n    }\n\n    const stackIndex = this.#activeControllers.indexOf(name)\n    if (stackIndex !== -1) {\n        this.#activeControllers.splice(stackIndex, 1)\n    }\n\n    return this.removeChild(name)\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "getController",
        "line": 113,
        "source": "getController (name) {\n    return this.getChild(name)\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "setActive",
        "line": 118,
        "source": "setActive (names) {\n    const nameArray = Array.isArray(names) ? names : [names]\n\n    for (const name of nameArray) {\n        if (!this.hasChild(name)) {\n            logger.warn(`Controller \"${name}\" not found. Cannot set as active controller.`)\n            return false\n        }\n    }\n\n    this.#activeControllers = [...nameArray]\n    this.emit('controllers:activated', nameArray)\n\n    return true\n}",
        "kind": "method",
        "params": [
          "names"
        ]
      },
      {
        "name": "getActive",
        "line": 135,
        "source": "getActive () {\n    return [...this.#activeControllers]\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "pushActive",
        "line": 140,
        "source": "pushActive (name) {\n    if (!this.hasChild(name)) {\n        logger.warn(`Controller \"${name}\" not found`)\n        return false\n    }\n\n    if (this.#activeControllers.includes(name)) {\n        return false\n    }\n\n    this.#activeControllers.push(name)\n    this.emit('controller:pushed', name, this.#activeControllers.length)\n\n    return true\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "popActive",
        "line": 157,
        "source": "popActive () {\n    if (this.#activeControllers.length === 0) {\n        logger.warn('Active controllers stack is empty')\n        return null\n    }\n\n    const popped = this.#activeControllers.pop()\n    this.emit('controller:popped', popped, this.#activeControllers.length)\n\n    return popped\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "clearActive",
        "line": 170,
        "source": "clearActive () {\n    this.#activeControllers = []\n    this.emit('controllers:cleared')\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "execute",
        "line": 176,
        "source": "execute (actionName, ...args) {\n    if (this.#activeControllers.length === 0) {\n        logger.warn('No active controllers')\n        return\n    }\n\n    const registry = this.childrenRegistry\n\n    for (let i = this.#activeControllers.length - 1; i >= 0; i--) {\n        const controllerName = this.#activeControllers[i]\n        const controller = registry.get(controllerName)\n\n        if (!controller) {\n            logger.warn(`Controller \"${controllerName}\" not found in registry but present in active stack`)\n            continue\n        }\n\n        const hasAction = controller.hasAction(actionName)\n\n        controller.execute(actionName, ...args)\n\n        if (hasAction && !controller.shouldPropagate(actionName)) {\n            return\n        }\n    }\n}",
        "kind": "method",
        "params": [
          "actionName",
          "...args"
        ]
      },
      {
        "name": "executeTo",
        "line": 204,
        "source": "executeTo (name, actionName, ...args) {\n    const controller = this.getController(name)\n\n    if (controller && this.#isControllerActive(name)) {\n        if (typeof controller.execute === 'function') {\n            controller.execute(actionName, ...args)\n        } else if (typeof controller[actionName] === 'function') {\n            controller[actionName](...args)\n        }\n    }\n}",
        "kind": "method",
        "params": [
          "name",
          "actionName",
          "...args"
        ]
      },
      {
        "name": "dispatchAction",
        "line": 217,
        "source": "dispatchAction (binding, ...args) {\n    if (binding.controllerName) {\n        this.executeTo(binding.controllerName, binding.actionName, ...args)\n    } else {\n        this.execute(binding.actionName, ...args)\n    }\n}",
        "kind": "method",
        "params": [
          "binding",
          "...args"
        ]
      },
      {
        "name": "listControllers",
        "line": 231,
        "source": "listControllers () {\n    return this.listNamesFor('controller')\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "listAllActions",
        "line": 236,
        "source": "listAllActions () {\n    const allActions = new Map()\n    const registry = this.childrenRegistry\n\n    for (const [name, controller] of registry.entries) {\n        if (typeof controller.listActionsWithParams === 'function') {\n            allActions.set(name, controller.listActionsWithParams())\n        } else if (typeof controller.listActions === 'function') {\n            allActions.set(name, controller.listActions().map(n => ({name: n, params: []})))\n        }\n    }\n\n    return allActions\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "engine",
        "line": 36,
        "source": "get engine () {\n    return this.host\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "mainController",
        "line": 41,
        "source": "get mainController () {\n    const controllers = this.listControllers()\n    return controllers.length > 0 ? this.getController(controllers[0]) : null\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [],
    "constructor": null,
    "isDefault": true
  },
  "/core/inflector.doc.js": {
    "type": "class",
    "file": "/core/inflector.js",
    "name": "Inflector",
    "line": 1,
    "extends": null,
    "statics": [],
    "methods": [
      {
        "name": "plural",
        "line": 17,
        "source": "plural (word) {\n    return this.#replaceWord(\n        this.#irregularSingles,\n        this.#irregularPlurals,\n        this.#pluralRules\n    )(word)\n}",
        "kind": "method",
        "params": [
          "word"
        ]
      },
      {
        "name": "singular",
        "line": 26,
        "source": "singular (word) {\n    return this.#replaceWord(\n        this.#irregularPlurals,\n        this.#irregularSingles,\n        this.#singularRules\n    )(word)\n}",
        "kind": "method",
        "params": [
          "word"
        ]
      },
      {
        "name": "isPlural",
        "line": 35,
        "source": "isPlural (word) {\n    return this.#checkWord(\n        this.#irregularSingles,\n        this.#irregularPlurals,\n        this.#pluralRules\n    )(word)\n}",
        "kind": "method",
        "params": [
          "word"
        ]
      },
      {
        "name": "isSingular",
        "line": 44,
        "source": "isSingular (word) {\n    return this.#checkWord(\n        this.#irregularPlurals,\n        this.#irregularSingles,\n        this.#singularRules\n    )(word)\n}",
        "kind": "method",
        "params": [
          "word"
        ]
      },
      {
        "name": "pluralize",
        "line": 53,
        "source": "pluralize (word, count, inclusive) {\n    const pluralized = count === 1 ? this.singular(word) : this.plural(word)\n    return (inclusive ? count + ' ' : '') + pluralized\n}",
        "kind": "method",
        "params": [
          "word",
          "count",
          "inclusive"
        ]
      },
      {
        "name": "toCamelCase",
        "line": 59,
        "source": "toCamelCase (string) { // eslint-disable-line local/class-methods-use-this -- clean\n    return string\n        .replace(/[-_\\s]([a-z])/g, (match, letter) => letter.toUpperCase())\n        .replace(/^[A-Z]/, letter => letter.toLowerCase())\n}",
        "kind": "method",
        "params": [
          "string"
        ]
      },
      {
        "name": "toPascalCase",
        "line": 66,
        "source": "toPascalCase (string) {\n    return this.toCamelCase(string).replace(/^[a-z]/, letter => letter.toUpperCase())\n}",
        "kind": "method",
        "params": [
          "string"
        ]
      },
      {
        "name": "toSnakeCase",
        "line": 71,
        "source": "toSnakeCase (string) { // eslint-disable-line local/class-methods-use-this -- clean\n    return string\n        .replace(/[-\\s]/g, '_')\n        .replace(/([A-Z])([A-Z][a-z])/g, '$1_$2')\n        .replace(/([a-z])([A-Z])/g, '$1_$2')\n        .replace(/([a-z])(\\d+[A-Z])$/g, '$1_$2')\n        .replace(/(\\d)([A-Z][a-z])/g, '$1_$2')\n        .toLowerCase()\n        .replace(/^_/, '')\n}",
        "kind": "method",
        "params": [
          "string"
        ]
      },
      {
        "name": "toKebabCase",
        "line": 83,
        "source": "toKebabCase (string) { // eslint-disable-line local/class-methods-use-this -- clean\n    return string\n        .replace(/[_\\s]/g, '-')\n        .replace(/([A-Z])([A-Z][a-z])/g, '$1-$2')\n        .replace(/([a-z])([A-Z])/g, '$1-$2')\n        .replace(/([a-z])(\\d+[A-Z])$/g, '$1-$2')\n        .replace(/(\\d)([A-Z][a-z])/g, '$1-$2')\n        .toLowerCase()\n        .replace(/^-/, '')\n}",
        "kind": "method",
        "params": [
          "string"
        ]
      },
      {
        "name": "toHumanCase",
        "line": 95,
        "source": "toHumanCase (string) { // eslint-disable-line local/class-methods-use-this -- clean\n    return string\n        .replace(/[-_]/g, ' ')\n        .replace(/([A-Z])([A-Z][a-z])/g, '$1 $2')\n        .replace(/([a-z])([A-Z])/g, '$1 $2')\n        .replace(/([a-z])(\\d+[A-Z])$/g, '$1 $2')\n        .replace(/(\\d)([A-Z][a-z])/g, '$1 $2')\n        .replace(/^\\s+/, '')\n        .replace(/\\s+/g, ' ')\n}",
        "kind": "method",
        "params": [
          "string"
        ]
      },
      {
        "name": "addPluralRule",
        "line": 107,
        "source": "addPluralRule (rule, replacement) {\n    this.#pluralRules.push([sanitizeRule(rule), replacement])\n}",
        "kind": "method",
        "params": [
          "rule",
          "replacement"
        ]
      },
      {
        "name": "addSingularRule",
        "line": 112,
        "source": "addSingularRule (rule, replacement) {\n    this.#singularRules.push([sanitizeRule(rule), replacement])\n}",
        "kind": "method",
        "params": [
          "rule",
          "replacement"
        ]
      },
      {
        "name": "addUncountableRule",
        "line": 117,
        "source": "addUncountableRule (word) {\n    if (typeof word === 'string') {\n        this.#uncountables[word.toLowerCase()] = true\n        return\n    }\n\n    this.addPluralRule(word, '$0')\n    this.addSingularRule(word, '$0')\n}",
        "kind": "method",
        "params": [
          "word"
        ]
      },
      {
        "name": "addIrregularRule",
        "line": 128,
        "source": "addIrregularRule (single, pluralForm) {\n    const s = single.toLowerCase()\n    const p = pluralForm.toLowerCase()\n\n    this.#irregularSingles[s] = p\n    this.#irregularPlurals[p] = s\n}",
        "kind": "method",
        "params": [
          "single",
          "pluralForm"
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 9,
      "source": "constructor () {\n    this.#loadIrregulars()\n    this.#loadPlurals()\n    this.#loadSingulars()\n    this.#loadUncountables()\n}",
      "kind": "constructor",
      "params": []
    },
    "isDefault": true
  },
  "/core/logger.doc.js": {
    "type": "class",
    "file": "/core/logger.js",
    "name": "Logger",
    "line": 13,
    "extends": "Notifier",
    "statics": [],
    "methods": [
      {
        "name": "log",
        "line": 70,
        "source": "log (...items) {\n    this.#emit('notice', ...items)\n}",
        "kind": "method",
        "params": [
          "...items"
        ]
      },
      {
        "name": "info",
        "line": 75,
        "source": "info (...items) {\n    this.#emit('info', ...items)\n}",
        "kind": "method",
        "params": [
          "...items"
        ]
      },
      {
        "name": "notice",
        "line": 80,
        "source": "notice (...items) {\n    this.#emit('notice', ...items)\n}",
        "kind": "method",
        "params": [
          "...items"
        ]
      },
      {
        "name": "warn",
        "line": 85,
        "source": "warn (...items) {\n    this.#emit('warn', ...items)\n}",
        "kind": "method",
        "params": [
          "...items"
        ]
      },
      {
        "name": "error",
        "line": 90,
        "source": "error (...items) {\n    this.#emit('error', ...items)\n}",
        "kind": "method",
        "params": [
          "...items"
        ]
      },
      {
        "name": "success",
        "line": 95,
        "source": "success (...items) {\n    this.#emit('success', ...items)\n}",
        "kind": "method",
        "params": [
          "...items"
        ]
      },
      {
        "name": "clear",
        "line": 100,
        "source": "clear () {\n    const entry = {event: 'clear', timestamp: Date.now()}\n    this.#record(entry)\n    this.emit('clear', entry)\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "spacer",
        "line": 107,
        "source": "spacer () {\n    const entry = {event: 'spacer', timestamp: Date.now()}\n    this.#record(entry)\n    this.emit('spacer', entry)\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "title",
        "line": 114,
        "source": "title (title) {\n    const entry = {event: 'title', title, timestamp: Date.now()}\n    this.#record(entry)\n    this.emit('title', entry)\n}",
        "kind": "method",
        "params": [
          "title"
        ]
      },
      {
        "name": "clearHistory",
        "line": 121,
        "source": "clearHistory () {\n    this.#history = []\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "history",
        "line": 19,
        "source": "get history () {\n    return this.#history\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "maxHistory",
        "line": 24,
        "source": "get maxHistory () {\n    return this.#maxHistory\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "consoleOutput",
        "line": 35,
        "source": "get consoleOutput () {\n    return this.#consoleOutput\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "maxHistory",
        "line": 29,
        "source": "set maxHistory (value) {\n    this.#maxHistory = value\n    this.#trimHistory()\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "consoleOutput",
        "line": 40,
        "source": "set consoleOutput (value) {\n    this.#consoleOutput = value\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      }
    ],
    "constructor": null
  },
  "/core/notifier.doc.js": {
    "type": "class",
    "file": "/core/notifier.js",
    "name": "Notifier",
    "line": 2,
    "extends": null,
    "statics": [
      {
        "name": "notifierMethods",
        "line": 143,
        "source": "static notifierMethods = [\n    'getListenersFor',\n    'on',\n    'once',\n    'off',\n    'emit',\n    'emitter',\n    'listenTo',\n    'listenToOnce',\n    'cleanExternalListeners',\n    'removeListeners',\n    'removeListenersFor',\n    'delegateEvents'\n]",
        "kind": "property",
        "value": "[\n    'getListenersFor',\n    'on',\n    'once',\n    'off',\n    'emit',\n    'emitter',\n    'listenTo',\n    'listenToOnce',\n    'cleanExternalListeners',\n    'removeListeners',\n    'removeListenersFor',\n    'delegateEvents'\n]"
      }
    ],
    "methods": [
      {
        "name": "getListenersFor",
        "line": 7,
        "source": "getListenersFor (name) {\n    return this.#listenersFor[name]\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "on",
        "line": 12,
        "source": "on (name, listener) {\n    if (typeof listener !== 'function') {\n        throw new TypeError('Listener must be a function')\n    }\n\n    if (!this.#listenersFor[name]) {\n        this.#listenersFor[name] = []\n    }\n\n    this.#listenersFor[name].push(listener)\n\n    return listener\n}",
        "kind": "method",
        "params": [
          "name",
          "listener"
        ]
      },
      {
        "name": "once",
        "line": 27,
        "source": "once (name, listener) {\n    if (typeof listener !== 'function') {\n        throw new TypeError('Listener must be a function')\n    }\n\n    const onceWrapper = (...args) => {\n        listener(...args)\n        this.off(name, onceWrapper)\n    }\n\n    return this.on(name, onceWrapper)\n}",
        "kind": "method",
        "params": [
          "name",
          "listener"
        ]
      },
      {
        "name": "off",
        "line": 41,
        "source": "off (name, listener) {\n    const listeners = this.getListenersFor(name)\n\n    if (typeof listener === 'undefined') {\n        return this.removeListenersFor(name)\n    } else if (Array.isArray(listeners)) {\n        const index = listeners.indexOf(listener)\n\n        if (index !== -1) {\n            listeners.splice(index, 1)\n            return true\n        }\n    }\n\n    return false\n}",
        "kind": "method",
        "params": [
          "name",
          "listener"
        ]
      },
      {
        "name": "emit",
        "line": 59,
        "source": "emit (name, ...args) {\n    const listeners = this.getListenersFor(name)\n    if (!listeners) {\n        return\n    }\n\n    const listenersCopy = [...listeners]\n\n    for (const listener of listenersCopy) {\n        listener.call(this, ...args)\n    }\n}",
        "kind": "method",
        "params": [
          "name",
          "...args"
        ]
      },
      {
        "name": "emitter",
        "line": 73,
        "source": "emitter (name) {\n    return (...args) => this.emit(name, ...args)\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "listenTo",
        "line": 78,
        "source": "listenTo (target, eventName, callback) {\n    target.on(eventName, callback)\n    this.#externalListeners.push({target, eventName, callback})\n}",
        "kind": "method",
        "params": [
          "target",
          "eventName",
          "callback"
        ]
      },
      {
        "name": "listenToOnce",
        "line": 84,
        "source": "listenToOnce (target, eventName, callback) {\n    const onceWrapper = (...args) => {\n        callback(...args)\n\n        target.off(eventName, onceWrapper)\n\n        const index = this.#externalListeners.findIndex(\n            l => l.target === target && l.eventName === eventName && l.callback === onceWrapper\n        )\n        if (index !== -1) {\n            this.#externalListeners.splice(index, 1)\n        }\n    }\n\n    target.on(eventName, onceWrapper)\n    this.#externalListeners.push({target, eventName, callback: onceWrapper})\n}",
        "kind": "method",
        "params": [
          "target",
          "eventName",
          "callback"
        ]
      },
      {
        "name": "cleanExternalListeners",
        "line": 103,
        "source": "cleanExternalListeners () {\n    this.#externalListeners.forEach(({target, eventName, callback}) => {\n        target.off(eventName, callback)\n    })\n    this.#externalListeners = []\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "removeListeners",
        "line": 111,
        "source": "removeListeners () {\n    Object.keys(this.#listenersFor).forEach(name => this.removeListenersFor(name))\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "removeListenersFor",
        "line": 116,
        "source": "removeListenersFor (name) {\n    const listeners = this.getListenersFor(name)\n\n    if (listeners) {\n        listeners.length = 0\n        delete this.#listenersFor[name]\n        return true\n    }\n\n    return false\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "delegateEvents",
        "line": 129,
        "source": "delegateEvents (target, events, namespace) {\n    if (!target || (!Array.isArray(events) && typeof events !== 'object')) {\n        return\n    }\n\n    const eventArray = Array.isArray(events) ? events : Object.keys(events)\n    eventArray.forEach((event) => {\n        this.listenTo(target, event, (...args) => {\n            const prefixedEvent = namespace ? `${namespace}:${event}` : event\n            this.emit(prefixedEvent, ...args)\n        })\n    })\n}",
        "kind": "method",
        "params": [
          "target",
          "events",
          "namespace"
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": null,
    "isDefault": true
  },
  "/core/observable_map.doc.js": {
    "type": "class",
    "file": "/core/observable_map.js",
    "name": "ObservableMap",
    "line": 4,
    "extends": "Notifier",
    "statics": [],
    "methods": [
      {
        "name": "get",
        "line": 49,
        "source": "get (key) {\n    return this.#map.get(key)\n}",
        "kind": "method",
        "params": [
          "key"
        ]
      },
      {
        "name": "has",
        "line": 54,
        "source": "has (key) {\n    return this.#map.has(key)\n}",
        "kind": "method",
        "params": [
          "key"
        ]
      },
      {
        "name": "hasValue",
        "line": 59,
        "source": "hasValue (value) {\n    return this.#values.has(value)\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "keyFor",
        "line": 64,
        "source": "keyFor (value) {\n    return this.#keyByValue.get(value)\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "hasEntry",
        "line": 69,
        "source": "hasEntry (key, value) {\n    return this.get(key) === value\n}",
        "kind": "method",
        "params": [
          "key",
          "value"
        ]
      },
      {
        "name": "isKeyOf",
        "line": 74,
        "source": "isKeyOf (key, value) {\n    return this.keyFor(value) === key\n}",
        "kind": "method",
        "params": [
          "key",
          "value"
        ]
      },
      {
        "name": "forEach",
        "line": 79,
        "source": "forEach (callbackFn, thisArg) {\n    this.#map.forEach(callbackFn, thisArg)\n}",
        "kind": "method",
        "params": [
          "callbackFn",
          "thisArg"
        ]
      },
      {
        "name": "set",
        "line": 84,
        "source": "set (key, value) {\n    const exists = this.#map.has(key)\n    const oldValue = exists ? this.#map.get(key) : undefined\n    const isReplacing = exists && oldValue !== value\n\n    this.#map.set(key, value)\n    this.#values.add(value)\n    this.#keyByValue.set(value, key)\n\n    if (isReplacing) {\n        this.#removeFromValues(oldValue)\n        this.emit('delete', key, oldValue)\n    }\n\n    this.emit('set', key, value, oldValue)\n\n    return true\n}",
        "kind": "method",
        "params": [
          "key",
          "value"
        ]
      },
      {
        "name": "delete",
        "line": 104,
        "source": "delete (key) {\n    const exists = this.#map.has(key)\n\n    if (!exists) {\n        return false\n    }\n\n    const value = this.#map.get(key)\n    const deleted = this.#map.delete(key)\n\n    if (deleted) {\n        this.#removeFromValues(value)\n        this.emit('delete', key, value)\n    }\n\n    return deleted\n}",
        "kind": "method",
        "params": [
          "key"
        ]
      },
      {
        "name": "updateKey",
        "line": 123,
        "source": "updateKey (oldKey, newKey, item) {\n    if (!this.has(oldKey)) {\n        return false\n    }\n\n    if (oldKey === newKey) {\n        return false\n    }\n\n    const value = this.get(oldKey)\n\n    if (item !== undefined && value !== item) {\n        return false\n    }\n\n    this.#map.delete(oldKey)\n    this.#map.set(newKey, value)\n\n    this.emit('key:updated', oldKey, newKey, value)\n\n    return true\n}",
        "kind": "method",
        "params": [
          "oldKey",
          "newKey",
          "item"
        ]
      },
      {
        "name": "clear",
        "line": 147,
        "source": "clear () {\n    if (this.#map.size > 0) {\n        const itemsToDelete = Array.from(this.#map.entries())\n        itemsToDelete.forEach(([key, value]) => {\n            this.emit('delete', key, value)\n        })\n\n        this.#map.clear()\n        this.#values.clear()\n        this.#keyByValue.clear()\n\n        this.emit('clear')\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "addCollection",
        "line": 174,
        "source": "addCollection (collection) {\n    if (!collection || typeof collection !== 'object') {\n        return false\n    }\n\n    if (typeof collection.forEach === 'function') {\n        collection.forEach((value, key) => {\n            this.set(key, value)\n        })\n    } else {\n        for (const key in collection) {\n            if (Object.prototype.hasOwnProperty.call(collection, key)) {\n                this.set(key, collection[key])\n            }\n        }\n    }\n\n    return true\n}",
        "kind": "method",
        "params": [
          "collection"
        ]
      },
      {
        "name": "toObject",
        "line": 195,
        "source": "toObject () {\n    const object = {}\n    this.#map.forEach((value, key) => {\n        object[key] = value\n    })\n    return object\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "size",
        "line": 19,
        "source": "get size () {\n    return this.#map.size\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "entries",
        "line": 24,
        "source": "get entries () {\n    return Array.from(this.#map.entries())\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "keys",
        "line": 29,
        "source": "get keys () {\n    return this.#map.keys()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "values",
        "line": 34,
        "source": "get values () {\n    return this.#map.values()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "all",
        "line": 39,
        "source": "get all () {\n    return Array.from(this.#map.values())\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "map",
        "line": 44,
        "source": "get map () {\n    return this.#map\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 10,
      "source": "constructor (collection) {\n    super()\n\n    if (collection) {\n        this.addCollection(collection)\n    }\n}",
      "kind": "constructor",
      "params": [
        "collection"
      ]
    },
    "isDefault": true
  },
  "/core/observable_set.doc.js": {
    "type": "class",
    "file": "/core/observable_set.js",
    "name": "ObservableSet",
    "line": 4,
    "extends": "Notifier",
    "statics": [],
    "methods": [
      {
        "name": "add",
        "line": 24,
        "source": "add (value) {\n    if (!this.#set.has(value)) {\n        this.#set.add(value)\n        this.emit('add', value)\n    }\n    return this\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "delete",
        "line": 33,
        "source": "delete (value) {\n    const deleted = this.#set.delete(value)\n    if (deleted) {\n        this.emit('delete', value)\n    }\n    return deleted\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "clear",
        "line": 42,
        "source": "clear () {\n    if (this.#set.size > 0) {\n        const values = Array.from(this.#set)\n        this.#set.clear()\n        this.emit('clear', values)\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "has",
        "line": 51,
        "source": "has (value) {\n    return this.#set.has(value)\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "values",
        "line": 56,
        "source": "values () {\n    return this.#set.values()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "keys",
        "line": 61,
        "source": "keys () {\n    return this.#set.keys()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "entries",
        "line": 66,
        "source": "entries () {\n    return this.#set.entries()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "forEach",
        "line": 71,
        "source": "forEach (callbackFn, thisArg) {\n    this.#set.forEach(callbackFn, thisArg)\n}",
        "kind": "method",
        "params": [
          "callbackFn",
          "thisArg"
        ]
      },
      {
        "name": "toArray",
        "line": 81,
        "source": "toArray () {\n    return Array.from(this.#set)\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "size",
        "line": 19,
        "source": "get size () {\n    return this.#set.size\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 8,
      "source": "constructor (values) {\n    super()\n\n    if (values) {\n        for (const value of values) {\n            this.#set.add(value)\n        }\n    }\n}",
      "kind": "constructor",
      "params": [
        "values"
      ]
    },
    "isDefault": true
  },
  "/core/perky_query.doc.js": {
    "type": "module",
    "file": "/core/perky_query.js",
    "functions": [
      {
        "name": "parseSelector",
        "line": 18,
        "params": [
          "selector"
        ],
        "source": "function parseSelector (selector) {\n    const segments = selector.trim().split(/\\s+/)\n\n    return segments.map(segment => {\n        const conditions = []\n        let match\n\n        SELECTOR_REGEX.lastIndex = 0\n\n        while ((match = SELECTOR_REGEX.exec(segment)) !== null) {\n            const [, prefix, value] = match\n\n            conditions.push({\n                type: PREFIX_TO_TYPE[prefix],\n                value\n            })\n        }\n\n        return conditions\n    }).filter(segment => segment.length > 0)\n}"
      },
      {
        "name": "matchesConditions",
        "line": 41,
        "params": [
          "module",
          "conditions"
        ],
        "source": "function matchesConditions (module, conditions) {\n    return conditions.every(({type, value}) => {\n        const matcher = TYPE_MATCHERS[type]\n        return matcher ? matcher(module, value) : false\n    })\n}"
      },
      {
        "name": "findMatchingChildren",
        "line": 49,
        "params": [
          "candidates",
          "conditions"
        ],
        "source": "function findMatchingChildren (candidates, conditions) {\n    return candidates.flatMap(candidate => {\n        const children = candidate.children || []\n        return children.filter(child => matchesConditions(child, conditions))\n    })\n}"
      },
      {
        "name": "query",
        "line": 57,
        "params": [
          "root",
          "selector"
        ],
        "source": "function query (root, selector) {\n    const segments = parseSelector(selector)\n\n    if (segments.length === 0) {\n        return null\n    }\n\n    let candidates = [root]\n\n    for (const conditions of segments) {\n        candidates = findMatchingChildren(candidates, conditions)\n\n        if (candidates.length === 0) {\n            return null\n        }\n    }\n\n    return candidates[0] || null\n}"
      },
      {
        "name": "queryAll",
        "line": 78,
        "params": [
          "root",
          "selector"
        ],
        "source": "function queryAll (root, selector) {\n    const segments = parseSelector(selector)\n\n    if (segments.length === 0) {\n        return []\n    }\n\n    let candidates = [root]\n\n    for (const conditions of segments) {\n        candidates = findMatchingChildren(candidates, conditions)\n\n        if (candidates.length === 0) {\n            return []\n        }\n    }\n\n    return candidates\n}"
      }
    ],
    "exports": []
  },
  "/core/registry.doc.js": {
    "type": "class",
    "file": "/core/registry.js",
    "name": "Registry",
    "line": 4,
    "extends": "ObservableMap",
    "statics": [],
    "methods": [
      {
        "name": "addIndex",
        "line": 16,
        "source": "addIndex (name, keyFunction) {\n    if (keyFunction === undefined) {\n        keyFunction = name\n    }\n\n    if (typeof keyFunction === 'string') {\n        const propertyName = keyFunction\n        keyFunction = (item) => item[propertyName]\n    }\n\n    if (typeof keyFunction !== 'function') {\n        return false\n    }\n\n    const index = {\n        keyFn: keyFunction,\n        data: new Map()\n    }\n\n    this.#indexes.set(name, index)\n\n    for (const value of this.map.values()) {\n        this.#addToIndex(name, value)\n    }\n\n    return true\n}",
        "kind": "method",
        "params": [
          "name",
          "keyFunction"
        ]
      },
      {
        "name": "lookup",
        "line": 45,
        "source": "lookup (indexName, key) {\n    const index = this.#indexes.get(indexName)\n\n    if (!index) {\n        throw new Error(`Index '${indexName}' does not exist`)\n    }\n\n    const items = index.data.get(key)\n    return items ? Array.from(items) : []\n}",
        "kind": "method",
        "params": [
          "indexName",
          "key"
        ]
      },
      {
        "name": "lookupKeys",
        "line": 57,
        "source": "lookupKeys (indexName, key) {\n    const itemsSet = new Set(this.lookup(indexName, key))\n\n    if (itemsSet.size === 0) {\n        return []\n    }\n\n    const keys = []\n    for (const [k, v] of this.map.entries()) {\n        if (itemsSet.has(v)) {\n            keys.push(k)\n        }\n    }\n\n    return keys\n}",
        "kind": "method",
        "params": [
          "indexName",
          "key"
        ]
      },
      {
        "name": "hasIndex",
        "line": 75,
        "source": "hasIndex (name) {\n    return this.#indexes.has(name)\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "removeIndex",
        "line": 80,
        "source": "removeIndex (name) {\n    return this.#indexes.delete(name)\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "updateIndexFor",
        "line": 85,
        "source": "updateIndexFor (item, indexName, oldKeys, newKeys) {\n    if (!this.hasValue(item)) {\n        return false\n    }\n\n    const index = this.#indexes.get(indexName)\n    if (!index) {\n        return false\n    }\n\n    const oldKeysArray = Array.isArray(oldKeys) ? oldKeys : [oldKeys]\n    const newKeysArray = Array.isArray(newKeys) ? newKeys : [newKeys]\n\n    for (const oldKey of oldKeysArray) {\n        const items = index.data.get(oldKey)\n        if (items) {\n            items.delete(item)\n            if (items.size === 0) {\n                index.data.delete(oldKey)\n            }\n        }\n    }\n\n    for (const newKey of newKeysArray) {\n        if (!index.data.has(newKey)) {\n            index.data.set(newKey, new Set())\n        }\n        index.data.get(newKey).add(item)\n    }\n\n    return true\n}",
        "kind": "method",
        "params": [
          "item",
          "indexName",
          "oldKeys",
          "newKeys"
        ]
      },
      {
        "name": "refreshIndexFor",
        "line": 119,
        "source": "refreshIndexFor (value, indexName) {\n    if (!this.hasValue(value)) {\n        return false\n    }\n\n    const index = this.#indexes.get(indexName)\n    if (!index) {\n        return false\n    }\n\n    for (const [key, items] of index.data.entries()) {\n        if (items.has(value)) {\n            items.delete(value)\n            if (items.size === 0) {\n                index.data.delete(key)\n            }\n        }\n    }\n\n    this.#addToIndex(indexName, value)\n\n    return true\n}",
        "kind": "method",
        "params": [
          "value",
          "indexName"
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 8,
      "source": "constructor (collection) {\n    super(collection)\n\n    this.on('set', this.#handleSet)\n    this.on('delete', this.#handleDelete)\n}",
      "kind": "constructor",
      "params": [
        "collection"
      ]
    },
    "isDefault": true
  },
  "/application/application.doc.js": {
    "type": "class",
    "file": "/application/application.js",
    "name": "Application",
    "line": 12,
    "extends": "PerkyModule",
    "statics": [
      {
        "name": "$category",
        "line": 14,
        "source": "static $category = 'application'",
        "kind": "property",
        "value": "'application'"
      },
      {
        "name": "$eagerStart",
        "line": 16,
        "source": "static $eagerStart = false",
        "kind": "property",
        "value": "false"
      },
      {
        "name": "ActionController",
        "line": 18,
        "source": "static ActionController = ActionController",
        "kind": "property",
        "value": "ActionController"
      }
    ],
    "methods": [
      {
        "name": "preload",
        "line": 67,
        "source": "async preload () {\n    return this.loadTag('preload')\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 20,
      "source": "constructor (options = {}) {\n    super(options)\n\n    const manifestData = options.manifest || this.constructor.manifest || {}\n\n    this.create(Manifest, {\n        $bind: 'manifest',\n        data: manifestData.export ? manifestData.export() : manifestData\n    })\n\n    this.create(ActionDispatcher, {\n        $bind: 'actionDispatcher'\n    })\n\n    this.create(PerkyView, {\n        $bind: 'perkyView',\n        className: 'perky-application'\n    })\n\n    this.create(SourceManager, {\n        $bind: 'sourceManager',\n        loaders: new Registry(loaders),\n        manifest: this.manifest\n    })\n\n    this.create(InputSystem, {\n        $bind: 'inputSystem',\n        bindings: options.bindings\n    })\n\n    this.actionDispatcher.on('controller:set', this.#autoRegisterBindings.bind(this))\n\n    this.#createMainController()\n\n    this.configureApplication?.(options)\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/application/application_manager.doc.js": {
    "type": "class",
    "file": "/application/application_manager.js",
    "name": "ApplicationManager",
    "line": 5,
    "extends": "PerkyModule",
    "statics": [],
    "methods": [
      {
        "name": "register",
        "line": 9,
        "source": "register (name, Application) {\n    if (this.constructors.has(name)) {\n        throw new Error(`Application \"${name}\" is already registered.`)\n    }\n\n    this.constructors.set(name, Application)\n}",
        "kind": "method",
        "params": [
          "name",
          "Application"
        ]
      },
      {
        "name": "unregister",
        "line": 18,
        "source": "unregister (name) {\n    if (this.constructors.has(name)) {\n        this.constructors.delete(name)\n    }\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "createApp",
        "line": 25,
        "source": "createApp (name, params = {}) {\n    if (!this.constructors.has(name)) {\n        throw new Error(`Application \"${name}\" is not registered.`)\n    }\n\n    const Application = this.constructors.get(name)\n\n    const options = {\n        ...params,\n        $category: 'application'\n    }\n\n    return this.create(Application, options)\n}",
        "kind": "method",
        "params": [
          "name",
          "params = ..."
        ]
      },
      {
        "name": "spawn",
        "line": 41,
        "source": "async spawn (name, params = {}) {\n    const {preload = true, ...appParams} = params\n    const app = this.createApp(name, appParams)\n\n    if (preload === 'all') {\n        await app.loadAll()\n    } else if (preload === true) {\n        await app.preload()\n    }\n\n    if (params.container) {\n        app.mount(params.container)\n    }\n\n    app.start()\n    return app\n}",
        "kind": "method",
        "params": [
          "name",
          "params = ..."
        ]
      },
      {
        "name": "startApp",
        "line": 60,
        "source": "startApp (nameOrId) {\n    const app = this.#findApp(nameOrId)\n    if (app) {\n        app.start()\n    }\n}",
        "kind": "method",
        "params": [
          "nameOrId"
        ]
      },
      {
        "name": "stopApp",
        "line": 68,
        "source": "stopApp (nameOrId) {\n    const app = this.#findApp(nameOrId)\n    if (app) {\n        app.stop()\n    }\n}",
        "kind": "method",
        "params": [
          "nameOrId"
        ]
      },
      {
        "name": "execute",
        "line": 76,
        "source": "execute (nameOrId, method, ...args) {\n    const app = this.#findApp(nameOrId)\n    if (app) {\n        app.execute(method, ...args)\n    }\n}",
        "kind": "method",
        "params": [
          "nameOrId",
          "method",
          "...args"
        ]
      },
      {
        "name": "disposeApp",
        "line": 84,
        "source": "disposeApp (nameOrId) {\n    const app = this.#findApp(nameOrId)\n    if (app) {\n        this.removeChild(app.$id)\n    }\n}",
        "kind": "method",
        "params": [
          "nameOrId"
        ]
      },
      {
        "name": "list",
        "line": 92,
        "source": "list (grep = null) {\n    const apps = this.children\n\n    if (grep) {\n        return apps.filter(app => app.$name && app.$name.includes(grep))\n    }\n\n    return apps\n}",
        "kind": "method",
        "params": [
          "grep = ..."
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": null,
    "isDefault": true
  },
  "/application/asset.doc.js": {
    "type": "class",
    "file": "/application/asset.js",
    "name": "Asset",
    "line": 4,
    "extends": null,
    "statics": [],
    "methods": [
      {
        "name": "hasTag",
        "line": 25,
        "source": "hasTag (tag) {\n    return Array.isArray(this.tags) && this.tags.includes(tag)\n}",
        "kind": "method",
        "params": [
          "tag"
        ]
      },
      {
        "name": "export",
        "line": 30,
        "source": "export () {\n    const exported = {\n        type: this.type,\n        id: this.id,\n        name: this.name,\n        tags: this.tags,\n        config: this.config\n    }\n\n    if (this.url) {\n        exported.url = this.url\n    } else if (this.source) {\n        exported.source = this.source\n    }\n\n    return exported\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "loaded",
        "line": 20,
        "source": "get loaded () {\n    return Boolean(this.source)\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 6,
      "source": "constructor (params = {}) {\n    this.type    = params.type\n    this.name    = params.name\n    this.id      = params.id || guessId(params)\n    this.name ??= this.id\n\n    this.url       = params.url || params.path\n    this.source    = params.source\n    this.tags      = params.tags  || []\n    this.config    = params.config || {}\n    this.updatedAt = params.updatedAt || 0\n}",
      "kind": "constructor",
      "params": [
        "params = ..."
      ]
    },
    "isDefault": true
  },
  "/application/dom_utils.doc.js": {
    "type": "module",
    "file": "/application/dom_utils.js",
    "functions": [
      {
        "name": "createElement",
        "line": 23,
        "params": [
          "tag",
          "options = ..."
        ],
        "source": "function createElement (tag, options = {}) {\n    const el = document.createElement(tag)\n    applyElementOptions(el, options)\n    return el\n}"
      },
      {
        "name": "applyElementOptions",
        "line": 30,
        "params": [
          "el",
          "options"
        ],
        "source": "function applyElementOptions (el, options) {\n    applyDirectAttributes(el, options)\n    applyContent(el, options)\n\n    if (options.style) {\n        setStyle(el, options.style)\n    }\n\n    if (options.attrs) {\n        setAttributes(el, options.attrs)\n    }\n}"
      },
      {
        "name": "applyDirectAttributes",
        "line": 44,
        "params": [
          "el",
          "options"
        ],
        "source": "function applyDirectAttributes (el, options) {\n    for (const attr of directAttrs) {\n        if (attr in options) {\n            el[attr] = options[attr]\n        }\n    }\n\n    if (options.class || options.className) {\n        el.className = options.class || options.className\n    }\n}"
      },
      {
        "name": "applyContent",
        "line": 57,
        "params": [
          "el",
          "options"
        ],
        "source": "function applyContent (el, options) {\n    if (options.text) {\n        el.textContent = options.text\n    }\n\n    if (options.html) {\n        el.innerHTML = options.html\n    }\n}"
      },
      {
        "name": "setAttributes",
        "line": 68,
        "params": [
          "element",
          "attrs"
        ],
        "source": "function setAttributes (element, attrs) {\n    for (const [key, value] of Object.entries(attrs)) {\n        const attrName = key.includes('-') ? key : toKebabCase(key)\n        element.setAttribute(attrName, value)\n    }\n}"
      },
      {
        "name": "setStyle",
        "line": 76,
        "params": [
          "element",
          "styles"
        ],
        "source": "function setStyle (element, styles) {\n    if (typeof styles === 'string') {\n        element.style.cssText = styles\n    } else {\n        for (const [key, value] of Object.entries(styles)) {\n            element.style[key] = value\n        }\n    }\n}"
      },
      {
        "name": "createStyleSheet",
        "line": 87,
        "params": [
          "css"
        ],
        "source": "function createStyleSheet (css) {\n    const sheet = new CSSStyleSheet()\n    if (sheet.replaceSync) {\n        sheet.replaceSync(css)\n    }\n    return sheet\n}"
      },
      {
        "name": "adoptStyleSheets",
        "line": 96,
        "params": [
          "shadowRoot",
          "...sheets"
        ],
        "source": "function adoptStyleSheets (shadowRoot, ...sheets) {\n    shadowRoot.adoptedStyleSheets = sheets.filter(Boolean)\n}"
      }
    ],
    "exports": []
  },
  "/application/loaders.doc.js": {
    "type": "module",
    "file": "/application/loaders.js",
    "functions": [
      {
        "name": "normalizeParams",
        "line": 1,
        "params": [
          "params"
        ],
        "source": "function normalizeParams (params) {\n    if (typeof params === 'string') {\n        return {url: params, config: {}}\n    }\n    return {\n        url: params.url,\n        config: params.config || {}\n    }\n}"
      },
      {
        "name": "checkResponse",
        "line": 12,
        "params": [
          "response",
          "url"
        ],
        "source": "function checkResponse (response, url) {\n    if (!response.ok) {\n        throw new Error(`HTTP Error ${response.status} (${response.statusText}) for ${url}`)\n    }\n}"
      },
      {
        "name": "loadResponse",
        "line": 19,
        "params": [
          "params"
        ],
        "source": "async function loadResponse (params) {\n    const {url, config} = normalizeParams(params)\n\n    return fetch(url, config)\n}"
      },
      {
        "name": "loadBlob",
        "line": 26,
        "params": [
          "params"
        ],
        "source": "async function loadBlob (params) {\n    const {url} = normalizeParams(params)\n    const response = await loadResponse(params)\n\n    checkResponse(response, url)\n\n    return response.blob()\n}"
      },
      {
        "name": "loadImage",
        "line": 36,
        "params": [
          "params"
        ],
        "source": "async function loadImage (params) {\n    const blob = await loadBlob(params)\n    const url = URL.createObjectURL(blob)\n\n    return new Promise((resolve, reject) => {\n        const img = new Image()\n\n        img.onload = function () {\n            URL.revokeObjectURL(url)\n            resolve(img)\n        }\n\n        img.onerror = function () {\n            URL.revokeObjectURL(url)\n            const normalizedParams = normalizeParams(params)\n            reject(new Error(`Failed to load image: ${normalizedParams.url}`))\n        }\n\n        img.src = url\n    })\n}"
      },
      {
        "name": "loadText",
        "line": 59,
        "params": [
          "params"
        ],
        "source": "async function loadText (params) {\n    const {url} = normalizeParams(params)\n    const response = await loadResponse(params)\n\n    checkResponse(response, url)\n\n    return response.text()\n}"
      },
      {
        "name": "loadJson",
        "line": 69,
        "params": [
          "params"
        ],
        "source": "async function loadJson (params) {\n    const {url} = normalizeParams(params)\n    const response = await loadResponse(params)\n\n    checkResponse(response, url)\n\n    return response.json()\n}"
      },
      {
        "name": "loadArrayBuffer",
        "line": 79,
        "params": [
          "params"
        ],
        "source": "async function loadArrayBuffer (params) {\n    const {url} = normalizeParams(params)\n    const response = await loadResponse(params)\n\n    checkResponse(response, url)\n\n    return response.arrayBuffer()\n}"
      },
      {
        "name": "loadAudio",
        "line": 89,
        "params": [
          "params"
        ],
        "source": "async function loadAudio (params) {\n    const {url} = normalizeParams(params)\n    return {\n        type: 'deferred_audio',\n        url\n    }\n}"
      },
      {
        "name": "loadFont",
        "line": 98,
        "params": [
          "params"
        ],
        "source": "function loadFont (params) {\n    const {url, config} = normalizeParams(params)\n    const {\n        name,\n        family = name,\n        style = 'normal',\n        weight = 'normal'\n    } = config\n\n    const fontName = family || name\n    const font = new FontFace(fontName, `url(${url})`, {style, weight})\n\n    return font.load()\n        .then(() => {\n            document.fonts.add(font)\n            return font\n        })\n        .catch(error => {\n            throw new Error(`Failed to load font \"${fontName}\": ${error.message}`)\n        })\n}"
      },
      {
        "name": "replaceUrlFilename",
        "line": 121,
        "params": [
          "url",
          "filename"
        ],
        "source": "function replaceUrlFilename (url, filename) {\n    let splitted = url.split('/')\n    splitted.pop()\n    splitted.push(filename)\n    return splitted.join('/')\n}"
      },
      {
        "name": "removeFileExtension",
        "line": 129,
        "params": [
          "filename"
        ],
        "source": "function removeFileExtension (filename) {\n    return filename.replace(/\\.[^/.]+$/, '')\n}"
      },
      {
        "name": "loadSpritesheet",
        "line": 134,
        "params": [
          "params"
        ],
        "source": "async function loadSpritesheet (params) {\n    const {url} = normalizeParams(params)\n\n    const data = await loadJson({url})\n\n    const baseUrl = url.substring(0, url.lastIndexOf('/') + 1)\n\n    const imagePromises = data.meta.images.map(imageInfo => {\n        const imageUrl = baseUrl + imageInfo.filename\n        return loadImage({url: imageUrl})\n    })\n\n    const images = await Promise.all(imagePromises)\n\n    return {\n        data,\n        images\n    }\n}"
      }
    ],
    "exports": [
      {
        "name": "loaders",
        "kind": "variable",
        "line": 157,
        "source": "export const loaders = {\n    response: loadResponse,\n    blob: loadBlob,\n    image: loadImage,\n    text: loadText,\n    json: loadJson,\n    arrayBuffer: loadArrayBuffer,\n    audio: loadAudio,\n    font: loadFont,\n    spritesheet: loadSpritesheet,\n    animator: loadJson\n}"
      }
    ]
  },
  "/application/manifest.doc.js": {
    "type": "class",
    "file": "/application/manifest.js",
    "name": "Manifest",
    "line": 7,
    "extends": "PerkyModule",
    "statics": [
      {
        "name": "$category",
        "line": 9,
        "source": "static $category = 'manifest'",
        "kind": "property",
        "value": "'manifest'"
      },
      {
        "name": "$lifecycle",
        "line": 10,
        "source": "static $lifecycle = false",
        "kind": "property",
        "value": "false"
      }
    ],
    "methods": [
      {
        "name": "onInstall",
        "line": 32,
        "source": "onInstall (host) {\n    this.delegateTo(host, [\n        'getConfig',\n        'setConfig',\n        'addAsset',\n        'getAsset',\n        'getAssets',\n        'getAssetsByType',\n        'getAssetsByTag',\n        'getSource',\n        'getAllAssets'\n    ])\n\n    this.delegateTo(host, {\n        export: 'exportManifest',\n        import: 'importManifest'\n    })\n}",
        "kind": "method",
        "params": [
          "host"
        ]
      },
      {
        "name": "import",
        "line": 52,
        "source": "import (jsonData) {\n    if (typeof jsonData === 'string') {\n        try {\n            this.#data = JSON.parse(jsonData)\n        } catch (error) {\n            throw new Error(`Failed to parse manifest JSON: ${error.message}`)\n        }\n    } else if (jsonData && typeof jsonData === 'object') {\n        this.#data = jsonData\n    } else {\n        throw new Error('Invalid manifest data: must be a JSON string or object')\n    }\n\n    this.assets.clear()\n    this.#initAssets()\n\n    return this\n}",
        "kind": "method",
        "params": [
          "jsonData"
        ]
      },
      {
        "name": "export",
        "line": 72,
        "source": "export () {\n    return deepMerge({}, {\n        config: this.#data.config,\n        assets: this.#exportAssets()\n    })\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "getConfig",
        "line": 80,
        "source": "getConfig (path) {\n    if (path === undefined) {\n        return this.#data.config\n    }\n\n    return getNestedValue(this.#data.config, path)\n}",
        "kind": "method",
        "params": [
          "path"
        ]
      },
      {
        "name": "setConfig",
        "line": 89,
        "source": "setConfig (path, value) {\n    setNestedValue(this.#data.config, path, value)\n    return this\n}",
        "kind": "method",
        "params": [
          "path",
          "value"
        ]
      },
      {
        "name": "addAsset",
        "line": 95,
        "source": "addAsset (assetData) {\n    validateAssetInput(assetData)\n\n    const asset = prepareAsset(assetData)\n\n    this.assets.set(asset.id, asset)\n\n    return asset\n}",
        "kind": "method",
        "params": [
          "assetData"
        ]
      },
      {
        "name": "getAsset",
        "line": 106,
        "source": "getAsset (id) {\n    return this.assets.get(id) || null\n}",
        "kind": "method",
        "params": [
          "id"
        ]
      },
      {
        "name": "getSource",
        "line": 111,
        "source": "getSource (id) {\n    const asset = this.getAsset(id)\n\n    if (!asset) {\n        return null\n    }\n\n    return asset.source\n}",
        "kind": "method",
        "params": [
          "id"
        ]
      },
      {
        "name": "getAssetsByType",
        "line": 122,
        "source": "getAssetsByType (type) {\n    return this.assets.lookup('type', type)\n}",
        "kind": "method",
        "params": [
          "type"
        ]
      },
      {
        "name": "getAssetsByTag",
        "line": 127,
        "source": "getAssetsByTag (tag) {\n    if (!tag || typeof tag !== 'string') {\n        return []\n    }\n\n    return this.assets.lookup('tags', tag)\n}",
        "kind": "method",
        "params": [
          "tag"
        ]
      },
      {
        "name": "getAssets",
        "line": 136,
        "source": "getAssets () {\n    return this.assets.all\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "getAllAssets",
        "line": 141,
        "source": "getAllAssets () {\n    return this.assets.all\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "hasAsset",
        "line": 146,
        "source": "hasAsset (id) {\n    return this.assets.has(id)\n}",
        "kind": "method",
        "params": [
          "id"
        ]
      },
      {
        "name": "removeAsset",
        "line": 151,
        "source": "removeAsset (id) {\n    return this.assets.delete(id)\n}",
        "kind": "method",
        "params": [
          "id"
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 14,
      "source": "constructor (params = {}) {\n    const {data = {}, ...moduleParams} = params\n\n    super(moduleParams)\n\n    this.#data = setDefaults(data, {\n        config: {},\n        assets: {}\n    })\n\n    this.assets = new Registry()\n    this.assets.addIndex('type', asset => asset.type)\n    this.assets.addIndex('tags', asset => asset.tags)\n\n    this.#initAssets()\n}",
      "kind": "constructor",
      "params": [
        "params = ..."
      ]
    },
    "isDefault": true
  },
  "/application/perky_element.doc.js": {
    "type": "class",
    "file": "/application/perky_element.js",
    "name": "PerkyElement",
    "line": 7,
    "extends": "HTMLElement",
    "statics": [],
    "methods": [
      {
        "name": "connectedCallback",
        "line": 18,
        "source": "connectedCallback () {\n    this.#adoptStyles()\n    this.onConnected?.()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "disconnectedCallback",
        "line": 24,
        "source": "disconnectedCallback () {\n    this.#cleanListeners()\n    this.onDisconnected?.()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "listenTo",
        "line": 52,
        "source": "listenTo (target, eventName, callback) {\n    target.on(eventName, callback)\n    this.#listeners.push({target, eventName, callback})\n}",
        "kind": "method",
        "params": [
          "target",
          "eventName",
          "callback"
        ]
      },
      {
        "name": "cleanListeners",
        "line": 66,
        "source": "cleanListeners () {\n    this.#cleanListeners()\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 11,
      "source": "constructor () {\n    super()\n    this.attachShadow({mode: 'open'})\n    this.onInit?.()\n}",
      "kind": "constructor",
      "params": []
    },
    "isDefault": true
  },
  "/application/perky_view.doc.js": {
    "type": "class",
    "file": "/application/perky_view.js",
    "name": "PerkyView",
    "line": 6,
    "extends": "PerkyModule",
    "statics": [
      {
        "name": "$category",
        "line": 8,
        "source": "static $category = 'perkyView'",
        "kind": "property",
        "value": "'perkyView'"
      },
      {
        "name": "defaultElement",
        "line": 159,
        "source": "static defaultElement (params) {\n    const element = createElement('div', {\n        id: params.id || uniqueId('perky_view', 'perky_view'),\n        class: params.className || 'perky-view'\n    })\n\n    const styles = {\n        display: 'block',\n        overflow: 'hidden',\n        position: 'relative',\n        width: '100%',\n        height: '100%',\n        ...this.defaultStyles(params)\n    }\n\n    Object.assign(element.style, styles)\n\n    return element\n}",
        "kind": "method",
        "params": [
          "params"
        ]
      },
      {
        "name": "defaultStyles",
        "line": 180,
        "source": "static defaultStyles () {\n    return {}\n}",
        "kind": "method",
        "params": []
      }
    ],
    "methods": [
      {
        "name": "onInstall",
        "line": 39,
        "source": "onInstall (host) {\n    this.delegateTo(host, [\n        'element',\n        'mount',\n        'dismount',\n        'mounted',\n        'displayMode',\n        'setDisplayMode',\n        'enterFullscreenMode',\n        'exitFullscreenMode',\n        'toggleFullscreen'\n    ])\n\n    this.delegateEventsTo(host, [\n        'resize',\n        'mount',\n        'dismount',\n        'displayMode:changed'\n    ])\n}",
        "kind": "method",
        "params": [
          "host"
        ]
      },
      {
        "name": "addClass",
        "line": 91,
        "source": "addClass (className) {\n    this.element.classList.add(className)\n}",
        "kind": "method",
        "params": [
          "className"
        ]
      },
      {
        "name": "removeClass",
        "line": 96,
        "source": "removeClass (className) {\n    this.element.classList.remove(className)\n}",
        "kind": "method",
        "params": [
          "className"
        ]
      },
      {
        "name": "hasClass",
        "line": 101,
        "source": "hasClass (className) {\n    return this.element.classList.contains(className)\n}",
        "kind": "method",
        "params": [
          "className"
        ]
      },
      {
        "name": "setSize",
        "line": 106,
        "source": "setSize ({width, height, unit = 'px'}) {\n    Object.assign(this.element.style, {\n        width: `${width}${unit}`,\n        height: `${height}${unit}`\n    })\n\n    this.emit('resize', {width, height})\n}",
        "kind": "method",
        "params": [
          "{...}"
        ]
      },
      {
        "name": "fit",
        "line": 116,
        "source": "fit (element = this.container) {\n    const {width, height} = element.getBoundingClientRect()\n\n    this.setSize({width, height})\n}",
        "kind": "method",
        "params": [
          "element = ..."
        ]
      },
      {
        "name": "mount",
        "line": 123,
        "source": "mount (container) {\n    if (!container) {\n        throw new Error('Container element is required')\n    }\n\n    if (this.container && this.container !== container) {\n        this.container.removeChild(this.element)\n    }\n\n    container.appendChild(this.element)\n\n    this.emit('mount', {container})\n\n    if (this.#resizeObserver) {\n        this.#resizeObserver.observe(this.element)\n    }\n}",
        "kind": "method",
        "params": [
          "container"
        ]
      },
      {
        "name": "dismount",
        "line": 142,
        "source": "dismount () {\n    if (this.container) {\n        this.container.removeChild(this.element)\n        this.emit('dismount', {container: this.container})\n    }\n\n    if (this.#resizeObserver) {\n        this.#resizeObserver.disconnect()\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "isVisible",
        "line": 185,
        "source": "isVisible () {\n    return this.element.style.display !== 'none'\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "onDispose",
        "line": 190,
        "source": "onDispose () {\n    this.exitFullscreenMode()\n\n    if (this.#resizeObserver) {\n        this.#resizeObserver.disconnect()\n        this.#resizeObserver = null\n    }\n\n    if (this.#onFullscreenChange) {\n        document.removeEventListener('fullscreenchange', this.#onFullscreenChange)\n    }\n\n    this.dismount()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "hide",
        "line": 221,
        "source": "hide () {\n    if (this.display && this.display !== 'none') {\n        this.#previousDisplay = this.display\n    }\n\n    this.display = 'none'\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "show",
        "line": 230,
        "source": "show () {\n    if (this.#previousDisplay) {\n        this.display = this.#previousDisplay\n        this.#previousDisplay = null\n    } else {\n        this.display = ''\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "setDisplayMode",
        "line": 240,
        "source": "setDisplayMode (mode) {\n    const modes = {\n        normal: () => this.exitFullscreenMode(),\n        fullscreen: () => this.enterFullscreenMode()\n    }\n\n    if (modes[mode]) {\n        modes[mode]()\n    }\n}",
        "kind": "method",
        "params": [
          "mode"
        ]
      },
      {
        "name": "enterFullscreenMode",
        "line": 252,
        "source": "enterFullscreenMode () {\n    if (this.displayMode === 'fullscreen') {\n        return\n    }\n\n    this.displayMode = 'fullscreen'\n\n    document.body.classList.add('fullscreen-mode')\n\n    this.#previousStyles = {\n        position: this.element.style.position,\n        top: this.element.style.top,\n        left: this.element.style.left,\n        width: this.element.style.width,\n        height: this.element.style.height,\n        zIndex: this.element.style.zIndex\n    }\n\n    Object.assign(this.element.style, {\n        position: 'fixed',\n        top: '0',\n        left: '0',\n        width: '100vw',\n        height: '100vh',\n        zIndex: '10000'\n    })\n\n    this.#requestFullscreen()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "exitFullscreenMode",
        "line": 283,
        "source": "exitFullscreenMode () {\n    if (this.displayMode === 'normal') {\n        return\n    }\n\n    if (document.fullscreenElement) {\n        document.exitFullscreen()\n    }\n\n    this.displayMode = 'normal'\n\n    document.body.style.overflow = ''\n    document.body.classList.remove('fullscreen-mode')\n\n    Object.assign(this.element.style, this.#previousStyles)\n    this.#previousStyles = {}\n\n    this.#dispatchDisplayModeChanged('normal')\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "toggleFullscreen",
        "line": 304,
        "source": "toggleFullscreen () {\n    const mode = this.displayMode\n\n    if (mode === 'fullscreen') {\n        this.exitFullscreenMode()\n    } else {\n        this.enterFullscreenMode()\n    }\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "container",
        "line": 61,
        "source": "get container () {\n    return this.element.parentElement\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "width",
        "line": 66,
        "source": "get width () {\n    return this.element.offsetWidth\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "height",
        "line": 71,
        "source": "get height () {\n    return this.element.offsetHeight\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "size",
        "line": 76,
        "source": "get size () {\n    return {\n        width: this.width,\n        height: this.height\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "aspectRatio",
        "line": 84,
        "source": "get aspectRatio () {\n    const {width, height} = this.size\n\n    return height > 0 ? width / height : 0\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "mounted",
        "line": 154,
        "source": "get mounted () {\n    return Boolean(this.container && this.container.contains(this.element))\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "html",
        "line": 206,
        "source": "get html () {\n    return this.element.innerHTML\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "display",
        "line": 211,
        "source": "get display () {\n    return this.element.style.display\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "display",
        "line": 216,
        "source": "set display (display) {\n    this.element.style.display = display\n}",
        "kind": "method",
        "params": [
          "display"
        ]
      }
    ],
    "constructor": {
      "name": "constructor",
      "line": 16,
      "source": "constructor (params = {}) {\n    super(params)\n\n    this.element = params.element ? params.element : this.constructor.defaultElement(params)\n\n    if (params.position) {\n        applyPositionStyle(this.element, params.position)\n    }\n\n    if (params.container) {\n        this.mount(params.container)\n    }\n\n    if (params.className) {\n        this.addClass(params.className)\n    }\n\n\n    this.#setupResizeObserver()\n    this.#setupFullscreenEvents()\n}",
      "kind": "constructor",
      "params": [
        "params = ..."
      ]
    },
    "isDefault": true
  },
  "/application/source_loader.doc.js": {
    "type": "class",
    "file": "/application/source_loader.js",
    "name": "SourceLoader",
    "line": 5,
    "extends": "PerkyModule",
    "statics": [],
    "methods": [
      {
        "name": "load",
        "line": 34,
        "source": "async load () {\n    if (this.loading) {\n        return false\n    }\n\n    this.loading = true\n\n    const promises = this.assets.map(asset => {\n        return this.loadAsset(asset)\n    })\n\n    await Promise.all(promises)\n\n    this.loading = false\n\n    this.emit('complete', this.assets)\n\n    return this.assets\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "loadAsset",
        "line": 55,
        "source": "async loadAsset (asset) {\n    const assetKey = `${asset.type}:${asset.id}`\n\n    if (asset.loaded) {\n        return asset\n    }\n\n    if (this.#loadingPromises[assetKey]) {\n        return this.#loadingPromises[assetKey]\n    }\n\n    const loader = this.loaders.get(asset.type)\n\n    if (!loader) {\n        throw new Error(`No loader found for asset type: ${asset.type}`)\n    }\n\n    const params = asset.url ? {\n        url: asset.url,\n        config: asset.config || {}\n    } : asset\n\n    this.#loadingPromises[assetKey] = Promise.resolve()\n        .then(() => loader(params))\n        .then(source => {\n            asset.source = source\n            delete this.#loadingPromises[assetKey]\n\n            this.emit('progress', this.progress, {asset, source})\n            return asset\n        })\n        .catch(error => {\n            delete this.#loadingPromises[assetKey]\n\n            this.emit('error', asset, error)\n            throw error\n        })\n\n    return this.#loadingPromises[assetKey]\n}",
        "kind": "method",
        "params": [
          "asset"
        ]
      }
    ],
    "getters": [
      {
        "name": "assetCount",
        "line": 16,
        "source": "get assetCount () {\n    return this.assets.length\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "loadedCount",
        "line": 21,
        "source": "get loadedCount () {\n    return this.assets.filter(asset => asset.loaded).length\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "progress",
        "line": 26,
        "source": "get progress () {\n    if (this.assetCount === 0) {\n        return 1\n    }\n    return this.loadedCount / this.assetCount\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 9,
      "source": "constructor (assets, loaders) {\n    super()\n    this.loaders = loaders instanceof Registry ? loaders : new Registry(loaders)\n    this.assets = assets\n}",
      "kind": "constructor",
      "params": [
        "assets",
        "loaders"
      ]
    },
    "isDefault": true
  },
  "/application/source_manager.doc.js": {
    "type": "class",
    "file": "/application/source_manager.js",
    "name": "SourceManager",
    "line": 5,
    "extends": "PerkyModule",
    "statics": [
      {
        "name": "$category",
        "line": 7,
        "source": "static $category = 'sourceManager'",
        "kind": "property",
        "value": "'sourceManager'"
      }
    ],
    "methods": [
      {
        "name": "onInstall",
        "line": 17,
        "source": "onInstall (host) {\n    this.delegateTo(host, ['loadAsset', 'loadTag', 'loadAll', 'loaders'])\n\n    this.delegateEventsTo(host, [\n        'loader:progress',\n        'loader:complete',\n        'loader:error',\n        'asset:loaded'\n    ])\n}",
        "kind": "method",
        "params": [
          "host"
        ]
      },
      {
        "name": "loadAsset",
        "line": 29,
        "source": "async loadAsset (id) {\n    const asset = this.manifest.getAsset(id)\n\n    if (!asset) {\n        throw new Error(`Asset not found: ${id}`)\n    }\n\n    const sourceLoader = new SourceLoader([asset], this.loaders)\n    this.#setupLoaderEvents(sourceLoader)\n\n    await sourceLoader.load()\n\n    return sourceLoader\n}",
        "kind": "method",
        "params": [
          "id"
        ]
      },
      {
        "name": "loadTag",
        "line": 45,
        "source": "async loadTag (tag) {\n    const assets = this.manifest.getAssetsByTag(tag)\n\n    const sourceLoader = new SourceLoader(assets, this.loaders)\n    this.#setupLoaderEvents(sourceLoader)\n\n    await sourceLoader.load()\n\n    return sourceLoader\n}",
        "kind": "method",
        "params": [
          "tag"
        ]
      },
      {
        "name": "loadAll",
        "line": 57,
        "source": "async loadAll () {\n    const assets = this.manifest.getAllAssets()\n\n    const sourceLoader = new SourceLoader(assets, this.loaders)\n    this.#setupLoaderEvents(sourceLoader)\n\n    await sourceLoader.load()\n\n    return sourceLoader\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 9,
      "source": "constructor (options = {}) {\n    super(options)\n\n    this.loaders = options.loaders\n    this.manifest = options.manifest\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/game/game.doc.js": {
    "type": "class",
    "file": "/game/game.js",
    "name": "Game",
    "line": 9,
    "extends": "Application",
    "statics": [
      {
        "name": "ActionController",
        "line": 11,
        "source": "static ActionController = GameController",
        "kind": "property",
        "value": "GameController"
      },
      {
        "name": "RenderSystem",
        "line": 12,
        "source": "static RenderSystem = RenderSystem",
        "kind": "property",
        "value": "RenderSystem"
      },
      {
        "name": "AudioSystem",
        "line": 13,
        "source": "static AudioSystem = AudioSystem",
        "kind": "property",
        "value": "AudioSystem"
      },
      {
        "name": "camera",
        "line": 15,
        "source": "static camera = {unitsInView: {width: 10, height: 10}}",
        "kind": "property",
        "value": "{unitsInView: {width: 10, height: 10}}"
      },
      {
        "name": "layer",
        "line": 16,
        "source": "static layer = {type: 'webgl'}",
        "kind": "property",
        "value": "{type: 'webgl'}"
      },
      {
        "name": "postPasses",
        "line": 17,
        "source": "static postPasses = []",
        "kind": "property",
        "value": "[]"
      }
    ],
    "methods": [
      {
        "name": "setStage",
        "line": 40,
        "source": "setStage (StageClass, options = {}) {\n    if (this.stage) {\n        this.removeChild(this.stage.$id)\n        this.world = null\n        this.worldView = null\n    }\n\n    this.create(StageClass, {$bind: 'stage', game: this, ...options})\n\n    if (this.stage.world) {\n        this.world = this.stage.world\n    }\n\n    if (this.stage.worldView) {\n        this.worldView = this.stage.worldView\n    }\n}",
        "kind": "method",
        "params": [
          "StageClass",
          "options = ..."
        ]
      },
      {
        "name": "update",
        "line": 73,
        "source": "update () {\n\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "render",
        "line": 78,
        "source": "render () {\n\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "onStart",
        "line": 83,
        "source": "onStart () {\n    this.#buildTextureAtlases()\n    this.#buildSpritesheets()\n    this.#listenForLateAssets()\n    this.#setupPostPasses()\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 19,
      "source": "constructor (params = {}) {\n    super(params)\n\n    this.create(GameLoop, {$bind: 'gameLoop'})\n    this.#createRenderSystem(params)\n    this.#createAudioSystem(params)\n    this.create(TextureSystem, {\n        $bind: 'textureSystem',\n        fallback: (id) => this.getSource(id),\n        ...params.textureSystem\n    })\n\n    this.camera = this.renderSystem?.getCamera('main')\n\n    this.on('update', this.#onUpdate)\n    this.on('render', this.#onRender)\n\n    this.configureGame?.(params)\n}",
      "kind": "constructor",
      "params": [
        "params = ..."
      ]
    },
    "isDefault": true
  },
  "/game/auto_view.doc.js": {
    "type": "class",
    "file": "/game/auto_view.js",
    "name": "AutoView",
    "line": 4,
    "extends": "EntityView",
    "statics": [],
    "methods": [
      {
        "name": "sync",
        "line": 51,
        "source": "sync () {\n    super.sync()\n\n    if (this.#stringBindings) {\n        for (let i = 0; i < this.#stringBindings.length; i++) {\n            const {prop, entityProp} = this.#stringBindings[i]\n            this.root[prop] = this.entity[entityProp]\n        }\n    }\n\n    if (this.#functionBindings) {\n        for (let i = 0; i < this.#functionBindings.length; i++) {\n            const {prop, fn} = this.#functionBindings[i]\n            this.root[prop] = fn(this.entity)\n        }\n    }\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 9,
      "source": "constructor (entity, context) {\n    super(entity, context)\n\n    const config = context.config || {}\n    const {sync, ...objectOptions} = config\n\n    this.#compileBindings(sync)\n\n    const ObjectClass = context.ObjectClass\n    this.root = new ObjectClass({\n        x: entity.x,\n        y: entity.y,\n        ...objectOptions\n    })\n}",
      "kind": "constructor",
      "params": [
        "entity",
        "context"
      ]
    },
    "isDefault": true
  },
  "/game/collision_box_view.doc.js": {
    "type": "class",
    "file": "/game/collision_box_view.js",
    "name": "CollisionBoxView",
    "line": 5,
    "extends": "EntityView",
    "statics": [],
    "methods": [],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 7,
      "source": "constructor (entity, context) {\n    super(entity, context)\n\n    const config = context.config || {}\n\n    this.root = new Rectangle({\n        x: entity.x,\n        y: entity.y,\n        width: config.width ?? 1,\n        height: config.height ?? 1,\n        color: 'transparent',\n        strokeColor: config.strokeColor ?? '#ff0000',\n        strokeWidth: config.strokeWidth ?? 2\n    })\n}",
      "kind": "constructor",
      "params": [
        "entity",
        "context"
      ]
    },
    "isDefault": true
  },
  "/game/entity.doc.js": {
    "type": "class",
    "file": "/game/entity.js",
    "name": "Entity",
    "line": 5,
    "extends": "PerkyModule",
    "statics": [
      {
        "name": "$category",
        "line": 7,
        "source": "static $category = 'entity'",
        "kind": "property",
        "value": "'entity'"
      }
    ],
    "methods": [
      {
        "name": "update",
        "line": 39,
        "source": "update () {\n\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "x",
        "line": 19,
        "source": "get x () {\n    return this.position.x\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "y",
        "line": 29,
        "source": "get y () {\n    return this.position.y\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "x",
        "line": 24,
        "source": "set x (value) {\n    this.position.x = value\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "y",
        "line": 34,
        "source": "set y (value) {\n    this.position.y = value\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      }
    ],
    "constructor": {
      "name": "constructor",
      "line": 9,
      "source": "constructor (options = {}) {\n    super(options)\n\n    const {x = 0, y = 0} = options\n\n    this.position = new Vec2(x, y)\n    this.velocity = new Vec2(0, 0)\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/game/entity_view.doc.js": {
    "type": "class",
    "file": "/game/entity_view.js",
    "name": "EntityView",
    "line": 1,
    "extends": null,
    "statics": [],
    "methods": [
      {
        "name": "sync",
        "line": 10,
        "source": "sync () {\n    if (this.root) {\n        this.root.x = this.entity.x\n        this.root.y = this.entity.y\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "dispose",
        "line": 18,
        "source": "dispose () {\n    if (this.root && this.context.group) {\n        this.context.group.remove(this.root)\n    }\n    this.root = null\n    this.entity = null\n    this.context = null\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 3,
      "source": "constructor (entity, context) {\n    this.entity = entity\n    this.context = context\n    this.root = null\n}",
      "kind": "constructor",
      "params": [
        "entity",
        "context"
      ]
    },
    "isDefault": true
  },
  "/game/game_controller.doc.js": {
    "type": "class",
    "file": "/game/game_controller.js",
    "name": "GameController",
    "line": 4,
    "extends": "ActionController",
    "statics": [
      {
        "name": "resources",
        "line": 6,
        "source": "static resources = ['world', 'renderer', 'camera']",
        "kind": "property",
        "value": "['world', 'renderer', 'camera']"
      }
    ],
    "methods": [
      {
        "name": "spawn",
        "line": 13,
        "source": "spawn (Entity, options = {}) {\n    return this.world?.create(Entity, options)\n}",
        "kind": "method",
        "params": [
          "Entity",
          "options = ..."
        ]
      }
    ],
    "getters": [
      {
        "name": "game",
        "line": 8,
        "source": "get game () {\n    return this.engine\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [],
    "constructor": null,
    "isDefault": true
  },
  "/game/game_loop.doc.js": {
    "type": "class",
    "file": "/game/game_loop.js",
    "name": "GameLoop",
    "line": 4,
    "extends": "PerkyModule",
    "statics": [
      {
        "name": "$category",
        "line": 6,
        "source": "static $category = 'gameLoop'",
        "kind": "property",
        "value": "'gameLoop'"
      }
    ],
    "methods": [
      {
        "name": "onInstall",
        "line": 27,
        "source": "onInstall (host) {\n    this.delegateTo(host, [\n        'paused',\n        'pause',\n        'resume',\n        'setFps',\n        'getFps',\n        'getCurrentFps',\n        'getScreenFps',\n        'fpsLimited',\n        'setFpsLimited'\n    ])\n\n    this.delegateEventsTo(host, [\n        'update',\n        'render',\n        'pause',\n        'resume',\n        'changed:fps',\n        'changed:fpsLimited'\n    ])\n}",
        "kind": "method",
        "params": [
          "host"
        ]
      },
      {
        "name": "onStart",
        "line": 66,
        "source": "onStart () {\n    this.#paused = false\n    this.lastTime = performance.now()\n    this.accumulator = 0\n    this.frameCount = 0\n    this.lastFpsUpdate = this.lastTime\n\n    requestAnimationFrame(time => update(this, time))\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "pause",
        "line": 77,
        "source": "pause (...args) {\n    if (!this.started || this.#paused) {\n        return false\n    }\n\n    this.#paused = true\n    this.emit('pause', ...args)\n\n    return true\n}",
        "kind": "method",
        "params": [
          "...args"
        ]
      },
      {
        "name": "resume",
        "line": 89,
        "source": "resume (...args) {\n    if (!this.started || !this.#paused) {\n        return false\n    }\n\n    this.#paused = false\n    this.lastTime = performance.now()\n    this.emit('resume', ...args)\n\n    requestAnimationFrame(time => update(this, time))\n\n    return true\n}",
        "kind": "method",
        "params": [
          "...args"
        ]
      },
      {
        "name": "getFps",
        "line": 104,
        "source": "getFps () {\n    return this.fps\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "setFps",
        "line": 109,
        "source": "setFps (fps) {\n    this.fps = fps\n    this.frameInterval = 1000 / fps\n    this.emit('changed:fps', fps)\n}",
        "kind": "method",
        "params": [
          "fps"
        ]
      },
      {
        "name": "getCurrentFps",
        "line": 116,
        "source": "getCurrentFps () {\n    return this.currentFps || 0\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "getScreenFps",
        "line": 121,
        "source": "getScreenFps () {\n    return this.screenFps || 0\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "setFpsLimited",
        "line": 131,
        "source": "setFpsLimited (value) {\n    this.#fpsLimited = value\n    this.emit('changed:fpsLimited', value)\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      }
    ],
    "getters": [
      {
        "name": "paused",
        "line": 51,
        "source": "get paused () {\n    return this.#paused\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "running",
        "line": 61,
        "source": "get running () {\n    return super.running && !this.#paused\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "fpsLimited",
        "line": 126,
        "source": "get fpsLimited () {\n    return this.#fpsLimited\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "paused",
        "line": 56,
        "source": "set paused (value) {\n    this.#paused = value\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      }
    ],
    "constructor": {
      "name": "constructor",
      "line": 11,
      "source": "constructor (params = {}) {\n    super(params)\n\n    this.lastTime = 0\n    this.accumulator = 0\n    this.maxFrameSkip = params.maxFrameSkip || 5\n    this.frameCount = 0\n    this.screenFrameCount = 0\n    this.lastFpsUpdate = 0\n\n    this.fps = params.fps ?? 60\n    this.frameInterval = 1000 / this.fps\n    this.#fpsLimited = params.fpsLimited ?? false\n}",
      "kind": "constructor",
      "params": [
        "params = ..."
      ]
    },
    "isDefault": true
  },
  "/game/stage.doc.js": {
    "type": "class",
    "file": "/game/stage.js",
    "name": "Stage",
    "line": 5,
    "extends": "PerkyModule",
    "statics": [
      {
        "name": "$category",
        "line": 7,
        "source": "static $category = 'stage'",
        "kind": "property",
        "value": "'stage'"
      },
      {
        "name": "World",
        "line": 8,
        "source": "static World = null",
        "kind": "property",
        "value": "null"
      },
      {
        "name": "WorldView",
        "line": 9,
        "source": "static WorldView = WorldView",
        "kind": "property",
        "value": "WorldView"
      }
    ],
    "methods": [
      {
        "name": "update",
        "line": 47,
        "source": "update () {\n\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "render",
        "line": 52,
        "source": "render () {\n\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 11,
      "source": "constructor (options = {}) {\n    super(options)\n\n    this.game = options.game\n\n    this.#createWorld()\n    this.#createWorldView()\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/game/world.doc.js": {
    "type": "class",
    "file": "/game/world.js",
    "name": "World",
    "line": 4,
    "extends": "PerkyModule",
    "statics": [
      {
        "name": "$category",
        "line": 6,
        "source": "static $category = 'world'",
        "kind": "property",
        "value": "'world'"
      }
    ],
    "methods": [
      {
        "name": "update",
        "line": 13,
        "source": "update (deltaTime, context) {\n    if (!this.started) {\n        return\n    }\n\n    this.preUpdate(deltaTime, context)\n\n    for (const entity of this.entities) {\n        if (entity.started) {\n            entity.update(deltaTime)\n        }\n    }\n\n    this.postUpdate(deltaTime, context)\n}",
        "kind": "method",
        "params": [
          "deltaTime",
          "context"
        ]
      },
      {
        "name": "preUpdate",
        "line": 30,
        "source": "preUpdate () {\n\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "postUpdate",
        "line": 35,
        "source": "postUpdate () {\n\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "entities",
        "line": 8,
        "source": "get entities () {\n    return this.childrenByCategory('entity')\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [],
    "constructor": null,
    "isDefault": true
  },
  "/game/world_view.doc.js": {
    "type": "class",
    "file": "/game/world_view.js",
    "name": "WorldView",
    "line": 7,
    "extends": "PerkyModule",
    "statics": [
      {
        "name": "$category",
        "line": 9,
        "source": "static $category = 'worldView'",
        "kind": "property",
        "value": "'worldView'"
      }
    ],
    "methods": [
      {
        "name": "onStart",
        "line": 25,
        "source": "onStart () {\n    this.#bindWorldEvents()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "onStop",
        "line": 30,
        "source": "onStop () {\n    this.#disposeAllViews()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "register",
        "line": 35,
        "source": "register (classOrMatcher, View, config = null) {\n    const isObject2D = isObject2DClass(View)\n    const registration = isObject2D\n        ? {View: AutoView, config, ObjectClass: View}\n        : {View, config}\n\n    if (typeof classOrMatcher === 'function' && classOrMatcher.prototype) {\n        const isClass = classOrMatcher.toString().startsWith('class ') ||\n            Object.getOwnPropertyNames(classOrMatcher.prototype).length > 1\n\n        if (isClass) {\n            this.#classRegistry.set(classOrMatcher, registration)\n            return this\n        }\n    }\n\n    this.#matcherRegistry.push({matcher: classOrMatcher, ...registration})\n    return this\n}",
        "kind": "method",
        "params": [
          "classOrMatcher",
          "View",
          "config = ..."
        ]
      },
      {
        "name": "unregister",
        "line": 56,
        "source": "unregister (classOrMatcher) {\n    if (this.#classRegistry.has(classOrMatcher)) {\n        this.#classRegistry.delete(classOrMatcher)\n        return true\n    }\n\n    const index = this.#matcherRegistry.findIndex(entry => entry.matcher === classOrMatcher)\n    if (index !== -1) {\n        this.#matcherRegistry.splice(index, 1)\n        return true\n    }\n\n    return false\n}",
        "kind": "method",
        "params": [
          "classOrMatcher"
        ]
      },
      {
        "name": "clearRegistry",
        "line": 72,
        "source": "clearRegistry () {\n    this.#classRegistry.clear()\n    this.#matcherRegistry.length = 0\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "getViews",
        "line": 79,
        "source": "getViews (entityId) {\n    return this.#views.get(entityId) || []\n}",
        "kind": "method",
        "params": [
          "entityId"
        ]
      },
      {
        "name": "updateViews",
        "line": 84,
        "source": "updateViews (deltaTime) {\n    for (const views of this.#views.values()) {\n        for (const view of views) {\n            view.update?.(deltaTime)\n        }\n    }\n}",
        "kind": "method",
        "params": [
          "deltaTime"
        ]
      },
      {
        "name": "syncViews",
        "line": 93,
        "source": "syncViews () {\n    for (const views of this.#views.values()) {\n        for (const view of views) {\n            view.sync()\n        }\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "setupRenderGroups",
        "line": 102,
        "source": "setupRenderGroups () {\n    const gameRenderer = this.game.getRenderer('game')\n\n    gameRenderer.appendRenderGroup({\n        $name: 'entities',\n        content: this.rootGroup\n    })\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "update",
        "line": 112,
        "source": "update (deltaTime) {\n    this.updateViews(deltaTime)\n}",
        "kind": "method",
        "params": [
          "deltaTime"
        ]
      },
      {
        "name": "sync",
        "line": 117,
        "source": "sync () {\n    this.syncViews()\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 15,
      "source": "constructor (options = {}) {\n    super(options)\n\n    this.world = options.world\n    this.game = options.game\n\n    this.rootGroup = new Group2D()\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/math/random.doc.js": {
    "type": "class",
    "file": "/math/random.js",
    "name": "Random",
    "line": 5,
    "extends": null,
    "statics": [
      {
        "name": "generateSeed",
        "line": 135,
        "source": "static generateSeed (length = 10) {\n    let result = ''\n\n    for (let i = 0; i < length; i++) {\n        result += CHARACTERS.charAt(Math.floor(Math.random() * CHARACTERS.length))\n    }\n\n    return result\n}",
        "kind": "method",
        "params": [
          "length = ..."
        ]
      }
    ],
    "methods": [
      {
        "name": "setSeed",
        "line": 48,
        "source": "setSeed (seed) {\n    this.#seed = seed\n    this.#initSeed(seed)\n\n    return this\n}",
        "kind": "method",
        "params": [
          "seed"
        ]
      },
      {
        "name": "getSeed",
        "line": 56,
        "source": "getSeed () {\n    return this.#seed\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "setState",
        "line": 61,
        "source": "setState (state) {\n    this.#c = state.c\n    this.#s0 = state.s0\n    this.#s1 = state.s1\n    this.#s2 = state.s2\n\n    return this\n}",
        "kind": "method",
        "params": [
          "state"
        ]
      },
      {
        "name": "getState",
        "line": 71,
        "source": "getState () {\n    return {\n        c: this.#c,\n        s0: this.#s0,\n        s1: this.#s1,\n        s2: this.#s2\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "fork",
        "line": 81,
        "source": "fork () {\n    const forked = new Random(this.#seed)\n    forked.setState(this.getState())\n\n    return forked\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "between",
        "line": 89,
        "source": "between (min, max) {\n    return this.#next() * (max - min) + min\n}",
        "kind": "method",
        "params": [
          "min",
          "max"
        ]
      },
      {
        "name": "intBetween",
        "line": 94,
        "source": "intBetween (min, max) {\n    return Math.floor(this.between(min, max))\n}",
        "kind": "method",
        "params": [
          "min",
          "max"
        ]
      },
      {
        "name": "pick",
        "line": 99,
        "source": "pick (array) {\n    return array[this.intBetween(0, array.length)]\n}",
        "kind": "method",
        "params": [
          "array"
        ]
      },
      {
        "name": "oneChanceIn",
        "line": 104,
        "source": "oneChanceIn (chances) {\n    return this.#next() < 1 / chances\n}",
        "kind": "method",
        "params": [
          "chances"
        ]
      },
      {
        "name": "coinToss",
        "line": 109,
        "source": "coinToss () {\n    return this.#next() < 0.5\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "weightedChoice",
        "line": 114,
        "source": "weightedChoice (choices) {\n    if (!choices || choices.length === 0) {\n        return undefined\n    }\n\n    const totalWeight = choices.reduce((total, choice) => total + choice.weight, 0)\n\n    let randomValue = this.#next() * totalWeight\n\n    for (const choice of choices) {\n        randomValue -= choice.weight\n\n        if (randomValue <= 0) {\n            return choice.value\n        }\n    }\n\n    return choices[choices.length - 1].value\n}",
        "kind": "method",
        "params": [
          "choices"
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 13,
      "source": "constructor (seed = Random.generateSeed()) {\n    this.#seed = seed\n    this.#initSeed(seed)\n}",
      "kind": "constructor",
      "params": [
        "seed = ..."
      ]
    },
    "isDefault": true
  },
  "/math/color.doc.js": {
    "type": "class",
    "file": "/math/color.js",
    "name": "Color",
    "line": 20,
    "extends": null,
    "statics": [],
    "methods": [
      {
        "name": "set",
        "line": 34,
        "source": "set (value) { // eslint-disable-line local/nested-complexity -- clean\n    if (value instanceof Color) {\n        this.r = value.r\n        this.g = value.g\n        this.b = value.b\n        this.a = value.a\n    } else if (typeof value === 'string') {\n        this.#parseString(value)\n    } else if (typeof value === 'number') {\n        this.#parseNumber(value)\n    } else if (Array.isArray(value)) {\n        this.#parseArray(value)\n    } else if (typeof value === 'object') {\n        this.#parseObject(value)\n    }\n\n    return this\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "toHsl",
        "line": 172,
        "source": "toHsl () {\n    const r = this.r\n    const g = this.g\n    const b = this.b\n\n    const max = Math.max(r, g, b)\n    const min = Math.min(r, g, b)\n    const l = (max + min) / 2\n\n    let h = 0\n    let s = 0\n\n    if (max !== min) {\n        const d = max - min\n        s = l > 0.5 ? d / (2 - max - min) : d / (max + min)\n\n        if (max === r) {\n            h = ((g - b) / d + (g < b ? 6 : 0)) / 6\n        } else if (max === g) {\n            h = ((b - r) / d + 2) / 6\n        } else {\n            h = ((r - g) / d + 4) / 6\n        }\n    }\n\n    return {\n        h: Math.round(h * 360),\n        s: Math.round(s * 100),\n        l: Math.round(l * 100),\n        a: this.a\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "toRgb",
        "line": 206,
        "source": "toRgb () {\n    return {\n        r: Math.round(this.r * 255),\n        g: Math.round(this.g * 255),\n        b: Math.round(this.b * 255),\n        a: this.a\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "toHex",
        "line": 216,
        "source": "toHex (includeAlpha = false) {\n    const r = Math.round(this.r * 255).toString(16).padStart(2, '0')\n    const g = Math.round(this.g * 255).toString(16).padStart(2, '0')\n    const b = Math.round(this.b * 255).toString(16).padStart(2, '0')\n\n    if (includeAlpha) {\n        const a = Math.round(this.a * 255).toString(16).padStart(2, '0')\n        return `#${r}${g}${b}${a}`\n    }\n\n    return `#${r}${g}${b}`\n}",
        "kind": "method",
        "params": [
          "includeAlpha = ..."
        ]
      },
      {
        "name": "toRgbString",
        "line": 230,
        "source": "toRgbString () {\n    const rgb = this.toRgb()\n    if (this.a < 1) {\n        return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${this.a})`\n    }\n    return `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "toHslString",
        "line": 239,
        "source": "toHslString () {\n    const hsl = this.toHsl()\n    if (this.a < 1) {\n        return `hsla(${hsl.h}, ${hsl.s}%, ${hsl.l}%, ${this.a})`\n    }\n    return `hsl(${hsl.h}, ${hsl.s}%, ${hsl.l}%)`\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "toString",
        "line": 248,
        "source": "toString () {\n    return this.toHex()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "clone",
        "line": 253,
        "source": "clone () {\n    const color = new Color()\n    color.r = this.r\n    color.g = this.g\n    color.b = this.b\n    color.a = this.a\n    return color\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "copy",
        "line": 263,
        "source": "copy (color) {\n    this.r = color.r\n    this.g = color.g\n    this.b = color.b\n    this.a = color.a\n    return this\n}",
        "kind": "method",
        "params": [
          "color"
        ]
      },
      {
        "name": "setAlpha",
        "line": 272,
        "source": "setAlpha (a) {\n    this.a = a\n    return this\n}",
        "kind": "method",
        "params": [
          "a"
        ]
      },
      {
        "name": "lighten",
        "line": 278,
        "source": "lighten (amount) {\n    const hsl = this.toHsl()\n    hsl.l = Math.min(100, hsl.l + amount)\n    this.set({h: hsl.h, s: hsl.s, l: hsl.l, a: this.a})\n    return this\n}",
        "kind": "method",
        "params": [
          "amount"
        ]
      },
      {
        "name": "darken",
        "line": 286,
        "source": "darken (amount) {\n    const hsl = this.toHsl()\n    hsl.l = Math.max(0, hsl.l - amount)\n    this.set({h: hsl.h, s: hsl.s, l: hsl.l, a: this.a})\n    return this\n}",
        "kind": "method",
        "params": [
          "amount"
        ]
      },
      {
        "name": "saturate",
        "line": 294,
        "source": "saturate (amount) {\n    const hsl = this.toHsl()\n    hsl.s = Math.min(100, hsl.s + amount)\n    this.set({h: hsl.h, s: hsl.s, l: hsl.l, a: this.a})\n    return this\n}",
        "kind": "method",
        "params": [
          "amount"
        ]
      },
      {
        "name": "desaturate",
        "line": 302,
        "source": "desaturate (amount) {\n    const hsl = this.toHsl()\n    hsl.s = Math.max(0, hsl.s - amount)\n    this.set({h: hsl.h, s: hsl.s, l: hsl.l, a: this.a})\n    return this\n}",
        "kind": "method",
        "params": [
          "amount"
        ]
      },
      {
        "name": "rotate",
        "line": 310,
        "source": "rotate (degrees) {\n    const hsl = this.toHsl()\n    hsl.h = (hsl.h + degrees) % 360\n    if (hsl.h < 0) {\n        hsl.h += 360\n    }\n    this.set({h: hsl.h, s: hsl.s, l: hsl.l, a: this.a})\n    return this\n}",
        "kind": "method",
        "params": [
          "degrees"
        ]
      },
      {
        "name": "mix",
        "line": 321,
        "source": "mix (color, ratio = 0.5) {\n    const other = color instanceof Color ? color : new Color(color)\n    this.r += (other.r - this.r) * ratio\n    this.g += (other.g - this.g) * ratio\n    this.b += (other.b - this.b) * ratio\n    this.a += (other.a - this.a) * ratio\n    return this\n}",
        "kind": "method",
        "params": [
          "color",
          "ratio = ..."
        ]
      },
      {
        "name": "invert",
        "line": 331,
        "source": "invert () {\n    this.r = 1 - this.r\n    this.g = 1 - this.g\n    this.b = 1 - this.b\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "grayscale",
        "line": 339,
        "source": "grayscale () {\n    const gray = this.r * 0.299 + this.g * 0.587 + this.b * 0.114\n    this.r = gray\n    this.g = gray\n    this.b = gray\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "equals",
        "line": 348,
        "source": "equals (color) {\n    const other = color instanceof Color ? color : new Color(color)\n    return this.r === other.r &&\n           this.g === other.g &&\n           this.b === other.b &&\n           this.a === other.a\n}",
        "kind": "method",
        "params": [
          "color"
        ]
      }
    ],
    "getters": [
      {
        "name": "luminance",
        "line": 357,
        "source": "get luminance () {\n    const r = this.r <= 0.03928 ? this.r / 12.92 : ((this.r + 0.055) / 1.055) ** 2.4\n    const g = this.g <= 0.03928 ? this.g / 12.92 : ((this.g + 0.055) / 1.055) ** 2.4\n    const b = this.b <= 0.03928 ? this.b / 12.92 : ((this.b + 0.055) / 1.055) ** 2.4\n    return 0.2126 * r + 0.7152 * g + 0.0722 * b\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "isDark",
        "line": 365,
        "source": "get isDark () {\n    return this.luminance < 0.5\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "isLight",
        "line": 370,
        "source": "get isLight () {\n    return this.luminance >= 0.5\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 22,
      "source": "constructor (value) {\n    this.r = 0\n    this.g = 0\n    this.b = 0\n    this.a = 1\n\n    if (value !== undefined) {\n        this.set(value)\n    }\n}",
      "kind": "constructor",
      "params": [
        "value"
      ]
    },
    "isDefault": true
  },
  "/math/grid.doc.js": {
    "type": "class",
    "file": "/math/grid.js",
    "name": "Grid",
    "line": 23,
    "extends": null,
    "statics": [],
    "methods": [
      {
        "name": "getCell",
        "line": 34,
        "source": "getCell (coords) {\n    const key = getCellKey(coords)\n    return this.cells.get(key)\n}",
        "kind": "method",
        "params": [
          "coords"
        ]
      },
      {
        "name": "setCell",
        "line": 40,
        "source": "setCell (coords, value) {\n    const key = getCellKey(coords)\n\n    if (value === undefined) {\n        this.cells.delete(key)\n    } else {\n        this.cells.set(key, value)\n    }\n}",
        "kind": "method",
        "params": [
          "coords",
          "value"
        ]
      },
      {
        "name": "isInside",
        "line": 51,
        "source": "isInside (coords) {\n    if (this.width === null || this.height === null) {\n        return true\n    }\n\n    return coords.x >= 0 && coords.x < this.width &&\n           coords.y >= 0 && coords.y < this.height\n}",
        "kind": "method",
        "params": [
          "coords"
        ]
      },
      {
        "name": "forEachCell",
        "line": 61,
        "source": "forEachCell (callback) {\n    if (this.width === null || this.height === null) {\n        throw new Error('Cannot iterate over infinite grid. Use forEachDefinedCell instead.')\n    }\n\n    for (let y = 0; y < this.height; y++) {\n        for (let x = 0; x < this.width; x++) {\n            const coords = {x, y}\n            const value = this.getCell(coords)\n            callback(coords, value)\n        }\n    }\n}",
        "kind": "method",
        "params": [
          "callback"
        ]
      },
      {
        "name": "forEachDefinedCell",
        "line": 76,
        "source": "forEachDefinedCell (callback) {\n    for (const [key, value] of this.cells) {\n        const coords = parseCellKey(key)\n        callback(coords, value)\n    }\n}",
        "kind": "method",
        "params": [
          "callback"
        ]
      },
      {
        "name": "neighbourOf",
        "line": 84,
        "source": "neighbourOf (coords, step) {\n    return {\n        x: coords.x + step.x,\n        y: coords.y + step.y,\n        cell: this.getCell({\n            x: coords.x + step.x,\n            y: coords.y + step.y\n        })\n    }\n}",
        "kind": "method",
        "params": [
          "coords",
          "step"
        ]
      },
      {
        "name": "fourNeighboursOf",
        "line": 96,
        "source": "fourNeighboursOf (coords) {\n    return Object.values(fourDirections).map(direction => {\n        return this.neighbourOf(coords, direction)\n    })\n}",
        "kind": "method",
        "params": [
          "coords"
        ]
      },
      {
        "name": "eightNeighboursOf",
        "line": 103,
        "source": "eightNeighboursOf (coords) {\n    return Object.values(eightDirections).map(direction => {\n        return this.neighbourOf(coords, direction)\n    })\n}",
        "kind": "method",
        "params": [
          "coords"
        ]
      },
      {
        "name": "getCol",
        "line": 110,
        "source": "getCol (x) {\n    if (this.height === null) {\n        throw new Error('Cannot get column from infinite grid')\n    }\n\n    const result = []\n    for (let y = 0; y < this.height; y++) {\n        result.push(this.getCell({x, y}))\n    }\n    return result\n}",
        "kind": "method",
        "params": [
          "x"
        ]
      },
      {
        "name": "getRow",
        "line": 123,
        "source": "getRow (y) {\n    if (this.width === null) {\n        throw new Error('Cannot get row from infinite grid')\n    }\n\n    const result = []\n    for (let x = 0; x < this.width; x++) {\n        result.push(this.getCell({x, y}))\n    }\n    return result\n}",
        "kind": "method",
        "params": [
          "y"
        ]
      },
      {
        "name": "clear",
        "line": 136,
        "source": "clear () {\n    this.cells.clear()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "clone",
        "line": 141,
        "source": "clone () {\n    const newGrid = new Grid({width: this.width, height: this.height})\n    newGrid.cells = new Map(this.cells)\n    return newGrid\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "getBounds",
        "line": 148,
        "source": "getBounds () {\n    if (this.cells.size === 0) {\n        return null\n    }\n\n    let minX = Infinity\n    let maxX = -Infinity\n    let minY = Infinity\n    let maxY = -Infinity\n\n    for (const key of this.cells.keys()) {\n        const {x, y} = parseCellKey(key)\n        minX = Math.min(minX, x)\n        maxX = Math.max(maxX, x)\n        minY = Math.min(minY, y)\n        maxY = Math.max(maxY, y)\n    }\n\n    return {\n        minX,\n        maxX,\n        minY,\n        maxY,\n        width: maxX - minX + 1,\n        height: maxY - minY + 1\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "export",
        "line": 177,
        "source": "export () {\n    const cells = {}\n\n    this.forEachDefinedCell((coords, value) => {\n        const key = getCellKey(coords)\n        cells[key] = exportValue(value)\n    })\n\n    return {\n        width: this.width,\n        height: this.height,\n        cells\n    }\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 25,
      "source": "constructor (options = {}) {\n    const {width = null, height = null} = options\n\n    this.width = width\n    this.height = height\n    this.cells = new Map()\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/math/noise.doc.js": {
    "type": "class",
    "file": "/math/noise.js",
    "name": "Noise",
    "line": 3,
    "extends": null,
    "statics": [],
    "methods": [
      {
        "name": "seed",
        "line": 13,
        "source": "seed (seed) {\n    const p = buildPermutation(seed)\n    this.#perm = new Array(512)\n    this.#gradP = new Array(512)\n\n    for (let i = 0; i < 256; i++) {\n        this.#perm[i] = p[i]\n        this.#perm[i + 256] = p[i]\n        this.#gradP[i] = GRAD3[p[i] % 12]\n        this.#gradP[i + 256] = GRAD3[p[i] % 12]\n    }\n\n    return this\n}",
        "kind": "method",
        "params": [
          "seed"
        ]
      },
      {
        "name": "perlin",
        "line": 29,
        "source": "perlin (x, y = 0, z = 0) {\n    const X = Math.floor(x) & 255\n    const Y = Math.floor(y) & 255\n    const Z = Math.floor(z) & 255\n\n    x -= Math.floor(x)\n    y -= Math.floor(y)\n    z -= Math.floor(z)\n\n    const u = fade(x)\n    const v = fade(y)\n    const w = fade(z)\n\n    const A = this.#perm[X] + Y\n    const AA = this.#perm[A] + Z\n    const AB = this.#perm[A + 1] + Z\n    const B = this.#perm[X + 1] + Y\n    const BA = this.#perm[B] + Z\n    const BB = this.#perm[B + 1] + Z\n\n    return lerp(\n        lerp(\n            lerp(\n                dot(this.#gradP[AA], x, y, z),\n                dot(this.#gradP[BA], x - 1, y, z),\n                u\n            ),\n            lerp(\n                dot(this.#gradP[AB], x, y - 1, z),\n                dot(this.#gradP[BB], x - 1, y - 1, z),\n                u\n            ),\n            v\n        ),\n        lerp(\n            lerp(\n                dot(this.#gradP[AA + 1], x, y, z - 1),\n                dot(this.#gradP[BA + 1], x - 1, y, z - 1),\n                u\n            ),\n            lerp(\n                dot(this.#gradP[AB + 1], x, y - 1, z - 1),\n                dot(this.#gradP[BB + 1], x - 1, y - 1, z - 1),\n                u\n            ),\n            v\n        ),\n        w\n    )\n}",
        "kind": "method",
        "params": [
          "x",
          "y = ...",
          "z = ..."
        ]
      },
      {
        "name": "perlin2d",
        "line": 81,
        "source": "perlin2d (x, y) {\n    return this.perlin(x, y, 0)\n}",
        "kind": "method",
        "params": [
          "x",
          "y"
        ]
      },
      {
        "name": "fbm",
        "line": 86,
        "source": "fbm (x, y, {octaves = 4, lacunarity = 2, persistence = 0.5} = {}) {\n    let value = 0\n    let amplitude = 1\n    let frequency = 1\n    let maxValue = 0\n\n    for (let i = 0; i < octaves; i++) {\n        value += this.perlin2d(x * frequency, y * frequency) * amplitude\n        maxValue += amplitude\n        amplitude *= persistence\n        frequency *= lacunarity\n    }\n\n    return value / maxValue\n}",
        "kind": "method",
        "params": [
          "x",
          "y",
          "undefined = ..."
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 8,
      "source": "constructor (seed = 0) {\n    this.seed(seed)\n}",
      "kind": "constructor",
      "params": [
        "seed = ..."
      ]
    },
    "isDefault": true
  },
  "/math/pathfinder.doc.js": {
    "type": "class",
    "file": "/math/pathfinder.js",
    "name": "Pathfinder",
    "line": 11,
    "extends": null,
    "statics": [],
    "methods": [
      {
        "name": "findPath",
        "line": 26,
        "source": "findPath (grid, start, goal) { // eslint-disable-line complexity -- clean\n    if (!grid.isInside(start) || !grid.isInside(goal)) {\n        return null\n    }\n\n    if (!this.isWalkable(grid.getCell(start)) || !this.isWalkable(grid.getCell(goal))) {\n        return null\n    }\n\n    const openSet = new Set()\n    const closedSet = new Set()\n    const cameFrom = new Map()\n    const gScore = new Map()\n    const fScore = new Map()\n\n    const startKey = getCoordsKey(start)\n    const goalKey = getCoordsKey(goal)\n\n    openSet.add(startKey)\n    gScore.set(startKey, 0)\n    fScore.set(startKey, this.heuristic(start, goal))\n\n    while (openSet.size > 0) {\n        let current = getLowestFScore(openSet, fScore)\n        let currentCoords = parseKey(current)\n\n        if (current === goalKey) {\n            return reconstructPath(cameFrom, current)\n        }\n\n        openSet.delete(current)\n        closedSet.add(current)\n\n        const directions = this.allowDiagonal ? eightDirections : fourDirections\n        const neighbors = Object.values(directions).map(direction => {\n            return {\n                x: currentCoords.x + direction.x,\n                y: currentCoords.y + direction.y\n            }\n        })\n\n        for (const neighbor of neighbors) {\n            const neighborKey = getCoordsKey(neighbor)\n\n            if (!grid.isInside(neighbor)) {\n                continue\n            }\n\n            if (!this.isWalkable(grid.getCell(neighbor))) {\n                continue\n            }\n\n            if (closedSet.has(neighborKey)) {\n                continue\n            }\n\n            const tentativeGScore = gScore.get(current) + getMoveCost(currentCoords, neighbor)\n\n            if (!openSet.has(neighborKey)) {\n                openSet.add(neighborKey)\n            } else if (tentativeGScore >= gScore.get(neighborKey)) {\n                continue\n            }\n\n            cameFrom.set(neighborKey, current)\n            gScore.set(neighborKey, tentativeGScore)\n            fScore.set(neighborKey, tentativeGScore + this.heuristic(neighbor, goal))\n        }\n    }\n\n    return null\n}",
        "kind": "method",
        "params": [
          "grid",
          "start",
          "goal"
        ]
      },
      {
        "name": "setHeuristic",
        "line": 100,
        "source": "setHeuristic (heuristic) {\n    this.heuristic = heuristic\n}",
        "kind": "method",
        "params": [
          "heuristic"
        ]
      },
      {
        "name": "setAllowDiagonal",
        "line": 105,
        "source": "setAllowDiagonal (allowDiagonal) {\n    this.allowDiagonal = allowDiagonal\n}",
        "kind": "method",
        "params": [
          "allowDiagonal"
        ]
      },
      {
        "name": "setWalkableFunction",
        "line": 110,
        "source": "setWalkableFunction (isWalkable) {\n    this.isWalkable = isWalkable\n}",
        "kind": "method",
        "params": [
          "isWalkable"
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 13,
      "source": "constructor (options = {}) {\n    const {\n        heuristic = heuristics.manhattan,\n        allowDiagonal = false,\n        isWalkable = () => true\n    } = options\n\n    this.heuristic = heuristic\n    this.allowDiagonal = allowDiagonal\n    this.isWalkable = isWalkable\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/math/vec2.doc.js": {
    "type": "class",
    "file": "/math/vec2.js",
    "name": "Vec2",
    "line": 1,
    "extends": null,
    "statics": [],
    "methods": [
      {
        "name": "set",
        "line": 19,
        "source": "set (x, y) {\n    this.x = x\n    this.y = y\n    return this\n}",
        "kind": "method",
        "params": [
          "x",
          "y"
        ]
      },
      {
        "name": "setX",
        "line": 26,
        "source": "setX (x) {\n    this.x = x\n    return this\n}",
        "kind": "method",
        "params": [
          "x"
        ]
      },
      {
        "name": "setY",
        "line": 32,
        "source": "setY (y) {\n    this.y = y\n    return this\n}",
        "kind": "method",
        "params": [
          "y"
        ]
      },
      {
        "name": "setScalar",
        "line": 38,
        "source": "setScalar (scalar) {\n    this.x = scalar\n    this.y = scalar\n    return this\n}",
        "kind": "method",
        "params": [
          "scalar"
        ]
      },
      {
        "name": "copy",
        "line": 45,
        "source": "copy (v) {\n    this.x = v.x\n    this.y = v.y\n    return this\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "clone",
        "line": 52,
        "source": "clone () {\n    return new Vec2(this.x, this.y)\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "add",
        "line": 57,
        "source": "add (v) {\n    this.x += v.x\n    this.y += v.y\n    return this\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "addScalar",
        "line": 64,
        "source": "addScalar (s) {\n    this.x += s\n    this.y += s\n    return this\n}",
        "kind": "method",
        "params": [
          "s"
        ]
      },
      {
        "name": "addVectors",
        "line": 71,
        "source": "addVectors (a, b) {\n    this.x = a.x + b.x\n    this.y = a.y + b.y\n    return this\n}",
        "kind": "method",
        "params": [
          "a",
          "b"
        ]
      },
      {
        "name": "addScaledVector",
        "line": 78,
        "source": "addScaledVector (v, s) {\n    this.x += v.x * s\n    this.y += v.y * s\n    return this\n}",
        "kind": "method",
        "params": [
          "v",
          "s"
        ]
      },
      {
        "name": "sub",
        "line": 85,
        "source": "sub (v) {\n    this.x -= v.x\n    this.y -= v.y\n    return this\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "subScalar",
        "line": 92,
        "source": "subScalar (s) {\n    this.x -= s\n    this.y -= s\n    return this\n}",
        "kind": "method",
        "params": [
          "s"
        ]
      },
      {
        "name": "subVectors",
        "line": 99,
        "source": "subVectors (a, b) {\n    this.x = a.x - b.x\n    this.y = a.y - b.y\n    return this\n}",
        "kind": "method",
        "params": [
          "a",
          "b"
        ]
      },
      {
        "name": "multiply",
        "line": 106,
        "source": "multiply (v) {\n    this.x *= v.x\n    this.y *= v.y\n    return this\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "multiplyScalar",
        "line": 113,
        "source": "multiplyScalar (scalar) {\n    this.x *= scalar\n    this.y *= scalar\n    return this\n}",
        "kind": "method",
        "params": [
          "scalar"
        ]
      },
      {
        "name": "divide",
        "line": 120,
        "source": "divide (v) {\n    this.x /= v.x\n    this.y /= v.y\n    return this\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "divideScalar",
        "line": 127,
        "source": "divideScalar (scalar) {\n    return this.multiplyScalar(1 / scalar)\n}",
        "kind": "method",
        "params": [
          "scalar"
        ]
      },
      {
        "name": "dot",
        "line": 132,
        "source": "dot (v) {\n    return this.x * v.x + this.y * v.y\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "cross",
        "line": 137,
        "source": "cross (v) {\n    return this.x * v.y - this.y * v.x\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "lengthSq",
        "line": 142,
        "source": "lengthSq () {\n    return this.x * this.x + this.y * this.y\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "length",
        "line": 147,
        "source": "length () {\n    return Math.sqrt(this.lengthSq())\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "manhattanLength",
        "line": 152,
        "source": "manhattanLength () {\n    return Math.abs(this.x) + Math.abs(this.y)\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "normalize",
        "line": 157,
        "source": "normalize () {\n    return this.divideScalar(this.length() || 1)\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "angle",
        "line": 162,
        "source": "angle () {\n    return Math.atan2(-this.y, -this.x) + Math.PI\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "angleTo",
        "line": 167,
        "source": "angleTo (v) {\n    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq())\n    if (denominator === 0) {\n        return Math.PI / 2\n    }\n    const theta = this.dot(v) / denominator\n    return Math.acos(Math.max(-1, Math.min(1, theta)))\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "distanceTo",
        "line": 177,
        "source": "distanceTo (v) {\n    return Math.sqrt(this.distanceToSquared(v))\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "distanceToSquared",
        "line": 182,
        "source": "distanceToSquared (v) {\n    const dx = this.x - v.x\n    const dy = this.y - v.y\n    return dx * dx + dy * dy\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "manhattanDistanceTo",
        "line": 189,
        "source": "manhattanDistanceTo (v) {\n    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y)\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "setLength",
        "line": 194,
        "source": "setLength (length) {\n    return this.normalize().multiplyScalar(length)\n}",
        "kind": "method",
        "params": [
          "length"
        ]
      },
      {
        "name": "lerp",
        "line": 199,
        "source": "lerp (v, alpha) {\n    this.x += (v.x - this.x) * alpha\n    this.y += (v.y - this.y) * alpha\n    return this\n}",
        "kind": "method",
        "params": [
          "v",
          "alpha"
        ]
      },
      {
        "name": "lerpVectors",
        "line": 206,
        "source": "lerpVectors (v1, v2, alpha) {\n    this.x = v1.x + (v2.x - v1.x) * alpha\n    this.y = v1.y + (v2.y - v1.y) * alpha\n    return this\n}",
        "kind": "method",
        "params": [
          "v1",
          "v2",
          "alpha"
        ]
      },
      {
        "name": "equals",
        "line": 213,
        "source": "equals (v) {\n    return v.x === this.x && v.y === this.y\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "fromArray",
        "line": 218,
        "source": "fromArray (array, offset = 0) {\n    this.x = array[offset]\n    this.y = array[offset + 1]\n    return this\n}",
        "kind": "method",
        "params": [
          "array",
          "offset = ..."
        ]
      },
      {
        "name": "toArray",
        "line": 225,
        "source": "toArray (array = [], offset = 0) {\n    array[offset] = this.x\n    array[offset + 1] = this.y\n    return array\n}",
        "kind": "method",
        "params": [
          "array = ...",
          "offset = ..."
        ]
      },
      {
        "name": "negate",
        "line": 232,
        "source": "negate () {\n    this.x = -this.x\n    this.y = -this.y\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "min",
        "line": 239,
        "source": "min (v) {\n    this.x = Math.min(this.x, v.x)\n    this.y = Math.min(this.y, v.y)\n    return this\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "max",
        "line": 246,
        "source": "max (v) {\n    this.x = Math.max(this.x, v.x)\n    this.y = Math.max(this.y, v.y)\n    return this\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "clamp",
        "line": 253,
        "source": "clamp (min, max) {\n    this.x = Math.max(min.x, Math.min(max.x, this.x))\n    this.y = Math.max(min.y, Math.min(max.y, this.y))\n    return this\n}",
        "kind": "method",
        "params": [
          "min",
          "max"
        ]
      },
      {
        "name": "clampScalar",
        "line": 260,
        "source": "clampScalar (minVal, maxVal) {\n    this.x = Math.max(minVal, Math.min(maxVal, this.x))\n    this.y = Math.max(minVal, Math.min(maxVal, this.y))\n    return this\n}",
        "kind": "method",
        "params": [
          "minVal",
          "maxVal"
        ]
      },
      {
        "name": "clampLength",
        "line": 267,
        "source": "clampLength (min, max) {\n    const length = this.length()\n    return this.divideScalar(length || 1).multiplyScalar(\n        Math.max(min, Math.min(max, length))\n    )\n}",
        "kind": "method",
        "params": [
          "min",
          "max"
        ]
      },
      {
        "name": "floor",
        "line": 275,
        "source": "floor () {\n    this.x = Math.floor(this.x)\n    this.y = Math.floor(this.y)\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "ceil",
        "line": 282,
        "source": "ceil () {\n    this.x = Math.ceil(this.x)\n    this.y = Math.ceil(this.y)\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "round",
        "line": 289,
        "source": "round () {\n    this.x = Math.round(this.x)\n    this.y = Math.round(this.y)\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "roundToZero",
        "line": 296,
        "source": "roundToZero () {\n    this.x = Math.trunc(this.x)\n    this.y = Math.trunc(this.y)\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "rotateAround",
        "line": 303,
        "source": "rotateAround (center, angle) {\n    const c = Math.cos(angle)\n    const s = Math.sin(angle)\n\n    const x = this.x - center.x\n    const y = this.y - center.y\n\n    this.x = x * c - y * s + center.x\n    this.y = x * s + y * c + center.y\n\n    return this\n}",
        "kind": "method",
        "params": [
          "center",
          "angle"
        ]
      },
      {
        "name": "random",
        "line": 317,
        "source": "random () {\n    this.x = Math.random()\n    this.y = Math.random()\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "getComponent",
        "line": 324,
        "source": "getComponent (index) {\n    if (index === 0) {\n        return this.x\n    } else if (index === 1) {\n        return this.y\n    }\n    throw new Error(`index out of range: ${index}`)\n}",
        "kind": "method",
        "params": [
          "index"
        ]
      },
      {
        "name": "setComponent",
        "line": 334,
        "source": "setComponent (index, value) {\n    if (index === 0) {\n        this.x = value\n    } else if (index === 1) {\n        this.y = value\n    } else {\n        throw new Error(`index out of range: ${index}`)\n    }\n    return this\n}",
        "kind": "method",
        "params": [
          "index",
          "value"
        ]
      }
    ],
    "getters": [
      {
        "name": "width",
        "line": 346,
        "source": "get width () {\n    return this.x\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "height",
        "line": 356,
        "source": "get height () {\n    return this.y\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "isVector2",
        "line": 366,
        "source": "get isVector2 () { // eslint-disable-line local/class-methods-use-this -- clean\n    return true\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "width",
        "line": 351,
        "source": "set width (value) {\n    this.x = value\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "height",
        "line": 361,
        "source": "set height (value) {\n    this.y = value\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      }
    ],
    "constructor": {
      "name": "constructor",
      "line": 3,
      "source": "constructor (x = 0, y = 0) {\n    if (typeof x === 'object') {\n        if (Array.isArray(x)) {\n            this.x = x[0] ?? 0\n            this.y = x[1] ?? 0\n        } else {\n            this.x = x.x ?? 0\n            this.y = x.y ?? 0\n        }\n    } else {\n        this.x = x\n        this.y = y\n    }\n}",
      "kind": "constructor",
      "params": [
        "x = ...",
        "y = ..."
      ]
    },
    "isDefault": true
  },
  "/math/vec3.doc.js": {
    "type": "class",
    "file": "/math/vec3.js",
    "name": "Vec3",
    "line": 1,
    "extends": null,
    "statics": [],
    "methods": [
      {
        "name": "set",
        "line": 22,
        "source": "set (x, y, z) {\n    this.x = x\n    this.y = y\n    this.z = z\n    return this\n}",
        "kind": "method",
        "params": [
          "x",
          "y",
          "z"
        ]
      },
      {
        "name": "setX",
        "line": 30,
        "source": "setX (x) {\n    this.x = x\n    return this\n}",
        "kind": "method",
        "params": [
          "x"
        ]
      },
      {
        "name": "setY",
        "line": 36,
        "source": "setY (y) {\n    this.y = y\n    return this\n}",
        "kind": "method",
        "params": [
          "y"
        ]
      },
      {
        "name": "setZ",
        "line": 42,
        "source": "setZ (z) {\n    this.z = z\n    return this\n}",
        "kind": "method",
        "params": [
          "z"
        ]
      },
      {
        "name": "setScalar",
        "line": 48,
        "source": "setScalar (scalar) {\n    this.x = scalar\n    this.y = scalar\n    this.z = scalar\n    return this\n}",
        "kind": "method",
        "params": [
          "scalar"
        ]
      },
      {
        "name": "copy",
        "line": 56,
        "source": "copy (v) {\n    this.x = v.x\n    this.y = v.y\n    this.z = v.z\n    return this\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "clone",
        "line": 64,
        "source": "clone () {\n    return new Vec3(this.x, this.y, this.z)\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "add",
        "line": 69,
        "source": "add (v) {\n    this.x += v.x\n    this.y += v.y\n    this.z += v.z\n    return this\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "addScalar",
        "line": 77,
        "source": "addScalar (s) {\n    this.x += s\n    this.y += s\n    this.z += s\n    return this\n}",
        "kind": "method",
        "params": [
          "s"
        ]
      },
      {
        "name": "addVectors",
        "line": 85,
        "source": "addVectors (a, b) {\n    this.x = a.x + b.x\n    this.y = a.y + b.y\n    this.z = a.z + b.z\n    return this\n}",
        "kind": "method",
        "params": [
          "a",
          "b"
        ]
      },
      {
        "name": "addScaledVector",
        "line": 93,
        "source": "addScaledVector (v, s) {\n    this.x += v.x * s\n    this.y += v.y * s\n    this.z += v.z * s\n    return this\n}",
        "kind": "method",
        "params": [
          "v",
          "s"
        ]
      },
      {
        "name": "sub",
        "line": 101,
        "source": "sub (v) {\n    this.x -= v.x\n    this.y -= v.y\n    this.z -= v.z\n    return this\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "subScalar",
        "line": 109,
        "source": "subScalar (s) {\n    this.x -= s\n    this.y -= s\n    this.z -= s\n    return this\n}",
        "kind": "method",
        "params": [
          "s"
        ]
      },
      {
        "name": "subVectors",
        "line": 117,
        "source": "subVectors (a, b) {\n    this.x = a.x - b.x\n    this.y = a.y - b.y\n    this.z = a.z - b.z\n    return this\n}",
        "kind": "method",
        "params": [
          "a",
          "b"
        ]
      },
      {
        "name": "multiply",
        "line": 125,
        "source": "multiply (v) {\n    this.x *= v.x\n    this.y *= v.y\n    this.z *= v.z\n    return this\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "multiplyScalar",
        "line": 133,
        "source": "multiplyScalar (scalar) {\n    this.x *= scalar\n    this.y *= scalar\n    this.z *= scalar\n    return this\n}",
        "kind": "method",
        "params": [
          "scalar"
        ]
      },
      {
        "name": "multiplyVectors",
        "line": 141,
        "source": "multiplyVectors (a, b) {\n    this.x = a.x * b.x\n    this.y = a.y * b.y\n    this.z = a.z * b.z\n    return this\n}",
        "kind": "method",
        "params": [
          "a",
          "b"
        ]
      },
      {
        "name": "divide",
        "line": 149,
        "source": "divide (v) {\n    this.x /= v.x\n    this.y /= v.y\n    this.z /= v.z\n    return this\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "divideScalar",
        "line": 157,
        "source": "divideScalar (scalar) {\n    return this.multiplyScalar(1 / scalar)\n}",
        "kind": "method",
        "params": [
          "scalar"
        ]
      },
      {
        "name": "dot",
        "line": 162,
        "source": "dot (v) {\n    return this.x * v.x + this.y * v.y + this.z * v.z\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "cross",
        "line": 167,
        "source": "cross (v) {\n    return this.crossVectors(this, v)\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "crossVectors",
        "line": 172,
        "source": "crossVectors (a, b) {\n    const ax = a.x\n    const ay = a.y\n    const az = a.z\n    const bx = b.x\n    const by = b.y\n    const bz = b.z\n\n    this.x = ay * bz - az * by\n    this.y = az * bx - ax * bz\n    this.z = ax * by - ay * bx\n\n    return this\n}",
        "kind": "method",
        "params": [
          "a",
          "b"
        ]
      },
      {
        "name": "lengthSq",
        "line": 188,
        "source": "lengthSq () {\n    return this.x * this.x + this.y * this.y + this.z * this.z\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "length",
        "line": 193,
        "source": "length () {\n    return Math.sqrt(this.lengthSq())\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "manhattanLength",
        "line": 198,
        "source": "manhattanLength () {\n    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "normalize",
        "line": 203,
        "source": "normalize () {\n    return this.divideScalar(this.length() || 1)\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "setLength",
        "line": 208,
        "source": "setLength (length) {\n    return this.normalize().multiplyScalar(length)\n}",
        "kind": "method",
        "params": [
          "length"
        ]
      },
      {
        "name": "angleTo",
        "line": 213,
        "source": "angleTo (v) {\n    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq())\n    if (denominator === 0) {\n        return Math.PI / 2\n    }\n    const theta = this.dot(v) / denominator\n    return Math.acos(Math.max(-1, Math.min(1, theta)))\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "distanceTo",
        "line": 223,
        "source": "distanceTo (v) {\n    return Math.sqrt(this.distanceToSquared(v))\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "distanceToSquared",
        "line": 228,
        "source": "distanceToSquared (v) {\n    const dx = this.x - v.x\n    const dy = this.y - v.y\n    const dz = this.z - v.z\n    return dx * dx + dy * dy + dz * dz\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "manhattanDistanceTo",
        "line": 236,
        "source": "manhattanDistanceTo (v) {\n    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z)\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "lerp",
        "line": 241,
        "source": "lerp (v, alpha) {\n    this.x += (v.x - this.x) * alpha\n    this.y += (v.y - this.y) * alpha\n    this.z += (v.z - this.z) * alpha\n    return this\n}",
        "kind": "method",
        "params": [
          "v",
          "alpha"
        ]
      },
      {
        "name": "lerpVectors",
        "line": 249,
        "source": "lerpVectors (v1, v2, alpha) {\n    this.x = v1.x + (v2.x - v1.x) * alpha\n    this.y = v1.y + (v2.y - v1.y) * alpha\n    this.z = v1.z + (v2.z - v1.z) * alpha\n    return this\n}",
        "kind": "method",
        "params": [
          "v1",
          "v2",
          "alpha"
        ]
      },
      {
        "name": "equals",
        "line": 257,
        "source": "equals (v) {\n    return v.x === this.x && v.y === this.y && v.z === this.z\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "fromArray",
        "line": 262,
        "source": "fromArray (array, offset = 0) {\n    this.x = array[offset]\n    this.y = array[offset + 1]\n    this.z = array[offset + 2]\n    return this\n}",
        "kind": "method",
        "params": [
          "array",
          "offset = ..."
        ]
      },
      {
        "name": "toArray",
        "line": 270,
        "source": "toArray (array = [], offset = 0) {\n    array[offset] = this.x\n    array[offset + 1] = this.y\n    array[offset + 2] = this.z\n    return array\n}",
        "kind": "method",
        "params": [
          "array = ...",
          "offset = ..."
        ]
      },
      {
        "name": "negate",
        "line": 278,
        "source": "negate () {\n    this.x = -this.x\n    this.y = -this.y\n    this.z = -this.z\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "min",
        "line": 286,
        "source": "min (v) {\n    this.x = Math.min(this.x, v.x)\n    this.y = Math.min(this.y, v.y)\n    this.z = Math.min(this.z, v.z)\n    return this\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "max",
        "line": 294,
        "source": "max (v) {\n    this.x = Math.max(this.x, v.x)\n    this.y = Math.max(this.y, v.y)\n    this.z = Math.max(this.z, v.z)\n    return this\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "clamp",
        "line": 302,
        "source": "clamp (min, max) {\n    this.x = Math.max(min.x, Math.min(max.x, this.x))\n    this.y = Math.max(min.y, Math.min(max.y, this.y))\n    this.z = Math.max(min.z, Math.min(max.z, this.z))\n    return this\n}",
        "kind": "method",
        "params": [
          "min",
          "max"
        ]
      },
      {
        "name": "clampScalar",
        "line": 310,
        "source": "clampScalar (minVal, maxVal) {\n    this.x = Math.max(minVal, Math.min(maxVal, this.x))\n    this.y = Math.max(minVal, Math.min(maxVal, this.y))\n    this.z = Math.max(minVal, Math.min(maxVal, this.z))\n    return this\n}",
        "kind": "method",
        "params": [
          "minVal",
          "maxVal"
        ]
      },
      {
        "name": "clampLength",
        "line": 318,
        "source": "clampLength (min, max) {\n    const length = this.length()\n    return this.divideScalar(length || 1).multiplyScalar(\n        Math.max(min, Math.min(max, length))\n    )\n}",
        "kind": "method",
        "params": [
          "min",
          "max"
        ]
      },
      {
        "name": "floor",
        "line": 326,
        "source": "floor () {\n    this.x = Math.floor(this.x)\n    this.y = Math.floor(this.y)\n    this.z = Math.floor(this.z)\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "ceil",
        "line": 334,
        "source": "ceil () {\n    this.x = Math.ceil(this.x)\n    this.y = Math.ceil(this.y)\n    this.z = Math.ceil(this.z)\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "round",
        "line": 342,
        "source": "round () {\n    this.x = Math.round(this.x)\n    this.y = Math.round(this.y)\n    this.z = Math.round(this.z)\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "roundToZero",
        "line": 350,
        "source": "roundToZero () {\n    this.x = Math.trunc(this.x)\n    this.y = Math.trunc(this.y)\n    this.z = Math.trunc(this.z)\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "random",
        "line": 358,
        "source": "random () {\n    this.x = Math.random()\n    this.y = Math.random()\n    this.z = Math.random()\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "randomDirection",
        "line": 366,
        "source": "randomDirection () {\n    const u = (Math.random() - 0.5) * 2\n    const t = Math.random() * Math.PI * 2\n    const f = Math.sqrt(1 - u * u)\n\n    this.x = f * Math.cos(t)\n    this.y = f * Math.sin(t)\n    this.z = u\n\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "reflect",
        "line": 379,
        "source": "reflect (normal) {\n    return this.sub(new Vec3().copy(normal).multiplyScalar(2 * this.dot(normal)))\n}",
        "kind": "method",
        "params": [
          "normal"
        ]
      },
      {
        "name": "projectOnVector",
        "line": 384,
        "source": "projectOnVector (v) {\n    const denominator = v.lengthSq()\n    if (denominator === 0) {\n        return this.set(0, 0, 0)\n    }\n    const scalar = v.dot(this) / denominator\n    return this.copy(v).multiplyScalar(scalar)\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "projectOnPlane",
        "line": 394,
        "source": "projectOnPlane (planeNormal) {\n    const projected = new Vec3().copy(this).projectOnVector(planeNormal)\n    return this.sub(projected)\n}",
        "kind": "method",
        "params": [
          "planeNormal"
        ]
      },
      {
        "name": "applyAxisAngle",
        "line": 400,
        "source": "applyAxisAngle (axis, angle) {\n    const halfAngle = angle / 2\n    const s = Math.sin(halfAngle)\n\n    const qx = axis.x * s\n    const qy = axis.y * s\n    const qz = axis.z * s\n    const qw = Math.cos(halfAngle)\n\n    const ix = qw * this.x + qy * this.z - qz * this.y\n    const iy = qw * this.y + qz * this.x - qx * this.z\n    const iz = qw * this.z + qx * this.y - qy * this.x\n    const iw = -qx * this.x - qy * this.y - qz * this.z\n\n    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy\n    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz\n    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx\n\n    return this\n}",
        "kind": "method",
        "params": [
          "axis",
          "angle"
        ]
      },
      {
        "name": "getComponent",
        "line": 422,
        "source": "getComponent (index) {\n    if (index === 0) {\n        return this.x\n    } else if (index === 1) {\n        return this.y\n    } else if (index === 2) {\n        return this.z\n    }\n    throw new Error(`index out of range: ${index}`)\n}",
        "kind": "method",
        "params": [
          "index"
        ]
      },
      {
        "name": "setComponent",
        "line": 434,
        "source": "setComponent (index, value) {\n    if (index === 0) {\n        this.x = value\n    } else if (index === 1) {\n        this.y = value\n    } else if (index === 2) {\n        this.z = value\n    } else {\n        throw new Error(`index out of range: ${index}`)\n    }\n    return this\n}",
        "kind": "method",
        "params": [
          "index",
          "value"
        ]
      }
    ],
    "getters": [
      {
        "name": "isVector3",
        "line": 448,
        "source": "get isVector3 () { // eslint-disable-line local/class-methods-use-this -- clean\n    return true\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 3,
      "source": "constructor (x = 0, y = 0, z = 0) { // eslint-disable-line complexity -- clean\n    if (typeof x === 'object') {\n        if (Array.isArray(x)) {\n            this.x = x[0] ?? 0\n            this.y = x[1] ?? 0\n            this.z = x[2] ?? 0\n        } else {\n            this.x = x.x ?? 0\n            this.y = x.y ?? 0\n            this.z = x.z ?? 0\n        }\n    } else {\n        this.x = x\n        this.y = y\n        this.z = z\n    }\n}",
      "kind": "constructor",
      "params": [
        "x = ...",
        "y = ...",
        "z = ..."
      ]
    },
    "isDefault": true
  },
  "/math/vec4.doc.js": {
    "type": "class",
    "file": "/math/vec4.js",
    "name": "Vec4",
    "line": 1,
    "extends": null,
    "statics": [],
    "methods": [
      {
        "name": "set",
        "line": 25,
        "source": "set (x, y, z, w) {\n    this.x = x\n    this.y = y\n    this.z = z\n    this.w = w\n    return this\n}",
        "kind": "method",
        "params": [
          "x",
          "y",
          "z",
          "w"
        ]
      },
      {
        "name": "setX",
        "line": 34,
        "source": "setX (x) {\n    this.x = x\n    return this\n}",
        "kind": "method",
        "params": [
          "x"
        ]
      },
      {
        "name": "setY",
        "line": 40,
        "source": "setY (y) {\n    this.y = y\n    return this\n}",
        "kind": "method",
        "params": [
          "y"
        ]
      },
      {
        "name": "setZ",
        "line": 46,
        "source": "setZ (z) {\n    this.z = z\n    return this\n}",
        "kind": "method",
        "params": [
          "z"
        ]
      },
      {
        "name": "setW",
        "line": 52,
        "source": "setW (w) {\n    this.w = w\n    return this\n}",
        "kind": "method",
        "params": [
          "w"
        ]
      },
      {
        "name": "setScalar",
        "line": 58,
        "source": "setScalar (scalar) {\n    this.x = scalar\n    this.y = scalar\n    this.z = scalar\n    this.w = scalar\n    return this\n}",
        "kind": "method",
        "params": [
          "scalar"
        ]
      },
      {
        "name": "copy",
        "line": 67,
        "source": "copy (v) {\n    this.x = v.x\n    this.y = v.y\n    this.z = v.z ?? 0\n    this.w = v.w ?? 1\n    return this\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "clone",
        "line": 76,
        "source": "clone () {\n    return new Vec4(this.x, this.y, this.z, this.w)\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "add",
        "line": 81,
        "source": "add (v) {\n    this.x += v.x\n    this.y += v.y\n    this.z += v.z\n    this.w += v.w\n    return this\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "addScalar",
        "line": 90,
        "source": "addScalar (s) {\n    this.x += s\n    this.y += s\n    this.z += s\n    this.w += s\n    return this\n}",
        "kind": "method",
        "params": [
          "s"
        ]
      },
      {
        "name": "addVectors",
        "line": 99,
        "source": "addVectors (a, b) {\n    this.x = a.x + b.x\n    this.y = a.y + b.y\n    this.z = a.z + b.z\n    this.w = a.w + b.w\n    return this\n}",
        "kind": "method",
        "params": [
          "a",
          "b"
        ]
      },
      {
        "name": "addScaledVector",
        "line": 108,
        "source": "addScaledVector (v, s) {\n    this.x += v.x * s\n    this.y += v.y * s\n    this.z += v.z * s\n    this.w += v.w * s\n    return this\n}",
        "kind": "method",
        "params": [
          "v",
          "s"
        ]
      },
      {
        "name": "sub",
        "line": 117,
        "source": "sub (v) {\n    this.x -= v.x\n    this.y -= v.y\n    this.z -= v.z\n    this.w -= v.w\n    return this\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "subScalar",
        "line": 126,
        "source": "subScalar (s) {\n    this.x -= s\n    this.y -= s\n    this.z -= s\n    this.w -= s\n    return this\n}",
        "kind": "method",
        "params": [
          "s"
        ]
      },
      {
        "name": "subVectors",
        "line": 135,
        "source": "subVectors (a, b) {\n    this.x = a.x - b.x\n    this.y = a.y - b.y\n    this.z = a.z - b.z\n    this.w = a.w - b.w\n    return this\n}",
        "kind": "method",
        "params": [
          "a",
          "b"
        ]
      },
      {
        "name": "multiply",
        "line": 144,
        "source": "multiply (v) {\n    this.x *= v.x\n    this.y *= v.y\n    this.z *= v.z\n    this.w *= v.w\n    return this\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "multiplyScalar",
        "line": 153,
        "source": "multiplyScalar (scalar) {\n    this.x *= scalar\n    this.y *= scalar\n    this.z *= scalar\n    this.w *= scalar\n    return this\n}",
        "kind": "method",
        "params": [
          "scalar"
        ]
      },
      {
        "name": "divide",
        "line": 162,
        "source": "divide (v) {\n    this.x /= v.x\n    this.y /= v.y\n    this.z /= v.z\n    this.w /= v.w\n    return this\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "divideScalar",
        "line": 171,
        "source": "divideScalar (scalar) {\n    return this.multiplyScalar(1 / scalar)\n}",
        "kind": "method",
        "params": [
          "scalar"
        ]
      },
      {
        "name": "dot",
        "line": 176,
        "source": "dot (v) {\n    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "lengthSq",
        "line": 181,
        "source": "lengthSq () {\n    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "length",
        "line": 186,
        "source": "length () {\n    return Math.sqrt(this.lengthSq())\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "manhattanLength",
        "line": 191,
        "source": "manhattanLength () {\n    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "normalize",
        "line": 196,
        "source": "normalize () {\n    return this.divideScalar(this.length() || 1)\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "setLength",
        "line": 201,
        "source": "setLength (length) {\n    return this.normalize().multiplyScalar(length)\n}",
        "kind": "method",
        "params": [
          "length"
        ]
      },
      {
        "name": "lerp",
        "line": 206,
        "source": "lerp (v, alpha) {\n    this.x += (v.x - this.x) * alpha\n    this.y += (v.y - this.y) * alpha\n    this.z += (v.z - this.z) * alpha\n    this.w += (v.w - this.w) * alpha\n    return this\n}",
        "kind": "method",
        "params": [
          "v",
          "alpha"
        ]
      },
      {
        "name": "lerpVectors",
        "line": 215,
        "source": "lerpVectors (v1, v2, alpha) {\n    this.x = v1.x + (v2.x - v1.x) * alpha\n    this.y = v1.y + (v2.y - v1.y) * alpha\n    this.z = v1.z + (v2.z - v1.z) * alpha\n    this.w = v1.w + (v2.w - v1.w) * alpha\n    return this\n}",
        "kind": "method",
        "params": [
          "v1",
          "v2",
          "alpha"
        ]
      },
      {
        "name": "equals",
        "line": 224,
        "source": "equals (v) {\n    return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "fromArray",
        "line": 229,
        "source": "fromArray (array, offset = 0) {\n    this.x = array[offset]\n    this.y = array[offset + 1]\n    this.z = array[offset + 2]\n    this.w = array[offset + 3]\n    return this\n}",
        "kind": "method",
        "params": [
          "array",
          "offset = ..."
        ]
      },
      {
        "name": "toArray",
        "line": 238,
        "source": "toArray (array = [], offset = 0) {\n    array[offset] = this.x\n    array[offset + 1] = this.y\n    array[offset + 2] = this.z\n    array[offset + 3] = this.w\n    return array\n}",
        "kind": "method",
        "params": [
          "array = ...",
          "offset = ..."
        ]
      },
      {
        "name": "negate",
        "line": 247,
        "source": "negate () {\n    this.x = -this.x\n    this.y = -this.y\n    this.z = -this.z\n    this.w = -this.w\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "min",
        "line": 256,
        "source": "min (v) {\n    this.x = Math.min(this.x, v.x)\n    this.y = Math.min(this.y, v.y)\n    this.z = Math.min(this.z, v.z)\n    this.w = Math.min(this.w, v.w)\n    return this\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "max",
        "line": 265,
        "source": "max (v) {\n    this.x = Math.max(this.x, v.x)\n    this.y = Math.max(this.y, v.y)\n    this.z = Math.max(this.z, v.z)\n    this.w = Math.max(this.w, v.w)\n    return this\n}",
        "kind": "method",
        "params": [
          "v"
        ]
      },
      {
        "name": "clamp",
        "line": 274,
        "source": "clamp (min, max) {\n    this.x = Math.max(min.x, Math.min(max.x, this.x))\n    this.y = Math.max(min.y, Math.min(max.y, this.y))\n    this.z = Math.max(min.z, Math.min(max.z, this.z))\n    this.w = Math.max(min.w, Math.min(max.w, this.w))\n    return this\n}",
        "kind": "method",
        "params": [
          "min",
          "max"
        ]
      },
      {
        "name": "clampScalar",
        "line": 283,
        "source": "clampScalar (minVal, maxVal) {\n    this.x = Math.max(minVal, Math.min(maxVal, this.x))\n    this.y = Math.max(minVal, Math.min(maxVal, this.y))\n    this.z = Math.max(minVal, Math.min(maxVal, this.z))\n    this.w = Math.max(minVal, Math.min(maxVal, this.w))\n    return this\n}",
        "kind": "method",
        "params": [
          "minVal",
          "maxVal"
        ]
      },
      {
        "name": "clampLength",
        "line": 292,
        "source": "clampLength (min, max) {\n    const length = this.length()\n    return this.divideScalar(length || 1).multiplyScalar(\n        Math.max(min, Math.min(max, length))\n    )\n}",
        "kind": "method",
        "params": [
          "min",
          "max"
        ]
      },
      {
        "name": "floor",
        "line": 300,
        "source": "floor () {\n    this.x = Math.floor(this.x)\n    this.y = Math.floor(this.y)\n    this.z = Math.floor(this.z)\n    this.w = Math.floor(this.w)\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "ceil",
        "line": 309,
        "source": "ceil () {\n    this.x = Math.ceil(this.x)\n    this.y = Math.ceil(this.y)\n    this.z = Math.ceil(this.z)\n    this.w = Math.ceil(this.w)\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "round",
        "line": 318,
        "source": "round () {\n    this.x = Math.round(this.x)\n    this.y = Math.round(this.y)\n    this.z = Math.round(this.z)\n    this.w = Math.round(this.w)\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "roundToZero",
        "line": 327,
        "source": "roundToZero () {\n    this.x = Math.trunc(this.x)\n    this.y = Math.trunc(this.y)\n    this.z = Math.trunc(this.z)\n    this.w = Math.trunc(this.w)\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "random",
        "line": 336,
        "source": "random () {\n    this.x = Math.random()\n    this.y = Math.random()\n    this.z = Math.random()\n    this.w = Math.random()\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "getComponent",
        "line": 345,
        "source": "getComponent (index) {\n    if (index === 0) {\n        return this.x\n    } else if (index === 1) {\n        return this.y\n    } else if (index === 2) {\n        return this.z\n    } else if (index === 3) {\n        return this.w\n    }\n    throw new Error(`index out of range: ${index}`)\n}",
        "kind": "method",
        "params": [
          "index"
        ]
      },
      {
        "name": "setComponent",
        "line": 359,
        "source": "setComponent (index, value) {\n    if (index === 0) {\n        this.x = value\n    } else if (index === 1) {\n        this.y = value\n    } else if (index === 2) {\n        this.z = value\n    } else if (index === 3) {\n        this.w = value\n    } else {\n        throw new Error(`index out of range: ${index}`)\n    }\n    return this\n}",
        "kind": "method",
        "params": [
          "index",
          "value"
        ]
      }
    ],
    "getters": [
      {
        "name": "width",
        "line": 375,
        "source": "get width () {\n    return this.z\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "height",
        "line": 385,
        "source": "get height () {\n    return this.w\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "isVector4",
        "line": 395,
        "source": "get isVector4 () { // eslint-disable-line local/class-methods-use-this -- clean\n    return true\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "width",
        "line": 380,
        "source": "set width (value) {\n    this.z = value\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "height",
        "line": 390,
        "source": "set height (value) {\n    this.w = value\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      }
    ],
    "constructor": {
      "name": "constructor",
      "line": 3,
      "source": "constructor (x = 0, y = 0, z = 0, w = 1) { // eslint-disable-line complexity -- clean\n    if (typeof x === 'object') {\n        if (Array.isArray(x)) {\n            this.x = x[0] ?? 0\n            this.y = x[1] ?? 0\n            this.z = x[2] ?? 0\n            this.w = x[3] ?? 1\n        } else {\n            this.x = x.x ?? 0\n            this.y = x.y ?? 0\n            this.z = x.z ?? 0\n            this.w = x.w ?? 1\n        }\n    } else {\n        this.x = x\n        this.y = y\n        this.z = z\n        this.w = w\n    }\n}",
      "kind": "constructor",
      "params": [
        "x = ...",
        "y = ...",
        "z = ...",
        "w = ..."
      ]
    },
    "isDefault": true
  },
  "/math/services/pathfinding_service.doc.js": {
    "type": "class",
    "file": "/math/services/pathfinding_service.js",
    "name": "PathfindingService",
    "line": 6,
    "extends": "ServiceHost",
    "statics": [
      {
        "name": "serviceMethods",
        "line": 8,
        "source": "static serviceMethods = ['findPath', 'setGrid', 'setCell']",
        "kind": "property",
        "value": "['findPath', 'setGrid', 'setCell']"
      }
    ],
    "methods": [
      {
        "name": "setGrid",
        "line": 25,
        "source": "setGrid (req, res) {\n    try {\n        const {gridData} = req.params\n\n        if (!gridData) {\n            res.error('Missing gridData parameter')\n            return\n        }\n\n        this.grid = new Grid({\n            width: gridData.width,\n            height: gridData.height\n        })\n\n        if (gridData.cells) {\n            Object.entries(gridData.cells).forEach(([key, value]) => {\n                const coords = parseCellKey(key)\n                this.grid.setCell(coords, value)\n            })\n        }\n\n        this.pathCache.clear()\n\n        res.send({\n            success: true,\n            gridSize: `${gridData.width}x${gridData.height}`,\n            cellCount: Object.keys(gridData.cells || {}).length\n        })\n\n    } catch (error) {\n        res.error(`Failed to set grid: ${error.message}`)\n    }\n}",
        "kind": "method",
        "params": [
          "req",
          "res"
        ]
      },
      {
        "name": "setCell",
        "line": 60,
        "source": "setCell (req, res) {\n    try {\n        const {coords, value} = req.params\n\n        if (!this.grid) {\n            res.error('No grid set. Call setGrid first.')\n            return\n        }\n\n        if (!coords || (coords.x === undefined || coords.y === undefined)) {\n            res.error('Missing or invalid coords parameter')\n            return\n        }\n\n        this.grid.setCell(coords, value)\n\n        this.pathCache.clear()\n\n        res.send({\n            success: true,\n            coords,\n            value,\n            cacheCleared: true\n        })\n\n    } catch (error) {\n        res.error(`Failed to set cell: ${error.message}`)\n    }\n}",
        "kind": "method",
        "params": [
          "req",
          "res"
        ]
      },
      {
        "name": "findPath",
        "line": 91,
        "source": "findPath (req, res) { // eslint-disable-line complexity -- clean\n    try {\n        const {start, goal, options = {}} = req.params\n\n        if (!this.grid) {\n            res.error('No grid set. Call setGrid first.')\n            return\n        }\n\n        if (!start || !goal) {\n            res.error('Missing start or goal coordinates')\n            return\n        }\n\n        if (options.heuristic && heuristics[options.heuristic]) {\n            this.pathfinder.setHeuristic(heuristics[options.heuristic])\n        }\n\n        if (typeof options.allowDiagonal === 'boolean') {\n            this.pathfinder.setAllowDiagonal(options.allowDiagonal)\n        }\n\n        const cacheKey = getCacheKey(start, goal, options)\n        if (this.pathCache.has(cacheKey)) {\n            const cachedResult = this.pathCache.get(cacheKey)\n            res.send({\n                ...cachedResult,\n                cached: true\n            })\n            return\n        }\n\n        const startTime = performance.now()\n        const path = this.pathfinder.findPath(this.grid, start, goal)\n        const calculationTime = performance.now() - startTime\n\n        const result = {\n            path: path || [],\n            found: Boolean(path),\n            length: path ? path.length : 0,\n            calculationTime,\n            cached: false\n        }\n\n        this.cacheResult(cacheKey, result)\n\n        res.send(result)\n\n    } catch (error) {\n        res.error(`Pathfinding failed: ${error.message}`)\n    }\n}",
        "kind": "method",
        "params": [
          "req",
          "res"
        ]
      },
      {
        "name": "cacheResult",
        "line": 145,
        "source": "cacheResult (key, result) {\n    if (this.pathCache.size >= this.maxCacheSize) {\n        const firstKey = this.pathCache.keys().next().value\n        this.pathCache.delete(firstKey)\n    }\n\n    this.pathCache.set(key, {\n        path: result.path,\n        found: result.found,\n        length: result.length,\n        calculationTime: result.calculationTime\n    })\n}",
        "kind": "method",
        "params": [
          "key",
          "result"
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 10,
      "source": "constructor (config = {}) {\n    super(config)\n\n    this.grid = null\n    this.pathfinder = new Pathfinder({\n        heuristic: heuristics[config.heuristic] ?? heuristics.manhattan,\n        allowDiagonal: config.allowDiagonal ?? true,\n        isWalkable: isWalkable\n    })\n\n    this.pathCache = new Map()\n    this.maxCacheSize = config.maxCacheSize || 500\n}",
      "kind": "constructor",
      "params": [
        "config = ..."
      ]
    },
    "isDefault": true
  },
  "/render/canvas_renderer.doc.js": {
    "type": "class",
    "file": "/render/canvas_renderer.js",
    "name": "CanvasRenderer",
    "line": 10,
    "extends": "BaseRenderer",
    "statics": [
      {
        "name": "$name",
        "line": 12,
        "source": "static $name = 'canvasRenderer'",
        "kind": "property",
        "value": "'canvasRenderer'"
      }
    ],
    "methods": [
      {
        "name": "registerRenderer",
        "line": 48,
        "source": "registerRenderer (renderer) {\n    renderer.init({ctx: this.ctx, canvas: this.canvas})\n\n    for (const ObjectClass of renderer.constructor.handles) {\n        this.#rendererRegistry.set(ObjectClass, renderer)\n    }\n\n    if (!this.#renderers.includes(renderer)) {\n        this.#renderers.push(renderer)\n    }\n\n    return this\n}",
        "kind": "method",
        "params": [
          "renderer"
        ]
      },
      {
        "name": "unregisterRenderer",
        "line": 63,
        "source": "unregisterRenderer (renderer) {\n    for (const ObjectClass of renderer.constructor.handles) {\n        if (this.#rendererRegistry.get(ObjectClass) === renderer) {\n            this.#rendererRegistry.delete(ObjectClass)\n        }\n    }\n\n    const index = this.#renderers.indexOf(renderer)\n    if (index !== -1) {\n        this.#renderers.splice(index, 1)\n    }\n\n    renderer.dispose()\n    return this\n}",
        "kind": "method",
        "params": [
          "renderer"
        ]
      },
      {
        "name": "onDispose",
        "line": 80,
        "source": "onDispose () {\n    for (const renderer of this.#renderers) {\n        renderer.dispose()\n    }\n    this.#renderers = []\n    this.#rendererRegistry.clear()\n\n    if (this.#debugGizmoRenderer) {\n        this.#debugGizmoRenderer.dispose()\n        this.#debugGizmoRenderer = null\n    }\n\n    super.onDispose()\n    this.ctx = null\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "render",
        "line": 97,
        "source": "render (scene) {\n    const ctx = this.ctx\n\n    this.stats.totalObjects = 0\n    this.stats.renderedObjects = 0\n    this.stats.culledObjects = 0\n\n    ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\n\n    if (this.backgroundColor && this.backgroundColor !== 'transparent') {\n        ctx.fillStyle = this.backgroundColor\n        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height)\n    }\n\n    this.camera.update()\n\n    ctx.save()\n    this.camera.applyToContext(ctx, this.pixelRatio)\n\n    scene.updateWorldMatrix(false)\n\n    for (const renderer of this.#renderers) {\n        renderer.reset()\n    }\n\n    const debugGizmoRenderer = this.enableDebugGizmos ? this.#debugGizmoRenderer : null\n    if (debugGizmoRenderer) {\n        debugGizmoRenderer.reset()\n    }\n\n    traverseAndCollect(scene, this.#rendererRegistry, {\n        camera: this.camera,\n        enableCulling: this.enableCulling,\n        stats: this.stats,\n        debugGizmoRenderer\n    })\n\n    for (const renderer of this.#renderers) {\n        renderer.flush()\n    }\n\n    if (debugGizmoRenderer) {\n        debugGizmoRenderer.flush()\n    }\n\n    ctx.restore()\n}",
        "kind": "method",
        "params": [
          "scene"
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 18,
      "source": "constructor (options = {}) {\n    super(options)\n\n    this.ctx = this.canvas.getContext('2d')\n\n    this.#setupDefaultRenderers()\n    this.applyPixelRatio()\n\n    this.backgroundColor = options.backgroundColor ?? null\n    this.enableCulling = options.enableCulling ?? false\n    this.enableDebugGizmos = options.enableDebugGizmos ?? true\n\n    this.stats = {\n        totalObjects: 0,\n        renderedObjects: 0,\n        culledObjects: 0\n    }\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/render/webgl_renderer.doc.js": {
    "type": "class",
    "file": "/render/webgl_renderer.js",
    "name": "WebGLRenderer",
    "line": 19,
    "extends": "BaseRenderer",
    "statics": [
      {
        "name": "$name",
        "line": 21,
        "source": "static $name = 'webGLRenderer'",
        "kind": "property",
        "value": "'webGLRenderer'"
      }
    ],
    "methods": [
      {
        "name": "onInstall",
        "line": 58,
        "source": "onInstall (host) {\n    this.delegateTo(host, [\n        'setRenderGroups',\n        'clearRenderGroups',\n        'prependRenderGroup',\n        'appendRenderGroup',\n        'removeRenderGroup',\n        'setUniform',\n        'getUniform',\n        'getPass',\n        'addPostPass',\n        'removePostPass',\n        'registerShaderEffect'\n    ])\n}",
        "kind": "method",
        "params": [
          "host"
        ]
      },
      {
        "name": "registerRenderer",
        "line": 135,
        "source": "registerRenderer (renderer) {\n    const context = {\n        gl: this.gl,\n        spriteProgram: this.spriteProgram,\n        primitiveProgram: this.primitiveProgram,\n        textureManager: this.textureManager,\n        shaderEffectRegistry: this.#shaderEffectRegistry\n    }\n\n    renderer.init(context)\n\n    for (const ObjectClass of renderer.constructor.handles) {\n        this.#rendererRegistry.set(ObjectClass, renderer)\n    }\n\n    if (!this.#renderers.includes(renderer)) {\n        this.#renderers.push(renderer)\n    }\n\n    return this\n}",
        "kind": "method",
        "params": [
          "renderer"
        ]
      },
      {
        "name": "unregisterRenderer",
        "line": 158,
        "source": "unregisterRenderer (renderer) {\n    for (const ObjectClass of renderer.constructor.handles) {\n        if (this.#rendererRegistry.get(ObjectClass) === renderer) {\n            this.#rendererRegistry.delete(ObjectClass)\n        }\n    }\n\n    const index = this.#renderers.indexOf(renderer)\n    if (index !== -1) {\n        this.#renderers.splice(index, 1)\n    }\n\n    renderer.dispose()\n    return this\n}",
        "kind": "method",
        "params": [
          "renderer"
        ]
      },
      {
        "name": "applyPixelRatio",
        "line": 175,
        "source": "applyPixelRatio () {\n    super.applyPixelRatio()\n\n    if (this.gl) {\n        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height)\n    }\n\n    if (this.postProcessor) {\n        this.postProcessor.resize(this.canvas.width, this.canvas.height)\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "registerShaderEffect",
        "line": 198,
        "source": "registerShaderEffect (EffectClass) {\n    return this.#shaderEffectRegistry.register(EffectClass)\n}",
        "kind": "method",
        "params": [
          "EffectClass"
        ]
      },
      {
        "name": "setUniform",
        "line": 203,
        "source": "setUniform (name, value, type = null) {\n    this.#shaderEffectRegistry.setUniform(name, value, type)\n    return this\n}",
        "kind": "method",
        "params": [
          "name",
          "value",
          "type = ..."
        ]
      },
      {
        "name": "getUniform",
        "line": 209,
        "source": "getUniform (name) {\n    return this.#shaderEffectRegistry.getUniform(name)\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "registerShader",
        "line": 214,
        "source": "registerShader (id, definition) {\n    return this.#shaderRegistry.register(id, definition)\n}",
        "kind": "method",
        "params": [
          "id",
          "definition"
        ]
      },
      {
        "name": "getShader",
        "line": 219,
        "source": "getShader (id) {\n    return this.#shaderRegistry.get(id)\n}",
        "kind": "method",
        "params": [
          "id"
        ]
      },
      {
        "name": "addPostPass",
        "line": 224,
        "source": "addPostPass (PassClass, options = {}) {\n    const pass = this.create(PassClass, options)\n    this.postProcessor.addPass(pass)\n    return pass\n}",
        "kind": "method",
        "params": [
          "PassClass",
          "options = ..."
        ]
      },
      {
        "name": "removePostPass",
        "line": 231,
        "source": "removePostPass (pass) {\n    this.removeChild(pass.$id)\n    this.postProcessor.removePass(pass)\n    return this\n}",
        "kind": "method",
        "params": [
          "pass"
        ]
      },
      {
        "name": "getPass",
        "line": 238,
        "source": "getPass (name) {\n    return this.getChild(name)\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "setRenderGroups",
        "line": 248,
        "source": "setRenderGroups (configs) {\n    this.clearRenderGroups()\n\n    for (const config of configs) {\n        this.appendRenderGroup(config)\n    }\n\n    return this\n}",
        "kind": "method",
        "params": [
          "configs"
        ]
      },
      {
        "name": "clearRenderGroups",
        "line": 259,
        "source": "clearRenderGroups () {\n    for (const group of this.#renderGroupOrder) {\n        this.removeChild(group.$id)\n    }\n    this.#renderGroupOrder = []\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "prependRenderGroup",
        "line": 273,
        "source": "prependRenderGroup (config) {\n    this.#ensureCompositeSetup()\n    const group = this.create(RenderGroup, config)\n    this.#renderGroupOrder.unshift(group)\n    return group\n}",
        "kind": "method",
        "params": [
          "config"
        ]
      },
      {
        "name": "appendRenderGroup",
        "line": 281,
        "source": "appendRenderGroup (config) {\n    this.#ensureCompositeSetup()\n    const group = this.create(RenderGroup, config)\n    this.#renderGroupOrder.push(group)\n    return group\n}",
        "kind": "method",
        "params": [
          "config"
        ]
      },
      {
        "name": "removeRenderGroup",
        "line": 289,
        "source": "removeRenderGroup (groupOrId) {\n    const id = typeof groupOrId === 'string' ? groupOrId : groupOrId.$id\n    const index = this.#renderGroupOrder.findIndex(g => g.$id === id)\n\n    if (index !== -1) {\n        this.#renderGroupOrder.splice(index, 1)\n        this.removeChild(id)\n    }\n\n    return this\n}",
        "kind": "method",
        "params": [
          "groupOrId"
        ]
      },
      {
        "name": "onDispose",
        "line": 344,
        "source": "onDispose () {\n    for (const renderer of this.#renderers) {\n        renderer.dispose()\n    }\n    this.#renderers = []\n    this.#rendererRegistry.clear()\n\n    if (this.#debugGizmoRenderer) {\n        this.#debugGizmoRenderer.dispose()\n        this.#debugGizmoRenderer = null\n    }\n\n    this.clearRenderGroups()\n\n    if (this.#compositeQuad) {\n        this.#compositeQuad.dispose(this.gl)\n        this.#compositeQuad = null\n    }\n\n    if (this.#shaderEffectRegistry) {\n        this.#shaderEffectRegistry.dispose()\n        this.#shaderEffectRegistry = null\n    }\n\n    if (this.#shaderRegistry) {\n        this.#shaderRegistry.dispose()\n        this.#shaderRegistry = null\n    }\n\n    super.onDispose()\n    this.gl = null\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "render",
        "line": 399,
        "source": "render (scene) {\n    if (this.renderGroups.length > 0 && !scene) {\n        return this.#renderWithGroups()\n    }\n    return this.#renderSingleScene(scene)\n}",
        "kind": "method",
        "params": [
          "scene"
        ]
      }
    ],
    "getters": [
      {
        "name": "shaderRegistry",
        "line": 188,
        "source": "get shaderRegistry () {\n    return this.#shaderRegistry\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "shaderEffectRegistry",
        "line": 193,
        "source": "get shaderEffectRegistry () {\n    return this.#shaderEffectRegistry\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "postPasses",
        "line": 243,
        "source": "get postPasses () {\n    return this.childrenByCategory('renderPass')\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "renderGroups",
        "line": 268,
        "source": "get renderGroups () {\n    return this.#renderGroupOrder\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 33,
      "source": "constructor (options = {}) {\n    const {autoFit, ...parentOptions} = options\n    super(parentOptions)\n\n    this.#setupWebGL()\n    this.#setupDefaultRenderers()\n    this.applyPixelRatio()\n\n    this.backgroundColor = options.backgroundColor ?? null\n    this.enableCulling = options.enableCulling ?? false\n    this.enableDebugGizmos = options.enableDebugGizmos ?? true\n\n    this.stats = {\n        totalObjects: 0,\n        renderedObjects: 0,\n        culledObjects: 0,\n        drawCalls: 0\n    }\n\n    if (autoFit) {\n        this.autoFitEnabled = true\n    }\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/render/base_renderer.doc.js": {
    "type": "class",
    "file": "/render/base_renderer.js",
    "name": "BaseRenderer",
    "line": 5,
    "extends": "PerkyModule",
    "statics": [
      {
        "name": "$category",
        "line": 7,
        "source": "static $category = 'renderer'",
        "kind": "property",
        "value": "'renderer'"
      }
    ],
    "methods": [
      {
        "name": "applyPixelRatio",
        "line": 98,
        "source": "applyPixelRatio () {\n    this.canvas.width = this.displayWidth * this.pixelRatio\n    this.canvas.height = this.displayHeight * this.pixelRatio\n\n    this.canvas.style.width = `${this.displayWidth}px`\n    this.canvas.style.height = `${this.displayHeight}px`\n\n    if (this.camera) {\n        this.camera.viewportWidth = this.displayWidth\n        this.camera.viewportHeight = this.displayHeight\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "setPixelRatio",
        "line": 112,
        "source": "setPixelRatio (ratio) {\n    this.pixelRatio = ratio\n    this.applyPixelRatio()\n    return this\n}",
        "kind": "method",
        "params": [
          "ratio"
        ]
      },
      {
        "name": "resize",
        "line": 119,
        "source": "resize (width, height) {\n    this.displayWidth = width\n    this.displayHeight = height\n    this.applyPixelRatio()\n    this.emit('resize', width, height)\n    return this\n}",
        "kind": "method",
        "params": [
          "width",
          "height"
        ]
      },
      {
        "name": "resizeToContainer",
        "line": 128,
        "source": "resizeToContainer () {\n    const parent = this.canvas.parentElement\n    if (!parent) {\n        return this\n    }\n\n    const width = parent.clientWidth\n    const height = parent.clientHeight\n\n    if (width > 0 && height > 0) {\n        return this.resize(width, height)\n    }\n\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "onDispose",
        "line": 145,
        "source": "onDispose () {\n    this.autoFitEnabled = false\n\n    if (this.canvas && this.canvas.parentElement) {\n        this.canvas.parentElement.removeChild(this.canvas)\n    }\n\n    this.canvas = null\n    this.camera = null\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "container",
        "line": 36,
        "source": "get container () {\n    return this.canvas?.parentElement\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "autoFitEnabled",
        "line": 49,
        "source": "get autoFitEnabled () {\n    return this.#autoFitEnabled\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "container",
        "line": 41,
        "source": "set container (value) {\n    if (value) {\n        value.appendChild(this.canvas)\n        this.#refreshAutoFit()\n    }\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "autoFitEnabled",
        "line": 54,
        "source": "set autoFitEnabled (value) {\n    if (this.#autoFitEnabled === value) {\n        return\n    }\n    this.#autoFitEnabled = value\n    this.#updateAutoFitObserver()\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      }
    ],
    "constructor": {
      "name": "constructor",
      "line": 12,
      "source": "constructor (options = {}) {\n    super(options)\n\n    this.canvas = options.canvas || document.createElement('canvas')\n    this.pixelRatio = options.pixelRatio ?? 1\n    this.displayWidth = options.width ?? this.canvas.width\n    this.displayHeight = options.height ?? this.canvas.height\n\n    this.camera = options.camera ?? new Camera({\n        viewportWidth: this.displayWidth,\n        viewportHeight: this.displayHeight,\n        pixelRatio: 1\n    })\n\n    if (options.container) {\n        this.container = options.container\n    }\n\n    if (options.autoFit) {\n        this.autoFitEnabled = true\n    }\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/render/camera.doc.js": {
    "type": "class",
    "file": "/render/camera.js",
    "name": "Camera",
    "line": 5,
    "extends": "PerkyModule",
    "statics": [
      {
        "name": "$category",
        "line": 7,
        "source": "static $category = 'camera'",
        "kind": "property",
        "value": "'camera'"
      }
    ],
    "methods": [
      {
        "name": "setUnitsInView",
        "line": 72,
        "source": "setUnitsInView (units) {\n    if (typeof units === 'number') {\n        this.unitsInView = {height: units}\n    } else {\n        this.unitsInView = units\n    }\n    return this\n}",
        "kind": "method",
        "params": [
          "units"
        ]
      },
      {
        "name": "setZoom",
        "line": 82,
        "source": "setZoom (zoom) {\n    this.zoom = zoom\n    return this\n}",
        "kind": "method",
        "params": [
          "zoom"
        ]
      },
      {
        "name": "setPosition",
        "line": 88,
        "source": "setPosition (x, y) {\n    this.x = x\n    this.y = y\n    return this\n}",
        "kind": "method",
        "params": [
          "x",
          "y"
        ]
      },
      {
        "name": "follow",
        "line": 95,
        "source": "follow (target, speed = 0.1) {\n    this.followTarget = target\n    this.followSpeed = speed\n    return this\n}",
        "kind": "method",
        "params": [
          "target",
          "speed = ..."
        ]
      },
      {
        "name": "stopFollow",
        "line": 102,
        "source": "stopFollow () {\n    this.followTarget = null\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "animateTo",
        "line": 108,
        "source": "animateTo (config, options = {}) {\n    const duration = options.duration ?? 1\n    const easing = options.easing ?? 'easeOutQuad'\n    const onComplete = options.onComplete ?? null\n\n    this.transition = {\n        startX: this.x,\n        startY: this.y,\n        startZoom: this.zoom,\n        startRotation: this.rotation,\n        targetX: config.x ?? this.x,\n        targetY: config.y ?? this.y,\n        targetZoom: config.zoom ?? this.zoom,\n        targetRotation: config.rotation ?? this.rotation,\n        duration,\n        elapsed: 0,\n        easing: Easing.resolve(easing),\n        onComplete\n    }\n\n    return this\n}",
        "kind": "method",
        "params": [
          "config",
          "options = ..."
        ]
      },
      {
        "name": "transitionTo",
        "line": 132,
        "source": "transitionTo (otherCamera, options = {}) {\n    return this.animateTo({\n        x: otherCamera.x,\n        y: otherCamera.y,\n        zoom: otherCamera.zoom,\n        rotation: otherCamera.rotation\n    }, options)\n}",
        "kind": "method",
        "params": [
          "otherCamera",
          "options = ..."
        ]
      },
      {
        "name": "cancelTransition",
        "line": 142,
        "source": "cancelTransition () {\n    this.transition = null\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "animate",
        "line": 148,
        "source": "animate (handler, options = {}) {\n    const effect = {\n        handler,\n        duration: options.duration ?? Infinity,\n        elapsed: 0,\n        onComplete: options.onComplete ?? null\n    }\n\n    this.effects.push(effect)\n    return this\n}",
        "kind": "method",
        "params": [
          "handler",
          "options = ..."
        ]
      },
      {
        "name": "shake",
        "line": 161,
        "source": "shake (options = {}) {\n    const intensity = options.intensity ?? 0.5\n    const duration = options.duration ?? 0.3\n    const decay = options.decay ?? true\n\n    return this.animate((deltaTime, elapsed, total) => {\n        const progress = elapsed / total\n        const factor = decay ? 1 - progress : 1\n\n        this.offsetX = (Math.random() - 0.5) * 2 * intensity * factor\n        this.offsetY = (Math.random() - 0.5) * 2 * intensity * factor\n\n        return progress >= 1\n    }, {\n        duration,\n        onComplete: () => {\n            this.offsetX = 0\n            this.offsetY = 0\n        }\n    })\n}",
        "kind": "method",
        "params": [
          "options = ..."
        ]
      },
      {
        "name": "clearEffects",
        "line": 184,
        "source": "clearEffects () {\n    this.effects = []\n    this.offsetX = 0\n    this.offsetY = 0\n    this.offsetZoom = 0\n    this.offsetRotation = 0\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "update",
        "line": 194,
        "source": "update (deltaTime = 0) {\n    if (this.followTarget) {\n        const dx = this.followTarget.x - this.x\n        const dy = this.followTarget.y - this.y\n        this.x += dx * this.followSpeed\n        this.y += dy * this.followSpeed\n    }\n\n    if (!deltaTime) {\n        return\n    }\n\n    if (this.transition) {\n        this.transition.elapsed += deltaTime\n\n        const t = Math.min(this.transition.elapsed / this.transition.duration, 1)\n        const easedT = this.transition.easing(t)\n\n        this.x = this.transition.startX + (this.transition.targetX - this.transition.startX) * easedT\n        this.y = this.transition.startY + (this.transition.targetY - this.transition.startY) * easedT\n        this.zoom = this.transition.startZoom + (this.transition.targetZoom - this.transition.startZoom) * easedT\n        this.rotation = this.transition.startRotation + (this.transition.targetRotation - this.transition.startRotation) * easedT\n\n        if (t >= 1) {\n            const onComplete = this.transition.onComplete\n            this.transition = null\n            if (onComplete) {\n                onComplete()\n            }\n        }\n    }\n\n    for (let i = this.effects.length - 1; i >= 0; i--) {\n        const effect = this.effects[i]\n        effect.elapsed += deltaTime\n\n        const done = effect.handler(deltaTime, effect.elapsed, effect.duration)\n\n        if (done) {\n            if (effect.onComplete) {\n                effect.onComplete()\n            }\n            this.effects.splice(i, 1)\n        }\n    }\n}",
        "kind": "method",
        "params": [
          "deltaTime = ..."
        ]
      },
      {
        "name": "worldToScreen",
        "line": 242,
        "source": "worldToScreen (worldX, worldY) {\n    const ppu = this.pixelsPerUnit\n    const rotation = this.effectiveRotation\n\n    let dx = worldX - this.effectiveX\n    let dy = worldY - this.effectiveY\n\n    if (rotation !== 0) {\n        const cos = Math.cos(-rotation)\n        const sin = Math.sin(-rotation)\n        const rotatedX = dx * cos - dy * sin\n        const rotatedY = dx * sin + dy * cos\n        dx = rotatedX\n        dy = rotatedY\n    }\n\n    const screenX = dx * ppu + this.viewportWidth / 2\n    const screenY = -dy * ppu + this.viewportHeight / 2\n    return {x: screenX, y: screenY}\n}",
        "kind": "method",
        "params": [
          "worldX",
          "worldY"
        ]
      },
      {
        "name": "worldToScreenCSS",
        "line": 264,
        "source": "worldToScreenCSS (worldX, worldY) {\n    return this.worldToScreen(worldX, worldY)\n}",
        "kind": "method",
        "params": [
          "worldX",
          "worldY"
        ]
      },
      {
        "name": "screenToWorld",
        "line": 269,
        "source": "screenToWorld (screenX, screenY) {\n    const ppu = this.pixelsPerUnit\n    const rotation = this.effectiveRotation\n\n    let dx = (screenX - this.viewportWidth / 2) / ppu\n    let dy = -((screenY - this.viewportHeight / 2) / ppu)\n\n    if (rotation !== 0) {\n        const cos = Math.cos(rotation)\n        const sin = Math.sin(rotation)\n        const rotatedX = dx * cos - dy * sin\n        const rotatedY = dx * sin + dy * cos\n        dx = rotatedX\n        dy = rotatedY\n    }\n\n    const worldX = dx + this.effectiveX\n    const worldY = dy + this.effectiveY\n    return {x: worldX, y: worldY}\n}",
        "kind": "method",
        "params": [
          "screenX",
          "screenY"
        ]
      },
      {
        "name": "isVisible",
        "line": 291,
        "source": "isVisible (bounds) {\n    if (!bounds || (bounds.width === 0 && bounds.height === 0)) {\n        return false\n    }\n\n    const halfWidth = this.viewportWidth / (2 * this.pixelsPerUnit)\n    const halfHeight = this.viewportHeight / (2 * this.pixelsPerUnit)\n\n    const cameraMinX = this.effectiveX - halfWidth\n    const cameraMaxX = this.effectiveX + halfWidth\n    const cameraMinY = this.effectiveY - halfHeight\n    const cameraMaxY = this.effectiveY + halfHeight\n\n    return !(\n        bounds.maxX < cameraMinX ||\n        bounds.minX > cameraMaxX ||\n        bounds.maxY < cameraMinY ||\n        bounds.minY > cameraMaxY\n    )\n}",
        "kind": "method",
        "params": [
          "bounds"
        ]
      },
      {
        "name": "applyToContext",
        "line": 313,
        "source": "applyToContext (ctx, pixelRatio = 1) {\n    const physicalWidth = this.viewportWidth * pixelRatio\n    const physicalHeight = this.viewportHeight * pixelRatio\n    const rotation = this.effectiveRotation\n\n    ctx.translate(physicalWidth / 2, physicalHeight / 2)\n\n    if (rotation !== 0) {\n        ctx.rotate(-rotation)\n    }\n\n    const ppu = this.pixelsPerUnit * pixelRatio\n    ctx.scale(ppu, -ppu)\n\n    ctx.translate(-this.effectiveX, -this.effectiveY)\n}",
        "kind": "method",
        "params": [
          "ctx",
          "pixelRatio = ..."
        ]
      }
    ],
    "getters": [
      {
        "name": "pixelsPerUnit",
        "line": 41,
        "source": "get pixelsPerUnit () {\n    const effectiveZoom = this.zoom + this.offsetZoom\n\n    if (this.unitsInView.width && this.unitsInView.height) {\n        const ppuForWidth = this.viewportWidth / this.unitsInView.width\n        const ppuForHeight = this.viewportHeight / this.unitsInView.height\n\n        return Math.min(ppuForWidth, ppuForHeight) * effectiveZoom\n    } else if (this.unitsInView.width) {\n        return this.viewportWidth / this.unitsInView.width * effectiveZoom\n    } else {\n        return this.viewportHeight / this.unitsInView.height * effectiveZoom\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "effectiveX",
        "line": 57,
        "source": "get effectiveX () {\n    return this.x + this.offsetX\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "effectiveY",
        "line": 62,
        "source": "get effectiveY () {\n    return this.y + this.offsetY\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "effectiveRotation",
        "line": 67,
        "source": "get effectiveRotation () {\n    return this.rotation + this.offsetRotation\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 9,
      "source": "constructor (options = {}) { // eslint-disable-line complexity -- clean\n    super(options)\n\n    this.x = options.x ?? 0\n    this.y = options.y ?? 0\n    this.zoom = options.zoom ?? 1\n    this.rotation = options.rotation ?? 0\n\n    const unitsInView = options.unitsInView ?? 10\n    if (typeof unitsInView === 'number') {\n        this.unitsInView = {height: unitsInView}\n    } else {\n        this.unitsInView = unitsInView\n    }\n\n    this.viewportWidth = options.viewportWidth ?? 800\n    this.viewportHeight = options.viewportHeight ?? 600\n    this.pixelRatio = options.pixelRatio ?? 1\n\n    this.followTarget = null\n    this.followSpeed = 0.1\n\n    this.offsetX = 0\n    this.offsetY = 0\n    this.offsetZoom = 0\n    this.offsetRotation = 0\n\n    this.transition = null\n    this.effects = []\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/render/canvas_layer.doc.js": {
    "type": "class",
    "file": "/render/canvas_layer.js",
    "name": "CanvasLayer",
    "line": 12,
    "extends": "Layer",
    "statics": [],
    "methods": [
      {
        "name": "applyStyles",
        "line": 63,
        "source": "applyStyles () {\n    this.canvas.style.position = 'absolute'\n    this.canvas.style.top = '0'\n    this.canvas.style.left = '0'\n    this.canvas.style.zIndex = this.zIndex\n    this.canvas.style.opacity = this.opacity\n    this.canvas.style.pointerEvents = this.pointerEvents\n    this.canvas.style.display = this.visible ? 'block' : 'none'\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "setContent",
        "line": 74,
        "source": "setContent (content) {\n    this.content = content\n    return this\n}",
        "kind": "method",
        "params": [
          "content"
        ]
      },
      {
        "name": "render",
        "line": 80,
        "source": "render () {\n    if (this.renderer.renderGroups?.length > 0) {\n        this.renderer.render()\n    } else if (this.content) {\n        this.renderer.render(this.content)\n    }\n\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "resize",
        "line": 91,
        "source": "resize (width, height) {\n    const vp = this.calculateViewport(width, height)\n    this.renderer.resize(vp.width, vp.height)\n    this.applyViewport()\n    return this\n}",
        "kind": "method",
        "params": [
          "width",
          "height"
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 14,
      "source": "constructor (options = {}) { // eslint-disable-line complexity -- clean\n    super(options)\n\n    this.canvas = document.createElement('canvas')\n    this.element = this.canvas\n    this.rendererType = options.rendererType ?? 'canvas'\n\n    this.applyStyles()\n\n    const width = options.width ?? 800\n    const height = options.height ?? 600\n    const pixelRatio = options.pixelRatio ?? 1\n\n    const vp = this.calculateViewport(width, height)\n\n    const camera = options.camera\n    if (camera) {\n        camera.viewportWidth = vp.width\n        camera.viewportHeight = vp.height\n        camera.pixelRatio ??= 1\n    }\n\n    const RendererClass = RENDERERS[this.rendererType]\n    if (!RendererClass) {\n        throw new Error(`Unknown renderer type: \"${this.rendererType}\"`)\n    }\n\n    this.create(RendererClass, {\n        $bind: 'renderer',\n        canvas: this.canvas,\n        width: vp.width,\n        height: vp.height,\n        pixelRatio,\n        camera,\n        showGrid: options.showGrid ?? false,\n        gridStep: options.gridStep,\n        gridOpacity: options.gridOpacity,\n        gridColor: options.gridColor,\n        backgroundColor: options.backgroundColor,\n        enableCulling: options.enableCulling ?? false\n    })\n\n    this.content = null\n    this.autoRender = options.autoRender ?? true\n\n    this.applyViewport()\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/render/circle.doc.js": {
    "type": "class",
    "file": "/render/circle.js",
    "name": "Circle",
    "line": 4,
    "extends": "Object2D",
    "statics": [],
    "methods": [
      {
        "name": "setRadius",
        "line": 16,
        "source": "setRadius (radius) {\n    this.radius = radius\n    return this\n}",
        "kind": "method",
        "params": [
          "radius"
        ]
      },
      {
        "name": "getBounds",
        "line": 22,
        "source": "getBounds () {\n    const size = this.radius * 2\n    const offsetX = -size * this.anchorX\n    const offsetY = -size * this.anchorY\n\n    return {\n        minX: offsetX,\n        minY: offsetY,\n        maxX: offsetX + size,\n        maxY: offsetY + size,\n        width: size,\n        height: size\n    }\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 6,
      "source": "constructor (options = {}) {\n    super(options)\n\n    this.radius = options.radius ?? 10\n    this.color = options.color ?? '#000000'\n    this.strokeColor = options.strokeColor ?? '#000000'\n    this.strokeWidth = options.strokeWidth ?? 0\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/render/group_2d.doc.js": {
    "type": "class",
    "file": "/render/group_2d.js",
    "name": "Group2D",
    "line": 4,
    "extends": "Object2D",
    "statics": [],
    "methods": [
      {
        "name": "addChild",
        "line": 11,
        "source": "addChild (...objects) {\n    return this.add(...objects)\n}",
        "kind": "method",
        "params": [
          "...objects"
        ]
      },
      {
        "name": "getBounds",
        "line": 16,
        "source": "getBounds () {\n    if (this.children.length === 0) {\n        return {\n            minX: 0,\n            minY: 0,\n            maxX: 0,\n            maxY: 0,\n            width: 0,\n            height: 0\n        }\n    }\n\n    let minX = Infinity\n    let minY = Infinity\n    let maxX = -Infinity\n    let maxY = -Infinity\n\n    this.children.forEach(child => {\n        const bounds = child.getBounds()\n\n        if (bounds.width === 0 && bounds.height === 0) {\n            return\n        }\n\n        const m = child.worldMatrix\n        const corners = [\n            {x: bounds.minX, y: bounds.minY},\n            {x: bounds.maxX, y: bounds.minY},\n            {x: bounds.minX, y: bounds.maxY},\n            {x: bounds.maxX, y: bounds.maxY}\n        ]\n\n        corners.forEach(corner => {\n            const x = m[0] * corner.x + m[2] * corner.y + m[4]\n            const y = m[1] * corner.x + m[3] * corner.y + m[5]\n\n            minX = Math.min(minX, x)\n            minY = Math.min(minY, y)\n            maxX = Math.max(maxX, x)\n            maxY = Math.max(maxY, y)\n        })\n    })\n\n    if (minX === Infinity) {\n        return {\n            minX: 0,\n            minY: 0,\n            maxX: 0,\n            maxY: 0,\n            width: 0,\n            height: 0\n        }\n    }\n\n    return {\n        minX,\n        minY,\n        maxX,\n        maxY,\n        width: maxX - minX,\n        height: maxY - minY\n    }\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 6,
      "source": "constructor (options = {}) {\n    super(options)\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/render/html_layer.doc.js": {
    "type": "class",
    "file": "/render/html_layer.js",
    "name": "HTMLLayer",
    "line": 5,
    "extends": "Layer",
    "statics": [],
    "methods": [
      {
        "name": "applyStyles",
        "line": 32,
        "source": "applyStyles () {\n    this.div.style.position = 'absolute'\n    this.div.style.top = '0'\n    this.div.style.left = '0'\n    this.div.style.width = '100%'\n    this.div.style.height = '100%'\n    this.div.style.zIndex = this.zIndex\n    this.div.style.opacity = this.opacity\n    this.div.style.pointerEvents = this.pointerEvents\n    this.div.style.display = this.visible ? 'block' : 'none'\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "setContent",
        "line": 45,
        "source": "setContent (content) {\n    if (typeof content === 'string') {\n        this.div.innerHTML = content\n    } else if (content instanceof HTMLElement) {\n        this.div.innerHTML = ''\n        this.div.appendChild(content)\n    }\n    return this\n}",
        "kind": "method",
        "params": [
          "content"
        ]
      },
      {
        "name": "addClass",
        "line": 56,
        "source": "addClass (className) {\n    this.div.classList.add(className)\n    return this\n}",
        "kind": "method",
        "params": [
          "className"
        ]
      },
      {
        "name": "removeClass",
        "line": 62,
        "source": "removeClass (className) {\n    this.div.classList.remove(className)\n    return this\n}",
        "kind": "method",
        "params": [
          "className"
        ]
      },
      {
        "name": "setStyle",
        "line": 68,
        "source": "setStyle (property, value) {\n    this.div.style[property] = value\n    return this\n}",
        "kind": "method",
        "params": [
          "property",
          "value"
        ]
      },
      {
        "name": "resize",
        "line": 74,
        "source": "resize (width, height) {\n    const vp = this.calculateViewport(width, height)\n    this.div.style.width = `${vp.width}px`\n    this.div.style.height = `${vp.height}px`\n    this.applyViewport()\n    return this\n}",
        "kind": "method",
        "params": [
          "width",
          "height"
        ]
      },
      {
        "name": "setCamera",
        "line": 83,
        "source": "setCamera (camera) {\n    this.camera = camera\n    return this\n}",
        "kind": "method",
        "params": [
          "camera"
        ]
      },
      {
        "name": "createWorldElement",
        "line": 89,
        "source": "createWorldElement (content, worldX, worldY, options = {}) { // eslint-disable-line complexity -- clean\n    const el = createElement('div', {\n        html: content,\n        style: {\n            position: 'absolute',\n            pointerEvents: options.pointerEvents ?? 'auto',\n            willChange: 'transform',\n            left: '0',\n            top: '0'\n        }\n    })\n\n    const worldEl = {\n        element: el,\n        worldX,\n        worldY,\n        offsetX: options.offsetX ?? 0,\n        offsetY: options.offsetY ?? 0,\n        worldOffsetX: options.worldOffsetX ?? 0,\n        worldOffsetY: options.worldOffsetY ?? 0,\n        worldScaleX: options.worldScaleX ?? 1,\n        worldScaleY: options.worldScaleY ?? 1,\n        autoCenter: options.autoCenter ?? false,\n        inheritTransform: options.inheritTransform ?? false,\n        targetObject: options.targetObject ?? null,\n        lastScreenX: null,\n        lastScreenY: null,\n        lastZoom: null,\n        visible: true\n    }\n\n    this.div.appendChild(el)\n    this.worldElements.push(worldEl)\n\n    if (worldEl.autoCenter) {\n        requestAnimationFrame(() => {\n            const rect = el.getBoundingClientRect()\n            if (this.camera) {\n                const ppu = this.camera.pixelsPerUnit\n                if (worldEl.autoCenter === true || worldEl.autoCenter === 'x') {\n                    worldEl.worldOffsetX = -(rect.width / 2) / ppu\n                }\n                if (worldEl.autoCenter === true || worldEl.autoCenter === 'y') {\n                    worldEl.worldOffsetY = (rect.height / 2) / ppu\n                }\n            }\n        })\n    }\n\n    return el\n}",
        "kind": "method",
        "params": [
          "content",
          "worldX",
          "worldY",
          "options = ..."
        ]
      },
      {
        "name": "removeWorldElement",
        "line": 142,
        "source": "removeWorldElement (element) {\n    const index = this.worldElements.findIndex(w => w.element === element)\n    if (index !== -1) {\n        this.worldElements.splice(index, 1)\n        if (element.parentElement) {\n            element.parentElement.removeChild(element)\n        }\n    }\n    return this\n}",
        "kind": "method",
        "params": [
          "element"
        ]
      },
      {
        "name": "updateElementWorldPosition",
        "line": 154,
        "source": "updateElementWorldPosition (element, worldX, worldY) {\n    const worldEl = this.worldElements.find(w => w.element === element)\n    if (worldEl) {\n        worldEl.worldX = worldX\n        worldEl.worldY = worldY\n    }\n    return this\n}",
        "kind": "method",
        "params": [
          "element",
          "worldX",
          "worldY"
        ]
      },
      {
        "name": "setElementTarget",
        "line": 164,
        "source": "setElementTarget (element, targetObject) {\n    const worldEl = this.worldElements.find(w => w.element === element)\n    if (worldEl) {\n        worldEl.targetObject = targetObject\n    }\n    return this\n}",
        "kind": "method",
        "params": [
          "element",
          "targetObject"
        ]
      },
      {
        "name": "updateWorldElements",
        "line": 173,
        "source": "updateWorldElements (force = false) {\n    if (!this.camera || this.worldElements.length === 0) {\n        return this\n    }\n\n    const ctx = {\n        camera: this.camera,\n        ppu: this.camera.pixelsPerUnit,\n        zoomChanged: force || this.worldElements.some(el => el.lastZoom !== this.camera.zoom),\n        force,\n        threshold: this.updateThreshold\n    }\n\n    this.worldElements.forEach(worldEl => {\n        updateSingleWorldElement(worldEl, ctx)\n    })\n\n    return this\n}",
        "kind": "method",
        "params": [
          "force = ..."
        ]
      },
      {
        "name": "cssToWorldUnits",
        "line": 194,
        "source": "cssToWorldUnits (pixels) {\n    if (!this.camera) {\n        return 0\n    }\n\n\n    const ppu = this.camera.pixelsPerUnit\n    return pixels / ppu\n}",
        "kind": "method",
        "params": [
          "pixels"
        ]
      },
      {
        "name": "worldUnitsToCss",
        "line": 205,
        "source": "worldUnitsToCss (units) {\n    if (!this.camera) {\n        return 0\n    }\n\n\n    const ppu = this.camera.pixelsPerUnit\n    return units * ppu\n}",
        "kind": "method",
        "params": [
          "units"
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 7,
      "source": "constructor (options = {}) {\n    super(options)\n\n    this.div = document.createElement('div')\n    this.element = this.div\n\n    this.applyStyles()\n\n    if (options.content) {\n        this.setContent(options.content)\n    }\n\n    if (options.className) {\n        this.div.className = options.className\n    }\n\n    this.worldElements = []\n    this.camera = options.camera ?? null\n    this.autoUpdate = options.autoUpdate ?? true\n    this.updateThreshold = options.updateThreshold ?? 0.5\n\n    this.applyViewport()\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/render/layer.doc.js": {
    "type": "class",
    "file": "/render/layer.js",
    "name": "Layer",
    "line": 4,
    "extends": "PerkyModule",
    "statics": [
      {
        "name": "$category",
        "line": 6,
        "source": "static $category = 'layer'",
        "kind": "property",
        "value": "'layer'"
      }
    ],
    "methods": [
      {
        "name": "calculateViewport",
        "line": 31,
        "source": "calculateViewport (containerWidth, containerHeight) { // eslint-disable-line complexity -- clean\n    const vp = this.viewport\n\n    const width = typeof vp.width === 'string' && vp.width.endsWith('%')\n        ? (parseFloat(vp.width) / 100) * containerWidth\n        : parseFloat(vp.width)\n\n    const height = typeof vp.height === 'string' && vp.height.endsWith('%')\n        ? (parseFloat(vp.height) / 100) * containerHeight\n        : parseFloat(vp.height)\n\n    let x = typeof vp.x === 'string' && vp.x.endsWith('%')\n        ? (parseFloat(vp.x) / 100) * containerWidth\n        : parseFloat(vp.x)\n\n    let y = typeof vp.y === 'string' && vp.y.endsWith('%')\n        ? (parseFloat(vp.y) / 100) * containerHeight\n        : parseFloat(vp.y)\n\n    const anchor = vp.anchor || 'top-left'\n    if (anchor.includes('right')) {\n        x = containerWidth - width - x\n    }\n    if (anchor.includes('bottom')) {\n        y = containerHeight - height - y\n    }\n\n    this.resolvedViewport.x = x\n    this.resolvedViewport.y = y\n    this.resolvedViewport.width = width\n    this.resolvedViewport.height = height\n\n    return this.resolvedViewport\n}",
        "kind": "method",
        "params": [
          "containerWidth",
          "containerHeight"
        ]
      },
      {
        "name": "applyViewport",
        "line": 67,
        "source": "applyViewport () {\n    if (!this.element) {\n        return this\n    }\n\n    const vp = this.resolvedViewport\n\n    this.element.style.left = `${vp.x}px`\n    this.element.style.top = `${vp.y}px`\n    this.element.style.width = `${vp.width}px`\n    this.element.style.height = `${vp.height}px`\n\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "setZIndex",
        "line": 83,
        "source": "setZIndex (zIndex) {\n    this.zIndex = zIndex\n    if (this.element) {\n        this.element.style.zIndex = zIndex\n    }\n    return this\n}",
        "kind": "method",
        "params": [
          "zIndex"
        ]
      },
      {
        "name": "setVisible",
        "line": 92,
        "source": "setVisible (visible) {\n    this.visible = visible\n    if (this.element) {\n        this.element.style.display = visible ? 'block' : 'none'\n    }\n    return this\n}",
        "kind": "method",
        "params": [
          "visible"
        ]
      },
      {
        "name": "setOpacity",
        "line": 101,
        "source": "setOpacity (opacity) {\n    this.opacity = opacity\n    if (this.element) {\n        this.element.style.opacity = opacity\n    }\n    return this\n}",
        "kind": "method",
        "params": [
          "opacity"
        ]
      },
      {
        "name": "setPointerEvents",
        "line": 110,
        "source": "setPointerEvents (value) {\n    this.pointerEvents = value\n    if (this.element) {\n        this.element.style.pointerEvents = value\n    }\n    return this\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "mount",
        "line": 119,
        "source": "mount (container) {\n    this.container = container\n    if (this.element) {\n        container.appendChild(this.element)\n    }\n    return this\n}",
        "kind": "method",
        "params": [
          "container"
        ]
      },
      {
        "name": "unmount",
        "line": 128,
        "source": "unmount () {\n    if (this.element && this.element.parentElement) {\n        this.element.parentElement.removeChild(this.element)\n    }\n    this.container = null\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "resize",
        "line": 137,
        "source": "resize (width, height) {\n    this.calculateViewport(width, height)\n    this.applyViewport()\n    return this\n}",
        "kind": "method",
        "params": [
          "width",
          "height"
        ]
      },
      {
        "name": "onDispose",
        "line": 144,
        "source": "onDispose () {\n    this.unmount()\n    this.element = null\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 8,
      "source": "constructor (options = {}) {\n    super(options)\n\n    this.zIndex = options.zIndex ?? 0\n    this.visible = options.visible ?? true\n    this.opacity = options.opacity ?? 1\n    this.pointerEvents = options.pointerEvents ?? 'auto'\n\n    this.element = null\n    this.container = null\n\n    this.viewport = options.viewport ?? {\n        x: 0,\n        y: 0,\n        width: '100%',\n        height: '100%',\n        anchor: 'top-left'\n    }\n\n    this.resolvedViewport = {x: 0, y: 0, width: 0, height: 0}\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/render/object_2d.doc.js": {
    "type": "class",
    "file": "/render/object_2d.js",
    "name": "Object2D",
    "line": 4,
    "extends": "Transform",
    "statics": [],
    "methods": [
      {
        "name": "showDebugGizmos",
        "line": 87,
        "source": "showDebugGizmos (options = {}) {\n    this.#debugGizmos = {\n        bounds: options.bounds ?? true,\n        anchor: options.anchor ?? true,\n        pivot: options.pivot ?? true,\n        origin: options.origin ?? true\n    }\n    return this\n}",
        "kind": "method",
        "params": [
          "options = ..."
        ]
      },
      {
        "name": "hideDebugGizmos",
        "line": 98,
        "source": "hideDebugGizmos () {\n    this.#debugGizmos = null\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "setPosition",
        "line": 104,
        "source": "setPosition (x, y) {\n    this.x = x\n    this.y = y\n    this.markDirty()\n    return this\n}",
        "kind": "method",
        "params": [
          "x",
          "y"
        ]
      },
      {
        "name": "setRotation",
        "line": 112,
        "source": "setRotation (rotation) {\n    this.rotation = rotation\n    this.markDirty()\n    return this\n}",
        "kind": "method",
        "params": [
          "rotation"
        ]
      },
      {
        "name": "setScale",
        "line": 119,
        "source": "setScale (scaleX, scaleY = scaleX) {\n    this.scaleX = scaleX\n    this.scaleY = scaleY\n    this.markDirty()\n    return this\n}",
        "kind": "method",
        "params": [
          "scaleX",
          "scaleY = ..."
        ]
      },
      {
        "name": "setOpacity",
        "line": 127,
        "source": "setOpacity (opacity) {\n    this.opacity = opacity\n    this.markDirty()\n    return this\n}",
        "kind": "method",
        "params": [
          "opacity"
        ]
      },
      {
        "name": "setVisible",
        "line": 134,
        "source": "setVisible (visible) {\n    this.visible = visible\n    this.markDirty()\n    return this\n}",
        "kind": "method",
        "params": [
          "visible"
        ]
      },
      {
        "name": "setDepth",
        "line": 141,
        "source": "setDepth (depth) {\n    this.depth = depth\n    return this\n}",
        "kind": "method",
        "params": [
          "depth"
        ]
      },
      {
        "name": "setAnchor",
        "line": 147,
        "source": "setAnchor (x, y = x) {\n    this.anchorX = x\n    this.anchorY = y\n    this.markDirty()\n    return this\n}",
        "kind": "method",
        "params": [
          "x",
          "y = ..."
        ]
      },
      {
        "name": "setPivot",
        "line": 155,
        "source": "setPivot (x, y) {\n    this.pivotX = x\n    this.pivotY = y\n    this.markDirty()\n    return this\n}",
        "kind": "method",
        "params": [
          "x",
          "y"
        ]
      },
      {
        "name": "getBounds",
        "line": 163,
        "source": "getBounds () { // eslint-disable-line local/class-methods-use-this -- clean\n    return {\n        minX: 0,\n        minY: 0,\n        maxX: 0,\n        maxY: 0,\n        width: 0,\n        height: 0\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "getWorldBounds",
        "line": 175,
        "source": "getWorldBounds () {\n    const localBounds = this.getBounds()\n\n    if (localBounds.width === 0 && localBounds.height === 0) {\n        return localBounds\n    }\n\n    const corners = [\n        {x: localBounds.minX, y: localBounds.minY},\n        {x: localBounds.maxX, y: localBounds.minY},\n        {x: localBounds.minX, y: localBounds.maxY},\n        {x: localBounds.maxX, y: localBounds.maxY}\n    ]\n\n    const transformedCorners = corners.map(corner => this.transformPoint(corner))\n\n    const xs = transformedCorners.map(c => c.x)\n    const ys = transformedCorners.map(c => c.y)\n\n    const minX = Math.min(...xs)\n    const minY = Math.min(...ys)\n    const maxX = Math.max(...xs)\n    const maxY = Math.max(...ys)\n\n    return {\n        minX,\n        minY,\n        maxX,\n        maxY,\n        width: maxX - minX,\n        height: maxY - minY\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "render",
        "line": 221,
        "source": "render () {\n\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "tint",
        "line": 51,
        "source": "get tint () {\n    return this.#tint\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "debugGizmos",
        "line": 61,
        "source": "get debugGizmos () {\n    return this.#debugGizmos\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "depth",
        "line": 71,
        "source": "get depth () {\n    return this.#depth\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "renderHints",
        "line": 210,
        "source": "get renderHints () {\n    const hasTint = this.#tint !== null\n\n    if (!hasTint) {\n        return null\n    }\n\n    return {tint: this.#tint}\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "tint",
        "line": 56,
        "source": "set tint (value) {\n    this.#tint = value\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "debugGizmos",
        "line": 66,
        "source": "set debugGizmos (value) {\n    this.#debugGizmos = value\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "depth",
        "line": 76,
        "source": "set depth (value) {\n    if (this.#depth !== value) {\n        this.#depth = value\n        if (this.parent) {\n            this.parent.markChildrenNeedSort()\n        }\n        this.markDirty()\n    }\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      }
    ],
    "constructor": {
      "name": "constructor",
      "line": 10,
      "source": "constructor (options = {}) { // eslint-disable-line complexity -- clean\n    super()\n\n    this.visible = options.visible ?? true\n    this.opacity = options.opacity ?? 1\n    this.#depth = options.depth ?? 0\n    this.anchorX = options.anchorX ?? 0.5\n    this.anchorY = options.anchorY ?? 0.5\n\n    if (options.debugGizmos !== undefined) {\n        this.#debugGizmos = options.debugGizmos\n    }\n\n    if (options.tint !== undefined) {\n        this.#tint = options.tint\n    }\n\n    if (options.x !== undefined) {\n        this.x = options.x\n    }\n    if (options.y !== undefined) {\n        this.y = options.y\n    }\n    if (options.rotation !== undefined) {\n        this.rotation = options.rotation\n    }\n    if (options.scaleX !== undefined) {\n        this.scaleX = options.scaleX\n    }\n    if (options.scaleY !== undefined) {\n        this.scaleY = options.scaleY\n    }\n    if (options.pivotX !== undefined) {\n        this.pivotX = options.pivotX\n    }\n    if (options.pivotY !== undefined) {\n        this.pivotY = options.pivotY\n    }\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/render/rectangle.doc.js": {
    "type": "class",
    "file": "/render/rectangle.js",
    "name": "Rectangle",
    "line": 4,
    "extends": "Object2D",
    "statics": [],
    "methods": [
      {
        "name": "getBounds",
        "line": 17,
        "source": "getBounds () {\n    const offsetX = -this.width * this.anchorX\n    const offsetY = -this.height * this.anchorY\n\n    return {\n        minX: offsetX,\n        minY: offsetY,\n        maxX: offsetX + this.width,\n        maxY: offsetY + this.height,\n        width: this.width,\n        height: this.height\n    }\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 6,
      "source": "constructor (options = {}) {\n    super(options)\n\n    this.width = options.width ?? 10\n    this.height = options.height ?? 10\n    this.color = options.color ?? '#000000'\n    this.strokeColor = options.strokeColor ?? '#000000'\n    this.strokeWidth = options.strokeWidth ?? 0\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/render/render_group.doc.js": {
    "type": "class",
    "file": "/render/render_group.js",
    "name": "RenderGroup",
    "line": 10,
    "extends": "PerkyModule",
    "statics": [
      {
        "name": "$category",
        "line": 12,
        "source": "static $category = 'renderGroup'",
        "kind": "property",
        "value": "'renderGroup'"
      },
      {
        "name": "$name",
        "line": 13,
        "source": "static $name = 'renderGroup'",
        "kind": "property",
        "value": "'renderGroup'"
      }
    ],
    "methods": [
      {
        "name": "onInstall",
        "line": 30,
        "source": "onInstall () {\n    const renderer = this.host\n    if (!renderer?.gl || !renderer?.shaderRegistry) {\n        return\n    }\n\n    this.#initPasses(renderer.shaderRegistry)\n    this.#initTransform(renderer)\n\n    const fbManager = renderer.postProcessor?.framebufferManager\n    if (fbManager) {\n        fbManager.getOrCreateBuffer(this.$id)\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "hasActivePasses",
        "line": 69,
        "source": "hasActivePasses () {\n    return this.postPasses.some(pass => pass.enabled)\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "onDispose",
        "line": 74,
        "source": "onDispose () {\n    const fbManager = this.host?.postProcessor?.framebufferManager\n    if (fbManager) {\n        fbManager.disposeBuffer(this.$id)\n    }\n\n    for (const pass of this.postPasses) {\n        pass.dispose()\n    }\n    this.postPasses = []\n\n    if (this.renderTransform) {\n        this.renderTransform.dispose()\n        this.renderTransform = null\n    }\n\n    this.#initialized = false\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "addPostPass",
        "line": 94,
        "source": "addPostPass (pass) {\n    if (this.#initialized && this.host?.shaderRegistry) {\n        pass.init(this.host.shaderRegistry)\n    }\n    this.postPasses.push(pass)\n    this.emit('postPass:added', pass)\n    return this\n}",
        "kind": "method",
        "params": [
          "pass"
        ]
      },
      {
        "name": "removePostPass",
        "line": 104,
        "source": "removePostPass (pass) {\n    const index = this.postPasses.indexOf(pass)\n    if (index !== -1) {\n        this.postPasses.splice(index, 1)\n        pass.dispose()\n        this.emit('postPass:removed', pass)\n    }\n    return this\n}",
        "kind": "method",
        "params": [
          "pass"
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 15,
      "source": "constructor (options = {}) {\n    super(options)\n\n    this.content = options.content ?? null\n    this.postPasses = options.postPasses ?? []\n    this.blendMode = options.blendMode ?? BLEND_MODES.normal\n    this.visible = options.visible ?? true\n    this.opacity = options.opacity ?? 1\n    this.renderTransform = options.renderTransform ?? null\n\n    this.#initialized = false\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/render/render_system.doc.js": {
    "type": "class",
    "file": "/render/render_system.js",
    "name": "RenderSystem",
    "line": 8,
    "extends": "PerkyModule",
    "statics": [
      {
        "name": "$category",
        "line": 10,
        "source": "static $category = 'renderSystem'",
        "kind": "property",
        "value": "'renderSystem'"
      }
    ],
    "methods": [
      {
        "name": "mount",
        "line": 69,
        "source": "mount (container) {\n    return this.view.mount(container)\n}",
        "kind": "method",
        "params": [
          "container"
        ]
      },
      {
        "name": "dismount",
        "line": 74,
        "source": "dismount () {\n    return this.view.dismount()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "setupCameras",
        "line": 84,
        "source": "setupCameras (camerasConfig = {}) {\n    const hasMainInConfig = 'main' in camerasConfig\n\n    if (!hasMainInConfig) {\n        this.createCamera('main', {\n            unitsInView: 10,\n            viewportWidth: this.layerWidth,\n            viewportHeight: this.layerHeight\n        })\n    }\n\n    Object.entries(camerasConfig).forEach(([id, config]) => {\n        this.createCamera(id, config)\n    })\n\n    return this\n}",
        "kind": "method",
        "params": [
          "camerasConfig = ..."
        ]
      },
      {
        "name": "createCamera",
        "line": 103,
        "source": "createCamera (id, config = {}) {\n    const options = {\n        $id: id,\n        viewportWidth: this.layerWidth,\n        viewportHeight: this.layerHeight,\n        ...config\n    }\n\n    return this.create(Camera, options)\n}",
        "kind": "method",
        "params": [
          "id",
          "config = ..."
        ]
      },
      {
        "name": "getCamera",
        "line": 115,
        "source": "getCamera (id = 'main') {\n    const camera = this.getChild(id)\n    if (!camera || camera.$category !== 'camera') {\n        throw new Error(`Camera \"${id}\" not found`)\n    }\n    return camera\n}",
        "kind": "method",
        "params": [
          "id = ..."
        ]
      },
      {
        "name": "setCamera",
        "line": 124,
        "source": "setCamera (id, config) {\n    const existing = this.getChild(id)\n    if (existing && existing.$category === 'camera') {\n        this.removeChild(id)\n    }\n    return this.createCamera(id, config)\n}",
        "kind": "method",
        "params": [
          "id",
          "config"
        ]
      },
      {
        "name": "resolveCamera",
        "line": 133,
        "source": "resolveCamera (cameraOption) {\n    if (!cameraOption) {\n        return null\n    }\n\n    if (typeof cameraOption === 'string') {\n        return this.getCamera(cameraOption)\n    }\n\n    if (cameraOption instanceof Camera) {\n        return cameraOption\n    }\n\n    if (typeof cameraOption === 'object') {\n        return this.createCamera(cameraOption.$id, cameraOption)\n    }\n\n    return null\n}",
        "kind": "method",
        "params": [
          "cameraOption"
        ]
      },
      {
        "name": "createLayer",
        "line": 154,
        "source": "createLayer (name, type = 'canvas', options = {}) {\n    if (this.childrenRegistry.has(name)) {\n        throw new Error(`Layer \"${name}\" already exists`)\n    }\n\n    const camera = this.resolveCamera(options.camera)\n\n    const layerOptions = {\n        $id: name,\n        $category: 'layer',\n        ...options,\n        width: this.layerWidth,\n        height: this.layerHeight,\n        camera,\n        layerManager: this\n    }\n\n    let LayerClass\n    if (type === 'canvas' || type === 'webgl') {\n        LayerClass = CanvasLayer\n        layerOptions.rendererType = type\n    } else if (type === 'html') {\n        LayerClass = HTMLLayer\n    } else {\n        throw new Error(`Unknown layer type: \"${type}\"`)\n    }\n\n    const layer = this.create(LayerClass, layerOptions)\n    layer.mount(this.element)\n    this.sortLayers()\n\n    return layer\n}",
        "kind": "method",
        "params": [
          "name",
          "type = ...",
          "options = ..."
        ]
      },
      {
        "name": "getLayer",
        "line": 189,
        "source": "getLayer (name) {\n    return this.getChild(name)\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "getRenderer",
        "line": 194,
        "source": "getRenderer (name) {\n    return this.getLayer(name).renderer\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "getHTML",
        "line": 199,
        "source": "getHTML (name) {\n    return this.getLayer(name).element\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "removeLayer",
        "line": 204,
        "source": "removeLayer (name) {\n    return this.removeChild(name)\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "sortLayers",
        "line": 209,
        "source": "sortLayers () {\n    const sorted = this.childrenByCategory('layer')\n        .sort((a, b) => a.zIndex - b.zIndex)\n\n    sorted.forEach(layer => {\n        if (layer.element && layer.element.parentElement) {\n            this.element.appendChild(layer.element)\n        }\n    })\n\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "resize",
        "line": 223,
        "source": "resize (width, height) {\n    this.layerWidth = width\n    this.layerHeight = height\n\n    this.childrenByCategory('camera').forEach(camera => {\n        camera.viewportWidth = width\n        camera.viewportHeight = height\n    })\n\n    this.childrenByCategory('layer').forEach(layer => {\n        layer.resize(width, height)\n    })\n\n    return this\n}",
        "kind": "method",
        "params": [
          "width",
          "height"
        ]
      },
      {
        "name": "resizeToContainer",
        "line": 240,
        "source": "resizeToContainer () {\n    const width = this.view.element.clientWidth\n    const height = this.view.element.clientHeight\n\n    if (width > 0 && height > 0) {\n        return this.resize(width, height)\n    }\n\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "enableAutoResize",
        "line": 252,
        "source": "enableAutoResize () {\n    this.autoResizeEnabled = true\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "disableAutoResize",
        "line": 258,
        "source": "disableAutoResize () {\n    this.autoResizeEnabled = false\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "render",
        "line": 264,
        "source": "render () {\n    this.childrenByCategory('layer').forEach(layer => {\n        if (layer instanceof CanvasLayer && layer.autoRender) {\n            layer.render()\n        }\n        if (layer instanceof HTMLLayer && layer.autoUpdate) {\n            layer.updateWorldElements()\n        }\n    })\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "renderLayer",
        "line": 277,
        "source": "renderLayer (name) {\n    const layer = this.getLayer(name)\n    if (layer instanceof CanvasLayer) {\n        layer.render()\n    }\n    return this\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "showLayer",
        "line": 286,
        "source": "showLayer (name) {\n    const layer = this.getLayer(name)\n    if (layer) {\n        layer.setVisible(true)\n    }\n    return this\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "hideLayer",
        "line": 295,
        "source": "hideLayer (name) {\n    const layer = this.getLayer(name)\n    if (layer) {\n        layer.setVisible(false)\n    }\n    return this\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "onInstall",
        "line": 304,
        "source": "onInstall (host) {\n    this.delegateTo(host, [\n        'createLayer',\n        'getLayer',\n        'getRenderer',\n        'getHTML',\n        'removeLayer',\n        'renderLayer',\n        'showLayer',\n        'hideLayer',\n        'createCamera',\n        'getCamera',\n        'setCamera'\n    ])\n\n    if (host.element) {\n        this.mount(host.element)\n    } else if (host.mounted !== undefined) {\n        this.listenToOnce(host, 'mount', () => {\n            this.mount(host.element)\n        })\n    }\n}",
        "kind": "method",
        "params": [
          "host"
        ]
      },
      {
        "name": "onDispose",
        "line": 329,
        "source": "onDispose () {\n    if (this.view?.element?.parentElement) {\n        this.view.element.parentElement.removeChild(this.view.element)\n    }\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "element",
        "line": 59,
        "source": "get element () {\n    return this.view.element\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "container",
        "line": 64,
        "source": "get container () {\n    return this.view.container\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "mounted",
        "line": 79,
        "source": "get mounted () {\n    return this.view.mounted\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 12,
      "source": "constructor (options = {}) {\n    super(options)\n\n    this.create(PerkyView, {\n        $bind: 'view',\n        className: options.className || 'render-system-container',\n        position: 'absolute'\n    })\n\n    if (options.container) {\n        this.mount(options.container)\n    }\n\n    this.#configureDimensions(options)\n    this.setupCameras(options.cameras)\n    this.#setupInitialLayers(options.layers)\n    this.#setupResizeListener()\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/render/render_transform.doc.js": {
    "type": "class",
    "file": "/render/render_transform.js",
    "name": "RenderTransform",
    "line": 2,
    "extends": null,
    "statics": [],
    "methods": [
      {
        "name": "init",
        "line": 9,
        "source": "init () {\n\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "apply",
        "line": 14,
        "source": "apply (context, matrices) {// eslint-disable-line local/class-methods-use-this -- clean\n    return matrices\n}",
        "kind": "method",
        "params": [
          "context",
          "matrices"
        ]
      },
      {
        "name": "getProgram",
        "line": 19,
        "source": "getProgram () { // eslint-disable-line local/class-methods-use-this -- clean\n    return null\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "applyUniforms",
        "line": 24,
        "source": "applyUniforms () {\n\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "dispose",
        "line": 29,
        "source": "dispose () {\n\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 4,
      "source": "constructor (options = {}) {\n    this.enabled = options.enabled ?? true\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/render/sprite.doc.js": {
    "type": "class",
    "file": "/render/sprite.js",
    "name": "Sprite",
    "line": 6,
    "extends": "Object2D",
    "statics": [],
    "methods": [
      {
        "name": "setFrame",
        "line": 59,
        "source": "setFrame (frame) {\n    if (frame instanceof TextureRegion) {\n        this.#region = frame\n    } else if (frame && frame.frame) {\n        const image = frame.image\n        this.#region = TextureRegion.fromFrame(image, frame.frame)\n    } else {\n        this.#region = null\n    }\n}",
        "kind": "method",
        "params": [
          "frame"
        ]
      },
      {
        "name": "addAnimation",
        "line": 71,
        "source": "addAnimation (name, animation) {\n    this.animations.set(name, animation)\n}",
        "kind": "method",
        "params": [
          "name",
          "animation"
        ]
      },
      {
        "name": "play",
        "line": 76,
        "source": "play (name) {\n    const animation = this.animations.get(name)\n    if (animation) {\n        if (this.currentAnimation && this.currentAnimation !== animation) {\n            this.currentAnimation.stop()\n        }\n        this.currentAnimation = animation\n        this.currentAnimation.play()\n    }\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "stop",
        "line": 88,
        "source": "stop () {\n    if (this.currentAnimation) {\n        this.currentAnimation.stop()\n        this.currentAnimation = null\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "getBounds",
        "line": 131,
        "source": "getBounds () {\n    const region = this.#region\n    const hasWidth = this.width !== null\n    const hasHeight = this.height !== null\n\n    if (!region) {\n        const renderW = hasWidth ? this.width : 10\n        const renderH = hasHeight ? this.height : 10\n        const offsetX = -renderW * this.anchorX\n        const offsetY = -renderH * this.anchorY\n\n        return {\n            minX: offsetX,\n            minY: offsetY,\n            maxX: offsetX + renderW,\n            maxY: offsetY + renderH,\n            width: renderW,\n            height: renderH\n        }\n    }\n\n    const w = region.width\n    const h = region.height\n\n    let renderW\n    let renderH\n\n    if (hasWidth && hasHeight) {\n        renderW = this.width\n        renderH = this.height\n    } else if (hasWidth) {\n        renderW = this.width\n        renderH = (h / w) * renderW\n    } else if (hasHeight) {\n        renderH = this.height\n        renderW = (w / h) * renderH\n    } else {\n        renderW = w\n        renderH = h\n    }\n\n    const offsetX = -renderW * this.anchorX\n    const offsetY = -renderH * this.anchorY\n\n    return {\n        minX: offsetX,\n        minY: offsetY,\n        maxX: offsetX + renderW,\n        maxY: offsetY + renderH,\n        width: renderW,\n        height: renderH\n    }\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "region",
        "line": 30,
        "source": "get region () {\n    return this.#region\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "image",
        "line": 40,
        "source": "get image () {\n    return this.#region?.image ?? null\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "currentFrame",
        "line": 54,
        "source": "get currentFrame () {\n    return this.#region\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "effects",
        "line": 96,
        "source": "get effects () {\n    if (!this.#effects) {\n        this.#effects = new SpriteEffectStack()\n    }\n    return this.#effects\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "renderHints",
        "line": 104,
        "source": "get renderHints () {\n    const parentHints = super.renderHints\n    const hasEffects = this.#effects !== null && this.#effects.count > 0\n\n    if (!parentHints && !hasEffects) {\n        return null\n    }\n\n    const hints = parentHints ? {...parentHints} : {}\n\n    if (hasEffects) {\n        const effectHints = this.#effects.getHints()\n        if (effectHints) {\n            hints.effects = effectHints\n        }\n\n        const shaderEffectTypes = this.#effects.getShaderEffectTypes()\n        if (shaderEffectTypes.length > 0) {\n            hints.shaderEffectTypes = shaderEffectTypes\n            hints.effectParams = this.#effects.getShaderEffectParams()\n        }\n    }\n\n    return hints\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "region",
        "line": 35,
        "source": "set region (value) {\n    this.#region = value\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "image",
        "line": 45,
        "source": "set image (value) {\n    if (value) {\n        this.#region = TextureRegion.fromImage(value)\n    } else {\n        this.#region = null\n    }\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      }
    ],
    "constructor": {
      "name": "constructor",
      "line": 11,
      "source": "constructor (options = {}) {\n    super(options)\n\n    this.width = options.width ?? null\n    this.height = options.height ?? null\n\n    this.animations = new Map()\n    this.currentAnimation = null\n\n    if (options.region) {\n        this.#region = options.region\n    } else if (options.frame) {\n        this.setFrame(options.frame)\n    } else if (options.image) {\n        this.#region = TextureRegion.fromImage(options.image)\n    }\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/render/sprite_animation.doc.js": {
    "type": "class",
    "file": "/render/sprite_animation.js",
    "name": "SpriteAnimation",
    "line": 4,
    "extends": "PerkyModule",
    "statics": [],
    "methods": [
      {
        "name": "getFrameDuration",
        "line": 34,
        "source": "getFrameDuration (index) {\n    const frame = this.frames[index]\n    const baseDuration = this.frameDuration\n\n    if (frame && typeof frame.duration === 'number') {\n        return baseDuration * frame.duration\n    }\n\n    return baseDuration\n}",
        "kind": "method",
        "params": [
          "index"
        ]
      },
      {
        "name": "play",
        "line": 66,
        "source": "play () {\n    if (this.playing || this.totalFrames === 0) {\n        return this\n    }\n\n    this.playing = true\n    this.completed = false\n    this.#elapsed = 0\n    this.#updateSpriteFrame()\n    this.emit('play')\n\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "pause",
        "line": 81,
        "source": "pause () {\n    if (!this.playing) {\n        return this\n    }\n\n    this.playing = false\n    this.emit('pause')\n\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "stop",
        "line": 93,
        "source": "stop () {\n    this.playing = false\n    this.currentIndex = 0\n    this.completed = false\n    this.#elapsed = 0\n    this.#updateSpriteFrame()\n    this.emit('stop')\n\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "restart",
        "line": 105,
        "source": "restart () {\n    this.currentIndex = 0\n    this.completed = false\n    this.#elapsed = 0\n    this.playing = true\n    this.#updateSpriteFrame()\n    this.emit('play')\n\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "setFrame",
        "line": 117,
        "source": "setFrame (index) {\n    if (index >= 0 && index < this.totalFrames) {\n        this.currentIndex = index\n        this.#updateSpriteFrame()\n        this.emit('frameChanged', this.currentFrame, index)\n    }\n    return this\n}",
        "kind": "method",
        "params": [
          "index"
        ]
      },
      {
        "name": "setFrameByName",
        "line": 127,
        "source": "setFrameByName (frameName) {\n    const index = this.frames.indexOf(frameName)\n    if (index !== -1) {\n        this.setFrame(index)\n    }\n    return this\n}",
        "kind": "method",
        "params": [
          "frameName"
        ]
      },
      {
        "name": "nextFrame",
        "line": 136,
        "source": "nextFrame () {\n    const nextIndex = (this.currentIndex + 1) % this.totalFrames\n    this.setFrame(nextIndex)\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "previousFrame",
        "line": 143,
        "source": "previousFrame () {\n    const prevIndex = this.currentIndex === 0 ? this.totalFrames - 1 : this.currentIndex - 1\n    this.setFrame(prevIndex)\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "setFps",
        "line": 150,
        "source": "setFps (fps) {\n    this.fps = fps\n    this.emit('fpsChanged', fps)\n    return this\n}",
        "kind": "method",
        "params": [
          "fps"
        ]
      },
      {
        "name": "setLoop",
        "line": 157,
        "source": "setLoop (loop) {\n    this.loop = loop\n    return this\n}",
        "kind": "method",
        "params": [
          "loop"
        ]
      },
      {
        "name": "setSpeed",
        "line": 163,
        "source": "setSpeed (speed) {\n    this.speed = speed\n    return this\n}",
        "kind": "method",
        "params": [
          "speed"
        ]
      },
      {
        "name": "setPlaybackMode",
        "line": 169,
        "source": "setPlaybackMode (mode) {\n    this.playbackMode = mode\n    if (mode === 'reverse') {\n        this.#pingpongDirection = -1\n    } else {\n        this.#pingpongDirection = 1\n    }\n    return this\n}",
        "kind": "method",
        "params": [
          "mode"
        ]
      },
      {
        "name": "addEvent",
        "line": 180,
        "source": "addEvent (frameIndex, eventName) {\n    if (!this.#events.has(frameIndex)) {\n        this.#events.set(frameIndex, [])\n    }\n    this.#events.get(frameIndex).push(eventName)\n\n    if (!this.#framesByEvent.has(eventName)) {\n        this.#framesByEvent.set(eventName, [])\n    }\n    this.#framesByEvent.get(eventName).push(frameIndex)\n\n    return this\n}",
        "kind": "method",
        "params": [
          "frameIndex",
          "eventName"
        ]
      },
      {
        "name": "removeEvent",
        "line": 195,
        "source": "removeEvent (frameIndex, eventName) {\n    if (!this.#events.has(frameIndex)) {\n        return this\n    }\n\n    const events = this.#events.get(frameIndex)\n    const index = events.indexOf(eventName)\n\n    if (index !== -1) {\n        events.splice(index, 1)\n    }\n\n    if (events.length === 0) {\n        this.#events.delete(frameIndex)\n    }\n\n    if (this.#framesByEvent.has(eventName)) {\n        const frames = this.#framesByEvent.get(eventName)\n        const frameIdx = frames.indexOf(frameIndex)\n        if (frameIdx !== -1) {\n            frames.splice(frameIdx, 1)\n        }\n        if (frames.length === 0) {\n            this.#framesByEvent.delete(eventName)\n        }\n    }\n\n    return this\n}",
        "kind": "method",
        "params": [
          "frameIndex",
          "eventName"
        ]
      },
      {
        "name": "clearEvents",
        "line": 226,
        "source": "clearEvents () {\n    this.#events.clear()\n    this.#framesByEvent.clear()\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "getEvents",
        "line": 233,
        "source": "getEvents (frameIndex) {\n    return this.#events.get(frameIndex) || []\n}",
        "kind": "method",
        "params": [
          "frameIndex"
        ]
      },
      {
        "name": "getFramesByEvent",
        "line": 238,
        "source": "getFramesByEvent (eventName) {\n    return this.#framesByEvent.get(eventName) || []\n}",
        "kind": "method",
        "params": [
          "eventName"
        ]
      },
      {
        "name": "getSegmentProgress",
        "line": 243,
        "source": "getSegmentProgress (eventName) {\n    const keyframes = this.getFramesByEvent(eventName)\n\n    if (keyframes.length < 2) {\n        return 0\n    }\n\n    const current = this.currentIndex\n\n    for (let i = 0; i < keyframes.length; i++) {\n        const start = keyframes[i]\n        const end = keyframes[(i + 1) % keyframes.length]\n\n        const isInSegment = (end > start)\n            ? (current >= start && current < end)\n            : (current >= start || current < end)\n\n        if (isInSegment) {\n            const segmentLength = (end > start) ? (end - start) : (this.totalFrames - start + end)\n            const position = (current >= start) ? (current - start) : (this.totalFrames - start + current)\n            return position / segmentLength\n        }\n    }\n\n    return 0\n}",
        "kind": "method",
        "params": [
          "eventName"
        ]
      },
      {
        "name": "seekToFrame",
        "line": 271,
        "source": "seekToFrame (index) {\n    if (index >= 0 && index < this.totalFrames) {\n        this.currentIndex = index\n        this.#elapsed = 0\n        this.#updateSpriteFrame()\n    }\n    return this\n}",
        "kind": "method",
        "params": [
          "index"
        ]
      },
      {
        "name": "seekToProgress",
        "line": 281,
        "source": "seekToProgress (progress) {\n    const clampedProgress = Math.max(0, Math.min(1, progress))\n    const targetIndex = Math.floor(clampedProgress * this.totalFrames)\n    return this.seekToFrame(Math.min(targetIndex, this.totalFrames - 1))\n}",
        "kind": "method",
        "params": [
          "progress"
        ]
      },
      {
        "name": "update",
        "line": 288,
        "source": "update (deltaTime) {\n    if (!this.playing || this.completed) {\n        return\n    }\n\n    this.#elapsed += deltaTime * this.speed\n\n    while (this.#elapsed >= this.currentFrameDuration) {\n        this.#elapsed -= this.currentFrameDuration\n        this.#advanceFrame()\n\n        if (this.completed) {\n            break\n        }\n    }\n}",
        "kind": "method",
        "params": [
          "deltaTime"
        ]
      },
      {
        "name": "onDispose",
        "line": 414,
        "source": "onDispose () {\n    this.playing = false\n    this.sprite = null\n    this.frames = []\n    this.#events.clear()\n    this.#framesByEvent.clear()\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "frameDuration",
        "line": 29,
        "source": "get frameDuration () {\n    return 1 / this.fps\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "currentFrameDuration",
        "line": 46,
        "source": "get currentFrameDuration () {\n    return this.getFrameDuration(this.currentIndex)\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "totalFrames",
        "line": 51,
        "source": "get totalFrames () {\n    return this.frames.length\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "currentFrame",
        "line": 56,
        "source": "get currentFrame () {\n    return this.frames[this.currentIndex] || null\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "progress",
        "line": 61,
        "source": "get progress () {\n    return this.totalFrames > 0 ? this.currentIndex / this.totalFrames : 0\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 11,
      "source": "constructor (options = {}) {\n    super(options)\n\n    const {sprite, frames, fps = 12, loop = true, speed = 1, playbackMode = 'forward'} = options\n\n    this.sprite = sprite\n    this.frames = Array.isArray(frames) ? frames : []\n    this.fps = fps\n    this.loop = loop\n    this.speed = speed\n    this.playbackMode = playbackMode\n\n    this.currentIndex = 0\n    this.playing = false\n    this.completed = false\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/render/sprite_animator.doc.js": {
    "type": "class",
    "file": "/render/sprite_animator.js",
    "name": "SpriteAnimator",
    "line": 5,
    "extends": "PerkyModule",
    "statics": [
      {
        "name": "$category",
        "line": 7,
        "source": "static $category = 'spriteAnimator'",
        "kind": "property",
        "value": "'spriteAnimator'"
      }
    ],
    "methods": [
      {
        "name": "loadConfig",
        "line": 28,
        "source": "loadConfig (config) {\n    for (const [name, animConfig] of Object.entries(config)) {\n        const frames = this.resolveFrames(animConfig)\n\n        const animation = this.create(SpriteAnimation, {\n            $id: name,\n            sprite: this.sprite,\n            frames,\n            fps: animConfig.fps ?? 12,\n            loop: animConfig.loop ?? true,\n            playbackMode: animConfig.playbackMode ?? 'forward'\n        })\n\n        if (animConfig.motion) {\n            animation.motion = animConfig.motion\n        }\n\n        registerFrameEvents(animation, frames)\n    }\n}",
        "kind": "method",
        "params": [
          "config"
        ]
      },
      {
        "name": "resolveFrames",
        "line": 50,
        "source": "resolveFrames (animConfig) {\n    if (animConfig.source) {\n        return this.resolveSourceFrames(animConfig.source)\n    }\n\n    if (animConfig.frames) {\n        return animConfig.frames.map(frame => this.resolveFrame(frame))\n    }\n\n    return []\n}",
        "kind": "method",
        "params": [
          "animConfig"
        ]
      },
      {
        "name": "resolveSourceFrames",
        "line": 63,
        "source": "resolveSourceFrames (source) {\n    const [spritesheetName, animationName] = source.split(':')\n    const spritesheet = this.textureSystem?.getSpritesheet(spritesheetName)\n\n    if (!spritesheet) {\n        return []\n    }\n\n    const frameNames = spritesheet.getAnimation(animationName) || []\n    return frameNames.map(frameName => ({\n        region: spritesheet.getRegion(frameName),\n        name: frameName\n    }))\n}",
        "kind": "method",
        "params": [
          "source"
        ]
      },
      {
        "name": "resolveFrame",
        "line": 79,
        "source": "resolveFrame (frameConfig) {\n    if (frameConfig.region) {\n        return {\n            region: this.textureSystem?.getRegion(frameConfig.region),\n            duration: frameConfig.duration,\n            events: frameConfig.events\n        }\n    }\n\n    if (!frameConfig.source) {\n        return {region: null}\n    }\n\n    const [spritesheetName, frameName] = frameConfig.source.split(':')\n    const spritesheet = this.textureSystem?.getSpritesheet(spritesheetName)\n\n    if (!spritesheet) {\n        return {region: null}\n    }\n\n    const region = spritesheet.getRegion(frameName)\n\n    return {\n        region,\n        name: frameName,\n        source: frameConfig.source,\n        duration: frameConfig.duration,\n        events: frameConfig.events\n    }\n}",
        "kind": "method",
        "params": [
          "frameConfig"
        ]
      },
      {
        "name": "play",
        "line": 111,
        "source": "play (name) {\n    if (this.current) {\n        this.current.stop()\n    }\n\n    this.current = this.getChild(name)\n    this.current?.restart()\n\n    return this.current\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "get",
        "line": 123,
        "source": "get (name) {\n    return this.getChild(name)\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "update",
        "line": 128,
        "source": "update (deltaTime) {\n    if (this.current) {\n        this.current.update(deltaTime)\n    }\n}",
        "kind": "method",
        "params": [
          "deltaTime"
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 9,
      "source": "constructor ({sprite, config, textureSystem} = {}) {\n    super()\n    this.sprite = sprite\n    this.textureSystem = textureSystem\n    this.current = null\n\n    const resolvedConfig = config || {\n        anchor: this.constructor.anchor,\n        animations: this.constructor.animations\n    }\n\n    this.anchor = resolvedConfig.anchor || {x: 0.5, y: 0.5}\n\n    if (resolvedConfig.animations) {\n        this.loadConfig(resolvedConfig.animations)\n    }\n}",
      "kind": "constructor",
      "params": [
        "undefined = ..."
      ]
    },
    "isDefault": true
  },
  "/render/spritesheet.doc.js": {
    "type": "class",
    "file": "/render/spritesheet.js",
    "name": "Spritesheet",
    "line": 4,
    "extends": null,
    "statics": [],
    "methods": [
      {
        "name": "getFrame",
        "line": 46,
        "source": "getFrame (name) {\n    return this.framesMap.get(name) || null\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "getRegion",
        "line": 51,
        "source": "getRegion (name) {\n    const frame = this.framesMap.get(name)\n    return frame?.region || null\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "getFrames",
        "line": 57,
        "source": "getFrames (names) {\n    if (!names) {\n        return Array.from(this.framesMap.values())\n    }\n    if (!Array.isArray(names)) {\n        return []\n    }\n    return names.map(name => this.getFrame(name)).filter(Boolean)\n}",
        "kind": "method",
        "params": [
          "names"
        ]
      },
      {
        "name": "getRegions",
        "line": 68,
        "source": "getRegions (names) {\n    return this.getFrames(names).map(frame => frame.region)\n}",
        "kind": "method",
        "params": [
          "names"
        ]
      },
      {
        "name": "getAnimation",
        "line": 73,
        "source": "getAnimation (name) {\n    return this.animations[name] || null\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "getAnimationRegions",
        "line": 78,
        "source": "getAnimationRegions (name) {\n    const frameNames = this.getAnimation(name)\n    if (!frameNames) {\n        return []\n    }\n    return this.getRegions(frameNames)\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "listFrames",
        "line": 87,
        "source": "listFrames () {\n    return Array.from(this.framesMap.keys())\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "listAnimations",
        "line": 92,
        "source": "listAnimations () {\n    return Object.keys(this.animations)\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 6,
      "source": "constructor (source) {\n    this.images = source.images || [source.image]\n    this.data = source.data || {frames: [], animations: {}, meta: {}}\n    this.framesMap = new Map()\n    this.animations = this.data.animations || {}\n\n    this.#initializeFrames(this.data.frames)\n}",
      "kind": "constructor",
      "params": [
        "source"
      ]
    },
    "isDefault": true
  },
  "/render/transform.doc.js": {
    "type": "class",
    "file": "/render/transform.js",
    "name": "Transform",
    "line": 1,
    "extends": null,
    "statics": [],
    "methods": [
      {
        "name": "add",
        "line": 124,
        "source": "add (...children) {\n    children.forEach(child => {\n        if (child.parent) {\n            child.parent.remove(child)\n        }\n        this.children.push(child)\n        child.parent = this\n        child.markDirty()\n    })\n    this.markChildrenNeedSort()\n    return this\n}",
        "kind": "method",
        "params": [
          "...children"
        ]
      },
      {
        "name": "remove",
        "line": 138,
        "source": "remove (child) {\n    const index = this.children.indexOf(child)\n    if (index !== -1) {\n        this.children.splice(index, 1)\n        child.parent = null\n        child.markDirty()\n    }\n    this.markChildrenNeedSort()\n    return this\n}",
        "kind": "method",
        "params": [
          "child"
        ]
      },
      {
        "name": "markChildrenNeedSort",
        "line": 150,
        "source": "markChildrenNeedSort () {\n    this.#childrenNeedSort = true\n    this.#sortedChildren = null\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "getSortedChildren",
        "line": 156,
        "source": "getSortedChildren () {\n    if (this.#childrenNeedSort || !this.#sortedChildren) {\n        this.#sortedChildren = this.children.slice().sort((a, b) => (a.depth ?? 0) - (b.depth ?? 0))\n        this.#childrenNeedSort = false\n    }\n    return this.#sortedChildren\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "markDirty",
        "line": 165,
        "source": "markDirty () {\n    if (this.#dirty) {\n        return\n    }\n    this.#dirty = true\n    this.children.forEach(child => child.markDirty())\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "updateLocalMatrix",
        "line": 174,
        "source": "updateLocalMatrix () {\n    const cos = Math.cos(this.rotation)\n    const sin = Math.sin(this.rotation)\n\n    const px = -this.pivotX\n    const py = -this.pivotY\n\n    const a = cos * this.scaleX\n    const b = sin * this.scaleX\n    const c = -sin * this.scaleY\n    const d = cos * this.scaleY\n\n    this.#localMatrix[0] = a\n    this.#localMatrix[1] = b\n    this.#localMatrix[2] = c\n    this.#localMatrix[3] = d\n    this.#localMatrix[4] = this.x + (px * a + py * c)\n    this.#localMatrix[5] = this.y + (px * b + py * d)\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "updateWorldMatrix",
        "line": 195,
        "source": "updateWorldMatrix (force = false) {\n    if (this.#dirty || force) {\n        this.updateLocalMatrix()\n\n        if (this.parent) {\n            multiplyMatrices(this.parent.#worldMatrix, this.#localMatrix, this.#worldMatrix)\n        } else {\n            this.#worldMatrix = [...this.#localMatrix]\n        }\n\n        this.#dirty = false\n    }\n\n    this.children.forEach(child => child.updateWorldMatrix(force))\n}",
        "kind": "method",
        "params": [
          "force = ..."
        ]
      },
      {
        "name": "transformPoint",
        "line": 212,
        "source": "transformPoint (point, matrix = this.#worldMatrix) {\n    return {\n        x: matrix[0] * point.x + matrix[2] * point.y + matrix[4],\n        y: matrix[1] * point.x + matrix[3] * point.y + matrix[5]\n    }\n}",
        "kind": "method",
        "params": [
          "point",
          "matrix = ..."
        ]
      }
    ],
    "getters": [
      {
        "name": "x",
        "line": 28,
        "source": "get x () {\n    return this.#x\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "y",
        "line": 41,
        "source": "get y () {\n    return this.#y\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "rotation",
        "line": 54,
        "source": "get rotation () {\n    return this.#rotation\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "scaleX",
        "line": 67,
        "source": "get scaleX () {\n    return this.#scaleX\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "scaleY",
        "line": 80,
        "source": "get scaleY () {\n    return this.#scaleY\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "pivotX",
        "line": 93,
        "source": "get pivotX () {\n    return this.#pivotX\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "pivotY",
        "line": 106,
        "source": "get pivotY () {\n    return this.#pivotY\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "worldMatrix",
        "line": 119,
        "source": "get worldMatrix () {\n    return this.#worldMatrix\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "x",
        "line": 33,
        "source": "set x (value) {\n    if (this.#x !== value) {\n        this.#x = value\n        this.markDirty()\n    }\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "y",
        "line": 46,
        "source": "set y (value) {\n    if (this.#y !== value) {\n        this.#y = value\n        this.markDirty()\n    }\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "rotation",
        "line": 59,
        "source": "set rotation (value) {\n    if (this.#rotation !== value) {\n        this.#rotation = value\n        this.markDirty()\n    }\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "scaleX",
        "line": 72,
        "source": "set scaleX (value) {\n    if (this.#scaleX !== value) {\n        this.#scaleX = value\n        this.markDirty()\n    }\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "scaleY",
        "line": 85,
        "source": "set scaleY (value) {\n    if (this.#scaleY !== value) {\n        this.#scaleY = value\n        this.markDirty()\n    }\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "pivotX",
        "line": 98,
        "source": "set pivotX (value) {\n    if (this.#pivotX !== value) {\n        this.#pivotX = value\n        this.markDirty()\n    }\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "pivotY",
        "line": 111,
        "source": "set pivotY (value) {\n    if (this.#pivotY !== value) {\n        this.#pivotY = value\n        this.markDirty()\n    }\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      }
    ],
    "constructor": {
      "name": "constructor",
      "line": 16,
      "source": "constructor () {\n    this.parent = null\n    this.children = []\n    this.#sortedChildren = null\n    this.#childrenNeedSort = false\n\n    this.#localMatrix = [1, 0, 0, 1, 0, 0]\n    this.#worldMatrix = [1, 0, 0, 1, 0, 0]\n    this.#dirty = true\n}",
      "kind": "constructor",
      "params": []
    },
    "isDefault": true
  },
  "/render/traverse.doc.js": {
    "type": "module",
    "file": "/render/traverse.js",
    "functions": [
      {
        "name": "traverseAndCollect",
        "line": 2,
        "params": [
          "object",
          "rendererRegistry",
          "options = ..."
        ],
        "source": "function traverseAndCollect (object, rendererRegistry, options = {}) {\n    const ctx = {\n        rendererRegistry,\n        camera: options.camera ?? null,\n        enableCulling: options.enableCulling ?? false,\n        stats: options.stats ?? null,\n        debugGizmoRenderer: options.debugGizmoRenderer ?? null\n    }\n\n    traverseNode(object, ctx, 1)\n}"
      },
      {
        "name": "traverseNode",
        "line": 15,
        "params": [
          "object",
          "ctx",
          "parentOpacity"
        ],
        "source": "function traverseNode (object, ctx, parentOpacity) { // eslint-disable-line complexity -- clean\n    if (!object.visible) {\n        return\n    }\n\n    if (ctx.stats) {\n        ctx.stats.totalObjects++\n    }\n\n    if (ctx.enableCulling && ctx.camera) {\n        const worldBounds = object.getWorldBounds()\n        if (!ctx.camera.isVisible(worldBounds)) {\n            if (ctx.stats) {\n                ctx.stats.culledObjects++\n            }\n            return\n        }\n    }\n\n    if (ctx.stats) {\n        ctx.stats.renderedObjects++\n    }\n\n    const effectiveOpacity = parentOpacity * object.opacity\n\n    const renderer = ctx.rendererRegistry.get(object.constructor)\n    if (renderer) {\n        renderer.collect(object, effectiveOpacity, object.renderHints)\n    }\n\n    if (ctx.debugGizmoRenderer && object.debugGizmos) {\n        ctx.debugGizmoRenderer.collectGizmo(object, effectiveOpacity)\n    }\n\n    const sortedChildren = object.getSortedChildren\n        ? object.getSortedChildren()\n        : object.children\n\n    for (let i = 0, len = sortedChildren.length; i < len; i++) {\n        traverseNode(sortedChildren[i], ctx, effectiveOpacity)\n    }\n}"
      }
    ],
    "exports": []
  },
  "/render/webgl_texture_manager.doc.js": {
    "type": "class",
    "file": "/render/webgl_texture_manager.js",
    "name": "WebGLTextureManager",
    "line": 4,
    "extends": "PerkyModule",
    "statics": [
      {
        "name": "$category",
        "line": 6,
        "source": "static $category = 'textureManager'",
        "kind": "property",
        "value": "'textureManager'"
      }
    ],
    "methods": [
      {
        "name": "onStart",
        "line": 25,
        "source": "onStart () {\n    if (this.autoFlushEnabled && this.autoFlushInterval > 0) {\n        this.#flushInterval = setInterval(() => {\n            this.flushStale()\n        }, this.autoFlushInterval)\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "onStop",
        "line": 34,
        "source": "onStop () {\n    if (this.#flushInterval) {\n        clearInterval(this.#flushInterval)\n        this.#flushInterval = null\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "acquire",
        "line": 47,
        "source": "acquire (image) {\n    if (!image) {\n        return null\n    }\n\n    if (this.#active.has(image)) {\n        this.#active.get(image).refs++\n        return this.#active.get(image).texture\n    }\n\n    if (this.#zombies.has(image)) {\n        return this.#resurrect(image)\n    }\n\n    return this.#createEntry(image)\n}",
        "kind": "method",
        "params": [
          "image"
        ]
      },
      {
        "name": "release",
        "line": 65,
        "source": "release (image) {\n    const entry = this.#active.get(image)\n    if (!entry) {\n        return false\n    }\n\n    entry.refs--\n\n    if (entry.refs <= 0) {\n        this.#active.delete(image)\n\n        this.#zombies.set(image, {\n            texture: entry.texture,\n            size: entry.size,\n            lastUsed: Date.now()\n        })\n        this.#zombieSize += entry.size\n\n        this.emit('zombie', image, entry.size)\n        this.flushIfFull()\n    }\n\n    return true\n}",
        "kind": "method",
        "params": [
          "image"
        ]
      },
      {
        "name": "flush",
        "line": 143,
        "source": "flush () {\n    const count = this.#zombies.size\n    const size = this.#zombieSize\n\n    for (const [, zombie] of this.#zombies) {\n        this.#gl.deleteTexture(zombie.texture)\n    }\n\n    this.#zombies.clear()\n    this.#zombieSize = 0\n\n    if (count > 0) {\n        this.emit('flush', count, size)\n    }\n\n    return {count, size}\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "flushIfFull",
        "line": 162,
        "source": "flushIfFull () {\n    if (this.#zombieSize <= this.maxZombieSize) {\n        return {count: 0, size: 0}\n    }\n\n    const targetSize = this.maxZombieSize * 0.5\n    const sorted = [...this.#zombies.entries()]\n        .sort((a, b) => a[1].lastUsed - b[1].lastUsed)\n\n    let count = 0\n    let size = 0\n\n    for (const [image, zombie] of sorted) {\n        if (this.#zombieSize <= targetSize) {\n            break\n        }\n\n        this.#deleteTexture(image, zombie)\n        count++\n        size += zombie.size\n    }\n\n    if (count > 0) {\n        this.emit('flushIfFull', count, size)\n    }\n\n    return {count, size}\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "flushStale",
        "line": 192,
        "source": "flushStale (maxAge = this.maxAge) {\n    const now = Date.now()\n    let count = 0\n    let size = 0\n\n    for (const [image, zombie] of this.#zombies) {\n        if (now - zombie.lastUsed > maxAge) {\n            this.#deleteTexture(image, zombie)\n            count++\n            size += zombie.size\n        }\n    }\n\n    if (count > 0) {\n        this.emit('flushStale', count, size)\n    }\n\n    return {count, size}\n}",
        "kind": "method",
        "params": [
          "maxAge = ..."
        ]
      },
      {
        "name": "getTexture",
        "line": 213,
        "source": "getTexture (image) {\n    if (!image) {\n        return null\n    }\n\n    const active = this.#active.get(image)\n    if (active) {\n        return active.texture\n    }\n\n    const zombie = this.#zombies.get(image)\n    if (zombie) {\n        return zombie.texture\n    }\n\n    return this.acquire(image)\n}",
        "kind": "method",
        "params": [
          "image"
        ]
      },
      {
        "name": "hasTexture",
        "line": 232,
        "source": "hasTexture (image) {\n    return this.#active.has(image) || this.#zombies.has(image)\n}",
        "kind": "method",
        "params": [
          "image"
        ]
      },
      {
        "name": "onDispose",
        "line": 257,
        "source": "onDispose () {\n    this.onStop()\n\n    for (const entry of this.#active.values()) {\n        this.#gl.deleteTexture(entry.texture)\n    }\n    this.#active.clear()\n\n    for (const zombie of this.#zombies.values()) {\n        this.#gl.deleteTexture(zombie.texture)\n    }\n    this.#zombies.clear()\n    this.#zombieSize = 0\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "gl",
        "line": 42,
        "source": "get gl () {\n    return this.#gl\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "stats",
        "line": 237,
        "source": "get stats () {\n    let activeSize = 0\n    for (const entry of this.#active.values()) {\n        activeSize += entry.size\n    }\n\n    return {\n        activeCount: this.#active.size,\n        activeSize,\n        activeSizeMB: (activeSize / (1024 * 1024)).toFixed(2),\n        zombieCount: this.#zombies.size,\n        zombieSize: this.#zombieSize,\n        zombieSizeMB: (this.#zombieSize / (1024 * 1024)).toFixed(2),\n        totalCount: this.#active.size + this.#zombies.size,\n        totalSize: activeSize + this.#zombieSize,\n        totalSizeMB: ((activeSize + this.#zombieSize) / (1024 * 1024)).toFixed(2)\n    }\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 14,
      "source": "constructor (options = {}) {\n    super(options)\n\n    this.#gl = options.gl\n    this.maxZombieSize = options.maxZombieSize ?? 150 * 1024 * 1024\n    this.maxAge = options.maxAge ?? 15 * 60 * 1000\n    this.autoFlushInterval = options.autoFlushInterval ?? 60 * 1000\n    this.autoFlushEnabled = options.autoFlush ?? true\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/render/canvas/canvas_circle_renderer.doc.js": {
    "type": "class",
    "file": "/render/canvas/canvas_circle_renderer.js",
    "name": "CanvasCircleRenderer",
    "line": 5,
    "extends": "CanvasObjectRenderer",
    "statics": [
      {
        "name": "handles",
        "line": 7,
        "source": "static get handles () {\n    return [Circle]\n}",
        "kind": "method",
        "params": []
      }
    ],
    "methods": [
      {
        "name": "render",
        "line": 12,
        "source": "render (circle, ctx) { // eslint-disable-line local/class-methods-use-this -- clean\n    const offsetX = -circle.radius * 2 * circle.anchorX + circle.radius\n    const offsetY = -circle.radius * 2 * circle.anchorY + circle.radius\n\n    ctx.beginPath()\n    ctx.arc(offsetX, offsetY, circle.radius, 0, Math.PI * 2)\n    ctx.fillStyle = circle.color\n    ctx.fill()\n\n    if (circle.strokeWidth > 0) {\n        ctx.strokeStyle = circle.strokeColor\n        ctx.lineWidth = circle.strokeWidth\n        ctx.stroke()\n    }\n}",
        "kind": "method",
        "params": [
          "circle",
          "ctx"
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": null,
    "isDefault": true
  },
  "/render/canvas/canvas_debug_gizmo_renderer.doc.js": {
    "type": "class",
    "file": "/render/canvas/canvas_debug_gizmo_renderer.js",
    "name": "CanvasDebugGizmoRenderer",
    "line": 4,
    "extends": "CanvasObjectRenderer",
    "statics": [
      {
        "name": "handles",
        "line": 6,
        "source": "static get handles () {\n    return []\n}",
        "kind": "method",
        "params": []
      }
    ],
    "methods": [
      {
        "name": "collectGizmo",
        "line": 11,
        "source": "collectGizmo (object, opacity) {\n    this.collect(object, opacity, null)\n}",
        "kind": "method",
        "params": [
          "object",
          "opacity"
        ]
      },
      {
        "name": "flush",
        "line": 16,
        "source": "flush () {\n    const ctx = this.ctx\n\n    for (const {object, opacity} of this.collected) {\n        ctx.save()\n        ctx.globalAlpha = opacity\n\n        const m = object.worldMatrix\n        ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5])\n\n        this.renderGizmos(object, ctx)\n\n        ctx.restore()\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "collect",
        "line": 38,
        "source": "collect (object, opacity, hints) {\n    if (!this.constructor.prototype._collected) {\n        this.constructor.prototype._collected = []\n    }\n    this.constructor.prototype._collected.push({object, opacity, hints})\n}",
        "kind": "method",
        "params": [
          "object",
          "opacity",
          "hints"
        ]
      },
      {
        "name": "reset",
        "line": 46,
        "source": "reset () {\n    this.constructor.prototype._collected = []\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "renderGizmos",
        "line": 51,
        "source": "renderGizmos (object, ctx) {\n    const gizmos = object.debugGizmos\n    if (!gizmos) {\n        return\n    }\n\n    const bounds = object.getBounds()\n    const hasSize = bounds.width > 0 || bounds.height > 0\n\n    if (gizmos.bounds && hasSize) {\n        this.renderBounds(ctx, bounds)\n    }\n\n    if (gizmos.anchor) {\n        this.renderAnchor(ctx, object, bounds)\n    }\n\n    if (gizmos.pivot) {\n        this.renderPivot(ctx, object)\n    }\n\n    if (gizmos.origin) {\n        this.renderOrigin(ctx)\n    }\n}",
        "kind": "method",
        "params": [
          "object",
          "ctx"
        ]
      },
      {
        "name": "renderBounds",
        "line": 78,
        "source": "renderBounds (ctx, bounds) { // eslint-disable-line local/class-methods-use-this -- clean\n    ctx.strokeStyle = 'rgba(0, 255, 0, 0.8)'\n    ctx.lineWidth = 0.02\n    ctx.setLineDash([0.05, 0.05])\n    ctx.strokeRect(bounds.minX, bounds.minY, bounds.width, bounds.height)\n    ctx.setLineDash([])\n}",
        "kind": "method",
        "params": [
          "ctx",
          "bounds"
        ]
      },
      {
        "name": "renderAnchor",
        "line": 87,
        "source": "renderAnchor (ctx, object, bounds) { // eslint-disable-line local/class-methods-use-this -- clean\n    const anchorX = bounds.minX + object.anchorX * bounds.width\n    const anchorY = bounds.minY + object.anchorY * bounds.height\n\n    const size = 0.08\n\n    ctx.strokeStyle = 'rgba(255, 255, 0, 1)'\n    ctx.lineWidth = 0.02\n\n    ctx.beginPath()\n    ctx.moveTo(anchorX - size, anchorY)\n    ctx.lineTo(anchorX + size, anchorY)\n    ctx.moveTo(anchorX, anchorY - size)\n    ctx.lineTo(anchorX, anchorY + size)\n    ctx.stroke()\n\n    ctx.fillStyle = 'rgba(255, 255, 0, 0.5)'\n    ctx.beginPath()\n    ctx.arc(anchorX, anchorY, size * 0.5, 0, Math.PI * 2)\n    ctx.fill()\n}",
        "kind": "method",
        "params": [
          "ctx",
          "object",
          "bounds"
        ]
      },
      {
        "name": "renderPivot",
        "line": 110,
        "source": "renderPivot (ctx, object) { // eslint-disable-line local/class-methods-use-this -- clean\n    const pivotX = object.pivotX\n    const pivotY = object.pivotY\n\n    const size = 0.06\n\n    ctx.strokeStyle = 'rgba(255, 0, 255, 1)'\n    ctx.lineWidth = 0.02\n\n    ctx.beginPath()\n    ctx.arc(pivotX, pivotY, size, 0, Math.PI * 2)\n    ctx.stroke()\n\n    ctx.beginPath()\n    ctx.moveTo(pivotX - size * 1.5, pivotY)\n    ctx.lineTo(pivotX + size * 1.5, pivotY)\n    ctx.moveTo(pivotX, pivotY - size * 1.5)\n    ctx.lineTo(pivotX, pivotY + size * 1.5)\n    ctx.stroke()\n}",
        "kind": "method",
        "params": [
          "ctx",
          "object"
        ]
      },
      {
        "name": "renderOrigin",
        "line": 132,
        "source": "renderOrigin (ctx) { // eslint-disable-line local/class-methods-use-this -- clean\n    const size = 0.1\n\n    ctx.strokeStyle = 'rgba(255, 0, 0, 1)'\n    ctx.lineWidth = 0.025\n\n    ctx.beginPath()\n    ctx.moveTo(0, 0)\n    ctx.lineTo(size * 2, 0)\n    ctx.stroke()\n\n    ctx.strokeStyle = 'rgba(0, 255, 0, 1)'\n    ctx.beginPath()\n    ctx.moveTo(0, 0)\n    ctx.lineTo(0, size * 2)\n    ctx.stroke()\n\n    ctx.fillStyle = 'rgba(255, 255, 255, 1)'\n    ctx.beginPath()\n    ctx.arc(0, 0, 0.03, 0, Math.PI * 2)\n    ctx.fill()\n}",
        "kind": "method",
        "params": [
          "ctx"
        ]
      }
    ],
    "getters": [
      {
        "name": "collected",
        "line": 33,
        "source": "get collected () {\n    return this.constructor.prototype._collected || []\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [],
    "constructor": null,
    "isDefault": true
  },
  "/render/canvas/canvas_object_renderer.doc.js": {
    "type": "class",
    "file": "/render/canvas/canvas_object_renderer.js",
    "name": "CanvasObjectRenderer",
    "line": 1,
    "extends": null,
    "statics": [
      {
        "name": "handles",
        "line": 6,
        "source": "static get handles () {\n    return []\n}",
        "kind": "method",
        "params": []
      }
    ],
    "methods": [
      {
        "name": "init",
        "line": 21,
        "source": "init (context) {\n    this.#context = context\n}",
        "kind": "method",
        "params": [
          "context"
        ]
      },
      {
        "name": "reset",
        "line": 26,
        "source": "reset () {\n    this.#collected = []\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "collect",
        "line": 31,
        "source": "collect (object, opacity, hints = null) {\n    this.#collected.push({object, opacity, hints})\n}",
        "kind": "method",
        "params": [
          "object",
          "opacity",
          "hints = ..."
        ]
      },
      {
        "name": "flush",
        "line": 36,
        "source": "flush () {\n    const ctx = this.ctx\n\n    for (const {object, opacity, hints} of this.#collected) {\n        ctx.save()\n\n        const m = object.worldMatrix\n        ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5])\n\n        ctx.globalAlpha = opacity\n\n        if (hints?.filter) {\n            ctx.filter = hints.filter\n        }\n\n        this.render(object, ctx, hints)\n\n        ctx.restore()\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "render",
        "line": 58,
        "source": "render () {\n\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "dispose",
        "line": 63,
        "source": "dispose () {\n    this.#collected = []\n    this.#context = null\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "ctx",
        "line": 11,
        "source": "get ctx () {\n    return this.#context?.ctx || null\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "context",
        "line": 16,
        "source": "get context () {\n    return this.#context\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [],
    "constructor": null,
    "isDefault": true
  },
  "/render/canvas/canvas_post_processor.doc.js": {
    "type": "class",
    "file": "/render/canvas/canvas_post_processor.js",
    "name": "CanvasPostProcessor",
    "line": 15,
    "extends": null,
    "statics": [],
    "methods": [
      {
        "name": "addFilter",
        "line": 31,
        "source": "addFilter (type, value) {\n    this.#filters.push({type, value})\n    return this\n}",
        "kind": "method",
        "params": [
          "type",
          "value"
        ]
      },
      {
        "name": "removeFilter",
        "line": 37,
        "source": "removeFilter (type) {\n    this.#filters = this.#filters.filter(f => f.type !== type)\n    return this\n}",
        "kind": "method",
        "params": [
          "type"
        ]
      },
      {
        "name": "clearFilters",
        "line": 43,
        "source": "clearFilters () {\n    this.#filters = []\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "addManualEffect",
        "line": 49,
        "source": "addManualEffect (effect) {\n    this.#manualEffects.push(effect)\n    return this\n}",
        "kind": "method",
        "params": [
          "effect"
        ]
      },
      {
        "name": "removeManualEffect",
        "line": 55,
        "source": "removeManualEffect (effect) {\n    const index = this.#manualEffects.indexOf(effect)\n    if (index !== -1) {\n        this.#manualEffects.splice(index, 1)\n    }\n    return this\n}",
        "kind": "method",
        "params": [
          "effect"
        ]
      },
      {
        "name": "clearManualEffects",
        "line": 64,
        "source": "clearManualEffects () {\n    this.#manualEffects = []\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "begin",
        "line": 78,
        "source": "begin () {\n    const filterString = this.#buildFilterString()\n    if (filterString) {\n        this.#ctx.filter = filterString\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "finish",
        "line": 86,
        "source": "finish (width, height) {\n    this.#ctx.filter = 'none'\n\n    for (const effect of this.#manualEffects) {\n        effect.apply(this.#ctx, width, height)\n    }\n}",
        "kind": "method",
        "params": [
          "width",
          "height"
        ]
      },
      {
        "name": "applyVignette",
        "line": 95,
        "source": "applyVignette (intensity = 0.6, softness = 0.5) {\n    const ctx = this.#ctx\n    const width = ctx.canvas.width\n    const height = ctx.canvas.height\n    const centerX = width / 2\n    const centerY = height / 2\n    const radius = Math.max(width, height) * (1 - intensity)\n\n    const gradient = ctx.createRadialGradient(\n        centerX, centerY, radius * softness,\n        centerX, centerY, radius\n    )\n\n    gradient.addColorStop(0, 'rgba(0, 0, 0, 0)')\n    gradient.addColorStop(1, `rgba(0, 0, 0, ${intensity})`)\n\n    ctx.save()\n    ctx.fillStyle = gradient\n    ctx.fillRect(0, 0, width, height)\n    ctx.restore()\n}",
        "kind": "method",
        "params": [
          "intensity = ...",
          "softness = ..."
        ]
      },
      {
        "name": "dispose",
        "line": 118,
        "source": "dispose () {\n    this.#filters = []\n    this.#manualEffects = []\n    this.#ctx = null\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "filters",
        "line": 26,
        "source": "get filters () {\n    return this.#filters\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 21,
      "source": "constructor (ctx) {\n    this.#ctx = ctx\n}",
      "kind": "constructor",
      "params": [
        "ctx"
      ]
    },
    "isDefault": true
  },
  "/render/canvas/canvas_rectangle_renderer.doc.js": {
    "type": "class",
    "file": "/render/canvas/canvas_rectangle_renderer.js",
    "name": "CanvasRectangleRenderer",
    "line": 5,
    "extends": "CanvasObjectRenderer",
    "statics": [
      {
        "name": "handles",
        "line": 7,
        "source": "static get handles () {\n    return [Rectangle]\n}",
        "kind": "method",
        "params": []
      }
    ],
    "methods": [
      {
        "name": "render",
        "line": 12,
        "source": "render (rect, ctx) { // eslint-disable-line local/class-methods-use-this -- clean\n    const offsetX = -rect.width * rect.anchorX\n    const offsetY = -rect.height * rect.anchorY\n\n    if (rect.color && rect.color !== 'transparent') {\n        ctx.fillStyle = rect.color\n        ctx.fillRect(offsetX, offsetY, rect.width, rect.height)\n    }\n\n    if (rect.strokeWidth > 0) {\n        ctx.strokeStyle = rect.strokeColor\n        ctx.lineWidth = rect.strokeWidth\n        ctx.strokeRect(offsetX, offsetY, rect.width, rect.height)\n    }\n}",
        "kind": "method",
        "params": [
          "rect",
          "ctx"
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": null,
    "isDefault": true
  },
  "/render/canvas/canvas_sprite_renderer.doc.js": {
    "type": "class",
    "file": "/render/canvas/canvas_sprite_renderer.js",
    "name": "CanvasSpriteRenderer",
    "line": 5,
    "extends": "CanvasObjectRenderer",
    "statics": [
      {
        "name": "handles",
        "line": 7,
        "source": "static get handles () {\n    return [Sprite]\n}",
        "kind": "method",
        "params": []
      }
    ],
    "methods": [
      {
        "name": "render",
        "line": 12,
        "source": "render (sprite, ctx) { // eslint-disable-line local/class-methods-use-this -- clean\n    const region = sprite.region\n\n    if (!region || !region.image) {\n        return\n    }\n\n    const img = region.image\n\n    if (!img.complete || img.naturalWidth === 0) {\n        return\n    }\n\n    const {x, y, width: w, height: h} = region.bounds\n    const bounds = sprite.getBounds()\n\n    ctx.save()\n    ctx.scale(1, -1)\n    ctx.drawImage(\n        img,\n        x, y, w, h,\n        bounds.minX,\n        -bounds.maxY,\n        bounds.width, bounds.height\n    )\n    ctx.restore()\n}",
        "kind": "method",
        "params": [
          "sprite",
          "ctx"
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": null,
    "isDefault": true
  },
  "/render/postprocessing/framebuffer_manager.doc.js": {
    "type": "class",
    "file": "/render/postprocessing/framebuffer_manager.js",
    "name": "FramebufferManager",
    "line": 1,
    "extends": null,
    "statics": [],
    "methods": [
      {
        "name": "resize",
        "line": 144,
        "source": "resize (width, height) {\n    if (width === this.#width && height === this.#height) {\n        return\n    }\n\n    this.#width = width\n    this.#height = height\n\n    this.#deleteFramebuffers()\n    this.#createFramebuffers()\n    this.#resizeNamedBuffers()\n}",
        "kind": "method",
        "params": [
          "width",
          "height"
        ]
      },
      {
        "name": "resetPingPong",
        "line": 196,
        "source": "resetPingPong () {\n    this.#currentPingPong = 0\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "bindSceneBuffer",
        "line": 201,
        "source": "bindSceneBuffer () {\n    const gl = this.#gl\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.#msaaFramebuffer)\n    gl.viewport(0, 0, this.#width, this.#height)\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "resolveSceneBuffer",
        "line": 208,
        "source": "resolveSceneBuffer () {\n    const gl = this.#gl\n    const width = this.#width\n    const height = this.#height\n\n    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this.#msaaFramebuffer)\n    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.#sceneFramebuffer)\n    gl.blitFramebuffer(\n        0, 0, width, height,\n        0, 0, width, height,\n        gl.COLOR_BUFFER_BIT,\n        gl.NEAREST\n    )\n    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null)\n    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null)\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "resolveToBuffer",
        "line": 226,
        "source": "resolveToBuffer (name) {\n    const buffer = this.#namedBuffers.get(name)\n    if (!buffer) {\n        return false\n    }\n\n    const gl = this.#gl\n    const width = this.#width\n    const height = this.#height\n\n    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this.#msaaFramebuffer)\n    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, buffer.framebuffer)\n    gl.blitFramebuffer(\n        0, 0, width, height,\n        0, 0, width, height,\n        gl.COLOR_BUFFER_BIT,\n        gl.NEAREST\n    )\n    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null)\n    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null)\n\n    return true\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "getSceneTexture",
        "line": 251,
        "source": "getSceneTexture () {\n    return this.#sceneTexture\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "bindPingPong",
        "line": 256,
        "source": "bindPingPong () {\n    const gl = this.#gl\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.#pingPongFramebuffers[this.#currentPingPong])\n    gl.viewport(0, 0, this.#width, this.#height)\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "swapAndGetTexture",
        "line": 263,
        "source": "swapAndGetTexture () {\n    const texture = this.#pingPongTextures[this.#currentPingPong]\n    this.#currentPingPong = 1 - this.#currentPingPong\n    return texture\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "getOrCreateBuffer",
        "line": 270,
        "source": "getOrCreateBuffer (name) {\n    if (!this.#namedBuffers.has(name)) {\n        const {framebuffer, texture} = this.#createFramebuffer()\n        this.#namedBuffers.set(name, {framebuffer, texture})\n    }\n    return this.#namedBuffers.get(name)\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "bindBuffer",
        "line": 279,
        "source": "bindBuffer (name) {\n    const buffer = this.#namedBuffers.get(name)\n    if (!buffer) {\n        return false\n    }\n    const gl = this.#gl\n    gl.bindFramebuffer(gl.FRAMEBUFFER, buffer.framebuffer)\n    gl.viewport(0, 0, this.#width, this.#height)\n    return true\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "getBufferTexture",
        "line": 291,
        "source": "getBufferTexture (name) {\n    return this.#namedBuffers.get(name)?.texture ?? null\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "disposeBuffer",
        "line": 296,
        "source": "disposeBuffer (name) {\n    const buffer = this.#namedBuffers.get(name)\n    if (!buffer) {\n        return false\n    }\n\n    const gl = this.#gl\n    gl.deleteFramebuffer(buffer.framebuffer)\n    gl.deleteTexture(buffer.texture)\n    this.#namedBuffers.delete(name)\n    return true\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "disposeNamedBuffers",
        "line": 310,
        "source": "disposeNamedBuffers () {\n    const gl = this.#gl\n    for (const {framebuffer, texture} of this.#namedBuffers.values()) {\n        gl.deleteFramebuffer(framebuffer)\n        gl.deleteTexture(texture)\n    }\n    this.#namedBuffers.clear()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "bindScreen",
        "line": 320,
        "source": "bindScreen () {\n    const gl = this.#gl\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null)\n    gl.viewport(0, 0, this.#width, this.#height)\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "dispose",
        "line": 327,
        "source": "dispose () {\n    this.#deleteFramebuffers()\n    this.disposeNamedBuffers()\n    this.#msaaFramebuffer = null\n    this.#msaaRenderbuffer = null\n    this.#sceneFramebuffer = null\n    this.#sceneTexture = null\n    this.#gl = null\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "width",
        "line": 26,
        "source": "get width () {\n    return this.#width\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "height",
        "line": 31,
        "source": "get height () {\n    return this.#height\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "samples",
        "line": 36,
        "source": "get samples () {\n    return this.#samples\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 17,
      "source": "constructor (gl, width, height, samples = 4) {\n    this.#gl = gl\n    this.#width = width\n    this.#height = height\n    this.#samples = Math.min(samples, gl.getParameter(gl.MAX_SAMPLES))\n    this.#createFramebuffers()\n}",
      "kind": "constructor",
      "params": [
        "gl",
        "width",
        "height",
        "samples = ..."
      ]
    },
    "isDefault": true
  },
  "/render/postprocessing/fullscreen_quad.doc.js": {
    "type": "class",
    "file": "/render/postprocessing/fullscreen_quad.js",
    "name": "FullscreenQuad",
    "line": 4,
    "extends": null,
    "statics": [],
    "methods": [
      {
        "name": "draw",
        "line": 39,
        "source": "draw (gl, program) {\n    const positionAttr = program.attributes.aPosition\n    const texCoordAttr = program.attributes.aTexCoord\n\n    if (positionAttr === undefined || positionAttr === -1) {\n        logger.warn('FullscreenQuad: aPosition attribute not found')\n        return\n    }\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.#vertexBuffer)\n    gl.enableVertexAttribArray(positionAttr)\n    gl.vertexAttribPointer(positionAttr, 2, gl.FLOAT, false, 0, 0)\n\n    if (texCoordAttr !== undefined && texCoordAttr !== -1) {\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.#texCoordBuffer)\n        gl.enableVertexAttribArray(texCoordAttr)\n        gl.vertexAttribPointer(texCoordAttr, 2, gl.FLOAT, false, 0, 0)\n    }\n\n    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)\n}",
        "kind": "method",
        "params": [
          "gl",
          "program"
        ]
      },
      {
        "name": "dispose",
        "line": 62,
        "source": "dispose (gl) {\n    if (this.#vertexBuffer) {\n        gl.deleteBuffer(this.#vertexBuffer)\n        this.#vertexBuffer = null\n    }\n    if (this.#texCoordBuffer) {\n        gl.deleteBuffer(this.#texCoordBuffer)\n        this.#texCoordBuffer = null\n    }\n}",
        "kind": "method",
        "params": [
          "gl"
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 9,
      "source": "constructor (gl) {\n    this.#createBuffers(gl)\n}",
      "kind": "constructor",
      "params": [
        "gl"
      ]
    },
    "isDefault": true
  },
  "/render/postprocessing/post_processor.doc.js": {
    "type": "class",
    "file": "/render/postprocessing/post_processor.js",
    "name": "PostProcessor",
    "line": 6,
    "extends": "PerkyModule",
    "statics": [
      {
        "name": "$category",
        "line": 8,
        "source": "static $category = 'postProcessor'",
        "kind": "property",
        "value": "'postProcessor'"
      },
      {
        "name": "$bind",
        "line": 9,
        "source": "static $bind = 'postProcessor'",
        "kind": "property",
        "value": "'postProcessor'"
      }
    ],
    "methods": [
      {
        "name": "onInstall",
        "line": 28,
        "source": "onInstall () {\n    this.#framebufferManager = new FramebufferManager(\n        this.#gl,\n        this.width,\n        this.height\n    )\n    this.#fullscreenQuad = new FullscreenQuad(this.#gl)\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "addPass",
        "line": 58,
        "source": "addPass (pass) {\n    pass.init(this.#shaderRegistry)\n    this.#passes.push(pass)\n    return this\n}",
        "kind": "method",
        "params": [
          "pass"
        ]
      },
      {
        "name": "removePass",
        "line": 65,
        "source": "removePass (pass) {\n    const index = this.#passes.indexOf(pass)\n    if (index !== -1) {\n        this.#passes.splice(index, 1)\n        pass.dispose()\n    }\n    return this\n}",
        "kind": "method",
        "params": [
          "pass"
        ]
      },
      {
        "name": "clearPasses",
        "line": 75,
        "source": "clearPasses () {\n    for (const pass of this.#passes) {\n        pass.dispose()\n    }\n    this.#passes = []\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "resize",
        "line": 84,
        "source": "resize (width, height) {\n    this.width = width\n    this.height = height\n    this.#framebufferManager?.resize(width, height)\n}",
        "kind": "method",
        "params": [
          "width",
          "height"
        ]
      },
      {
        "name": "hasActivePasses",
        "line": 91,
        "source": "hasActivePasses () {\n    return this.#enabled && this.#passes.some(pass => pass.enabled)\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "begin",
        "line": 96,
        "source": "begin () {\n    if (!this.hasActivePasses()) {\n        return false\n    }\n\n    this.#framebufferManager.resetPingPong()\n    this.#framebufferManager.bindSceneBuffer()\n\n    return true\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "finish",
        "line": 108,
        "source": "finish () {\n    if (!this.hasActivePasses()) {\n        return\n    }\n\n    const gl = this.#gl\n    const activePasses = this.#passes.filter(pass => pass.enabled)\n\n    this.#framebufferManager.resolveSceneBuffer()\n\n    gl.disable(gl.BLEND)\n\n    let inputTexture = this.#framebufferManager.getSceneTexture()\n\n    for (let i = 0; i < activePasses.length; i++) {\n        const isLast = i === activePasses.length - 1\n\n        if (isLast) {\n            this.#framebufferManager.bindScreen()\n\n            gl.clearColor(0, 0, 0, 1)\n            gl.clear(gl.COLOR_BUFFER_BIT)\n        } else {\n            this.#framebufferManager.bindPingPong()\n            gl.clearColor(0, 0, 0, 0)\n            gl.clear(gl.COLOR_BUFFER_BIT)\n        }\n\n        activePasses[i].render(gl, inputTexture, this.#fullscreenQuad)\n\n        if (!isLast) {\n            inputTexture = this.#framebufferManager.swapAndGetTexture()\n        }\n    }\n\n    gl.enable(gl.BLEND)\n    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "onDispose",
        "line": 148,
        "source": "onDispose () {\n    this.clearPasses()\n\n    if (this.#framebufferManager) {\n        this.#framebufferManager.dispose()\n        this.#framebufferManager = null\n    }\n\n    if (this.#fullscreenQuad) {\n        this.#fullscreenQuad.dispose(this.#gl)\n        this.#fullscreenQuad = null\n    }\n\n    this.#gl = null\n    this.#shaderRegistry = null\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "enabled",
        "line": 38,
        "source": "get enabled () {\n    return this.#enabled\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "passes",
        "line": 48,
        "source": "get passes () {\n    return this.#passes\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "framebufferManager",
        "line": 53,
        "source": "get framebufferManager () {\n    return this.#framebufferManager\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "enabled",
        "line": 43,
        "source": "set enabled (value) {\n    this.#enabled = value\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      }
    ],
    "constructor": {
      "name": "constructor",
      "line": 18,
      "source": "constructor (options = {}) {\n    super(options)\n\n    this.#gl = options.gl\n    this.#shaderRegistry = options.shaderRegistry\n    this.width = options.width\n    this.height = options.height\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/render/postprocessing/render_pass.doc.js": {
    "type": "class",
    "file": "/render/postprocessing/render_pass.js",
    "name": "RenderPass",
    "line": 4,
    "extends": "PerkyModule",
    "statics": [
      {
        "name": "$category",
        "line": 6,
        "source": "static $category = 'renderPass'",
        "kind": "property",
        "value": "'renderPass'"
      },
      {
        "name": "$lifecycle",
        "line": 7,
        "source": "static $lifecycle = false",
        "kind": "property",
        "value": "false"
      },
      {
        "name": "shaderDefinition",
        "line": 9,
        "source": "static shaderDefinition = null",
        "kind": "property",
        "value": "null"
      },
      {
        "name": "defaultUniforms",
        "line": 10,
        "source": "static defaultUniforms = {}",
        "kind": "property",
        "value": "{}"
      },
      {
        "name": "uniformConfig",
        "line": 11,
        "source": "static uniformConfig = {}",
        "kind": "property",
        "value": "{}"
      }
    ],
    "methods": [
      {
        "name": "init",
        "line": 43,
        "source": "init (shaderRegistry) {\n    const definition = this.constructor.shaderDefinition\n    if (!definition) {\n        throw new Error(`${this.constructor.name}.shaderDefinition must be defined`)\n    }\n\n    const id = `pass_${this.constructor.name}_${Date.now()}`\n    this.#program = shaderRegistry.register(id, definition)\n}",
        "kind": "method",
        "params": [
          "shaderRegistry"
        ]
      },
      {
        "name": "setUniform",
        "line": 54,
        "source": "setUniform (name, value) {\n    this.#uniforms[name] = value\n    return this\n}",
        "kind": "method",
        "params": [
          "name",
          "value"
        ]
      },
      {
        "name": "render",
        "line": 60,
        "source": "render (gl, inputTexture, fullscreenQuad) {\n    if (!this.#enabled || !this.#program) {\n        return\n    }\n\n    this.#program.use()\n\n    gl.activeTexture(gl.TEXTURE0)\n    gl.bindTexture(gl.TEXTURE_2D, inputTexture)\n    this.#program.setUniform1i('uTexture', 0)\n\n    this.applyUniforms()\n\n    fullscreenQuad.draw(gl, this.#program)\n}",
        "kind": "method",
        "params": [
          "gl",
          "inputTexture",
          "fullscreenQuad"
        ]
      },
      {
        "name": "applyUniforms",
        "line": 77,
        "source": "applyUniforms () {\n    for (const [name, value] of Object.entries(this.#uniforms)) {\n        this.#applyUniform(name, value)\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "onDispose",
        "line": 104,
        "source": "onDispose () {\n    this.#program = null\n    this.#uniforms = {}\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "enabled",
        "line": 23,
        "source": "get enabled () {\n    return this.#enabled\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "program",
        "line": 33,
        "source": "get program () {\n    return this.#program\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "uniforms",
        "line": 38,
        "source": "get uniforms () {\n    return this.#uniforms\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "enabled",
        "line": 28,
        "source": "set enabled (value) {\n    this.#enabled = value\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      }
    ],
    "constructor": {
      "name": "constructor",
      "line": 17,
      "source": "constructor (options = {}) {\n    super(options)\n    this.#uniforms = {...this.constructor.defaultUniforms}\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/render/postprocessing/passes/color_grade_pass.doc.js": {
    "type": "class",
    "file": "/render/postprocessing/passes/color_grade_pass.js",
    "name": "ColorGradePass",
    "line": 4,
    "extends": "RenderPass",
    "statics": [
      {
        "name": "shaderDefinition",
        "line": 6,
        "source": "static shaderDefinition = {\n    vertex: `#version 300 es\n        in vec2 aPosition;\n        in vec2 aTexCoord;\n        out vec2 vTexCoord;\n        void main() {\n            gl_Position = vec4(aPosition, 0.0, 1.0);\n            vTexCoord = aTexCoord;\n        }\n    `,\n    fragment: `#version 300 es\n        precision mediump float;\n        uniform sampler2D uTexture;\n        uniform float uBrightness;\n        uniform float uContrast;\n        uniform float uSaturation;\n        in vec2 vTexCoord;\n        out vec4 fragColor;\n        void main() {\n            vec4 color = texture(uTexture, vTexCoord);\n            vec3 rgb = color.rgb + uBrightness;\n            rgb = (rgb - 0.5) * uContrast + 0.5;\n            float gray = dot(rgb, vec3(0.299, 0.587, 0.114));\n            rgb = mix(vec3(gray), rgb, uSaturation);\n            fragColor = vec4(clamp(rgb, 0.0, 1.0), color.a);\n        }\n    `,\n    uniforms: ['uTexture', 'uBrightness', 'uContrast', 'uSaturation'],\n    attributes: ['aPosition', 'aTexCoord']\n}",
        "kind": "property",
        "value": "{\n    vertex: `#version 300 es\n        in vec2 aPosition;\n        in vec2 aTexCoord;\n        out vec2 vTexCoord;\n        void main() {\n            gl_Position = vec4(aPosition, 0.0, 1.0);\n            vTexCoord = aTexCoord;\n        }\n    `,\n    fragment: `#version 300 es\n        precision mediump float;\n        uniform sampler2D uTexture;\n        uniform float uBrightness;\n        uniform float uContrast;\n        uniform float uSaturation;\n        in vec2 vTexCoord;\n        out vec4 fragColor;\n        void main() {\n            vec4 color = texture(uTexture, vTexCoord);\n            vec3 rgb = color.rgb + uBrightness;\n            rgb = (rgb - 0.5) * uContrast + 0.5;\n            float gray = dot(rgb, vec3(0.299, 0.587, 0.114));\n            rgb = mix(vec3(gray), rgb, uSaturation);\n            fragColor = vec4(clamp(rgb, 0.0, 1.0), color.a);\n        }\n    `,\n    uniforms: ['uTexture', 'uBrightness', 'uContrast', 'uSaturation'],\n    attributes: ['aPosition', 'aTexCoord']\n}"
      },
      {
        "name": "defaultUniforms",
        "line": 37,
        "source": "static defaultUniforms = {\n    uBrightness: 0.0,\n    uContrast: 1.0,\n    uSaturation: 1.0\n}",
        "kind": "property",
        "value": "{\n    uBrightness: 0.0,\n    uContrast: 1.0,\n    uSaturation: 1.0\n}"
      },
      {
        "name": "uniformConfig",
        "line": 43,
        "source": "static uniformConfig = {\n    uBrightness: {min: -0.5, max: 0.5, step: 0.01},\n    uContrast: {min: 0.5, max: 1.5, step: 0.01},\n    uSaturation: {min: 0, max: 2, step: 0.01}\n}",
        "kind": "property",
        "value": "{\n    uBrightness: {min: -0.5, max: 0.5, step: 0.01},\n    uContrast: {min: 0.5, max: 1.5, step: 0.01},\n    uSaturation: {min: 0, max: 2, step: 0.01}\n}"
      }
    ],
    "methods": [],
    "getters": [],
    "setters": [],
    "constructor": null,
    "isDefault": true
  },
  "/render/postprocessing/passes/vignette_pass.doc.js": {
    "type": "class",
    "file": "/render/postprocessing/passes/vignette_pass.js",
    "name": "VignettePass",
    "line": 4,
    "extends": "RenderPass",
    "statics": [
      {
        "name": "$name",
        "line": 6,
        "source": "static $name = 'vignettePass'",
        "kind": "property",
        "value": "'vignettePass'"
      },
      {
        "name": "shaderDefinition",
        "line": 8,
        "source": "static shaderDefinition = {\n    vertex: `#version 300 es\n        in vec2 aPosition;\n        in vec2 aTexCoord;\n        out vec2 vTexCoord;\n        void main() {\n            gl_Position = vec4(aPosition, 0.0, 1.0);\n            vTexCoord = aTexCoord;\n        }\n    `,\n    fragment: `#version 300 es\n        precision highp float;\n        uniform sampler2D uTexture;\n        uniform float uIntensity;\n        uniform float uSmoothness;\n        uniform float uRoundness;\n        uniform vec3 uColor;\n        in vec2 vTexCoord;\n        out vec4 fragColor;\n\n        float dither(vec2 coord) {\n            return (fract(sin(dot(coord, vec2(12.9898, 78.233))) * 43758.5453) - 0.5) / 255.0;\n        }\n\n        void main() {\n            vec4 color = texture(uTexture, vTexCoord);\n            vec2 uv = vTexCoord * 2.0 - 1.0;\n\n            uv.x *= mix(1.0, 0.7, uRoundness);\n\n            float dist = dot(uv, uv);\n\n            float vignette = 1.0 - dist * uIntensity;\n            vignette = smoothstep(0.0, uSmoothness, vignette);\n\n            vec3 finalColor = mix(uColor, color.rgb, vignette);\n            finalColor += dither(gl_FragCoord.xy);\n\n            fragColor = vec4(finalColor, color.a);\n        }\n    `,\n    uniforms: ['uTexture', 'uIntensity', 'uSmoothness', 'uRoundness', 'uColor'],\n    attributes: ['aPosition', 'aTexCoord']\n}",
        "kind": "property",
        "value": "{\n    vertex: `#version 300 es\n        in vec2 aPosition;\n        in vec2 aTexCoord;\n        out vec2 vTexCoord;\n        void main() {\n            gl_Position = vec4(aPosition, 0.0, 1.0);\n            vTexCoord = aTexCoord;\n        }\n    `,\n    fragment: `#version 300 es\n        precision highp float;\n        uniform sampler2D uTexture;\n        uniform float uIntensity;\n        uniform float uSmoothness;\n        uniform float uRoundness;\n        uniform vec3 uColor;\n        in vec2 vTexCoord;\n        out vec4 fragColor;\n\n        float dither(vec2 coord) {\n            return (fract(sin(dot(coord, vec2(12.9898, 78.233))) * 43758.5453) - 0.5) / 255.0;\n        }\n\n        void main() {\n            vec4 color = texture(uTexture, vTexCoord);\n            vec2 uv = vTexCoord * 2.0 - 1.0;\n\n            uv.x *= mix(1.0, 0.7, uRoundness);\n\n            float dist = dot(uv, uv);\n\n            float vignette = 1.0 - dist * uIntensity;\n            vignette = smoothstep(0.0, uSmoothness, vignette);\n\n            vec3 finalColor = mix(uColor, color.rgb, vignette);\n            finalColor += dither(gl_FragCoord.xy);\n\n            fragColor = vec4(finalColor, color.a);\n        }\n    `,\n    uniforms: ['uTexture', 'uIntensity', 'uSmoothness', 'uRoundness', 'uColor'],\n    attributes: ['aPosition', 'aTexCoord']\n}"
      },
      {
        "name": "defaultUniforms",
        "line": 53,
        "source": "static defaultUniforms = {\n    uIntensity: 0.4,\n    uSmoothness: 0.8,\n    uRoundness: 0.5,\n    uColor: [0.0, 0.0, 0.0]\n}",
        "kind": "property",
        "value": "{\n    uIntensity: 0.4,\n    uSmoothness: 0.8,\n    uRoundness: 0.5,\n    uColor: [0.0, 0.0, 0.0]\n}"
      },
      {
        "name": "uniformConfig",
        "line": 60,
        "source": "static uniformConfig = {\n    uIntensity: {min: 0, max: 1, step: 0.01},\n    uSmoothness: {min: 0, max: 2, step: 0.01},\n    uRoundness: {min: 0, max: 1, step: 0.01},\n    uColor: {type: 'color'}\n}",
        "kind": "property",
        "value": "{\n    uIntensity: {min: 0, max: 1, step: 0.01},\n    uSmoothness: {min: 0, max: 2, step: 0.01},\n    uRoundness: {min: 0, max: 1, step: 0.01},\n    uColor: {type: 'color'}\n}"
      }
    ],
    "methods": [],
    "getters": [],
    "setters": [],
    "constructor": null,
    "isDefault": true
  },
  "/render/shaders/shader_effect.doc.js": {
    "type": "class",
    "file": "/render/shaders/shader_effect.js",
    "name": "ShaderEffect",
    "line": 1,
    "extends": null,
    "statics": [
      {
        "name": "shader",
        "line": 3,
        "source": "static shader = {\n    params: [],\n    uniforms: [],\n    fragment: ''\n}",
        "kind": "property",
        "value": "{\n    params: [],\n    uniforms: [],\n    fragment: ''\n}"
      }
    ],
    "methods": [
      {
        "name": "getParams",
        "line": 31,
        "source": "getParams () {\n    const {params} = this.constructor.shader\n    return params.map(name => this[name] ?? 0)\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "getHints",
        "line": 37,
        "source": "getHints () { // eslint-disable-line local/class-methods-use-this -- clean\n    return null\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "update",
        "line": 42,
        "source": "update () {\n\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "dispose",
        "line": 47,
        "source": "dispose () {\n\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "enabled",
        "line": 16,
        "source": "get enabled () {\n    return this.#enabled\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "type",
        "line": 26,
        "source": "get type () {\n    return this.constructor.name\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "enabled",
        "line": 21,
        "source": "set enabled (value) {\n    this.#enabled = value\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      }
    ],
    "constructor": {
      "name": "constructor",
      "line": 11,
      "source": "constructor (options = {}) {\n    this.#enabled = options.enabled ?? true\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/render/shaders/shader_effect_registry.doc.js": {
    "type": "class",
    "file": "/render/shaders/shader_effect_registry.js",
    "name": "ShaderEffectRegistry",
    "line": 15,
    "extends": null,
    "statics": [],
    "methods": [
      {
        "name": "setUniform",
        "line": 30,
        "source": "setUniform (name, value, type = null) {\n    this.#uniformValues.set(name, value)\n    if (type) {\n        this.#uniformTypes.set(name, type)\n    }\n    return this\n}",
        "kind": "method",
        "params": [
          "name",
          "value",
          "type = ..."
        ]
      },
      {
        "name": "getUniform",
        "line": 39,
        "source": "getUniform (name) {\n    return this.#uniformValues.get(name)\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "applyUniforms",
        "line": 44,
        "source": "applyUniforms (gl, program) {\n    const uniformSetters = {\n        float: (loc, val) => gl.uniform1f(loc, val),\n        vec2: (loc, val) => gl.uniform2fv(loc, val),\n        vec3: (loc, val) => gl.uniform3fv(loc, val),\n        vec4: (loc, val) => gl.uniform4fv(loc, val),\n        int: (loc, val) => gl.uniform1i(loc, val)\n    }\n\n    for (const [name, value] of this.#uniformValues) {\n        const location = program.uniforms[name]\n        if (location === undefined || location === -1) {\n            continue\n        }\n\n        const type = this.#uniformTypes.get(name) || DEFAULT_UNIFORM_TYPES[name] || 'float'\n        const setter = uniformSetters[type] || uniformSetters.float\n        setter(location, value)\n    }\n}",
        "kind": "method",
        "params": [
          "gl",
          "program"
        ]
      },
      {
        "name": "register",
        "line": 66,
        "source": "register (EffectClass) {\n    const name = EffectClass.name\n    this.#effects.set(name, EffectClass)\n    return this\n}",
        "kind": "method",
        "params": [
          "EffectClass"
        ]
      },
      {
        "name": "get",
        "line": 73,
        "source": "get (name) {\n    return this.#effects.get(name) || null\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "has",
        "line": 78,
        "source": "has (name) {\n    return this.#effects.has(name)\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "getShaderForEffects",
        "line": 83,
        "source": "getShaderForEffects (effectTypes) {\n    const sortedTypes = [...effectTypes].sort()\n    const cacheKey = sortedTypes.join('|') || 'base'\n\n    if (this.#shaderCache.has(cacheKey)) {\n        return this.#shaderCache.get(cacheKey)\n    }\n\n    const shader = this.#compileShader(sortedTypes, cacheKey)\n    this.#shaderCache.set(cacheKey, shader)\n    return shader\n}",
        "kind": "method",
        "params": [
          "effectTypes"
        ]
      },
      {
        "name": "dispose",
        "line": 155,
        "source": "dispose () {\n    this.#effects.clear()\n    this.#shaderCache.clear()\n    this.#uniformValues.clear()\n    this.#uniformTypes.clear()\n    this.#gl = null\n    this.#shaderRegistry = null\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 24,
      "source": "constructor (gl, shaderRegistry) {\n    this.#gl = gl\n    this.#shaderRegistry = shaderRegistry\n}",
      "kind": "constructor",
      "params": [
        "gl",
        "shaderRegistry"
      ]
    },
    "isDefault": true
  },
  "/render/shaders/shader_program.doc.js": {
    "type": "class",
    "file": "/render/shaders/shader_program.js",
    "name": "ShaderProgram",
    "line": 1,
    "extends": null,
    "statics": [],
    "methods": [
      {
        "name": "registerUniform",
        "line": 70,
        "source": "registerUniform (name) {\n    const location = this.#gl.getUniformLocation(this.#program, name)\n    this.#uniforms[name] = location\n    return this\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "registerAttribute",
        "line": 77,
        "source": "registerAttribute (name) {\n    const location = this.#gl.getAttribLocation(this.#program, name)\n    this.#attributes[name] = location\n    return this\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "use",
        "line": 84,
        "source": "use () {\n    this.#gl.useProgram(this.#program)\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "setUniform1f",
        "line": 90,
        "source": "setUniform1f (name, value) {\n    this.#gl.uniform1f(this.#uniforms[name], value)\n    return this\n}",
        "kind": "method",
        "params": [
          "name",
          "value"
        ]
      },
      {
        "name": "setUniform2f",
        "line": 96,
        "source": "setUniform2f (name, x, y) {\n    this.#gl.uniform2f(this.#uniforms[name], x, y)\n    return this\n}",
        "kind": "method",
        "params": [
          "name",
          "x",
          "y"
        ]
      },
      {
        "name": "setUniform3f",
        "line": 102,
        "source": "setUniform3f (name, x, y, z) {\n    this.#gl.uniform3f(this.#uniforms[name], x, y, z)\n    return this\n}",
        "kind": "method",
        "params": [
          "name",
          "x",
          "y",
          "z"
        ]
      },
      {
        "name": "setUniform4f",
        "line": 108,
        "source": "setUniform4f (name, values) {\n    this.#gl.uniform4f(this.#uniforms[name], values[0], values[1], values[2], values[3])\n    return this\n}",
        "kind": "method",
        "params": [
          "name",
          "values"
        ]
      },
      {
        "name": "setUniform1i",
        "line": 114,
        "source": "setUniform1i (name, value) {\n    this.#gl.uniform1i(this.#uniforms[name], value)\n    return this\n}",
        "kind": "method",
        "params": [
          "name",
          "value"
        ]
      },
      {
        "name": "setUniformMatrix3fv",
        "line": 120,
        "source": "setUniformMatrix3fv (name, transpose, value) {\n    this.#gl.uniformMatrix3fv(this.#uniforms[name], transpose, value)\n    return this\n}",
        "kind": "method",
        "params": [
          "name",
          "transpose",
          "value"
        ]
      },
      {
        "name": "setUniformMatrix4fv",
        "line": 126,
        "source": "setUniformMatrix4fv (name, transpose, value) {\n    this.#gl.uniformMatrix4fv(this.#uniforms[name], transpose, value)\n    return this\n}",
        "kind": "method",
        "params": [
          "name",
          "transpose",
          "value"
        ]
      },
      {
        "name": "dispose",
        "line": 132,
        "source": "dispose () {\n    if (this.#program) {\n        this.#gl.deleteProgram(this.#program)\n        this.#program = null\n    }\n    this.#uniforms = {}\n    this.#attributes = {}\n    this.#gl = null\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "program",
        "line": 14,
        "source": "get program () {\n    return this.#program\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "uniforms",
        "line": 19,
        "source": "get uniforms () {\n    return this.#uniforms\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "attributes",
        "line": 24,
        "source": "get attributes () {\n    return this.#attributes\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 8,
      "source": "constructor (gl, vertexSource, fragmentSource) {\n    this.#gl = gl\n    this.#program = this.#createProgram(vertexSource, fragmentSource)\n}",
      "kind": "constructor",
      "params": [
        "gl",
        "vertexSource",
        "fragmentSource"
      ]
    },
    "isDefault": true
  },
  "/render/shaders/shader_registry.doc.js": {
    "type": "class",
    "file": "/render/shaders/shader_registry.js",
    "name": "ShaderRegistry",
    "line": 4,
    "extends": null,
    "statics": [],
    "methods": [
      {
        "name": "register",
        "line": 15,
        "source": "register (id, {vertex, fragment, uniforms = [], attributes = []}) {\n    const program = new ShaderProgram(this.#gl, vertex, fragment)\n\n    for (const name of uniforms) {\n        program.registerUniform(name)\n    }\n\n    for (const name of attributes) {\n        program.registerAttribute(name)\n    }\n\n    this.#programs.set(id, program)\n    return program\n}",
        "kind": "method",
        "params": [
          "id",
          "{...}"
        ]
      },
      {
        "name": "get",
        "line": 31,
        "source": "get (id) {\n    return this.#programs.get(id) || null\n}",
        "kind": "method",
        "params": [
          "id"
        ]
      },
      {
        "name": "has",
        "line": 36,
        "source": "has (id) {\n    return this.#programs.has(id)\n}",
        "kind": "method",
        "params": [
          "id"
        ]
      },
      {
        "name": "setDefault",
        "line": 41,
        "source": "setDefault (type, id) {\n    this.#defaults.set(type, id)\n    return this\n}",
        "kind": "method",
        "params": [
          "type",
          "id"
        ]
      },
      {
        "name": "getDefault",
        "line": 47,
        "source": "getDefault (type) {\n    const id = this.#defaults.get(type)\n    return id ? this.get(id) : null\n}",
        "kind": "method",
        "params": [
          "type"
        ]
      },
      {
        "name": "unregister",
        "line": 53,
        "source": "unregister (id) {\n    const program = this.#programs.get(id)\n\n    if (program) {\n        program.dispose()\n        this.#programs.delete(id)\n\n        for (const [type, defaultId] of this.#defaults) {\n            if (defaultId === id) {\n                this.#defaults.delete(type)\n            }\n        }\n    }\n\n    return this\n}",
        "kind": "method",
        "params": [
          "id"
        ]
      },
      {
        "name": "dispose",
        "line": 71,
        "source": "dispose () {\n    for (const program of this.#programs.values()) {\n        program.dispose()\n    }\n\n    this.#programs.clear()\n    this.#defaults.clear()\n    this.#gl = null\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 10,
      "source": "constructor (gl) {\n    this.#gl = gl\n}",
      "kind": "constructor",
      "params": [
        "gl"
      ]
    },
    "isDefault": true
  },
  "/render/shaders/builtin/primitive_shader.doc.js": {
    "type": "module",
    "file": "/render/shaders/builtin/primitive_shader.js",
    "functions": [],
    "exports": [
      {
        "name": "PRIMITIVE_VERTEX",
        "kind": "variable",
        "line": 1,
        "source": "export const PRIMITIVE_VERTEX = `#version 300 es\nin vec2 aPosition;\nin vec4 aColor;\n\nuniform mat3 uProjectionMatrix;\nuniform mat3 uViewMatrix;\n\nout vec4 vColor;\n\nvoid main() {\n    vec3 viewPos = uViewMatrix * vec3(aPosition, 1.0);\n    vec3 clipPos = uProjectionMatrix * viewPos;\n\n    gl_Position = vec4(clipPos.xy, 0.0, 1.0);\n    vColor = aColor;\n}\n`"
      },
      {
        "name": "PRIMITIVE_FRAGMENT",
        "kind": "variable",
        "line": 20,
        "source": "export const PRIMITIVE_FRAGMENT = `#version 300 es\nprecision mediump float;\n\nin vec4 vColor;\n\nout vec4 fragColor;\n\nvoid main() {\n    fragColor = vColor;\n}\n`"
      },
      {
        "name": "PRIMITIVE_SHADER_DEF",
        "kind": "variable",
        "line": 33,
        "source": "export const PRIMITIVE_SHADER_DEF = {\n    vertex: PRIMITIVE_VERTEX,\n    fragment: PRIMITIVE_FRAGMENT,\n    uniforms: ['uProjectionMatrix', 'uViewMatrix'],\n    attributes: ['aPosition', 'aColor']\n}"
      }
    ]
  },
  "/render/shaders/builtin/shadow_shader.doc.js": {
    "type": "module",
    "file": "/render/shaders/builtin/shadow_shader.js",
    "functions": [],
    "exports": [
      {
        "name": "SHADOW_VERTEX",
        "kind": "variable",
        "line": 1,
        "source": "export const SHADOW_VERTEX = `#version 300 es\nin vec2 aPosition;\nin vec2 aTexCoord;\nin float aOpacity;\nin float aAnchorY;\n\nuniform mat3 uProjectionMatrix;\nuniform mat3 uViewMatrix;\nuniform mat3 uModelMatrix;\n\nuniform float uShadowSkewX;\nuniform float uShadowScaleY;\nuniform float uShadowOffsetY;\n\nout vec2 vTexCoord;\nout float vOpacity;\n\nvoid main() {\n\n\n    float distFromAnchor = aPosition.y - aAnchorY;\n\n\n    vec2 shadowPos = aPosition;\n    shadowPos.x += uShadowSkewX * distFromAnchor;\n    shadowPos.y = aAnchorY + distFromAnchor * uShadowScaleY + uShadowOffsetY;\n\n    vec3 worldPos = uModelMatrix * vec3(shadowPos, 1.0);\n    vec3 viewPos = uViewMatrix * worldPos;\n    vec3 clipPos = uProjectionMatrix * viewPos;\n\n    gl_Position = vec4(clipPos.xy, 0.0, 1.0);\n    vTexCoord = aTexCoord;\n    vOpacity = aOpacity;\n}\n`"
      },
      {
        "name": "SHADOW_FRAGMENT",
        "kind": "variable",
        "line": 39,
        "source": "export const SHADOW_FRAGMENT = `#version 300 es\nprecision mediump float;\n\nuniform sampler2D uTexture;\nuniform vec4 uShadowColor;\n\nin vec2 vTexCoord;\nin float vOpacity;\n\nout vec4 fragColor;\n\nvoid main() {\n    vec4 texColor = texture(uTexture, vTexCoord);\n\n    float alpha = texColor.a * vOpacity * uShadowColor.a;\n    fragColor = vec4(uShadowColor.rgb, alpha);\n}\n`"
      },
      {
        "name": "SHADOW_SHADER_DEF",
        "kind": "variable",
        "line": 59,
        "source": "export const SHADOW_SHADER_DEF = {\n    vertex: SHADOW_VERTEX,\n    fragment: SHADOW_FRAGMENT,\n    uniforms: [\n        'uProjectionMatrix',\n        'uViewMatrix',\n        'uModelMatrix',\n        'uShadowSkewX',\n        'uShadowScaleY',\n        'uShadowOffsetY',\n        'uTexture',\n        'uShadowColor'\n    ],\n    attributes: ['aPosition', 'aTexCoord', 'aOpacity', 'aAnchorY']\n}"
      }
    ]
  },
  "/render/shaders/builtin/sprite_shader.doc.js": {
    "type": "module",
    "file": "/render/shaders/builtin/sprite_shader.js",
    "functions": [],
    "exports": [
      {
        "name": "SPRITE_VERTEX",
        "kind": "variable",
        "line": 1,
        "source": "export const SPRITE_VERTEX = `#version 300 es\nin vec2 aPosition;\nin vec2 aTexCoord;\nin float aOpacity;\nin vec4 aTintColor;\nin vec4 aEffectParams;\nin vec4 aUVBounds;\n\nuniform mat3 uProjectionMatrix;\nuniform mat3 uViewMatrix;\nuniform mat3 uModelMatrix;\n\nout vec2 vTexCoord;\nout float vOpacity;\nout vec4 vTintColor;\nout vec4 vEffectParams;\nout vec4 vUVBounds;\n\nvoid main() {\n    vec3 worldPos = uModelMatrix * vec3(aPosition, 1.0);\n    vec3 viewPos = uViewMatrix * worldPos;\n    vec3 clipPos = uProjectionMatrix * viewPos;\n\n    gl_Position = vec4(clipPos.xy, 0.0, 1.0);\n    vTexCoord = aTexCoord;\n    vOpacity = aOpacity;\n    vTintColor = aTintColor;\n    vEffectParams = aEffectParams;\n    vUVBounds = aUVBounds;\n}\n`"
      },
      {
        "name": "SPRITE_FRAGMENT",
        "kind": "variable",
        "line": 34,
        "source": "export const SPRITE_FRAGMENT = `#version 300 es\nprecision mediump float;\n\nuniform sampler2D uTexture;\nuniform vec2 uTexelSize;\n\nin vec2 vTexCoord;\nin float vOpacity;\nin vec4 vTintColor;\nin vec4 vEffectParams;\nin vec4 vUVBounds;\n\nout vec4 fragColor;\n\nvoid main() {\n    vec4 color = texture(uTexture, vTexCoord);\n\n    if (vTintColor.a > 0.0) {\n        color.rgb = mix(color.rgb, vTintColor.rgb, vTintColor.a);\n    }\n\n    fragColor = vec4(color.rgb, color.a * vOpacity);\n}\n`"
      },
      {
        "name": "SPRITE_SHADER_DEF",
        "kind": "variable",
        "line": 60,
        "source": "export const SPRITE_SHADER_DEF = {\n    vertex: SPRITE_VERTEX,\n    fragment: SPRITE_FRAGMENT,\n    uniforms: [\n        'uProjectionMatrix',\n        'uViewMatrix',\n        'uModelMatrix',\n        'uTexture',\n        'uTexelSize'\n    ],\n    attributes: ['aPosition', 'aTexCoord', 'aOpacity', 'aTintColor', 'aEffectParams', 'aUVBounds']\n}"
      }
    ]
  },
  "/render/shaders/builtin/effects/outline_effect.doc.js": {
    "type": "class",
    "file": "/render/shaders/builtin/effects/outline_effect.js",
    "name": "OutlineEffect",
    "line": 4,
    "extends": "ShaderEffect",
    "statics": [
      {
        "name": "shader",
        "line": 6,
        "source": "static shader = {\n    params: ['width'],\n    uniforms: [],\n    fragment: `\n        if (width > 0.0 && color.a < 0.5) {\n            vec2 offset = texelSize * width * 100.0;\n\n            float neighborAlpha = 0.0;\n            neighborAlpha += texture(uTexture, texCoord + vec2(-offset.x, 0.0)).a;\n            neighborAlpha += texture(uTexture, texCoord + vec2(offset.x, 0.0)).a;\n            neighborAlpha += texture(uTexture, texCoord + vec2(0.0, -offset.y)).a;\n            neighborAlpha += texture(uTexture, texCoord + vec2(0.0, offset.y)).a;\n\n            if (neighborAlpha > 0.0) {\n                color = vec4(1.0, 1.0, 1.0, 1.0);\n            }\n        }\n    `\n}",
        "kind": "property",
        "value": "{\n    params: ['width'],\n    uniforms: [],\n    fragment: `\n        if (width > 0.0 && color.a < 0.5) {\n            vec2 offset = texelSize * width * 100.0;\n\n            float neighborAlpha = 0.0;\n            neighborAlpha += texture(uTexture, texCoord + vec2(-offset.x, 0.0)).a;\n            neighborAlpha += texture(uTexture, texCoord + vec2(offset.x, 0.0)).a;\n            neighborAlpha += texture(uTexture, texCoord + vec2(0.0, -offset.y)).a;\n            neighborAlpha += texture(uTexture, texCoord + vec2(0.0, offset.y)).a;\n\n            if (neighborAlpha > 0.0) {\n                color = vec4(1.0, 1.0, 1.0, 1.0);\n            }\n        }\n    `\n}"
      }
    ],
    "methods": [],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 28,
      "source": "constructor (options = {}) {\n    super(options)\n    this.width = options.width ?? 0.02\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/render/sprite_effects/outline_effect.doc.js": {
    "type": "class",
    "file": "/render/sprite_effects/outline_effect.js",
    "name": "OutlineEffect",
    "line": 4,
    "extends": "SpriteEffect",
    "statics": [
      {
        "name": "type",
        "line": 6,
        "source": "static type = 'outline'",
        "kind": "property",
        "value": "'outline'"
      }
    ],
    "methods": [
      {
        "name": "getHints",
        "line": 43,
        "source": "getHints () {\n    return {\n        width: this.#width,\n        color: this.#color\n    }\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "width",
        "line": 23,
        "source": "get width () {\n    return this.#width\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "color",
        "line": 33,
        "source": "get color () {\n    return this.#color\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "width",
        "line": 28,
        "source": "set width (value) {\n    this.#width = value\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "color",
        "line": 38,
        "source": "set color (value) {\n    this.#color = value\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      }
    ],
    "constructor": {
      "name": "constructor",
      "line": 11,
      "source": "constructor (options = {}) {\n    super(options)\n\n    if (options.width !== undefined) {\n        this.#width = options.width\n    }\n    if (options.color !== undefined) {\n        this.#color = options.color\n    }\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/render/sprite_effects/splatter_effect.doc.js": {
    "type": "class",
    "file": "/render/sprite_effects/splatter_effect.js",
    "name": "SplatterEffect",
    "line": 4,
    "extends": "SpriteEffect",
    "statics": [
      {
        "name": "type",
        "line": 6,
        "source": "static type = 'splatter'",
        "kind": "property",
        "value": "'splatter'"
      }
    ],
    "methods": [
      {
        "name": "getHints",
        "line": 57,
        "source": "getHints () {\n    return {\n        intensity: this.#intensity,\n        pattern: this.#pattern,\n        atlas: this.#atlas\n    }\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "intensity",
        "line": 27,
        "source": "get intensity () {\n    return this.#intensity\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "pattern",
        "line": 37,
        "source": "get pattern () {\n    return this.#pattern\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "atlas",
        "line": 47,
        "source": "get atlas () {\n    return this.#atlas\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "intensity",
        "line": 32,
        "source": "set intensity (value) {\n    this.#intensity = Math.max(0, Math.min(1, value))\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "pattern",
        "line": 42,
        "source": "set pattern (value) {\n    this.#pattern = value\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "atlas",
        "line": 52,
        "source": "set atlas (value) {\n    this.#atlas = value\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      }
    ],
    "constructor": {
      "name": "constructor",
      "line": 12,
      "source": "constructor (options = {}) {\n    super(options)\n\n    if (options.intensity !== undefined) {\n        this.#intensity = options.intensity\n    }\n    if (options.pattern !== undefined) {\n        this.#pattern = options.pattern\n    }\n    if (options.atlas !== undefined) {\n        this.#atlas = options.atlas\n    }\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/render/sprite_effects/sprite_effect.doc.js": {
    "type": "class",
    "file": "/render/sprite_effects/sprite_effect.js",
    "name": "SpriteEffect",
    "line": 1,
    "extends": null,
    "statics": [
      {
        "name": "type",
        "line": 3,
        "source": "static type = 'base'",
        "kind": "property",
        "value": "'base'"
      }
    ],
    "methods": [
      {
        "name": "getHints",
        "line": 27,
        "source": "getHints () { // eslint-disable-line local/class-methods-use-this -- clean\n    return null\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "update",
        "line": 32,
        "source": "update () {\n\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "dispose",
        "line": 37,
        "source": "dispose () {\n\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "enabled",
        "line": 12,
        "source": "get enabled () {\n    return this.#enabled\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "type",
        "line": 22,
        "source": "get type () {\n    return this.constructor.type\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "enabled",
        "line": 17,
        "source": "set enabled (value) {\n    this.#enabled = value\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      }
    ],
    "constructor": {
      "name": "constructor",
      "line": 7,
      "source": "constructor (options = {}) {\n    this.#enabled = options.enabled ?? true\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/render/sprite_effects/sprite_effect_stack.doc.js": {
    "type": "class",
    "file": "/render/sprite_effects/sprite_effect_stack.js",
    "name": "SpriteEffectStack",
    "line": 4,
    "extends": null,
    "statics": [],
    "methods": [
      {
        "name": "add",
        "line": 23,
        "source": "add (effect) {\n    if (this.has(effect.constructor)) {\n        return this\n    }\n\n    this.#effects.push(effect)\n    return this\n}",
        "kind": "method",
        "params": [
          "effect"
        ]
      },
      {
        "name": "remove",
        "line": 33,
        "source": "remove (EffectClass) {\n    const index = this.#effects.findIndex(e => e.constructor === EffectClass)\n\n    if (index !== -1) {\n        const effect = this.#effects[index]\n        effect.dispose()\n        this.#effects.splice(index, 1)\n    }\n\n    return this\n}",
        "kind": "method",
        "params": [
          "EffectClass"
        ]
      },
      {
        "name": "get",
        "line": 46,
        "source": "get (EffectClass) {\n    return this.#effects.find(e => e.constructor === EffectClass) || null\n}",
        "kind": "method",
        "params": [
          "EffectClass"
        ]
      },
      {
        "name": "has",
        "line": 51,
        "source": "has (EffectClass) {\n    return this.#effects.some(e => e.constructor === EffectClass)\n}",
        "kind": "method",
        "params": [
          "EffectClass"
        ]
      },
      {
        "name": "clear",
        "line": 56,
        "source": "clear () {\n    for (const effect of this.#effects) {\n        effect.dispose()\n    }\n    this.#effects = []\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "getHints",
        "line": 65,
        "source": "getHints () {\n    const hints = {}\n\n    for (const effect of this.#effects) {\n        if (!effect.enabled) {\n            continue\n        }\n\n        const effectHints = effect.getHints()\n\n        if (effectHints) {\n            hints[effect.type] = effectHints\n        }\n    }\n\n    return Object.keys(hints).length > 0 ? hints : null\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "update",
        "line": 84,
        "source": "update (deltaTime) {\n    for (const effect of this.#effects) {\n        if (effect.enabled) {\n            effect.update(deltaTime)\n        }\n    }\n}",
        "kind": "method",
        "params": [
          "deltaTime"
        ]
      },
      {
        "name": "dispose",
        "line": 93,
        "source": "dispose () {\n    this.clear()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "getShaderEffectTypes",
        "line": 98,
        "source": "getShaderEffectTypes () {\n    const types = []\n\n    for (const effect of this.#effects) {\n        if (effect.enabled && effect instanceof ShaderEffect) {\n            types.push(effect.type)\n        }\n    }\n\n    return types\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "getShaderEffectParams",
        "line": 111,
        "source": "getShaderEffectParams () {\n    const params = [0, 0, 0, 0]\n    let offset = 0\n\n    for (const effect of this.#effects) {\n        if (!effect.enabled || !(effect instanceof ShaderEffect)) {\n            continue\n        }\n\n        const effectParams = effect.getParams()\n\n        for (let i = 0; i < effectParams.length && offset + i < 4; i++) {\n            params[offset + i] = effectParams[i]\n        }\n\n        offset += effectParams.length\n    }\n\n    return params\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "effects",
        "line": 13,
        "source": "get effects () {\n    return this.#effects\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "count",
        "line": 18,
        "source": "get count () {\n    return this.#effects.length\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 8,
      "source": "constructor () {\n    this.#effects = []\n}",
      "kind": "constructor",
      "params": []
    },
    "isDefault": true
  },
  "/render/textures/shelf_packer.doc.js": {
    "type": "class",
    "file": "/render/textures/shelf_packer.js",
    "name": "ShelfPacker",
    "line": 1,
    "extends": null,
    "statics": [],
    "methods": [
      {
        "name": "pack",
        "line": 13,
        "source": "pack (w, h) {\n    const pw = w + this.padding\n    const ph = h + this.padding\n\n    for (const shelf of this.shelves) {\n        if (shelf.height >= ph && shelf.remainingWidth >= pw) {\n            const slot = {x: shelf.x, y: shelf.y}\n            shelf.x += pw\n            shelf.remainingWidth -= pw\n            return slot\n        }\n    }\n\n    if (this.currentY + ph > this.height) {\n        this.full = true\n        return null\n    }\n\n    const shelf = {\n        y: this.currentY,\n        x: pw,\n        height: ph,\n        remainingWidth: this.width - pw\n    }\n\n    this.shelves.push(shelf)\n    this.currentY += ph\n\n    return {x: 0, y: shelf.y}\n}",
        "kind": "method",
        "params": [
          "w",
          "h"
        ]
      },
      {
        "name": "canFit",
        "line": 45,
        "source": "canFit (w, h) {\n    const pw = w + this.padding\n    const ph = h + this.padding\n\n    for (const shelf of this.shelves) {\n        if (shelf.height >= ph && shelf.remainingWidth >= pw) {\n            return true\n        }\n    }\n\n    return this.currentY + ph <= this.height\n}",
        "kind": "method",
        "params": [
          "w",
          "h"
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 3,
      "source": "constructor (width, height, padding = 1) {\n    this.width = width\n    this.height = height\n    this.padding = padding\n    this.shelves = []\n    this.currentY = 0\n    this.full = false\n}",
      "kind": "constructor",
      "params": [
        "width",
        "height",
        "padding = ..."
      ]
    },
    "isDefault": true
  },
  "/render/textures/texture_atlas.doc.js": {
    "type": "class",
    "file": "/render/textures/texture_atlas.js",
    "name": "TextureAtlas",
    "line": 10,
    "extends": null,
    "statics": [
      {
        "name": "DEFAULT_SIZE",
        "line": 118,
        "source": "static get DEFAULT_SIZE () {\n    return DEFAULT_SIZE\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "MAX_SIZE",
        "line": 123,
        "source": "static get MAX_SIZE () {\n    return MAX_SIZE\n}",
        "kind": "method",
        "params": []
      }
    ],
    "methods": [
      {
        "name": "markClean",
        "line": 49,
        "source": "markClean () {\n    this.#dirty = false\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "add",
        "line": 54,
        "source": "add (id, image) {\n    if (this.#regions.has(id)) {\n        return this.#regions.get(id)\n    }\n\n    const slot = this.#packer.pack(image.width, image.height)\n\n    if (!slot) {\n        return null\n    }\n\n    this.#ctx.drawImage(image, slot.x, slot.y)\n\n    const region = new TextureRegion({\n        image: this.#canvas,\n        x: slot.x,\n        y: slot.y,\n        width: image.width,\n        height: image.height\n    })\n\n    this.#regions.set(id, region)\n    this.#dirty = true\n\n    return region\n}",
        "kind": "method",
        "params": [
          "id",
          "image"
        ]
      },
      {
        "name": "get",
        "line": 82,
        "source": "get (id) {\n    return this.#regions.get(id) || null\n}",
        "kind": "method",
        "params": [
          "id"
        ]
      },
      {
        "name": "has",
        "line": 87,
        "source": "has (id) {\n    return this.#regions.has(id)\n}",
        "kind": "method",
        "params": [
          "id"
        ]
      },
      {
        "name": "getAllRegions",
        "line": 92,
        "source": "getAllRegions () {\n    return this.#regions\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "canFit",
        "line": 97,
        "source": "canFit (width, height) {\n    return this.#packer.canFit(width, height)\n}",
        "kind": "method",
        "params": [
          "width",
          "height"
        ]
      },
      {
        "name": "clear",
        "line": 102,
        "source": "clear () {\n    this.#ctx.clearRect(0, 0, this.width, this.height)\n    this.#packer = new ShelfPacker(this.width, this.height, this.padding)\n    this.#regions.clear()\n    this.#dirty = true\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "dispose",
        "line": 110,
        "source": "dispose () {\n    this.#canvas = null\n    this.#ctx = null\n    this.#packer = null\n    this.#regions.clear()\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "canvas",
        "line": 29,
        "source": "get canvas () {\n    return this.#canvas\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "dirty",
        "line": 34,
        "source": "get dirty () {\n    return this.#dirty\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "full",
        "line": 39,
        "source": "get full () {\n    return this.#packer.full\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "regionCount",
        "line": 44,
        "source": "get regionCount () {\n    return this.#regions.size\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 18,
      "source": "constructor (options = {}) {\n    this.width = options.width ?? DEFAULT_SIZE\n    this.height = options.height ?? DEFAULT_SIZE\n    this.padding = options.padding ?? PADDING\n\n    this.#canvas = createCanvas(this.width, this.height)\n    this.#ctx = this.#canvas.getContext('2d')\n    this.#packer = new ShelfPacker(this.width, this.height, this.padding)\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/render/textures/texture_atlas_manager.doc.js": {
    "type": "class",
    "file": "/render/textures/texture_atlas_manager.js",
    "name": "TextureAtlasManager",
    "line": 5,
    "extends": null,
    "statics": [
      {
        "name": "DEFAULT_ATLAS",
        "line": 7,
        "source": "static DEFAULT_ATLAS = Symbol('default')",
        "kind": "property",
        "value": "Symbol('default')"
      }
    ],
    "methods": [
      {
        "name": "add",
        "line": 34,
        "source": "add (id, image) {\n    if (this.#regionIndex.has(id)) {\n        return this.#regionIndex.get(id)\n    }\n\n    if (!isValidImage(image)) {\n        return null\n    }\n\n    if (isOversized(image, this.#atlasSize)) {\n        return this.#addOversizedImage(id, image)\n    }\n\n    const region = this.#addToAtlas(id, image)\n\n    if (region) {\n        this.#regionIndex.set(id, region)\n    }\n\n    return region\n}",
        "kind": "method",
        "params": [
          "id",
          "image"
        ]
      },
      {
        "name": "addBatch",
        "line": 57,
        "source": "addBatch (images) {\n    const results = new Map()\n\n    for (const [id, image] of Object.entries(images)) {\n        const region = this.add(id, image)\n        results.set(id, region)\n    }\n\n    return results\n}",
        "kind": "method",
        "params": [
          "images"
        ]
      },
      {
        "name": "addToNamedAtlas",
        "line": 69,
        "source": "addToNamedAtlas (atlasName, id, image) {\n    if (this.#regionIndex.has(id)) {\n        return this.#regionIndex.get(id)\n    }\n\n    if (!isValidImage(image)) {\n        return null\n    }\n\n    if (isOversized(image, this.#atlasSize)) {\n        return this.#addOversizedImage(id, image)\n    }\n\n    const region = this.#addToNamedAtlas(atlasName, id, image)\n\n    if (region) {\n        this.#regionIndex.set(id, region)\n    }\n\n    return region\n}",
        "kind": "method",
        "params": [
          "atlasName",
          "id",
          "image"
        ]
      },
      {
        "name": "addBatchToNamedAtlas",
        "line": 92,
        "source": "addBatchToNamedAtlas (atlasName, images) {\n    const results = new Map()\n\n    for (const [id, image] of Object.entries(images)) {\n        const region = this.addToNamedAtlas(atlasName, id, image)\n        results.set(id, region)\n    }\n\n    return results\n}",
        "kind": "method",
        "params": [
          "atlasName",
          "images"
        ]
      },
      {
        "name": "get",
        "line": 104,
        "source": "get (id) {\n    return this.#regionIndex.get(id) || null\n}",
        "kind": "method",
        "params": [
          "id"
        ]
      },
      {
        "name": "has",
        "line": 109,
        "source": "has (id) {\n    return this.#regionIndex.has(id)\n}",
        "kind": "method",
        "params": [
          "id"
        ]
      },
      {
        "name": "getDirtyAtlases",
        "line": 114,
        "source": "getDirtyAtlases () {\n    return this.#atlases.filter(atlas => atlas.dirty)\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "markAllClean",
        "line": 119,
        "source": "markAllClean () {\n    for (const atlas of this.#atlases) {\n        atlas.markClean()\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "clear",
        "line": 126,
        "source": "clear () {\n    for (const atlas of this.#atlases) {\n        atlas.dispose()\n    }\n    this.#atlases = []\n    this.#atlasGroups.clear()\n    this.#regionIndex.clear()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "dispose",
        "line": 136,
        "source": "dispose () {\n    this.clear()\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "atlases",
        "line": 19,
        "source": "get atlases () {\n    return this.#atlases\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "atlasCount",
        "line": 24,
        "source": "get atlasCount () {\n    return this.#atlases.length\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "regionCount",
        "line": 29,
        "source": "get regionCount () {\n    return this.#regionIndex.size\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 14,
      "source": "constructor (options = {}) {\n    this.#atlasSize = options.atlasSize ?? TextureAtlas.DEFAULT_SIZE\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/render/textures/texture_region.doc.js": {
    "type": "class",
    "file": "/render/textures/texture_region.js",
    "name": "TextureRegion",
    "line": 1,
    "extends": null,
    "statics": [
      {
        "name": "fromImage",
        "line": 69,
        "source": "static fromImage (image) {\n    return new TextureRegion({\n        image,\n        x: 0,\n        y: 0,\n        width: image?.width || 0,\n        height: image?.height || 0\n    })\n}",
        "kind": "method",
        "params": [
          "image"
        ]
      },
      {
        "name": "fromFrame",
        "line": 80,
        "source": "static fromFrame (image, frame) {\n    return new TextureRegion({\n        image,\n        x: frame.x,\n        y: frame.y,\n        width: frame.w ?? frame.width,\n        height: frame.h ?? frame.height\n    })\n}",
        "kind": "method",
        "params": [
          "image",
          "frame"
        ]
      }
    ],
    "methods": [],
    "getters": [
      {
        "name": "u0",
        "line": 12,
        "source": "get u0 () {\n    if (!this.image || !this.image.width) {\n        return 0\n    }\n    return this.x / this.image.width\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "v0",
        "line": 20,
        "source": "get v0 () {\n    if (!this.image || !this.image.height) {\n        return 0\n    }\n    return this.y / this.image.height\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "u1",
        "line": 28,
        "source": "get u1 () {\n    if (!this.image || !this.image.width) {\n        return 1\n    }\n    return (this.x + this.width) / this.image.width\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "v1",
        "line": 36,
        "source": "get v1 () {\n    if (!this.image || !this.image.height) {\n        return 1\n    }\n    return (this.y + this.height) / this.image.height\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "uvs",
        "line": 44,
        "source": "get uvs () {\n    return {\n        u0: this.u0,\n        v0: this.v0,\n        u1: this.u1,\n        v1: this.v1\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "bounds",
        "line": 54,
        "source": "get bounds () {\n    return {\n        x: this.x,\n        y: this.y,\n        width: this.width,\n        height: this.height\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "valid",
        "line": 64,
        "source": "get valid () {\n    return this.image !== null && this.width > 0 && this.height > 0\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 3,
      "source": "constructor (options = {}) {\n    this.image = options.image || null\n    this.x = options.x ?? 0\n    this.y = options.y ?? 0\n    this.width = options.width ?? getImageWidth(this.image)\n    this.height = options.height ?? getImageHeight(this.image)\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/render/textures/texture_system.doc.js": {
    "type": "class",
    "file": "/render/textures/texture_system.js",
    "name": "TextureSystem",
    "line": 7,
    "extends": "PerkyModule",
    "statics": [
      {
        "name": "$category",
        "line": 9,
        "source": "static $category = 'textureSystem'",
        "kind": "property",
        "value": "'textureSystem'"
      }
    ],
    "methods": [
      {
        "name": "onInstall",
        "line": 24,
        "source": "onInstall (host) {\n    this.delegateTo(host, [\n        'getRegion',\n        'hasRegion',\n        'addRegion',\n        'addRegions',\n        'registerManualAtlas',\n        'getSpritesheet',\n        'registerSpritesheet'\n    ])\n}",
        "kind": "method",
        "params": [
          "host"
        ]
      },
      {
        "name": "getRegion",
        "line": 52,
        "source": "getRegion (id) {\n    const region = this.#manualRegions.get(id) || this.#atlasManager.get(id)\n    if (region) {\n        return region\n    }\n\n    const source = this.fallback?.(id)\n    if (source) {\n        return TextureRegion.fromImage(source)\n    }\n\n    return null\n}",
        "kind": "method",
        "params": [
          "id"
        ]
      },
      {
        "name": "hasRegion",
        "line": 67,
        "source": "hasRegion (id) {\n    return this.#manualRegions.has(id) || this.#atlasManager.has(id)\n}",
        "kind": "method",
        "params": [
          "id"
        ]
      },
      {
        "name": "addRegion",
        "line": 72,
        "source": "addRegion (id, image) {\n    if (this.hasRegion(id)) {\n        return this.getRegion(id)\n    }\n\n    return this.#atlasManager.add(id, image)\n}",
        "kind": "method",
        "params": [
          "id",
          "image"
        ]
      },
      {
        "name": "addRegions",
        "line": 81,
        "source": "addRegions (images) {\n    return this.#atlasManager.addBatch(images)\n}",
        "kind": "method",
        "params": [
          "images"
        ]
      },
      {
        "name": "registerManualAtlas",
        "line": 86,
        "source": "registerManualAtlas (id, image, frames) {\n    for (const [frameName, frameData] of Object.entries(frames)) {\n        const regionId = `${id}:${frameName}`\n        const region = TextureRegion.fromFrame(image, frameData)\n        this.#manualRegions.set(regionId, region)\n    }\n}",
        "kind": "method",
        "params": [
          "id",
          "image",
          "frames"
        ]
      },
      {
        "name": "registerSpritesheet",
        "line": 95,
        "source": "registerSpritesheet (id, source) {\n    const spritesheet = new Spritesheet(source)\n    this.#spritesheets.set(id, spritesheet)\n    return spritesheet\n}",
        "kind": "method",
        "params": [
          "id",
          "source"
        ]
      },
      {
        "name": "getSpritesheet",
        "line": 102,
        "source": "getSpritesheet (id) {\n    return this.#spritesheets.get(id) || null\n}",
        "kind": "method",
        "params": [
          "id"
        ]
      },
      {
        "name": "addFromAsset",
        "line": 107,
        "source": "addFromAsset (asset) {\n    if (!isImageAsset(asset) || !asset.source) {\n        return null\n    }\n\n    if (this.hasRegion(asset.id)) {\n        return this.getRegion(asset.id)\n    }\n\n    if (asset.config?.atlas === false) {\n        const region = TextureRegion.fromImage(asset.source)\n        this.#manualRegions.set(asset.id, region)\n        return region\n    }\n\n    return this.addRegion(asset.id, asset.source)\n}",
        "kind": "method",
        "params": [
          "asset"
        ]
      },
      {
        "name": "buildFromAssets",
        "line": 126,
        "source": "buildFromAssets (assets) {\n    const atlasGroups = new Map()\n    const defaultImages = {}\n\n    for (const asset of assets) {\n        if (!isImageAsset(asset) || !asset.source) {\n            continue\n        }\n\n        const atlasName = asset.config?.atlas\n        if (atlasName === false) {\n\n            this.#manualRegions.set(asset.id, TextureRegion.fromImage(asset.source))\n        } else if (atlasName) {\n\n            if (!atlasGroups.has(atlasName)) {\n                atlasGroups.set(atlasName, {})\n            }\n            atlasGroups.get(atlasName)[asset.id] = asset.source\n        } else {\n\n            defaultImages[asset.id] = asset.source\n        }\n    }\n\n\n    for (const [atlasName, images] of atlasGroups) {\n        this.#atlasManager.addBatchToNamedAtlas(atlasName, images)\n    }\n\n\n    return this.addRegions(defaultImages)\n}",
        "kind": "method",
        "params": [
          "assets"
        ]
      },
      {
        "name": "getDirtyAtlases",
        "line": 161,
        "source": "getDirtyAtlases () {\n    return this.#atlasManager.getDirtyAtlases()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "markAllClean",
        "line": 166,
        "source": "markAllClean () {\n    this.#atlasManager.markAllClean()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "clear",
        "line": 171,
        "source": "clear () {\n    this.#atlasManager.clear()\n    this.#manualRegions.clear()\n    this.#spritesheets.clear()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "onDispose",
        "line": 178,
        "source": "onDispose () {\n    this.clear()\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "atlasManager",
        "line": 37,
        "source": "get atlasManager () {\n    return this.#atlasManager\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "atlases",
        "line": 42,
        "source": "get atlases () {\n    return this.#atlasManager.atlases\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "regionCount",
        "line": 47,
        "source": "get regionCount () {\n    return this.#atlasManager.regionCount + this.#manualRegions.size\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 15,
      "source": "constructor (options = {}) {\n    super(options)\n    this.#atlasManager = new TextureAtlasManager({\n        atlasSize: options.atlasSize\n    })\n    this.fallback = options.fallback ?? null\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/render/transforms/shadow_transform.doc.js": {
    "type": "class",
    "file": "/render/transforms/shadow_transform.js",
    "name": "ShadowTransform",
    "line": 5,
    "extends": "RenderTransform",
    "statics": [
      {
        "name": "propertyConfig",
        "line": 41,
        "source": "static propertyConfig = {\n    skewX: {min: -2, max: 2, step: 0.05},\n    scaleY: {min: -1, max: 0, step: 0.05},\n    offsetY: {min: -0.5, max: 0.5, step: 0.01},\n    color: {type: 'color'}\n}",
        "kind": "property",
        "value": "{\n    skewX: {min: -2, max: 2, step: 0.05},\n    scaleY: {min: -1, max: 0, step: 0.05},\n    offsetY: {min: -0.5, max: 0.5, step: 0.01},\n    color: {type: 'color'}\n}"
      }
    ],
    "methods": [
      {
        "name": "init",
        "line": 19,
        "source": "init (context) {\n    this.#program = context.shaderRegistry.register('shadow', SHADOW_SHADER_DEF)\n}",
        "kind": "method",
        "params": [
          "context"
        ]
      },
      {
        "name": "getProgram",
        "line": 24,
        "source": "getProgram () {\n    return this.#program\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "applyUniforms",
        "line": 29,
        "source": "applyUniforms (gl, program) {\n    gl.uniform1f(program.uniforms.uShadowSkewX, this.skewX)\n    gl.uniform1f(program.uniforms.uShadowScaleY, this.scaleY)\n    gl.uniform1f(program.uniforms.uShadowOffsetY, this.offsetY)\n    gl.uniform4fv(program.uniforms.uShadowColor, this.color)\n}",
        "kind": "method",
        "params": [
          "gl",
          "program"
        ]
      },
      {
        "name": "getPropertyConfig",
        "line": 37,
        "source": "getPropertyConfig () {\n    return this.constructor.propertyConfig\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "dispose",
        "line": 48,
        "source": "dispose () {\n    this.#program = null\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 9,
      "source": "constructor (options = {}) {\n    super(options)\n\n    this.skewX = options.skewX ?? 0.5\n    this.scaleY = options.scaleY ?? -0.3\n    this.offsetY = options.offsetY ?? 0\n    this.color = options.color ?? [0, 0, 0, 0.4]\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/render/webgl/color_utils.doc.js": {
    "type": "module",
    "file": "/render/webgl/color_utils.js",
    "functions": [
      {
        "name": "parseColor",
        "line": 1,
        "params": [
          "colorString"
        ],
        "source": "function parseColor (colorString) {\n    if (colorString.startsWith('#')) {\n        const hex = colorString.substring(1)\n        const r = parseInt(hex.substring(0, 2), 16) / 255\n        const g = parseInt(hex.substring(2, 4), 16) / 255\n        const b = parseInt(hex.substring(4, 6), 16) / 255\n        return {r, g, b, a: 1}\n    }\n\n    if (colorString.startsWith('hsl')) {\n        const match = colorString.match(/hsl\\(\\s*(\\d+)\\s*,\\s*(\\d+)%?\\s*,\\s*(\\d+)%?\\s*\\)/)\n        if (match) {\n            const h = parseInt(match[1], 10) / 360\n            const s = parseInt(match[2], 10) / 100\n            const l = parseInt(match[3], 10) / 100\n            const {r, g, b} = hslToRgb(h, s, l)\n            return {r, g, b, a: 1}\n        }\n    }\n\n    return {r: 0, g: 0, b: 0, a: 1}\n}"
      },
      {
        "name": "hslToRgb",
        "line": 25,
        "params": [
          "h",
          "s",
          "l"
        ],
        "source": "function hslToRgb (h, s, l) {\n    if (s === 0) {\n        return {r: l, g: l, b: l}\n    }\n\n    const q = l < 0.5 ? l * (1 + s) : l + s - l * s\n    const p = 2 * l - q\n\n    return {\n        r: hueToRgb(p, q, h + 1 / 3),\n        g: hueToRgb(p, q, h),\n        b: hueToRgb(p, q, h - 1 / 3)\n    }\n}"
      },
      {
        "name": "hueToRgb",
        "line": 41,
        "params": [
          "p",
          "q",
          "t"
        ],
        "source": "function hueToRgb (p, q, t) {\n    if (t < 0) {\n        t += 1\n    }\n    if (t > 1) {\n        t -= 1\n    }\n    if (t < 1 / 6) {\n        return p + (q - p) * 6 * t\n    }\n    if (t < 1 / 2) {\n        return q\n    }\n    if (t < 2 / 3) {\n        return p + (q - p) * (2 / 3 - t) * 6\n    }\n    return p\n}"
      }
    ],
    "exports": []
  },
  "/render/webgl/webgl_circle_renderer.doc.js": {
    "type": "class",
    "file": "/render/webgl/webgl_circle_renderer.js",
    "name": "WebGLCircleRenderer",
    "line": 6,
    "extends": "WebGLPrimitiveRenderer",
    "statics": [
      {
        "name": "handles",
        "line": 8,
        "source": "static get handles () {\n    return [Circle]\n}",
        "kind": "method",
        "params": []
      }
    ],
    "methods": [
      {
        "name": "renderObject",
        "line": 13,
        "source": "renderObject (circle, opacity) {\n    const gl = this.gl\n    const program = this.context.primitiveProgram\n    const segments = 32\n    const radius = circle.radius\n    const offsetX = -radius * 2 * circle.anchorX + radius\n    const offsetY = -radius * 2 * circle.anchorY + radius\n\n    const color = parseColor(circle.color)\n    const m = circle.worldMatrix\n\n    const vertices = []\n\n    const centerX = m[0] * offsetX + m[2] * offsetY + m[4]\n    const centerY = m[1] * offsetX + m[3] * offsetY + m[5]\n    vertices.push(centerX, centerY, color.r, color.g, color.b, opacity)\n\n    for (let i = 0; i <= segments; i++) {\n        const angle = (i / segments) * Math.PI * 2\n        const x = offsetX + Math.cos(angle) * radius\n        const y = offsetY + Math.sin(angle) * radius\n\n        const worldX = m[0] * x + m[2] * y + m[4]\n        const worldY = m[1] * x + m[3] * y + m[5]\n\n        vertices.push(worldX, worldY, color.r, color.g, color.b, opacity)\n    }\n\n    const vertexData = new Float32Array(vertices)\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer)\n    gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.DYNAMIC_DRAW)\n\n    const stride = 6 * 4\n    gl.enableVertexAttribArray(program.attributes.aPosition)\n    gl.vertexAttribPointer(program.attributes.aPosition, 2, gl.FLOAT, false, stride, 0)\n\n    gl.enableVertexAttribArray(program.attributes.aColor)\n    gl.vertexAttribPointer(program.attributes.aColor, 4, gl.FLOAT, false, stride, 2 * 4)\n\n    gl.drawArrays(gl.TRIANGLE_FAN, 0, segments + 2)\n}",
        "kind": "method",
        "params": [
          "circle",
          "opacity"
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": null,
    "isDefault": true
  },
  "/render/webgl/webgl_debug_gizmo_renderer.doc.js": {
    "type": "class",
    "file": "/render/webgl/webgl_debug_gizmo_renderer.js",
    "name": "WebGLDebugGizmoRenderer",
    "line": 4,
    "extends": "WebGLObjectRenderer",
    "statics": [
      {
        "name": "handles",
        "line": 9,
        "source": "static get handles () {\n    return []\n}",
        "kind": "method",
        "params": []
      }
    ],
    "methods": [
      {
        "name": "init",
        "line": 14,
        "source": "init (context) {\n    super.init(context)\n    this.#vertexBuffer = context.gl.createBuffer()\n}",
        "kind": "method",
        "params": [
          "context"
        ]
      },
      {
        "name": "reset",
        "line": 20,
        "source": "reset () {\n    super.reset()\n    this.#gizmoObjects = []\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "collectGizmo",
        "line": 26,
        "source": "collectGizmo (object, opacity) {\n    this.#gizmoObjects.push({object, opacity})\n}",
        "kind": "method",
        "params": [
          "object",
          "opacity"
        ]
      },
      {
        "name": "flush",
        "line": 31,
        "source": "flush (matrices) {\n    if (this.#gizmoObjects.length === 0) {\n        return\n    }\n\n    const gl = this.gl\n    const program = this.context.primitiveProgram\n\n    gl.useProgram(program.program)\n    gl.uniformMatrix3fv(program.uniforms.uProjectionMatrix, false, matrices.projectionMatrix)\n    gl.uniformMatrix3fv(program.uniforms.uViewMatrix, false, matrices.viewMatrix)\n\n    for (const {object, opacity} of this.#gizmoObjects) {\n        this.renderGizmos(object, opacity)\n    }\n}",
        "kind": "method",
        "params": [
          "matrices"
        ]
      },
      {
        "name": "renderGizmos",
        "line": 49,
        "source": "renderGizmos (object, opacity) {\n    const gizmos = object.debugGizmos\n    if (!gizmos) {\n        return\n    }\n\n    const bounds = object.getBounds()\n    const hasSize = bounds.width > 0 || bounds.height > 0\n    const m = object.worldMatrix\n\n    if (gizmos.bounds && hasSize) {\n        this.renderBounds(m, bounds, opacity)\n    }\n\n    if (gizmos.anchor) {\n        this.renderAnchor(m, object, bounds, opacity)\n    }\n\n    if (gizmos.pivot) {\n        this.renderPivot(m, object, opacity)\n    }\n\n    if (gizmos.origin) {\n        this.renderOrigin(m, opacity)\n    }\n}",
        "kind": "method",
        "params": [
          "object",
          "opacity"
        ]
      },
      {
        "name": "renderBounds",
        "line": 77,
        "source": "renderBounds (m, bounds, opacity) {\n    const corners = [\n        {x: bounds.minX, y: bounds.minY},\n        {x: bounds.maxX, y: bounds.minY},\n        {x: bounds.maxX, y: bounds.maxY},\n        {x: bounds.minX, y: bounds.maxY}\n    ]\n\n    const transformed = corners.map(p => ({\n        x: m[0] * p.x + m[2] * p.y + m[4],\n        y: m[1] * p.x + m[3] * p.y + m[5]\n    }))\n\n    const vertices = []\n    const color = {r: 0, g: 1, b: 0}\n\n    for (let i = 0; i < 4; i++) {\n        const p1 = transformed[i]\n        const p2 = transformed[(i + 1) % 4]\n        vertices.push(p1.x, p1.y, color.r, color.g, color.b, opacity * 0.8)\n        vertices.push(p2.x, p2.y, color.r, color.g, color.b, opacity * 0.8)\n    }\n\n    this.drawLines(vertices)\n}",
        "kind": "method",
        "params": [
          "m",
          "bounds",
          "opacity"
        ]
      },
      {
        "name": "renderAnchor",
        "line": 104,
        "source": "renderAnchor (m, object, bounds, opacity) {\n    const anchorX = bounds.minX + object.anchorX * bounds.width\n    const anchorY = bounds.minY + object.anchorY * bounds.height\n\n    const worldX = m[0] * anchorX + m[2] * anchorY + m[4]\n    const worldY = m[1] * anchorX + m[3] * anchorY + m[5]\n\n    const size = 0.08\n    const color = {r: 1, g: 1, b: 0}\n\n    const vertices = [\n        worldX - size, worldY, color.r, color.g, color.b, opacity,\n        worldX + size, worldY, color.r, color.g, color.b, opacity,\n        worldX, worldY - size, color.r, color.g, color.b, opacity,\n        worldX, worldY + size, color.r, color.g, color.b, opacity\n    ]\n\n    this.drawLines(vertices)\n    this.drawCircle({x: worldX, y: worldY, radius: size * 0.5, color, opacity: opacity * 0.5, segments: 12})\n}",
        "kind": "method",
        "params": [
          "m",
          "object",
          "bounds",
          "opacity"
        ]
      },
      {
        "name": "renderPivot",
        "line": 126,
        "source": "renderPivot (m, object, opacity) {\n    const pivotX = object.pivotX\n    const pivotY = object.pivotY\n\n    const worldX = m[0] * pivotX + m[2] * pivotY + m[4]\n    const worldY = m[1] * pivotX + m[3] * pivotY + m[5]\n\n    const size = 0.06\n    const color = {r: 1, g: 0, b: 1}\n\n    const vertices = [\n        worldX - size * 1.5, worldY, color.r, color.g, color.b, opacity,\n        worldX + size * 1.5, worldY, color.r, color.g, color.b, opacity,\n        worldX, worldY - size * 1.5, color.r, color.g, color.b, opacity,\n        worldX, worldY + size * 1.5, color.r, color.g, color.b, opacity\n    ]\n\n    this.drawLines(vertices)\n    this.drawCircleOutline({x: worldX, y: worldY, radius: size, color, opacity, segments: 16})\n}",
        "kind": "method",
        "params": [
          "m",
          "object",
          "opacity"
        ]
      },
      {
        "name": "renderOrigin",
        "line": 148,
        "source": "renderOrigin (m, opacity) {\n    const originX = m[4]\n    const originY = m[5]\n\n    const size = 0.1\n    const scaleX = Math.sqrt(m[0] * m[0] + m[1] * m[1])\n    const scaleY = Math.sqrt(m[2] * m[2] + m[3] * m[3])\n\n    const xAxisX = originX + (m[0] / scaleX) * size * 2\n    const xAxisY = originY + (m[1] / scaleX) * size * 2\n    const yAxisX = originX + (m[2] / scaleY) * size * 2\n    const yAxisY = originY + (m[3] / scaleY) * size * 2\n\n    const vertices = [\n        originX, originY, 1, 0, 0, opacity,\n        xAxisX, xAxisY, 1, 0, 0, opacity,\n        originX, originY, 0, 1, 0, opacity,\n        yAxisX, yAxisY, 0, 1, 0, opacity\n    ]\n\n    this.drawLines(vertices)\n    this.drawCircle({x: originX, y: originY, radius: 0.03, color: {r: 1, g: 1, b: 1}, opacity, segments: 8})\n}",
        "kind": "method",
        "params": [
          "m",
          "opacity"
        ]
      },
      {
        "name": "drawLines",
        "line": 173,
        "source": "drawLines (vertices) {\n    const gl = this.gl\n    const program = this.context.primitiveProgram\n\n    const vertexData = new Float32Array(vertices)\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.#vertexBuffer)\n    gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.DYNAMIC_DRAW)\n\n    const stride = 6 * 4\n    gl.enableVertexAttribArray(program.attributes.aPosition)\n    gl.vertexAttribPointer(program.attributes.aPosition, 2, gl.FLOAT, false, stride, 0)\n\n    gl.enableVertexAttribArray(program.attributes.aColor)\n    gl.vertexAttribPointer(program.attributes.aColor, 4, gl.FLOAT, false, stride, 2 * 4)\n\n    gl.drawArrays(gl.LINES, 0, vertices.length / 6)\n}",
        "kind": "method",
        "params": [
          "vertices"
        ]
      },
      {
        "name": "drawCircle",
        "line": 193,
        "source": "drawCircle (options) {\n    const {x: cx, y: cy, radius, color, opacity, segments} = options\n    const gl = this.gl\n    const program = this.context.primitiveProgram\n\n    const vertices = [cx, cy, color.r, color.g, color.b, opacity]\n\n    for (let i = 0; i <= segments; i++) {\n        const angle = (i / segments) * Math.PI * 2\n        const x = cx + Math.cos(angle) * radius\n        const y = cy + Math.sin(angle) * radius\n        vertices.push(x, y, color.r, color.g, color.b, opacity)\n    }\n\n    const vertexData = new Float32Array(vertices)\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.#vertexBuffer)\n    gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.DYNAMIC_DRAW)\n\n    const stride = 6 * 4\n    gl.enableVertexAttribArray(program.attributes.aPosition)\n    gl.vertexAttribPointer(program.attributes.aPosition, 2, gl.FLOAT, false, stride, 0)\n\n    gl.enableVertexAttribArray(program.attributes.aColor)\n    gl.vertexAttribPointer(program.attributes.aColor, 4, gl.FLOAT, false, stride, 2 * 4)\n\n    gl.drawArrays(gl.TRIANGLE_FAN, 0, segments + 2)\n}",
        "kind": "method",
        "params": [
          "options"
        ]
      },
      {
        "name": "drawCircleOutline",
        "line": 223,
        "source": "drawCircleOutline (options) {\n    const {x: cx, y: cy, radius, color, opacity, segments} = options\n    const vertices = []\n\n    for (let i = 0; i < segments; i++) {\n        const angle1 = (i / segments) * Math.PI * 2\n        const angle2 = ((i + 1) / segments) * Math.PI * 2\n\n        const x1 = cx + Math.cos(angle1) * radius\n        const y1 = cy + Math.sin(angle1) * radius\n        const x2 = cx + Math.cos(angle2) * radius\n        const y2 = cy + Math.sin(angle2) * radius\n\n        vertices.push(x1, y1, color.r, color.g, color.b, opacity)\n        vertices.push(x2, y2, color.r, color.g, color.b, opacity)\n    }\n\n    this.drawLines(vertices)\n}",
        "kind": "method",
        "params": [
          "options"
        ]
      },
      {
        "name": "dispose",
        "line": 244,
        "source": "dispose () {\n    if (this.#vertexBuffer) {\n        this.gl.deleteBuffer(this.#vertexBuffer)\n        this.#vertexBuffer = null\n    }\n    this.#gizmoObjects = []\n    super.dispose()\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": null,
    "isDefault": true
  },
  "/render/webgl/webgl_object_renderer.doc.js": {
    "type": "class",
    "file": "/render/webgl/webgl_object_renderer.js",
    "name": "WebGLObjectRenderer",
    "line": 1,
    "extends": null,
    "statics": [
      {
        "name": "handles",
        "line": 7,
        "source": "static get handles () {\n    return []\n}",
        "kind": "method",
        "params": []
      }
    ],
    "methods": [
      {
        "name": "init",
        "line": 22,
        "source": "init (context) {\n    this.#gl = context.gl\n    this.#context = context\n}",
        "kind": "method",
        "params": [
          "context"
        ]
      },
      {
        "name": "reset",
        "line": 28,
        "source": "reset () {\n    this.#collected = []\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "collect",
        "line": 33,
        "source": "collect (object, opacity, hints = null) {\n    this.#collected.push({object, opacity, hints})\n}",
        "kind": "method",
        "params": [
          "object",
          "opacity",
          "hints = ..."
        ]
      },
      {
        "name": "flush",
        "line": 43,
        "source": "flush () {\n\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "dispose",
        "line": 48,
        "source": "dispose () {\n    this.#collected = []\n    this.#gl = null\n    this.#context = null\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "gl",
        "line": 12,
        "source": "get gl () {\n    return this.#gl\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "context",
        "line": 17,
        "source": "get context () {\n    return this.#context\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "collected",
        "line": 38,
        "source": "get collected () {\n    return this.#collected\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [],
    "constructor": null,
    "isDefault": true
  },
  "/render/webgl/webgl_primitive_renderer.doc.js": {
    "type": "class",
    "file": "/render/webgl/webgl_primitive_renderer.js",
    "name": "WebGLPrimitiveRenderer",
    "line": 4,
    "extends": "WebGLObjectRenderer",
    "statics": [],
    "methods": [
      {
        "name": "init",
        "line": 13,
        "source": "init (context) {\n    super.init(context)\n    this.#vertexBuffer = context.gl.createBuffer()\n}",
        "kind": "method",
        "params": [
          "context"
        ]
      },
      {
        "name": "flush",
        "line": 19,
        "source": "flush (matrices) {\n    if (this.collected.length === 0) {\n        return\n    }\n\n    const gl = this.gl\n    const program = this.context.primitiveProgram\n\n    gl.useProgram(program.program)\n    gl.uniformMatrix3fv(program.uniforms.uProjectionMatrix, false, matrices.projectionMatrix)\n    gl.uniformMatrix3fv(program.uniforms.uViewMatrix, false, matrices.viewMatrix)\n\n    for (const {object, opacity} of this.collected) {\n        this.renderObject(object, opacity)\n    }\n}",
        "kind": "method",
        "params": [
          "matrices"
        ]
      },
      {
        "name": "renderObject",
        "line": 37,
        "source": "renderObject () {\n\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "dispose",
        "line": 42,
        "source": "dispose () {\n    if (this.#vertexBuffer) {\n        this.gl.deleteBuffer(this.#vertexBuffer)\n        this.#vertexBuffer = null\n    }\n    super.dispose()\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "vertexBuffer",
        "line": 8,
        "source": "get vertexBuffer () {\n    return this.#vertexBuffer\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [],
    "constructor": null,
    "isDefault": true
  },
  "/render/webgl/webgl_rectangle_renderer.doc.js": {
    "type": "class",
    "file": "/render/webgl/webgl_rectangle_renderer.js",
    "name": "WebGLRectangleRenderer",
    "line": 6,
    "extends": "WebGLPrimitiveRenderer",
    "statics": [
      {
        "name": "handles",
        "line": 8,
        "source": "static get handles () {\n    return [Rectangle]\n}",
        "kind": "method",
        "params": []
      }
    ],
    "methods": [
      {
        "name": "renderObject",
        "line": 13,
        "source": "renderObject (rect, opacity) {\n    const gl = this.gl\n    const program = this.context.primitiveProgram\n\n    const offsetX = -rect.width * rect.anchorX\n    const offsetY = -rect.height * rect.anchorY\n    const m = rect.worldMatrix\n\n    const corners = [\n        {x: offsetX, y: offsetY},\n        {x: offsetX + rect.width, y: offsetY},\n        {x: offsetX + rect.width, y: offsetY + rect.height},\n        {x: offsetX, y: offsetY + rect.height}\n    ]\n\n    const worldCorners = corners.map(corner => ({\n        x: m[0] * corner.x + m[2] * corner.y + m[4],\n        y: m[1] * corner.x + m[3] * corner.y + m[5]\n    }))\n\n    if (rect.color && rect.color !== 'transparent') {\n        const color = parseColor(rect.color)\n        const vertices = []\n\n        for (const wc of worldCorners) {\n            vertices.push(wc.x, wc.y, color.r, color.g, color.b, opacity)\n        }\n\n        const vertexData = new Float32Array(vertices)\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer)\n        gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.DYNAMIC_DRAW)\n\n        const stride = 6 * 4\n        gl.enableVertexAttribArray(program.attributes.aPosition)\n        gl.vertexAttribPointer(program.attributes.aPosition, 2, gl.FLOAT, false, stride, 0)\n\n        gl.enableVertexAttribArray(program.attributes.aColor)\n        gl.vertexAttribPointer(program.attributes.aColor, 4, gl.FLOAT, false, stride, 2 * 4)\n\n        gl.drawArrays(gl.TRIANGLE_FAN, 0, 4)\n    }\n\n    if (rect.strokeWidth > 0) {\n        const strokeColor = parseColor(rect.strokeColor)\n        const vertices = []\n\n        for (let i = 0; i < 4; i++) {\n            const start = worldCorners[i]\n            const end = worldCorners[(i + 1) % 4]\n            vertices.push(\n                start.x, start.y, strokeColor.r, strokeColor.g, strokeColor.b, opacity,\n                end.x, end.y, strokeColor.r, strokeColor.g, strokeColor.b, opacity\n            )\n        }\n\n        const vertexData = new Float32Array(vertices)\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer)\n        gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.DYNAMIC_DRAW)\n\n        const stride = 6 * 4\n        gl.enableVertexAttribArray(program.attributes.aPosition)\n        gl.vertexAttribPointer(program.attributes.aPosition, 2, gl.FLOAT, false, stride, 0)\n\n        gl.enableVertexAttribArray(program.attributes.aColor)\n        gl.vertexAttribPointer(program.attributes.aColor, 4, gl.FLOAT, false, stride, 2 * 4)\n\n        gl.lineWidth(rect.strokeWidth)\n        gl.drawArrays(gl.LINES, 0, 8)\n    }\n}",
        "kind": "method",
        "params": [
          "rect",
          "opacity"
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": null,
    "isDefault": true
  },
  "/render/webgl/webgl_sprite_batch.doc.js": {
    "type": "class",
    "file": "/render/webgl/webgl_sprite_batch.js",
    "name": "WebGLSpriteBatch",
    "line": 8,
    "extends": null,
    "statics": [],
    "methods": [
      {
        "name": "begin",
        "line": 50,
        "source": "begin (program = null) {\n    this.spriteCount = 0\n    this.vertexIndex = 0\n    this.currentTexture = null\n    this.activeProgram = program\n}",
        "kind": "method",
        "params": [
          "program = ..."
        ]
      },
      {
        "name": "addSprite",
        "line": 106,
        "source": "addSprite (object, effectiveOpacity, hints = null) {\n    const region = object.region\n    const image = region?.image\n    const texture = getValidTexture(image, this.textureManager)\n\n    if (!texture) {\n        return\n    }\n\n    this.#ensureTexture(texture)\n\n    if (image) {\n        this.currentTextureSize.width = image.width || 1\n        this.currentTextureSize.height = image.height || 1\n    }\n\n    const corners = this.#tempCorners\n    const texCoords = this.#tempTexCoords\n    const bounds = object.getBounds()\n\n    transformCorners(object.worldMatrix, bounds, corners)\n    computeTexCoords(region, texCoords)\n\n    const localAnchorX = bounds.minX + object.anchorX * bounds.width\n    const localAnchorY = bounds.minY + object.anchorY * bounds.height\n    const m = object.worldMatrix\n    const worldAnchorY = m[1] * localAnchorX + m[3] * localAnchorY + m[5]\n\n    const uvBounds = region ? [region.uvs.u0, region.uvs.v0, region.uvs.u1, region.uvs.v1] : null\n\n    this.#writeVertices({\n        corners,\n        texCoords,\n        opacity: effectiveOpacity,\n        hints,\n        anchorY: worldAnchorY,\n        uvBounds\n    })\n}",
        "kind": "method",
        "params": [
          "object",
          "effectiveOpacity",
          "hints = ..."
        ]
      },
      {
        "name": "flush",
        "line": 147,
        "source": "flush (alternateProgram = null) {\n    if (this.spriteCount === 0) {\n        return\n    }\n\n    const gl = this.gl\n    const program = alternateProgram || this.activeProgram || this.spriteProgram\n\n    gl.useProgram(program.program)\n\n    gl.activeTexture(gl.TEXTURE0)\n    gl.bindTexture(gl.TEXTURE_2D, this.currentTexture)\n    gl.uniform1i(program.uniforms.uTexture, 0)\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer)\n    gl.bufferData(gl.ARRAY_BUFFER, this.vertexData.subarray(0, this.vertexIndex), gl.DYNAMIC_DRAW)\n\n    const stride = FLOATS_PER_VERTEX * 4\n\n    gl.enableVertexAttribArray(program.attributes.aPosition)\n    gl.vertexAttribPointer(program.attributes.aPosition, 2, gl.FLOAT, false, stride, 0)\n\n    gl.enableVertexAttribArray(program.attributes.aTexCoord)\n    gl.vertexAttribPointer(program.attributes.aTexCoord, 2, gl.FLOAT, false, stride, 2 * 4)\n\n    gl.enableVertexAttribArray(program.attributes.aOpacity)\n    gl.vertexAttribPointer(program.attributes.aOpacity, 1, gl.FLOAT, false, stride, 4 * 4)\n\n    this.#bindOptionalAttributes(program, stride)\n\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer)\n    gl.drawElements(gl.TRIANGLES, this.spriteCount * 6, gl.UNSIGNED_SHORT, 0)\n\n    this.spriteCount = 0\n    this.vertexIndex = 0\n}",
        "kind": "method",
        "params": [
          "alternateProgram = ..."
        ]
      },
      {
        "name": "end",
        "line": 206,
        "source": "end (alternateProgram = null) {\n    this.flush(alternateProgram)\n}",
        "kind": "method",
        "params": [
          "alternateProgram = ..."
        ]
      },
      {
        "name": "dispose",
        "line": 211,
        "source": "dispose () {\n    const gl = this.gl\n    gl.deleteBuffer(this.vertexBuffer)\n    gl.deleteBuffer(this.indexBuffer)\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 13,
      "source": "constructor (gl, spriteProgram, textureManager, options = {}) {\n    this.gl = gl\n    this.spriteProgram = spriteProgram\n    this.textureManager = textureManager\n\n    this.maxSprites = options.maxSprites ?? 1000\n\n\n    this.vertexData = new Float32Array(this.maxSprites * 4 * FLOATS_PER_VERTEX)\n    this.indexData = new Uint16Array(this.maxSprites * 6)\n\n    for (let i = 0; i < this.maxSprites; i++) {\n        const offset = i * 6\n        const vertexOffset = i * 4\n\n        this.indexData[offset + 0] = vertexOffset + 0\n        this.indexData[offset + 1] = vertexOffset + 1\n        this.indexData[offset + 2] = vertexOffset + 2\n        this.indexData[offset + 3] = vertexOffset + 0\n        this.indexData[offset + 4] = vertexOffset + 2\n        this.indexData[offset + 5] = vertexOffset + 3\n    }\n\n    this.vertexBuffer = gl.createBuffer()\n    this.indexBuffer = gl.createBuffer()\n\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer)\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indexData, gl.STATIC_DRAW)\n\n    this.currentTexture = null\n    this.currentTextureSize = {width: 1, height: 1}\n    this.spriteCount = 0\n    this.vertexIndex = 0\n    this.activeProgram = null\n}",
      "kind": "constructor",
      "params": [
        "gl",
        "spriteProgram",
        "textureManager",
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/render/webgl/webgl_sprite_renderer.doc.js": {
    "type": "class",
    "file": "/render/webgl/webgl_sprite_renderer.js",
    "name": "WebGLSpriteRenderer",
    "line": 6,
    "extends": "WebGLObjectRenderer",
    "statics": [
      {
        "name": "handles",
        "line": 11,
        "source": "static get handles () {\n    return [Sprite]\n}",
        "kind": "method",
        "params": []
      }
    ],
    "methods": [
      {
        "name": "init",
        "line": 16,
        "source": "init (context) {\n    super.init(context)\n    this.#spriteBatch = new WebGLSpriteBatch(\n        context.gl,\n        context.spriteProgram,\n        context.textureManager\n    )\n    this.#shaderEffectRegistry = context.shaderEffectRegistry\n}",
        "kind": "method",
        "params": [
          "context"
        ]
      },
      {
        "name": "reset",
        "line": 27,
        "source": "reset (renderContext = null) {\n    super.reset()\n    const program = renderContext?.transform?.getProgram() || null\n    this.#spriteBatch.begin(program)\n}",
        "kind": "method",
        "params": [
          "renderContext = ..."
        ]
      },
      {
        "name": "flush",
        "line": 34,
        "source": "flush (matrices, renderContext = null) {\n    const gl = this.gl\n    const transform = renderContext?.transform\n    const identityMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1]\n\n    const batches = this.#groupByShaderEffects()\n\n    for (const {key: effectKey, items} of batches) {\n        const program = this.#getProgramForEffects(effectKey, transform)\n\n        this.#spriteBatch.begin(program)\n\n        for (const {object, opacity, hints} of items) {\n            this.#spriteBatch.addSprite(object, opacity, hints)\n        }\n\n        gl.useProgram(program.program)\n        gl.uniformMatrix3fv(program.uniforms.uProjectionMatrix, false, matrices.projectionMatrix)\n        gl.uniformMatrix3fv(program.uniforms.uViewMatrix, false, matrices.viewMatrix)\n        gl.uniformMatrix3fv(program.uniforms.uModelMatrix, false, identityMatrix)\n\n        setEffectUniforms(gl, program, this.#spriteBatch.currentTextureSize)\n\n        if (this.#shaderEffectRegistry) {\n            this.#shaderEffectRegistry.applyUniforms(gl, program)\n        }\n\n        if (transform) {\n            transform.applyUniforms(gl, program, matrices)\n        }\n\n        this.#spriteBatch.end(program)\n    }\n}",
        "kind": "method",
        "params": [
          "matrices",
          "renderContext = ..."
        ]
      },
      {
        "name": "dispose",
        "line": 111,
        "source": "dispose () {\n    if (this.#spriteBatch) {\n        this.#spriteBatch.dispose()\n        this.#spriteBatch = null\n    }\n    this.#shaderEffectRegistry = null\n    super.dispose()\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": null,
    "isDefault": true
  },
  "/input/input_system.doc.js": {
    "type": "class",
    "file": "/input/input_system.js",
    "name": "InputSystem",
    "line": 9,
    "extends": "PerkyModule",
    "statics": [
      {
        "name": "$category",
        "line": 11,
        "source": "static $category = 'inputSystem'",
        "kind": "property",
        "value": "'inputSystem'"
      }
    ],
    "methods": [
      {
        "name": "onInstall",
        "line": 26,
        "source": "onInstall (host) {\n    this.registerDevice(KeyboardDevice, {\n        $id: 'keyboard',\n        $bind: 'keyboard'\n    })\n\n    this.registerDevice(MouseDevice, {\n        $id: 'mouse',\n        $bind: 'mouse',\n        container: host.element\n    })\n\n    this.registerDevice(TouchDevice, {\n        $id: 'touch',\n        $bind: 'touch',\n        container: host.element,\n        shouldPreventDefault: true\n    })\n\n    this.delegateTo(host, [\n        'registerDevice',\n        'unregisterDevice',\n        'getDevice',\n        'isPressed',\n        'isPressedAny',\n        'getAllPressed',\n        'getValueFor',\n        'getValueAny',\n        'addControl',\n        'getControl',\n        'getControlAny',\n        'getPressedControls'\n    ])\n\n    this.delegateTo(host, [\n        'inputBinder',\n        'bindInput',\n        'unbind',\n        'getBinding',\n        'hasBinding',\n        'getBindingsForInput',\n        'getBindingsForAction',\n        'getAllBindings',\n        'clearBindings',\n        'bindCombo'\n    ])\n\n    this.delegateTo(host, [\n        'isKeyPressed',\n        'isMousePressed',\n        'isTouchPressed',\n        'getKeyValue',\n        'getMouseValue',\n        'getTouchValue',\n        'isActionPressed',\n        'getActionControls',\n        'getInputValue',\n        'getInputValueAny',\n        'getDirection'\n    ])\n\n    this.delegateEventsTo(host, ['input:triggered'])\n}",
        "kind": "method",
        "params": [
          "host"
        ]
      },
      {
        "name": "registerDevice",
        "line": 91,
        "source": "registerDevice (DeviceClass, options = {}) {\n    return this.create(DeviceClass, options)\n}",
        "kind": "method",
        "params": [
          "DeviceClass",
          "options = ..."
        ]
      },
      {
        "name": "getDevice",
        "line": 96,
        "source": "getDevice (name) {\n    return this.getChild(name)\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "isPressed",
        "line": 101,
        "source": "isPressed (deviceName, controlName) {\n    const device = this.getDevice(deviceName)\n    return device ? device.isPressed(controlName) : false\n}",
        "kind": "method",
        "params": [
          "deviceName",
          "controlName"
        ]
      },
      {
        "name": "getValueFor",
        "line": 107,
        "source": "getValueFor (deviceName, controlName) {\n    const device = this.getDevice(deviceName)\n    return device ? device.getValueFor(controlName) : undefined\n}",
        "kind": "method",
        "params": [
          "deviceName",
          "controlName"
        ]
      },
      {
        "name": "getControl",
        "line": 113,
        "source": "getControl (deviceName, controlName) {\n    const device = this.getDevice(deviceName)\n    return device ? (device.getControl(controlName) ?? null) : null\n}",
        "kind": "method",
        "params": [
          "deviceName",
          "controlName"
        ]
      },
      {
        "name": "listDeviceNames",
        "line": 119,
        "source": "listDeviceNames () {\n    return this.listNamesFor('inputDevice')\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "isPressedAny",
        "line": 124,
        "source": "isPressedAny (controlName) {\n    const deviceNames = this.listDeviceNames()\n    for (const name of deviceNames) {\n        const device = this.getChild(name)\n        if (device && device.isPressed(controlName)) {\n            return true\n        }\n    }\n    return false\n}",
        "kind": "method",
        "params": [
          "controlName"
        ]
      },
      {
        "name": "getValueAny",
        "line": 136,
        "source": "getValueAny (controlName) {\n    const deviceNames = this.listDeviceNames()\n    for (const name of deviceNames) {\n        const device = this.getChild(name)\n        if (device) {\n            const value = device.getValueFor(controlName)\n            if (value !== undefined) {\n                return value\n            }\n        }\n    }\n    return undefined\n}",
        "kind": "method",
        "params": [
          "controlName"
        ]
      },
      {
        "name": "getControlAny",
        "line": 151,
        "source": "getControlAny (controlName) {\n    const deviceNames = this.listDeviceNames()\n    for (const name of deviceNames) {\n        const device = this.getChild(name)\n        if (device) {\n            const control = device.getControl(controlName)\n            if (control) {\n                return control\n            }\n        }\n    }\n    return null\n}",
        "kind": "method",
        "params": [
          "controlName"
        ]
      },
      {
        "name": "getAllPressed",
        "line": 166,
        "source": "getAllPressed (controlName) {\n    const results = []\n    const deviceNames = this.listDeviceNames()\n    for (const name of deviceNames) {\n        const device = this.getChild(name)\n        if (device && device.isPressed(controlName)) {\n            results.push(device)\n        }\n    }\n    return results\n}",
        "kind": "method",
        "params": [
          "controlName"
        ]
      },
      {
        "name": "getPressedControls",
        "line": 179,
        "source": "getPressedControls (deviceName) {\n    const device = this.getDevice(deviceName)\n    return device ? device.getPressedControls() : []\n}",
        "kind": "method",
        "params": [
          "deviceName"
        ]
      },
      {
        "name": "getAllValues",
        "line": 185,
        "source": "getAllValues (controlName) {\n    const results = []\n    const deviceNames = this.listDeviceNames()\n    for (const name of deviceNames) {\n        const device = this.getChild(name)\n        if (device) {\n            const value = device.getValueFor(controlName)\n            if (value !== undefined) {\n                results.push({device, value})\n            }\n        }\n    }\n    return results\n}",
        "kind": "method",
        "params": [
          "controlName"
        ]
      },
      {
        "name": "addControl",
        "line": 201,
        "source": "addControl (deviceNameOrControl, ControlOrParams = {}, params = {}) {\n\n    if (typeof deviceNameOrControl === 'string') {\n        const device = this.getDevice(deviceNameOrControl)\n\n        if (!device) {\n            throw new Error(`Device '${deviceNameOrControl}' not found`)\n        }\n\n        return device.findOrCreateControl(ControlOrParams, params)\n\n    } else if (typeof deviceNameOrControl === 'function') {\n\n        return this.addControlToFirst(deviceNameOrControl, ControlOrParams)\n    }\n\n    return null\n}",
        "kind": "method",
        "params": [
          "deviceNameOrControl",
          "ControlOrParams = ...",
          "params = ..."
        ]
      },
      {
        "name": "addControlToFirst",
        "line": 221,
        "source": "addControlToFirst (Control, params = {}) {\n    const deviceNames = this.listDeviceNames()\n    const firstDevice = deviceNames.length > 0 ? this.getChild(deviceNames[0]) : null\n    if (!firstDevice) {\n        throw new Error('No devices available')\n    }\n    return firstDevice.findOrCreateControl(Control, params)\n}",
        "kind": "method",
        "params": [
          "Control",
          "params = ..."
        ]
      },
      {
        "name": "addControlToAll",
        "line": 231,
        "source": "addControlToAll (Control, params = {}) {\n    const results = []\n    const deviceNames = this.listDeviceNames()\n    for (const name of deviceNames) {\n        const device = this.getChild(name)\n        if (device) {\n            const control = device.findOrCreateControl(Control, params)\n            results.push({device, control})\n        }\n    }\n    return results\n}",
        "kind": "method",
        "params": [
          "Control",
          "params = ..."
        ]
      },
      {
        "name": "deviceKeyFor",
        "line": 245,
        "source": "deviceKeyFor (device) {\n    return this.childrenRegistry.keyFor(device)\n}",
        "kind": "method",
        "params": [
          "device"
        ]
      },
      {
        "name": "getInputValue",
        "line": 250,
        "source": "getInputValue (deviceName, controlName) {\n    return this.getValueFor(deviceName, controlName)\n}",
        "kind": "method",
        "params": [
          "deviceName",
          "controlName"
        ]
      },
      {
        "name": "getInputValueAny",
        "line": 255,
        "source": "getInputValueAny (controlName) {\n    return this.getValueAny(controlName)\n}",
        "kind": "method",
        "params": [
          "controlName"
        ]
      },
      {
        "name": "isKeyPressed",
        "line": 260,
        "source": "isKeyPressed (keyName) {\n    return this.isPressed('keyboard', keyName)\n}",
        "kind": "method",
        "params": [
          "keyName"
        ]
      },
      {
        "name": "isMousePressed",
        "line": 265,
        "source": "isMousePressed (buttonName) {\n    return this.isPressed('mouse', buttonName)\n}",
        "kind": "method",
        "params": [
          "buttonName"
        ]
      },
      {
        "name": "getKeyValue",
        "line": 270,
        "source": "getKeyValue (keyName) {\n    return this.getInputValue('keyboard', keyName)\n}",
        "kind": "method",
        "params": [
          "keyName"
        ]
      },
      {
        "name": "getMouseValue",
        "line": 275,
        "source": "getMouseValue (buttonName) {\n    return this.getInputValue('mouse', buttonName)\n}",
        "kind": "method",
        "params": [
          "buttonName"
        ]
      },
      {
        "name": "isTouchPressed",
        "line": 280,
        "source": "isTouchPressed (controlName) {\n    return this.isPressed('touch', controlName)\n}",
        "kind": "method",
        "params": [
          "controlName"
        ]
      },
      {
        "name": "getTouchValue",
        "line": 285,
        "source": "getTouchValue (controlName) {\n    return this.getInputValue('touch', controlName)\n}",
        "kind": "method",
        "params": [
          "controlName"
        ]
      },
      {
        "name": "isActionPressed",
        "line": 290,
        "source": "isActionPressed (actionName, controllerName = null) {\n    const bindings = this.inputBinder.getBindingsForAction(actionName, controllerName, 'pressed')\n\n    for (const binding of bindings) {\n        if (typeof binding.shouldTrigger === 'function') {\n            if (binding.shouldTrigger(this)) {\n                return true\n            }\n        } else if (this.isPressed(binding.deviceName, binding.controlName)) {\n            return true\n        }\n    }\n\n    return false\n}",
        "kind": "method",
        "params": [
          "actionName",
          "controllerName = ..."
        ]
      },
      {
        "name": "getActionControls",
        "line": 307,
        "source": "getActionControls (actionName, controllerName = null) {\n    const bindings = this.inputBinder.getBindingsForAction(actionName, controllerName, 'pressed')\n    const controls = []\n\n    for (const binding of bindings) {\n        controls.push(...this.#getControlsFromBinding(binding))\n    }\n\n    return controls\n}",
        "kind": "method",
        "params": [
          "actionName",
          "controllerName = ..."
        ]
      },
      {
        "name": "getDirection",
        "line": 319,
        "source": "getDirection (name = 'move') {\n    const up = name + 'Up'\n    const down = name + 'Down'\n    const left = name + 'Left'\n    const right = name + 'Right'\n\n    const x = (this.isActionPressed(right) ? 1 : 0)\n        - (this.isActionPressed(left) ? 1 : 0)\n    const y = (this.isActionPressed(up) ? 1 : 0)\n        - (this.isActionPressed(down) ? 1 : 0)\n\n    const vec = new Vec2(x, y)\n\n    return vec.length() > 0 ? vec.clone().normalize() : vec\n}",
        "kind": "method",
        "params": [
          "name = ..."
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 13,
      "source": "constructor (options = {}) {\n    const {bindings = []} = options\n    super(options)\n\n    this.create(InputBinder, {\n        $bind: 'inputBinder',\n        bindings\n    })\n\n    this.#initEvents()\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/input/composite_binding.doc.js": {
    "type": "class",
    "file": "/input/composite_binding.js",
    "name": "CompositeBinding",
    "line": 4,
    "extends": "InputBinding",
    "statics": [
      {
        "name": "generateControlName",
        "line": 29,
        "source": "static generateControlName (controls) {\n    const controlNames = controls.map(c => `${c.deviceName}:${c.controlName}`).join('+')\n    return `combo(${controlNames})`\n}",
        "kind": "method",
        "params": [
          "controls"
        ]
      }
    ],
    "methods": [
      {
        "name": "matches",
        "line": 35,
        "source": "matches ({deviceName, controlName, eventType}) {\n    if (deviceName === 'composite' && controlName === this.controlName && eventType === this.eventType) {\n        return true\n    }\n\n    return this.controls.some(c => {\n        return c.deviceName === deviceName && c.controlName === controlName\n    }) && eventType === this.eventType\n}",
        "kind": "method",
        "params": [
          "{...}"
        ]
      },
      {
        "name": "shouldTrigger",
        "line": 46,
        "source": "shouldTrigger (inputSystem) {\n    return this.controls.every(({deviceName, controlName}) => {\n        return inputSystem.isPressed(deviceName, controlName)\n    })\n}",
        "kind": "method",
        "params": [
          "inputSystem"
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 6,
      "source": "constructor ({\n    controls,\n    actionName,\n    controllerName = null,\n    eventType = 'pressed'\n}) {\n\n    if (!Array.isArray(controls) || controls.length < 2) {\n        throw new Error('CompositeBinding requires an array of at least 2 controls')\n    }\n\n    super({\n        deviceName: 'composite',\n        controlName: CompositeBinding.generateControlName(controls),\n        actionName,\n        controllerName,\n        eventType\n    })\n\n    this.controls = controls\n}",
      "kind": "constructor",
      "params": [
        "{...}"
      ]
    },
    "isDefault": true
  },
  "/input/gamepad_info.doc.js": {
    "type": "class",
    "file": "/input/gamepad_info.js",
    "name": "GamepadInfo",
    "line": 2,
    "extends": null,
    "statics": [],
    "methods": [],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 4,
      "source": "constructor (rawId) {\n    this.raw = rawId\n    this.vendor = null\n    this.product = null\n    this.name = null\n    this.type = 'generic'\n    this.model = null\n\n    if (!rawId || typeof rawId !== 'string') {\n        this.type = 'unknown'\n        return\n    }\n\n    this.#parseRawId()\n    this.#determineType()\n    this.#refineType()\n}",
      "kind": "constructor",
      "params": [
        "rawId"
      ]
    },
    "isDefault": true
  },
  "/input/input_binder.doc.js": {
    "type": "class",
    "file": "/input/input_binder.js",
    "name": "InputBinder",
    "line": 7,
    "extends": "PerkyModule",
    "statics": [
      {
        "name": "$category",
        "line": 9,
        "source": "static $category = 'inputBinder'",
        "kind": "property",
        "value": "'inputBinder'"
      }
    ],
    "methods": [
      {
        "name": "onInstall",
        "line": 48,
        "source": "onInstall (host) {\n    this.delegateTo(host, [\n        'bindInput',\n        'unbind',\n        'getBinding',\n        'hasBinding',\n        'getBindingsForInput',\n        'getBindingsForAction',\n        'getAllBindings',\n        'clearBindings',\n        'bindCombo'\n    ])\n}",
        "kind": "method",
        "params": [
          "host"
        ]
      },
      {
        "name": "import",
        "line": 63,
        "source": "import (inputBinder) {\n    if (typeof inputBinder.export === 'function') {\n        inputBinder = inputBinder.export()\n    }\n\n    if (Array.isArray(inputBinder?.bindings)) {\n        this.importBindings(inputBinder.bindings)\n    }\n}",
        "kind": "method",
        "params": [
          "inputBinder"
        ]
      },
      {
        "name": "importBindings",
        "line": 74,
        "source": "importBindings (bindings) {\n    bindings.forEach(bindingData => this.bindInput(bindingData))\n}",
        "kind": "method",
        "params": [
          "bindings"
        ]
      },
      {
        "name": "bindInput",
        "line": 79,
        "source": "bindInput ({\n    deviceName,\n    controlName,\n    actionName,\n    controllerName = null,\n    eventType = 'pressed',\n    controls = null\n}) {\n    let binding\n\n    if (controls && Array.isArray(controls)) {\n        binding = new CompositeBinding({\n            controls,\n            actionName,\n            controllerName,\n            eventType\n        })\n    } else {\n        binding = new InputBinding({\n            deviceName: deviceName ?? detectDeviceFromControlName(controlName),\n            controlName,\n            actionName,\n            controllerName,\n            eventType\n        })\n    }\n\n    this.#bindings.set(binding.key, binding)\n    return binding\n}",
        "kind": "method",
        "params": [
          "{...}"
        ]
      },
      {
        "name": "unbind",
        "line": 111,
        "source": "unbind (params) {\n    const binding = this.getBinding(params)\n\n    if (binding) {\n        this.#bindings.delete(binding.key)\n        this.emit('binding:removed', binding)\n\n        return true\n    }\n    return false\n}",
        "kind": "method",
        "params": [
          "params"
        ]
      },
      {
        "name": "getBinding",
        "line": 124,
        "source": "getBinding (params) {\n    const {deviceName, controlName, actionName, controllerName = null, eventType = 'pressed'} = params\n\n    if (deviceName && controlName) {\n        const key = keyFor(params)\n        return this.#bindings.get(key) || null\n    }\n\n    const bindings = this.getBindingsForAction(actionName, controllerName, eventType)\n    return bindings.length > 0 ? bindings[0] : null\n}",
        "kind": "method",
        "params": [
          "params"
        ]
      },
      {
        "name": "hasBinding",
        "line": 137,
        "source": "hasBinding (params) {\n    return this.getBinding(params) !== null\n}",
        "kind": "method",
        "params": [
          "params"
        ]
      },
      {
        "name": "getBindingsForInput",
        "line": 142,
        "source": "getBindingsForInput ({deviceName, controlName, eventType}) {\n    const key = `${deviceName}:${controlName}:${eventType}`\n    const bindings = this.#bindings.lookup('input', key)\n\n    const directBindings = []\n    const compositeBindings = []\n\n    for (const binding of bindings) {\n        if (binding instanceof CompositeBinding) {\n            compositeBindings.push(binding)\n        } else {\n            directBindings.push(binding)\n        }\n    }\n\n    return [...directBindings, ...compositeBindings]\n}",
        "kind": "method",
        "params": [
          "{...}"
        ]
      },
      {
        "name": "getBindingsForAction",
        "line": 161,
        "source": "getBindingsForAction (actionName, controllerName = null, eventType = 'pressed') {\n    if (controllerName === null) {\n        const key = `${actionName}:${eventType}`\n        return this.#bindings.lookup('actionAll', key)\n    }\n\n    const controller = controllerName || ''\n    const key = `${actionName}:${eventType}:${controller}`\n    return this.#bindings.lookup('action', key)\n}",
        "kind": "method",
        "params": [
          "actionName",
          "controllerName = ...",
          "eventType = ..."
        ]
      },
      {
        "name": "getAllBindings",
        "line": 173,
        "source": "getAllBindings () {\n    return Array.from(this.#bindings.values)\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "clearBindings",
        "line": 178,
        "source": "clearBindings () {\n    this.#bindings.clear()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "bindCombo",
        "line": 183,
        "source": "bindCombo (controls, actionName, controllerName = null, eventType = 'pressed') {\n    if (!Array.isArray(controls) || controls.length < 2) {\n        throw new Error('Controls must be an array with at least 2 controls')\n    }\n\n    if (!actionName || typeof actionName !== 'string') {\n        throw new Error('actionName is required and must be a string')\n    }\n\n    const normalizedControls = controls.map((control, index) => {\n        if (typeof control === 'string') {\n            const deviceName = detectDeviceFromControlName(control)\n            return {deviceName, controlName: control}\n        } else if (control && typeof control === 'object' && control.deviceName && control.controlName) {\n            return control\n        } else {\n            throw new Error(`Control at index ${index} must be a string or object with deviceName and controlName properties`)\n        }\n    })\n\n    return this.bindInput({\n        controls: normalizedControls,\n        actionName,\n        controllerName,\n        eventType\n    })\n}",
        "kind": "method",
        "params": [
          "controls",
          "actionName",
          "controllerName = ...",
          "eventType = ..."
        ]
      },
      {
        "name": "export",
        "line": 212,
        "source": "export () {\n    return {\n        bindings: this.getAllBindings().map(binding => {\n            const exported = {\n                deviceName: binding.deviceName,\n                controlName: binding.controlName,\n                actionName: binding.actionName,\n                controllerName: binding.controllerName,\n                eventType: binding.eventType\n            }\n\n            if (binding.controls) {\n                exported.controls = binding.controls\n            }\n\n            return exported\n        })\n    }\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 13,
      "source": "constructor (options = {}) {\n    super(options)\n\n    const {bindings = [], inputBinder} = options\n\n    this.#bindings.addIndex('input', (binding) => {\n        if (binding instanceof CompositeBinding) {\n            const keys = binding.controls.map(({deviceName, controlName}) => {\n                return `${deviceName}:${controlName}:${binding.eventType}`\n            })\n\n            keys.push(`composite:${binding.controlName}:${binding.eventType}`)\n\n            return keys\n        }\n\n        return `${binding.deviceName}:${binding.controlName}:${binding.eventType}`\n    })\n\n    this.#bindings.addIndex('action', (binding) => {\n        const controller = binding.controllerName || ''\n        return `${binding.actionName}:${binding.eventType}:${controller}`\n    })\n\n    this.#bindings.addIndex('actionAll', (binding) => {\n        return `${binding.actionName}:${binding.eventType}`\n    })\n\n    if (inputBinder) {\n        this.import(inputBinder)\n    }\n    this.import({bindings})\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/input/input_binding.doc.js": {
    "type": "class",
    "file": "/input/input_binding.js",
    "name": "InputBinding",
    "line": 1,
    "extends": null,
    "statics": [
      {
        "name": "keyFor",
        "line": 29,
        "source": "static keyFor ({deviceName, controlName, actionName, controllerName = null, eventType = 'pressed'}) {\n    if (controllerName) {\n        return `${deviceName}:${controlName}:${eventType}:${actionName}:${controllerName}`\n    }\n\n    return `${deviceName}:${controlName}:${eventType}:${actionName}`\n}",
        "kind": "method",
        "params": [
          "{...}"
        ]
      }
    ],
    "methods": [
      {
        "name": "matches",
        "line": 38,
        "source": "matches ({deviceName, controlName, eventType}) {\n    return this.deviceName === deviceName &&\n        this.controlName === controlName &&\n        this.eventType === eventType\n}",
        "kind": "method",
        "params": [
          "{...}"
        ]
      },
      {
        "name": "updateInput",
        "line": 45,
        "source": "updateInput ({deviceName, controlName}) {\n    this.deviceName = deviceName\n    this.controlName = controlName\n}",
        "kind": "method",
        "params": [
          "{...}"
        ]
      }
    ],
    "getters": [
      {
        "name": "key",
        "line": 18,
        "source": "get key () {\n    return InputBinding.keyFor({\n        deviceName: this.deviceName,\n        controlName: this.controlName,\n        actionName: this.actionName,\n        controllerName: this.controllerName,\n        eventType: this.eventType\n    })\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 3,
      "source": "constructor ({\n    deviceName,\n    controlName,\n    actionName,\n    controllerName = null,\n    eventType = 'pressed'\n}) {\n    this.deviceName = deviceName\n    this.controlName = controlName\n    this.actionName = actionName\n    this.controllerName = controllerName\n    this.eventType = eventType\n}",
      "kind": "constructor",
      "params": [
        "{...}"
      ]
    },
    "isDefault": true
  },
  "/input/input_control.doc.js": {
    "type": "class",
    "file": "/input/input_control.js",
    "name": "InputControl",
    "line": 8,
    "extends": "Notifier",
    "statics": [
      {
        "name": "VALUE",
        "line": 10,
        "source": "static VALUE = VALUE",
        "kind": "property",
        "value": "VALUE"
      },
      {
        "name": "OLD_VALUE",
        "line": 11,
        "source": "static OLD_VALUE = OLD_VALUE",
        "kind": "property",
        "value": "OLD_VALUE"
      }
    ],
    "methods": [
      {
        "name": "setValue",
        "line": 27,
        "source": "setValue (value, event = null) {\n    if (value === this[VALUE]) {\n        return false\n    }\n\n    this[OLD_VALUE] = this[VALUE]\n    this[VALUE] = value\n\n    this.emit('updated', this[VALUE], this[OLD_VALUE], event)\n\n    return true\n}",
        "kind": "method",
        "params": [
          "value",
          "event = ..."
        ]
      },
      {
        "name": "getDefaultValue",
        "line": 51,
        "source": "getDefaultValue () { // eslint-disable-line local/class-methods-use-this -- clean\n    return 0\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "reset",
        "line": 56,
        "source": "reset () {\n    this.value = this.getDefaultValue()\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "value",
        "line": 41,
        "source": "get value () {\n    return this[VALUE]\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "oldValue",
        "line": 46,
        "source": "get oldValue () {\n    return this[OLD_VALUE]\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "value",
        "line": 22,
        "source": "set value (value) {\n    this.setValue(value)\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      }
    ],
    "constructor": {
      "name": "constructor",
      "line": 13,
      "source": "constructor ({device, name, value}) {\n    super()\n    this.device     = device\n    this.name       = name\n    this[OLD_VALUE] = null\n    this[VALUE]     = value ?? this.getDefaultValue()\n}",
      "kind": "constructor",
      "params": [
        "{...}"
      ]
    },
    "isDefault": true
  },
  "/input/input_device.doc.js": {
    "type": "class",
    "file": "/input/input_device.js",
    "name": "InputDevice",
    "line": 5,
    "extends": "PerkyModule",
    "statics": [
      {
        "name": "$category",
        "line": 7,
        "source": "static $category = 'inputDevice'",
        "kind": "property",
        "value": "'inputDevice'"
      }
    ],
    "methods": [
      {
        "name": "onInstall",
        "line": 22,
        "source": "onInstall (host) {\n    this.delegateEventsTo(host, ['control:pressed', 'control:released', 'control:updated'])\n}",
        "kind": "method",
        "params": [
          "host"
        ]
      },
      {
        "name": "registerControl",
        "line": 27,
        "source": "registerControl (control) {\n    if (!(control && control.name)) {\n        throw new Error('Control must have a name')\n    }\n\n    if (this.controls.has(control.name)) {\n        return false\n    }\n\n    this.controls.set(control.name, control)\n\n    return true\n}",
        "kind": "method",
        "params": [
          "control"
        ]
      },
      {
        "name": "getControl",
        "line": 42,
        "source": "getControl (name) {\n    return this.controls.get(name)\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "getValueFor",
        "line": 47,
        "source": "getValueFor (controlName) {\n    const control = this.getControl(controlName)\n    return control ? control.value : undefined\n}",
        "kind": "method",
        "params": [
          "controlName"
        ]
      },
      {
        "name": "isPressed",
        "line": 53,
        "source": "isPressed (controlName) {\n    return this.pressedNames.has(controlName)\n}",
        "kind": "method",
        "params": [
          "controlName"
        ]
      },
      {
        "name": "getPressedControls",
        "line": 58,
        "source": "getPressedControls () {\n    const results = []\n    for (const controlName of this.pressedNames) {\n        const control = this.getControl(controlName)\n        if (control) {\n            results.push(control)\n        }\n    }\n    return results\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "findOrCreateControl",
        "line": 70,
        "source": "findOrCreateControl (Control, params = {}) {\n    const controlName = params.name\n\n    if (!controlName) {\n        throw new Error('Control must have a name')\n    }\n\n    let control = this.controls.get(controlName)\n\n    if (control) {\n        return control\n    }\n\n    control = new Control({\n        device: this,\n        name: controlName,\n        ...params\n    })\n\n    if (this.registerControl(control)) {\n        return control\n    }\n\n    return null\n}",
        "kind": "method",
        "params": [
          "Control",
          "params = ..."
        ]
      },
      {
        "name": "shouldPreventDefaultFor",
        "line": 97,
        "source": "shouldPreventDefaultFor (event, control) {\n    if (!this.shouldPreventDefault) {\n        return false\n    }\n\n    if (typeof this.shouldPreventDefault === 'function') {\n        return this.shouldPreventDefault(event, control, this)\n    }\n\n    return true\n}",
        "kind": "method",
        "params": [
          "event",
          "control"
        ]
      },
      {
        "name": "preventDefault",
        "line": 110,
        "source": "preventDefault (event, control) {\n    if (control && event && this.shouldPreventDefaultFor(event, control)) {\n        if (isInteractiveTarget(event.target)) {\n            return\n        }\n        if (typeof event.preventDefault === 'function') {\n            event.preventDefault()\n        }\n        if (typeof event.stopPropagation === 'function') {\n            event.stopPropagation()\n        }\n    }\n}",
        "kind": "method",
        "params": [
          "event",
          "control"
        ]
      },
      {
        "name": "onDispose",
        "line": 125,
        "source": "onDispose () {\n    this.controls.clear()\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 9,
      "source": "constructor (options = {}) {\n    super(options)\n\n    const {container = window} = options\n\n    this.container = container\n    this.controls = new Registry()\n    this.pressedNames = new Set()\n\n    this.#initEvents()\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/input/input_controls/button_control.doc.js": {
    "type": "class",
    "file": "/input/input_controls/button_control.js",
    "name": "ButtonControl",
    "line": 4,
    "extends": "InputControl",
    "statics": [
      {
        "name": "defaultPressThreshold",
        "line": 6,
        "source": "static defaultPressThreshold = 0.1",
        "kind": "property",
        "value": "0.1"
      }
    ],
    "methods": [
      {
        "name": "setValue",
        "line": 15,
        "source": "setValue (value, event = null) {\n    this.lastEvent = event\n\n    if (super.setValue(value, event)) {\n\n        if (this.isPressed && !this.wasPressed) {\n            this.emit('pressed', this.lastEvent)\n        }\n\n        if (!this.isPressed && this.wasPressed) {\n            this.emit('released', this.lastEvent)\n        }\n\n        return true\n    }\n\n    return false\n}",
        "kind": "method",
        "params": [
          "value",
          "event = ..."
        ]
      },
      {
        "name": "press",
        "line": 45,
        "source": "press (event = null) {\n    this.setValue(1, event)\n}",
        "kind": "method",
        "params": [
          "event = ..."
        ]
      },
      {
        "name": "release",
        "line": 50,
        "source": "release (event = null) {\n    this.setValue(0, event)\n}",
        "kind": "method",
        "params": [
          "event = ..."
        ]
      }
    ],
    "getters": [
      {
        "name": "isPressed",
        "line": 35,
        "source": "get isPressed () {\n    return this.value >= this.pressThreshold\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "wasPressed",
        "line": 40,
        "source": "get wasPressed () {\n    return this.oldValue >= this.pressThreshold\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 8,
      "source": "constructor (params = {}) {\n    super(params)\n\n    this.pressThreshold = params.pressThreshold ?? this.constructor.defaultPressThreshold\n}",
      "kind": "constructor",
      "params": [
        "params = ..."
      ]
    },
    "isDefault": true
  },
  "/input/input_controls/navigation_control.doc.js": {
    "type": "class",
    "file": "/input/input_controls/navigation_control.js",
    "name": "NavigationControl",
    "line": 7,
    "extends": "InputControl",
    "statics": [],
    "methods": [
      {
        "name": "getDefaultValue",
        "line": 9,
        "source": "getDefaultValue () { // eslint-disable-line local/class-methods-use-this -- clean\n    return {deltaX: 0, deltaY: 0, deltaZ: 0, event: null}\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "setValue",
        "line": 14,
        "source": "setValue (wheelEvent, event = null) {\n    const delta = {\n        deltaX: wheelEvent.deltaX || 0,\n        deltaY: wheelEvent.deltaY || 0,\n        deltaZ: wheelEvent.deltaZ || 0,\n        event: wheelEvent\n    }\n\n    this[OLD_VALUE] = this[VALUE]\n    this[VALUE] = delta\n\n    this.emit('updated', this[VALUE], this[OLD_VALUE], event)\n\n    return true\n}",
        "kind": "method",
        "params": [
          "wheelEvent",
          "event = ..."
        ]
      }
    ],
    "getters": [
      {
        "name": "deltaY",
        "line": 31,
        "source": "get deltaY () {\n    return this.value.deltaY\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "deltaX",
        "line": 36,
        "source": "get deltaX () {\n    return this.value.deltaX\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "deltaZ",
        "line": 41,
        "source": "get deltaZ () {\n    return this.value.deltaZ\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "event",
        "line": 46,
        "source": "get event () {\n    return this.value.event\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "isTrackpadPinchZoom",
        "line": 51,
        "source": "get isTrackpadPinchZoom () {\n    return this.event && (this.event.ctrlKey || this.event.metaKey)\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "isMouseWheelZoom",
        "line": 56,
        "source": "get isMouseWheelZoom () {\n    if (!this.event || this.isTrackpadPinchZoom) {\n        return false\n    }\n\n    const isVerticalOnly = Math.abs(this.deltaX) <= 0.1\n    const isSignificantVertical = Math.abs(this.deltaY) >= 10\n\n    return isVerticalOnly && isSignificantVertical\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "isTrackpadPan",
        "line": 68,
        "source": "get isTrackpadPan () {\n    if (!this.event || this.isTrackpadPinchZoom) {\n        return false\n    }\n\n    return Math.abs(this.deltaX) > 0.1 || Math.abs(this.deltaY) > 0.1\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [],
    "constructor": null,
    "isDefault": true
  },
  "/input/input_controls/vec2_control.doc.js": {
    "type": "class",
    "file": "/input/input_controls/vec2_control.js",
    "name": "Vec2Control",
    "line": 7,
    "extends": "InputControl",
    "statics": [],
    "methods": [
      {
        "name": "getDefaultValue",
        "line": 9,
        "source": "getDefaultValue () { // eslint-disable-line local/class-methods-use-this -- clean\n    return new Vec2()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "setValue",
        "line": 14,
        "source": "setValue (value, event = null) {\n    if (!(value instanceof Vec2)) {\n        value = new Vec2(value)\n    }\n\n    if (this[VALUE] && this[VALUE].equals(value)) {\n        return false\n    }\n\n    this[OLD_VALUE] = this[VALUE]\n    this[VALUE] = new Vec2(value)\n\n    this.emit('updated', this[VALUE], this[OLD_VALUE], event)\n\n    return true\n}",
        "kind": "method",
        "params": [
          "value",
          "event = ..."
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": null,
    "isDefault": true
  },
  "/input/input_controls/vec3_control.doc.js": {
    "type": "class",
    "file": "/input/input_controls/vec3_control.js",
    "name": "Vec3Control",
    "line": 7,
    "extends": "InputControl",
    "statics": [],
    "methods": [
      {
        "name": "getDefaultValue",
        "line": 9,
        "source": "getDefaultValue () { // eslint-disable-line local/class-methods-use-this -- clean\n    return new Vec3()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "setValue",
        "line": 14,
        "source": "setValue (value, event = null) {\n    if (!(value instanceof Vec3)) {\n        value = new Vec3(value)\n    }\n\n    if (this[VALUE] && this[VALUE].equals(value)) {\n        return false\n    }\n\n    this[OLD_VALUE] = this[VALUE]\n    this[VALUE] = new Vec3(value)\n\n    this.emit('updated', this[VALUE], this[OLD_VALUE], event)\n\n    return true\n}",
        "kind": "method",
        "params": [
          "value",
          "event = ..."
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": null,
    "isDefault": true
  },
  "/input/input_devices/keyboard_device.doc.js": {
    "type": "class",
    "file": "/input/input_devices/keyboard_device.js",
    "name": "KeyboardDevice",
    "line": 5,
    "extends": "InputDevice",
    "statics": [
      {
        "name": "$name",
        "line": 7,
        "source": "static $name = 'keyboard'",
        "kind": "property",
        "value": "'keyboard'"
      }
    ],
    "methods": [
      {
        "name": "onStart",
        "line": 24,
        "source": "onStart () {\n    this.container.addEventListener('keydown', this.#keydownListener, true)\n    this.container.addEventListener('keyup', this.#keyupListener, true)\n    this.container.addEventListener('blur', this.#blurListener)\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "onStop",
        "line": 31,
        "source": "onStop () {\n    this.container.removeEventListener('keydown', this.#keydownListener, true)\n    this.container.removeEventListener('keyup', this.#keyupListener, true)\n    this.container.removeEventListener('blur', this.#blurListener)\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 13,
      "source": "constructor (params = {}) {\n    super(params)\n\n    this.shouldPreventDefault = params.shouldPreventDefault\n\n    this.#keydownListener = this.#handleKeydown.bind(this)\n    this.#keyupListener = this.#handleKeyup.bind(this)\n    this.#blurListener = this.#handleBlur.bind(this)\n}",
      "kind": "constructor",
      "params": [
        "params = ..."
      ]
    },
    "isDefault": true
  },
  "/input/input_devices/mouse_device.doc.js": {
    "type": "class",
    "file": "/input/input_devices/mouse_device.js",
    "name": "MouseDevice",
    "line": 7,
    "extends": "InputDevice",
    "statics": [
      {
        "name": "$name",
        "line": 9,
        "source": "static $name = 'mouse'",
        "kind": "property",
        "value": "'mouse'"
      }
    ],
    "methods": [
      {
        "name": "onStart",
        "line": 32,
        "source": "onStart () {\n    this.container.addEventListener('mousedown', this.#mousedownListener)\n    this.container.addEventListener('mouseup', this.#mouseupListener)\n    this.container.addEventListener('mousemove', this.#mousemoveListener)\n    this.container.addEventListener('contextmenu', this.#contextmenuListener)\n    this.container.addEventListener('wheel', this.#wheelListener, {passive: false})\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "onStop",
        "line": 41,
        "source": "onStop () {\n    this.container.removeEventListener('mousedown', this.#mousedownListener)\n    this.container.removeEventListener('mouseup', this.#mouseupListener)\n    this.container.removeEventListener('mousemove', this.#mousemoveListener)\n    this.container.removeEventListener('contextmenu', this.#contextmenuListener)\n    this.container.removeEventListener('wheel', this.#wheelListener, {passive: false})\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 17,
      "source": "constructor (params = {}) {\n    super(params)\n\n    this.shouldPreventDefault = params.shouldPreventDefault\n\n    this.#createControls()\n\n    this.#mousedownListener = this.#handleMousedown.bind(this)\n    this.#mouseupListener = this.#handleMouseup.bind(this)\n    this.#mousemoveListener = this.#handleMousemove.bind(this)\n    this.#contextmenuListener = this.#handleContextmenu.bind(this)\n    this.#wheelListener = this.#handleWheel.bind(this)\n}",
      "kind": "constructor",
      "params": [
        "params = ..."
      ]
    },
    "isDefault": true
  },
  "/input/input_devices/touch_device.doc.js": {
    "type": "class",
    "file": "/input/input_devices/touch_device.js",
    "name": "TouchDevice",
    "line": 6,
    "extends": "InputDevice",
    "statics": [
      {
        "name": "$name",
        "line": 8,
        "source": "static $name = 'touch'",
        "kind": "property",
        "value": "'touch'"
      }
    ],
    "methods": [
      {
        "name": "onStart",
        "line": 39,
        "source": "onStart () {\n    this.container.addEventListener('touchstart', this.#touchstartListener, {passive: false})\n    this.container.addEventListener('touchmove', this.#touchmoveListener, {passive: false})\n    this.container.addEventListener('touchend', this.#touchendListener)\n    this.container.addEventListener('touchcancel', this.#touchcancelListener)\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "onStop",
        "line": 47,
        "source": "onStop () {\n    this.container.removeEventListener('touchstart', this.#touchstartListener)\n    this.container.removeEventListener('touchmove', this.#touchmoveListener)\n    this.container.removeEventListener('touchend', this.#touchendListener)\n    this.container.removeEventListener('touchcancel', this.#touchcancelListener)\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 22,
      "source": "constructor (params = {}) {\n    super(params)\n\n    this.swipeThreshold = params.swipeThreshold ?? 30\n    this.tapThreshold = params.tapThreshold ?? 20\n    this.tapMaxDuration = params.tapMaxDuration ?? 300\n    this.shouldPreventDefault = params.shouldPreventDefault\n\n    this.#createControls()\n\n    this.#touchstartListener = this.#handleTouchstart.bind(this)\n    this.#touchmoveListener = this.#handleTouchmove.bind(this)\n    this.#touchendListener = this.#handleTouchend.bind(this)\n    this.#touchcancelListener = this.#handleTouchcancel.bind(this)\n}",
      "kind": "constructor",
      "params": [
        "params = ..."
      ]
    },
    "isDefault": true
  },
  "/audio/audio_system.doc.js": {
    "type": "class",
    "file": "/audio/audio_system.js",
    "name": "AudioSystem",
    "line": 9,
    "extends": "PerkyModule",
    "statics": [
      {
        "name": "$category",
        "line": 11,
        "source": "static $category = 'audioSystem'",
        "kind": "property",
        "value": "'audioSystem'"
      }
    ],
    "methods": [
      {
        "name": "onInstall",
        "line": 56,
        "source": "onInstall (host) {\n    this.delegateTo(host, {\n        play: 'playSound',\n        playAt: 'playSoundAt',\n        stop: 'stopSound',\n        unlock: 'unlockAudio',\n        setVolume: 'setVolume',\n        getVolume: 'getVolume'\n    })\n\n    this.delegateEventsTo(host, [\n        'audio:play',\n        'audio:stop',\n        'audio:unlocked'\n    ], 'audio')\n\n    if (host.sourceManager) {\n        this.listenTo(host.sourceManager, 'loader:progress', (_progress, {asset, source}) => {\n            if (asset.type === 'audio' && source?.type === 'deferred_audio') {\n                this.#pendingAudio.set(asset.id, source.url)\n            }\n        })\n    }\n\n    this.#applyConfig()\n}",
        "kind": "method",
        "params": [
          "host"
        ]
      },
      {
        "name": "onStart",
        "line": 84,
        "source": "onStart () {\n    onAudioUnlock(() => this.unlock())\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "onStop",
        "line": 89,
        "source": "onStop () {\n    if (this.#unlocked) {\n        this.#audioContext.suspend()\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "onDispose",
        "line": 96,
        "source": "onDispose () {\n    this.stopAll()\n    this.#buffers.clear()\n    this.#audioContext.dispose()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "unlock",
        "line": 103,
        "source": "async unlock () {\n    if (this.#unlocked) {\n        return true\n    }\n\n    try {\n        await this.#audioContext.resume()\n        this.#unlocked = true\n        await this.#loadPendingAudio()\n        this.emit('audio:unlocked')\n        return true\n    } catch {\n        return false\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "createChannel",
        "line": 132,
        "source": "createChannel (name, options = {}) {\n    return this.create(AudioChannel, {\n        $id: name,\n        $bind: name,\n        audioContext: this.#audioContext,\n        ...options\n    })\n}",
        "kind": "method",
        "params": [
          "name",
          "options = ..."
        ]
      },
      {
        "name": "getChannel",
        "line": 142,
        "source": "getChannel (name) {\n    return this.getChild(name)\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "hasChannel",
        "line": 147,
        "source": "hasChannel (name) {\n    return this.hasChild(name)\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "listChannels",
        "line": 152,
        "source": "listChannels () {\n    return this.listNamesFor('audioChannel')\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "registerBuffer",
        "line": 157,
        "source": "registerBuffer (id, buffer) {\n    this.#buffers.set(id, buffer)\n    this.emit('buffer:registered', id, buffer)\n}",
        "kind": "method",
        "params": [
          "id",
          "buffer"
        ]
      },
      {
        "name": "registerArrayBuffer",
        "line": 163,
        "source": "async registerArrayBuffer (id, arrayBuffer) {\n    try {\n        const audioBuffer = await this.#audioContext.decodeAudioData(arrayBuffer)\n        this.registerBuffer(id, audioBuffer)\n        return audioBuffer\n    } catch (e) {\n        this.emit('buffer:error', id, e)\n        return null\n    }\n}",
        "kind": "method",
        "params": [
          "id",
          "arrayBuffer"
        ]
      },
      {
        "name": "getBuffer",
        "line": 175,
        "source": "getBuffer (id) {\n    return this.#buffers.get(id) || null\n}",
        "kind": "method",
        "params": [
          "id"
        ]
      },
      {
        "name": "hasBuffer",
        "line": 180,
        "source": "hasBuffer (id) {\n    return this.#buffers.has(id)\n}",
        "kind": "method",
        "params": [
          "id"
        ]
      },
      {
        "name": "loadBuffer",
        "line": 185,
        "source": "async loadBuffer (id, url) {\n    try {\n        const response = await fetch(url)\n        const arrayBuffer = await response.arrayBuffer()\n        return this.registerArrayBuffer(id, arrayBuffer)\n    } catch (e) {\n        this.emit('buffer:error', id, e)\n        return null\n    }\n}",
        "kind": "method",
        "params": [
          "id",
          "url"
        ]
      },
      {
        "name": "play",
        "line": 197,
        "source": "play (bufferId, options = {}) {\n    if (!this.#unlocked) {\n        return null\n    }\n\n    const buffer = this.#buffers.get(bufferId)\n\n    if (!buffer) {\n        return null\n    }\n\n    const channelName = options.channel ?? 'sfx'\n    const channel = this.getChannel(channelName)\n\n    const sourceId = options.$id ?? uniqueId(this.childrenRegistry, bufferId)\n\n    const source = new AudioSource({\n        $id: sourceId,\n        audioContext: this.#audioContext,\n        channel,\n        loop: options.loop ?? false,\n        volume: options.volume ?? 1,\n        playbackRate: options.playbackRate ?? 1\n    })\n\n    source.playBuffer(buffer, options.offset ?? 0)\n\n    this.emit('audio:play', sourceId, bufferId, options)\n\n    return source\n}",
        "kind": "method",
        "params": [
          "bufferId",
          "options = ..."
        ]
      },
      {
        "name": "playAt",
        "line": 230,
        "source": "playAt (bufferId, x, y, options = {}) {\n    return this.play(bufferId, {\n        ...options,\n        spatial: true,\n        x,\n        y\n    })\n}",
        "kind": "method",
        "params": [
          "bufferId",
          "x",
          "y",
          "options = ..."
        ]
      },
      {
        "name": "playOscillator",
        "line": 240,
        "source": "playOscillator (options = {}) {\n    if (!this.#unlocked) {\n        return null\n    }\n\n    const channel = this.getChannel(options.channel ?? 'sfx')\n    const sourceId = options.$id ?? uniqueId(this.childrenRegistry, 'oscillator')\n\n    const source = new AudioSource({\n        ...options,\n        $id: sourceId,\n        audioContext: this.#audioContext,\n        channel\n    })\n\n    source.playOscillator(options.type, options.frequency, options.duration)\n    this.emit('audio:play', sourceId, 'oscillator', options)\n\n    return source\n}",
        "kind": "method",
        "params": [
          "options = ..."
        ]
      },
      {
        "name": "playOscillatorAt",
        "line": 262,
        "source": "playOscillatorAt (x, y, options = {}) {\n    return this.playOscillator({\n        ...options,\n        spatial: true,\n        x,\n        y\n    })\n}",
        "kind": "method",
        "params": [
          "x",
          "y",
          "options = ..."
        ]
      },
      {
        "name": "stop",
        "line": 272,
        "source": "stop (sourceId) {\n    for (const channelName of this.listChannels()) {\n        const channel = this.getChannel(channelName)\n        const source = channel?.getSource(sourceId)\n        if (source) {\n            source.stop()\n            this.emit('audio:stop', sourceId)\n            return true\n        }\n    }\n    return false\n}",
        "kind": "method",
        "params": [
          "sourceId"
        ]
      },
      {
        "name": "stopChannel",
        "line": 286,
        "source": "stopChannel (channelName) {\n    const channel = this.getChannel(channelName)\n    if (channel) {\n        channel.stopAll()\n        return true\n    }\n    return false\n}",
        "kind": "method",
        "params": [
          "channelName"
        ]
      },
      {
        "name": "stopAll",
        "line": 296,
        "source": "stopAll () {\n    for (const channelName of this.listChannels()) {\n        this.stopChannel(channelName)\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "setVolume",
        "line": 303,
        "source": "setVolume (value) {\n    this.masterVolume = value\n    this.emit('volume:changed', value)\n    return this\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "getVolume",
        "line": 310,
        "source": "getVolume () {\n    return this.masterVolume\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "setChannelVolume",
        "line": 315,
        "source": "setChannelVolume (channelName, value) {\n    const channel = this.getChannel(channelName)\n    if (channel) {\n        channel.setVolume(value)\n    }\n    return this\n}",
        "kind": "method",
        "params": [
          "channelName",
          "value"
        ]
      },
      {
        "name": "getChannelVolume",
        "line": 324,
        "source": "getChannelVolume (channelName) {\n    const channel = this.getChannel(channelName)\n    return channel ? channel.getVolume() : 0\n}",
        "kind": "method",
        "params": [
          "channelName"
        ]
      },
      {
        "name": "muteChannel",
        "line": 330,
        "source": "muteChannel (channelName) {\n    const channel = this.getChannel(channelName)\n    if (channel) {\n        channel.mute()\n    }\n    return this\n}",
        "kind": "method",
        "params": [
          "channelName"
        ]
      },
      {
        "name": "unmuteChannel",
        "line": 339,
        "source": "unmuteChannel (channelName) {\n    const channel = this.getChannel(channelName)\n    if (channel) {\n        channel.unmute()\n    }\n    return this\n}",
        "kind": "method",
        "params": [
          "channelName"
        ]
      },
      {
        "name": "setListenerPosition",
        "line": 348,
        "source": "setListenerPosition (x, y) {\n    this.#audioContext.setListenerPosition(x, y, 0)\n    return this\n}",
        "kind": "method",
        "params": [
          "x",
          "y"
        ]
      },
      {
        "name": "getListenerPosition",
        "line": 354,
        "source": "getListenerPosition () {\n    const pos = this.#audioContext.getListenerPosition()\n    return {x: pos.x, y: pos.y}\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "audioContext",
        "line": 31,
        "source": "get audioContext () {\n    return this.#audioContext\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "unlocked",
        "line": 36,
        "source": "get unlocked () {\n    return this.#unlocked\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "currentTime",
        "line": 41,
        "source": "get currentTime () {\n    return this.#audioContext.currentTime\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "masterVolume",
        "line": 46,
        "source": "get masterVolume () {\n    return this.#audioContext.getMasterVolume()\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "masterVolume",
        "line": 51,
        "source": "set masterVolume (value) {\n    this.#audioContext.setMasterVolume(value)\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      }
    ],
    "constructor": {
      "name": "constructor",
      "line": 18,
      "source": "constructor (options = {}) {\n    super(options)\n\n    this.#audioContext = new AudioContext()\n\n    const defaultChannels = options.channels ?? ['music', 'sfx', 'ambiance']\n\n    for (const channelName of defaultChannels) {\n        this.createChannel(channelName)\n    }\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/audio/audio_channel.doc.js": {
    "type": "class",
    "file": "/audio/audio_channel.js",
    "name": "AudioChannel",
    "line": 4,
    "extends": "PerkyModule",
    "statics": [
      {
        "name": "$category",
        "line": 6,
        "source": "static $category = 'audioChannel'",
        "kind": "property",
        "value": "'audioChannel'"
      }
    ],
    "methods": [
      {
        "name": "onInstall",
        "line": 64,
        "source": "onInstall () {\n\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "onDispose",
        "line": 69,
        "source": "onDispose () {\n    this.stopAll()\n\n    if (this.#gainNode) {\n        this.#gainNode.disconnect()\n        this.#gainNode = null\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "registerSource",
        "line": 90,
        "source": "registerSource (source) {\n    if (!source || !source.$id) {\n        return false\n    }\n\n    this.#sources.set(source.$id, source)\n    this.emit('source:added', source)\n\n    return true\n}",
        "kind": "method",
        "params": [
          "source"
        ]
      },
      {
        "name": "unregisterSource",
        "line": 102,
        "source": "unregisterSource (source) {\n    if (!source || !this.#sources.has(source.$id)) {\n        return false\n    }\n\n    this.#sources.delete(source.$id)\n    this.emit('source:removed', source)\n\n    return true\n}",
        "kind": "method",
        "params": [
          "source"
        ]
      },
      {
        "name": "getSource",
        "line": 114,
        "source": "getSource (id) {\n    return this.#sources.get(id) || null\n}",
        "kind": "method",
        "params": [
          "id"
        ]
      },
      {
        "name": "hasSource",
        "line": 119,
        "source": "hasSource (id) {\n    return this.#sources.has(id)\n}",
        "kind": "method",
        "params": [
          "id"
        ]
      },
      {
        "name": "stopAll",
        "line": 124,
        "source": "stopAll () {\n    for (const source of this.#sources.values()) {\n        if (source.stop) {\n            source.stop()\n        }\n    }\n\n    this.#sources.clear()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "setVolume",
        "line": 135,
        "source": "setVolume (value) {\n    this.volume = value\n    this.emit('volume:changed', this.#volume)\n    return this\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "getVolume",
        "line": 142,
        "source": "getVolume () {\n    return this.#volume\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "mute",
        "line": 147,
        "source": "mute () {\n    this.muted = true\n    this.emit('muted')\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "unmute",
        "line": 154,
        "source": "unmute () {\n    this.muted = false\n    this.emit('unmuted')\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "toggleMute",
        "line": 161,
        "source": "toggleMute () {\n    if (this.#muted) {\n        this.unmute()\n    } else {\n        this.mute()\n    }\n    return this\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "volume",
        "line": 22,
        "source": "get volume () {\n    return this.#volume\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "muted",
        "line": 33,
        "source": "get muted () {\n    return this.#muted\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "gainNode",
        "line": 44,
        "source": "get gainNode () {\n    if (!this.#gainNode && this.#audioContext) {\n        this.#gainNode = this.#audioContext.createGain()\n        this.#gainNode.connect(this.#audioContext.masterGain)\n        this.#updateGain()\n    }\n    return this.#gainNode\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "sources",
        "line": 54,
        "source": "get sources () {\n    return Array.from(this.#sources.values())\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "sourceCount",
        "line": 59,
        "source": "get sourceCount () {\n    return this.#sources.size\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "volume",
        "line": 27,
        "source": "set volume (value) {\n    this.#volume = Math.max(0, Math.min(1, value))\n    this.#updateGain()\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "muted",
        "line": 38,
        "source": "set muted (value) {\n    this.#muted = Boolean(value)\n    this.#updateGain()\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      }
    ],
    "constructor": {
      "name": "constructor",
      "line": 14,
      "source": "constructor (options = {}) {\n    super(options)\n\n    this.#audioContext = options.audioContext\n    this.#volume = options.volume ?? 1\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/audio/audio_context.doc.js": {
    "type": "class",
    "file": "/audio/audio_context.js",
    "name": "AudioContext",
    "line": 2,
    "extends": null,
    "statics": [],
    "methods": [
      {
        "name": "init",
        "line": 40,
        "source": "init () {\n    if (this.#context) {\n        return this.#context\n    }\n\n    const AudioContextClass = window.AudioContext || window.webkitAudioContext\n\n    if (!AudioContextClass) {\n        throw new Error('Web Audio API is not supported in this browser')\n    }\n\n    this.#context = new AudioContextClass()\n    this.#masterGain = this.#context.createGain()\n    this.#masterGain.gain.setValueAtTime(this.#masterVolume, this.#context.currentTime)\n    this.#masterGain.connect(this.#context.destination)\n    this.#suspended = this.#context.state === 'suspended'\n\n    if (this.#context.state === 'running') {\n        this.#processPendingDecodes()\n    }\n\n    return this.#context\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "resume",
        "line": 75,
        "source": "async resume () {\n    if (!this.#context) {\n        this.init()\n    }\n\n    if (this.#context.state === 'suspended') {\n        await this.#context.resume()\n        this.#suspended = false\n    }\n\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "suspend",
        "line": 89,
        "source": "suspend () {\n    if (this.#context && this.#context.state === 'running') {\n        this.#context.suspend()\n        this.#suspended = true\n    }\n\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "setMasterVolume",
        "line": 99,
        "source": "setMasterVolume (value) {\n    this.#masterVolume = Math.max(0, Math.min(1, value))\n\n    if (this.#masterGain) {\n        this.#masterGain.gain.setValueAtTime(\n            this.#masterVolume,\n            this.#context.currentTime\n        )\n    }\n\n    return this\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "getMasterVolume",
        "line": 113,
        "source": "getMasterVolume () {\n    return this.#masterVolume\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "createGain",
        "line": 118,
        "source": "createGain () {\n    this.init()\n    return this.#context.createGain()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "createOscillator",
        "line": 124,
        "source": "createOscillator () {\n    this.init()\n    return this.#context.createOscillator()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "createBufferSource",
        "line": 130,
        "source": "createBufferSource () {\n    this.init()\n    return this.#context.createBufferSource()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "createPanner",
        "line": 136,
        "source": "createPanner () {\n    this.init()\n    return this.#context.createPanner()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "createStereoPanner",
        "line": 142,
        "source": "createStereoPanner () {\n    this.init()\n    return this.#context.createStereoPanner()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "decodeAudioData",
        "line": 148,
        "source": "async decodeAudioData (arrayBuffer) {\n    this.init()\n\n    if (this.#context.state === 'suspended') {\n        return new Promise((resolve, reject) => {\n            this.#pendingDecodes.push({buffer: arrayBuffer, resolve, reject})\n        })\n    }\n\n    return this.#context.decodeAudioData(arrayBuffer)\n}",
        "kind": "method",
        "params": [
          "arrayBuffer"
        ]
      },
      {
        "name": "setListenerPosition",
        "line": 161,
        "source": "setListenerPosition (x, y, z = 0) {\n    this.init()\n    const listener = this.#context.listener\n\n    if (listener.positionX) {\n        listener.positionX.setValueAtTime(x, this.#context.currentTime)\n        listener.positionY.setValueAtTime(y, this.#context.currentTime)\n        listener.positionZ.setValueAtTime(z, this.#context.currentTime)\n    } else if (listener.setPosition) {\n        listener.setPosition(x, y, z)\n    }\n\n    return this\n}",
        "kind": "method",
        "params": [
          "x",
          "y",
          "z = ..."
        ]
      },
      {
        "name": "getListenerPosition",
        "line": 177,
        "source": "getListenerPosition () {\n    if (!this.#context?.listener) {\n        return {x: 0, y: 0, z: 0}\n    }\n\n    const listener = this.#context.listener\n\n    if (listener.positionX) {\n        return {\n            x: listener.positionX.value,\n            y: listener.positionY.value,\n            z: listener.positionZ.value\n        }\n    }\n\n    return {x: 0, y: 0, z: 0}\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "dispose",
        "line": 196,
        "source": "dispose () {\n    if (this.#context) {\n        this.#context.close()\n        this.#context = null\n        this.#masterGain = null\n    }\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "context",
        "line": 10,
        "source": "get context () {\n    return this.#context\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "masterGain",
        "line": 15,
        "source": "get masterGain () {\n    return this.#masterGain\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "currentTime",
        "line": 20,
        "source": "get currentTime () {\n    return this.#context?.currentTime ?? 0\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "suspended",
        "line": 25,
        "source": "get suspended () {\n    return this.#suspended\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "sampleRate",
        "line": 30,
        "source": "get sampleRate () {\n    return this.#context?.sampleRate ?? 44100\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "listener",
        "line": 35,
        "source": "get listener () {\n    return this.#context?.listener ?? null\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [],
    "constructor": null,
    "isDefault": true
  },
  "/audio/audio_source.doc.js": {
    "type": "class",
    "file": "/audio/audio_source.js",
    "name": "AudioSource",
    "line": 4,
    "extends": "PerkyModule",
    "statics": [
      {
        "name": "$category",
        "line": 6,
        "source": "static $category = 'audioSource'",
        "kind": "property",
        "value": "'audioSource'"
      },
      {
        "name": "$lifecycle",
        "line": 7,
        "source": "static $lifecycle = false",
        "kind": "property",
        "value": "false"
      }
    ],
    "methods": [
      {
        "name": "playBuffer",
        "line": 234,
        "source": "playBuffer (buffer, offset = 0) {\n    if (!this.#audioContext || !buffer) {\n        return false\n    }\n\n    this.stop()\n    this.#setupNodes()\n\n    this.#sourceNode = this.#audioContext.createBufferSource()\n    this.#sourceNode.buffer = buffer\n    this.#sourceNode.loop = this.#loop\n    this.#sourceNode.playbackRate.setValueAtTime(\n        this.#playbackRate,\n        this.#audioContext.context.currentTime\n    )\n    this.#sourceNode.connect(this.#gainNode)\n\n    this.#sourceNode.onended = () => {\n        if (this.#playing && !this.#loop) {\n            this.#playing = false\n            this.emit('ended')\n            this.#channel?.unregisterSource(this)\n        }\n    }\n\n    this.#sourceNode.start(0, offset)\n    this.#startTime = this.#audioContext.currentTime - offset\n    this.#playing = true\n\n    this.#channel?.registerSource(this)\n    this.emit('play')\n\n    return true\n}",
        "kind": "method",
        "params": [
          "buffer",
          "offset = ..."
        ]
      },
      {
        "name": "playOscillator",
        "line": 270,
        "source": "playOscillator (type = 'sine', frequency = 440, duration = null) {\n    if (!this.#audioContext) {\n        return false\n    }\n\n    this.stop()\n    this.#setupNodes()\n\n    this.#sourceNode = this.#audioContext.createOscillator()\n    this.#sourceNode.type = type\n    this.#sourceNode.frequency.setValueAtTime(\n        frequency,\n        this.#audioContext.context.currentTime\n    )\n    this.#sourceNode.connect(this.#gainNode)\n\n    this.#sourceNode.onended = () => {\n        if (this.#playing) {\n            this.#playing = false\n            this.emit('ended')\n            this.#channel?.unregisterSource(this)\n        }\n    }\n\n    this.#sourceNode.start()\n    this.#startTime = this.#audioContext.currentTime\n    this.#playing = true\n\n    if (duration !== null && duration > 0) {\n        this.#sourceNode.stop(this.#audioContext.context.currentTime + duration)\n    }\n\n    this.#channel?.registerSource(this)\n    this.emit('play')\n\n    return true\n}",
        "kind": "method",
        "params": [
          "type = ...",
          "frequency = ...",
          "duration = ..."
        ]
      },
      {
        "name": "stop",
        "line": 309,
        "source": "stop () {\n    if (!this.#playing) {\n        return false\n    }\n\n    this.#playing = false\n    this.#pauseTime = 0\n\n    if (this.#sourceNode) {\n        try {\n            this.#sourceNode.stop()\n        } catch {\n\n        }\n    }\n\n    this.#cleanupSourceNode()\n\n    if (this.#pannerNode) {\n        this.#pannerNode.disconnect()\n        this.#pannerNode = null\n    }\n\n    if (this.#gainNode) {\n        this.#gainNode.disconnect()\n        this.#gainNode = null\n    }\n\n    this.#channel?.unregisterSource(this)\n    this.emit('stop')\n\n    return true\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "setPosition",
        "line": 344,
        "source": "setPosition (x, y) {\n    this.#x = x\n    this.#y = y\n    this.#updatePannerPosition()\n    return this\n}",
        "kind": "method",
        "params": [
          "x",
          "y"
        ]
      },
      {
        "name": "getPosition",
        "line": 352,
        "source": "getPosition () {\n    return {x: this.#x, y: this.#y}\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "setVolume",
        "line": 357,
        "source": "setVolume (value) {\n    this.volume = value\n    return this\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "getVolume",
        "line": 363,
        "source": "getVolume () {\n    return this.#volume\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "setLoop",
        "line": 368,
        "source": "setLoop (value) {\n    this.loop = value\n    return this\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "setPlaybackRate",
        "line": 374,
        "source": "setPlaybackRate (value) {\n    this.playbackRate = value\n    return this\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "fadeIn",
        "line": 380,
        "source": "fadeIn (duration = 1) {\n    if (!this.#gainNode || !this.#audioContext?.context) {\n        return this\n    }\n\n    const ctx = this.#audioContext.context\n    this.#gainNode.gain.setValueAtTime(0, ctx.currentTime)\n    this.#gainNode.gain.linearRampToValueAtTime(this.#volume, ctx.currentTime + duration)\n\n    return this\n}",
        "kind": "method",
        "params": [
          "duration = ..."
        ]
      },
      {
        "name": "fadeOut",
        "line": 393,
        "source": "fadeOut (duration = 1, stopAfter = true) {\n    if (!this.#gainNode || !this.#audioContext?.context) {\n        return this\n    }\n\n    const ctx = this.#audioContext.context\n    this.#gainNode.gain.setValueAtTime(this.#gainNode.gain.value, ctx.currentTime)\n    this.#gainNode.gain.linearRampToValueAtTime(0, ctx.currentTime + duration)\n\n    if (stopAfter) {\n        setTimeout(() => this.stop(), duration * 1000)\n    }\n\n    return this\n}",
        "kind": "method",
        "params": [
          "duration = ...",
          "stopAfter = ..."
        ]
      },
      {
        "name": "onDispose",
        "line": 410,
        "source": "onDispose () {\n    this.stop()\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "playing",
        "line": 50,
        "source": "get playing () {\n    return this.#playing\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "loop",
        "line": 55,
        "source": "get loop () {\n    return this.#loop\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "volume",
        "line": 68,
        "source": "get volume () {\n    return this.#volume\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "playbackRate",
        "line": 79,
        "source": "get playbackRate () {\n    return this.#playbackRate\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "channel",
        "line": 95,
        "source": "get channel () {\n    return this.#channel\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "gainNode",
        "line": 100,
        "source": "get gainNode () {\n    return this.#gainNode\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "sourceNode",
        "line": 105,
        "source": "get sourceNode () {\n    return this.#sourceNode\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "currentTime",
        "line": 110,
        "source": "get currentTime () {\n    if (!this.#playing) {\n        return this.#pauseTime\n    }\n\n    return this.#audioContext.currentTime - this.#startTime\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "x",
        "line": 119,
        "source": "get x () {\n    return this.#x\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "y",
        "line": 130,
        "source": "get y () {\n    return this.#y\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "spatial",
        "line": 141,
        "source": "get spatial () {\n    return this.#spatial\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "refDistance",
        "line": 146,
        "source": "get refDistance () {\n    return this.#refDistance\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "maxDistance",
        "line": 151,
        "source": "get maxDistance () {\n    return this.#maxDistance\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "rolloffFactor",
        "line": 156,
        "source": "get rolloffFactor () {\n    return this.#rolloffFactor\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "loop",
        "line": 60,
        "source": "set loop (value) {\n    this.#loop = Boolean(value)\n    if (this.#sourceNode && 'loop' in this.#sourceNode) {\n        this.#sourceNode.loop = this.#loop\n    }\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "volume",
        "line": 73,
        "source": "set volume (value) {\n    this.#volume = Math.max(0, Math.min(1, value))\n    this.#updateGain()\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "playbackRate",
        "line": 84,
        "source": "set playbackRate (value) {\n    this.#playbackRate = Math.max(0.1, Math.min(10, value))\n    if (this.#sourceNode && 'playbackRate' in this.#sourceNode) {\n        this.#sourceNode.playbackRate.setValueAtTime(\n            this.#playbackRate,\n            this.#audioContext.context.currentTime\n        )\n    }\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "x",
        "line": 124,
        "source": "set x (value) {\n    this.#x = value\n    this.#updatePannerPosition()\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "y",
        "line": 135,
        "source": "set y (value) {\n    this.#y = value\n    this.#updatePannerPosition()\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      }
    ],
    "constructor": {
      "name": "constructor",
      "line": 27,
      "source": "constructor (options = {}) {\n    super(options)\n\n    this.#audioContext = options.audioContext\n    this.#channel = options.channel\n    this.#loop = options.loop ?? false\n    this.#volume = options.volume ?? 1\n    this.#playbackRate = options.playbackRate ?? 1\n    this.#spatial = options.spatial ?? false\n\n    this.#initSpatialOptions(options)\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/audio/audio_unlock.doc.js": {
    "type": "module",
    "file": "/audio/audio_unlock.js",
    "functions": [
      {
        "name": "handleUnlock",
        "line": 7,
        "params": [],
        "source": "function handleUnlock () {\n    if (unlocked) {\n        return\n    }\n\n    unlocked = true\n\n    for (const callback of pendingCallbacks) {\n        callback()\n    }\n\n    pendingCallbacks = []\n    cleanup()\n}"
      },
      {
        "name": "cleanup",
        "line": 23,
        "params": [],
        "source": "function cleanup () {\n    for (const event of unlockEvents) {\n        document.removeEventListener(event, handleUnlock, true)\n    }\n    window.removeEventListener('gamepadconnected', handleUnlock)\n}"
      },
      {
        "name": "onAudioUnlock",
        "line": 38,
        "params": [
          "callback"
        ],
        "source": "function onAudioUnlock (callback) {\n    if (unlocked) {\n        callback()\n    } else {\n        pendingCallbacks.push(callback)\n    }\n}"
      },
      {
        "name": "isAudioUnlocked",
        "line": 47,
        "params": [],
        "source": "function isAudioUnlocked () {\n    return unlocked\n}"
      }
    ],
    "exports": []
  },
  "/audio/patterns/pattern.doc.js": {
    "type": "class",
    "file": "/audio/patterns/pattern.js",
    "name": "Pattern",
    "line": 4,
    "extends": "PerkyModule",
    "statics": [
      {
        "name": "$category",
        "line": 6,
        "source": "static $category = 'pattern'",
        "kind": "property",
        "value": "'pattern'"
      },
      {
        "name": "$lifecycle",
        "line": 7,
        "source": "static $lifecycle = false",
        "kind": "property",
        "value": "false"
      }
    ],
    "methods": [
      {
        "name": "setPattern",
        "line": 99,
        "source": "setPattern (pattern) {\n    this.#steps = typeof pattern === 'string' ? parsePattern(pattern) : pattern\n    this.reset()\n    return this\n}",
        "kind": "method",
        "params": [
          "pattern"
        ]
      },
      {
        "name": "setSteps",
        "line": 106,
        "source": "setSteps (steps) {\n    this.#steps = steps\n    this.reset()\n    return this\n}",
        "kind": "method",
        "params": [
          "steps"
        ]
      },
      {
        "name": "setBpm",
        "line": 113,
        "source": "setBpm (value) {\n    this.bpm = value\n    return this\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "setSwing",
        "line": 119,
        "source": "setSwing (value) {\n    this.swing = value\n    return this\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "play",
        "line": 125,
        "source": "play () {\n    if (this.#playing) {\n        return this\n    }\n\n    this.#playing = true\n    this.emit('play')\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "stop",
        "line": 136,
        "source": "stop () {\n    if (!this.#playing) {\n        return this\n    }\n\n    this.#playing = false\n    this.emit('stop')\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "reset",
        "line": 147,
        "source": "reset () {\n    this.#currentStep = 0\n    this.#elapsed = 0\n    this.emit('reset')\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "update",
        "line": 155,
        "source": "update (delta) {\n    if (!this.#playing || this.#steps.length === 0) {\n        return\n    }\n\n    this.#elapsed += delta\n\n    const swingOffset = this.#currentStep % 2 === 1 ? this.#swing * this.#stepDuration * 0.5 : 0\n    const targetDuration = this.#stepDuration + swingOffset\n\n    while (this.#elapsed >= targetDuration) {\n        this.#elapsed -= targetDuration\n\n        const step = this.#steps[this.#currentStep]\n        this.#triggerStep(step, this.#currentStep)\n\n        this.#currentStep++\n\n        if (this.#currentStep >= this.#steps.length) {\n            if (this.#loop) {\n                this.#currentStep = 0\n                this.emit('loop')\n            } else {\n                this.#playing = false\n                this.emit('complete')\n                return\n            }\n        }\n    }\n}",
        "kind": "method",
        "params": [
          "delta"
        ]
      },
      {
        "name": "onStep",
        "line": 204,
        "source": "onStep (callback) {\n    this.on('step', callback)\n    return this\n}",
        "kind": "method",
        "params": [
          "callback"
        ]
      },
      {
        "name": "map",
        "line": 210,
        "source": "map (fn) {\n    const newSteps = this.#steps.map((step, i) => fn(step, i))\n    return new Pattern({\n        steps: newSteps,\n        bpm: this.#bpm,\n        loop: this.#loop,\n        swing: this.#swing\n    })\n}",
        "kind": "method",
        "params": [
          "fn"
        ]
      },
      {
        "name": "reverse",
        "line": 221,
        "source": "reverse () {\n    return new Pattern({\n        steps: [...this.#steps].reverse(),\n        bpm: this.#bpm,\n        loop: this.#loop,\n        swing: this.#swing\n    })\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "fast",
        "line": 231,
        "source": "fast (factor) {\n    return new Pattern({\n        steps: this.#steps,\n        bpm: this.#bpm * factor,\n        loop: this.#loop,\n        swing: this.#swing\n    })\n}",
        "kind": "method",
        "params": [
          "factor"
        ]
      },
      {
        "name": "slow",
        "line": 241,
        "source": "slow (factor) {\n    return this.fast(1 / factor)\n}",
        "kind": "method",
        "params": [
          "factor"
        ]
      },
      {
        "name": "every",
        "line": 246,
        "source": "every (n, fn) {\n    let count = 0\n    const newPattern = new Pattern({\n        steps: this.#steps,\n        bpm: this.#bpm,\n        loop: this.#loop,\n        swing: this.#swing\n    })\n\n    newPattern.on('loop', () => {\n        count++\n        if (count % n === 0) {\n            fn(newPattern)\n        }\n    })\n\n    return newPattern\n}",
        "kind": "method",
        "params": [
          "n",
          "fn"
        ]
      }
    ],
    "getters": [
      {
        "name": "steps",
        "line": 35,
        "source": "get steps () {\n    return this.#steps\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "stepCount",
        "line": 40,
        "source": "get stepCount () {\n    return this.#steps.length\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "bpm",
        "line": 45,
        "source": "get bpm () {\n    return this.#bpm\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "playing",
        "line": 56,
        "source": "get playing () {\n    return this.#playing\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "currentStep",
        "line": 61,
        "source": "get currentStep () {\n    return this.#currentStep\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "loop",
        "line": 66,
        "source": "get loop () {\n    return this.#loop\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "swing",
        "line": 76,
        "source": "get swing () {\n    return this.#swing\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "progress",
        "line": 86,
        "source": "get progress () {\n    if (this.#steps.length === 0) {\n        return 0\n    }\n    return this.#currentStep / this.#steps.length\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "bpm",
        "line": 50,
        "source": "set bpm (value) {\n    this.#bpm = Math.max(1, Math.min(999, value))\n    this.#updateStepDuration()\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "loop",
        "line": 71,
        "source": "set loop (value) {\n    this.#loop = Boolean(value)\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "swing",
        "line": 81,
        "source": "set swing (value) {\n    this.#swing = Math.max(0, Math.min(1, value))\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      }
    ],
    "constructor": {
      "name": "constructor",
      "line": 18,
      "source": "constructor (options = {}) {\n    super(options)\n\n    this.#bpm = options.bpm ?? 120\n    this.#loop = options.loop ?? true\n    this.#swing = options.swing ?? 0\n\n    if (options.steps) {\n        this.#steps = options.steps\n    } else if (options.pattern) {\n        this.#steps = parsePattern(options.pattern)\n    }\n\n    this.#updateStepDuration()\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/audio/patterns/sequencer.doc.js": {
    "type": "class",
    "file": "/audio/patterns/sequencer.js",
    "name": "Sequencer",
    "line": 5,
    "extends": "PerkyModule",
    "statics": [
      {
        "name": "$category",
        "line": 7,
        "source": "static $category = 'sequencer'",
        "kind": "property",
        "value": "'sequencer'"
      }
    ],
    "methods": [
      {
        "name": "onInstall",
        "line": 55,
        "source": "onInstall (host) {\n    this.delegateTo(host, [\n        'addPattern',\n        'removePattern',\n        'getPattern',\n        'hasPattern',\n        'playPatterns',\n        'stopPatterns',\n        'setBpm'\n    ])\n}",
        "kind": "method",
        "params": [
          "host"
        ]
      },
      {
        "name": "setBpm",
        "line": 68,
        "source": "setBpm (value) {\n    this.bpm = value\n    return this\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "addPattern",
        "line": 74,
        "source": "addPattern (name, patternOrString, options = {}) {\n    let pattern\n\n    if (patternOrString instanceof Pattern) {\n        pattern = patternOrString\n    } else {\n        pattern = new Pattern({\n            pattern: patternOrString,\n            bpm: this.#bpm,\n            ...options\n        })\n    }\n\n    pattern.$id = name\n\n    if (options.sounds && this.#audioSystem) {\n        this.#bindPatternToSounds(pattern, options.sounds)\n    }\n\n    if (options.onStep) {\n        pattern.onStep(options.onStep)\n    }\n\n    this.#patterns.set(name, pattern)\n\n    if (this.#playing) {\n        pattern.play()\n    }\n\n    this.emit('pattern:added', name, pattern)\n    return pattern\n}",
        "kind": "method",
        "params": [
          "name",
          "patternOrString",
          "options = ..."
        ]
      },
      {
        "name": "removePattern",
        "line": 154,
        "source": "removePattern (name) {\n    const pattern = this.#patterns.get(name)\n\n    if (!pattern) {\n        return false\n    }\n\n    pattern.stop()\n    this.#patterns.delete(name)\n    this.emit('pattern:removed', name)\n    return true\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "getPattern",
        "line": 168,
        "source": "getPattern (name) {\n    return this.#patterns.get(name) || null\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "hasPattern",
        "line": 173,
        "source": "hasPattern (name) {\n    return this.#patterns.has(name)\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "playPatterns",
        "line": 178,
        "source": "playPatterns () {\n    if (this.#playing) {\n        return this\n    }\n\n    this.#playing = true\n\n    for (const pattern of this.#patterns.values()) {\n        pattern.play()\n    }\n\n    this.emit('play')\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "stopPatterns",
        "line": 194,
        "source": "stopPatterns () {\n    if (!this.#playing) {\n        return this\n    }\n\n    this.#playing = false\n\n    for (const pattern of this.#patterns.values()) {\n        pattern.stop()\n    }\n\n    this.emit('stop')\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "resetAll",
        "line": 210,
        "source": "resetAll () {\n    for (const pattern of this.#patterns.values()) {\n        pattern.reset()\n    }\n\n    this.emit('reset')\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "update",
        "line": 220,
        "source": "update (delta) {\n    if (!this.#playing) {\n        return\n    }\n\n    for (const pattern of this.#patterns.values()) {\n        pattern.update(delta)\n    }\n}",
        "kind": "method",
        "params": [
          "delta"
        ]
      },
      {
        "name": "clear",
        "line": 231,
        "source": "clear () {\n    this.stopPatterns()\n\n    for (const name of this.#patterns.keys()) {\n        this.removePattern(name)\n    }\n\n    return this\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "onDispose",
        "line": 242,
        "source": "onDispose () {\n    this.clear()\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "audioSystem",
        "line": 22,
        "source": "get audioSystem () {\n    return this.#audioSystem\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "playing",
        "line": 27,
        "source": "get playing () {\n    return this.#playing\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "bpm",
        "line": 32,
        "source": "get bpm () {\n    return this.#bpm\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "patterns",
        "line": 45,
        "source": "get patterns () {\n    return Array.from(this.#patterns.values())\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "patternCount",
        "line": 50,
        "source": "get patternCount () {\n    return this.#patterns.size\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "bpm",
        "line": 37,
        "source": "set bpm (value) {\n    this.#bpm = Math.max(1, Math.min(999, value))\n    for (const pattern of this.#patterns.values()) {\n        pattern.bpm = this.#bpm\n    }\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      }
    ],
    "constructor": {
      "name": "constructor",
      "line": 14,
      "source": "constructor (options = {}) {\n    super(options)\n\n    this.#audioSystem = options.audioSystem\n    this.#bpm = options.bpm ?? 120\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/editor/number_input.doc.js": {
    "type": "class",
    "file": "/editor/number_input.js",
    "name": "NumberInput",
    "line": 191,
    "extends": "EditorComponent",
    "statics": [
      {
        "name": "styles",
        "line": 193,
        "source": "static styles = [controlsSheet, numberInputCSS]",
        "kind": "property",
        "value": "[controlsSheet, numberInputCSS]"
      },
      {
        "name": "observedAttributes",
        "line": 239,
        "source": "static get observedAttributes () {\n    return ['value', 'step', 'precision', 'label', 'min', 'max']\n}",
        "kind": "method",
        "params": []
      }
    ],
    "methods": [
      {
        "name": "onConnected",
        "line": 250,
        "source": "onConnected () {\n    this.#updateDisplay()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "onDisconnected",
        "line": 255,
        "source": "onDisconnected () {\n    if (this.#isDragging) {\n        this.#onDragEnd()\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "attributeChangedCallback",
        "line": 262,
        "source": "attributeChangedCallback (name, oldValue, newValue) {\n    handleAttributeChange(this, name, oldValue, newValue)\n}",
        "kind": "method",
        "params": [
          "name",
          "oldValue",
          "newValue"
        ]
      },
      {
        "name": "setValue",
        "line": 281,
        "source": "setValue (val) {\n    this.#value = val\n    this.#updateDisplay()\n}",
        "kind": "method",
        "params": [
          "val"
        ]
      },
      {
        "name": "setStep",
        "line": 287,
        "source": "setStep (val) {\n    this.#step = val\n}",
        "kind": "method",
        "params": [
          "val"
        ]
      },
      {
        "name": "setPrecision",
        "line": 292,
        "source": "setPrecision (val) {\n    this.#precision = val\n    this.#updateDisplay()\n}",
        "kind": "method",
        "params": [
          "val"
        ]
      },
      {
        "name": "setLabel",
        "line": 298,
        "source": "setLabel (val) {\n    this.#label = val\n    if (this.#labelEl) {\n        this.#labelEl.textContent = this.#label\n    }\n}",
        "kind": "method",
        "params": [
          "val"
        ]
      },
      {
        "name": "setMin",
        "line": 306,
        "source": "setMin (val) {\n    this.#min = val\n}",
        "kind": "method",
        "params": [
          "val"
        ]
      },
      {
        "name": "setMax",
        "line": 311,
        "source": "setMax (val) {\n    this.#max = val\n}",
        "kind": "method",
        "params": [
          "val"
        ]
      },
      {
        "name": "setCompact",
        "line": 316,
        "source": "setCompact (val) {\n    if (val) {\n        this.setAttribute('compact', '')\n    } else {\n        this.removeAttribute('compact')\n    }\n}",
        "kind": "method",
        "params": [
          "val"
        ]
      }
    ],
    "getters": [
      {
        "name": "value",
        "line": 267,
        "source": "get value () {\n    return this.#value\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "value",
        "line": 272,
        "source": "set value (val) {\n    const newValue = this.#clamp(parseFloat(val) || 0)\n    if (this.#value !== newValue) {\n        this.#value = newValue\n        this.#updateDisplay()\n    }\n}",
        "kind": "method",
        "params": [
          "val"
        ]
      }
    ],
    "constructor": {
      "name": "constructor",
      "line": 244,
      "source": "constructor () {\n    super()\n    this.#buildDOM()\n}",
      "kind": "constructor",
      "params": []
    },
    "isDefault": true
  },
  "/editor/perky_explorer.doc.js": {
    "type": "class",
    "file": "/editor/perky_explorer.js",
    "name": "PerkyExplorer",
    "line": 63,
    "extends": "EditorComponent",
    "statics": [
      {
        "name": "observedAttributes",
        "line": 65,
        "source": "static observedAttributes = ['embedded']",
        "kind": "property",
        "value": "['embedded']"
      },
      {
        "name": "styles",
        "line": 67,
        "source": "static styles = `${explorerStyles} ${containerStyles}`",
        "kind": "property",
        "value": "`${explorerStyles} ${containerStyles}`"
      }
    ],
    "methods": [
      {
        "name": "onConnected",
        "line": 94,
        "source": "onConnected () {\n    this.#buildDOM()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "onDisconnected",
        "line": 99,
        "source": "onDisconnected () {\n    if (this.#contextMenuEl && this.#contextMenuEl.parentNode) {\n        this.#contextMenuEl.parentNode.removeChild(this.#contextMenuEl)\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "attributeChangedCallback",
        "line": 106,
        "source": "attributeChangedCallback (name, oldValue, newValue) {\n    if (oldValue === newValue) {\n        return\n    }\n\n    if (name === 'embedded') {\n        this.#embedded = newValue !== null\n        this.#updateEmbeddedMode()\n    }\n}",
        "kind": "method",
        "params": [
          "name",
          "oldValue",
          "newValue"
        ]
      },
      {
        "name": "isSystemModule",
        "line": 160,
        "source": "isSystemModule (module) {\n    return module && this.#systemCategories.includes(module.$category)\n}",
        "kind": "method",
        "params": [
          "module"
        ]
      },
      {
        "name": "setModule",
        "line": 165,
        "source": "setModule (module) {\n    this.#module = module\n    this.#rootModule = module\n    this.#selectedModule = null\n\n    if (this.#rootNode) {\n        this.#rootNode.setModule(module, 0)\n        if (module) {\n            this.#rootNode.setExpanded(true)\n        }\n    }\n\n    this.#updateTreeVisibility()\n    this.#updateDetails()\n    this.#updateHeaderControls()\n    this.#closeSceneTree()\n}",
        "kind": "method",
        "params": [
          "module"
        ]
      },
      {
        "name": "getModule",
        "line": 184,
        "source": "getModule () {\n    return this.#module\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "focusModule",
        "line": 588,
        "source": "focusModule (module) {\n    if (!module) {\n        return\n    }\n\n    this.#rootModule = module\n    this.#rootNode.setModule(module, 0)\n    this.#rootNode.setExpanded(true)\n    this.#updateHeaderControls()\n\n\n    if (this.#selectedModule) {\n        const node = this.#rootNode.findNode(n => n.getModule() === this.#selectedModule)\n        if (node) {\n            node.setSelected(true)\n        } else {\n\n\n            this.#handleNodeSelect(module)\n        }\n    }\n}",
        "kind": "method",
        "params": [
          "module"
        ]
      }
    ],
    "getters": [
      {
        "name": "embedded",
        "line": 118,
        "source": "get embedded () {\n    return this.#embedded\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "systemCategories",
        "line": 134,
        "source": "get systemCategories () {\n    return this.#systemCategories\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "showSystemModules",
        "line": 145,
        "source": "get showSystemModules () {\n    return this.#showSystemModules\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "embedded",
        "line": 123,
        "source": "set embedded (value) {\n    this.#embedded = value\n    if (value) {\n        this.setAttribute('embedded', '')\n    } else {\n        this.removeAttribute('embedded')\n    }\n    this.#updateEmbeddedMode()\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "systemCategories",
        "line": 139,
        "source": "set systemCategories (value) {\n    this.#systemCategories = value\n    this.#refresh()\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "showSystemModules",
        "line": 150,
        "source": "set showSystemModules (value) {\n    this.#showSystemModules = value\n    this.#updateLayersButton()\n    this.#refresh()\n    this.dispatchEvent(new CustomEvent('showSystemModules:change', {\n        detail: {showSystemModules: value}\n    }))\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      }
    ],
    "constructor": null,
    "isDefault": true
  },
  "/editor/perky_logger.doc.js": {
    "type": "class",
    "file": "/editor/perky_logger.js",
    "name": "PerkyLogger",
    "line": 12,
    "extends": "EditorComponent",
    "statics": [
      {
        "name": "observedAttributes",
        "line": 14,
        "source": "static observedAttributes = ['max-entries', 'position', 'timestamp', 'theme']",
        "kind": "property",
        "value": "['max-entries', 'position', 'timestamp', 'theme']"
      },
      {
        "name": "styles",
        "line": 16,
        "source": "static styles = `\n${editorScrollbarStyles}\n${editorBaseStyles}\n\n:host {\n    display: block;\n    font-family: var(--font-mono);\n    font-size: 12px;\n    --logger-width: calc(100% - 20px);\n    --logger-margin: 0 10px 10px;\n    --logger-padding: 0;\n    --logger-border: 1px solid var(--border);\n    --logger-border-radius: 6px;\n    --logger-bg: var(--bg-primary);\n}\n\n.logger-wrapper {\n    width: var(--logger-width);\n    margin: var(--logger-margin);\n    position: relative;\n}\n\n.logger-controls {\n    display: flex;\n    gap: 2px;\n    background: var(--logger-bg);\n    padding: 4px 6px;\n    border: var(--logger-border);\n    border-bottom: none;\n    border-radius: var(--logger-border-radius) var(--logger-border-radius) 0 0;\n    width: fit-content;\n    margin-left: auto;\n    margin-right: 10px;\n    box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.2);\n    opacity: 0;\n    transition: opacity 0.2s ease;\n    pointer-events: none;\n}\n\n.logger-wrapper:hover .logger-controls {\n    opacity: 1;\n    pointer-events: auto;\n}\n\n.logger {\n    border-radius: var(--logger-border-radius);\n    overflow: hidden;\n    z-index: 100;\n    position: relative;\n    background: var(--logger-bg);\n    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);\n    border: var(--logger-border);\n    color: var(--fg-primary);\n    padding: var(--logger-padding);\n    transition: opacity 0.2s ease;\n}\n\n.logger-faded {\n    opacity: 0.4;\n}\n\n.logger-faded:hover {\n    opacity: 1;\n}\n\n.logger-btn {\n    width: 20px;\n    height: 20px;\n    padding: 3px;\n    background: transparent;\n    border: none;\n    cursor: pointer;\n    color: var(--fg-muted);\n    opacity: 0.5;\n    transition: opacity 0.15s, color 0.15s;\n}\n\n.logger-btn:hover {\n    opacity: 1;\n}\n\n.logger-btn.pinned {\n    color: var(--accent);\n    opacity: 0.8;\n}\n\n.logger-btn.pinned:hover {\n    opacity: 1;\n}\n\n.logger-btn svg {\n    width: 100%;\n    height: 100%;\n}\n\n.logger-content {\n    max-height: min(250px, 25vh);\n    overflow-y: auto;\n}\n\n.logger-entry {\n    padding: 3px 12px;\n    display: flex;\n    align-items: flex-start;\n    gap: 8px;\n    font-size: 10px;\n    line-height: 1.4;\n}\n\n.logger-indicator {\n    width: 6px;\n    height: 6px;\n    border-radius: 50%;\n    flex-shrink: 0;\n    background: var(--fg-muted);\n    opacity: 0.5;\n    position: relative;\n    top: 0.45em;\n}\n\n.log-info .logger-indicator {\n    background: var(--fg-muted);\n    opacity: 0.5;\n}\n\n.log-notice .logger-indicator {\n    background: var(--fg-muted);\n    opacity: 0.3;\n}\n\n.log-warn .logger-indicator {\n    background: var(--status-warning);\n    opacity: 1;\n}\n\n.log-error .logger-indicator {\n    background: var(--status-error);\n    opacity: 1;\n    box-shadow: 0 0 4px var(--status-error);\n}\n\n.log-success .logger-indicator {\n    background: var(--status-success);\n    opacity: 1;\n}\n\n.logger-timestamp {\n    color: var(--fg-muted);\n    font-size: 10px;\n    flex-shrink: 0;\n    opacity: 0;\n    transition: opacity 0.15s;\n    margin-top: 1px;\n}\n\n.logger-entry:hover .logger-timestamp {\n    opacity: 1;\n}\n\n.logger-copy-btn {\n    width: 14px;\n    height: 14px;\n    padding: 2px;\n    background: transparent;\n    border: none;\n    cursor: pointer;\n    color: var(--fg-muted);\n    opacity: 0;\n    transition: opacity 0.15s, color 0.15s;\n    flex-shrink: 0;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.logger-copy-btn svg {\n    width: 100%;\n    height: 100%;\n}\n\n.logger-entry:hover .logger-copy-btn {\n    opacity: 0.5;\n}\n\n.logger-copy-btn:hover {\n    opacity: 1 !important;\n    color: var(--accent);\n}\n\n.logger-message {\n    flex-grow: 1;\n    word-break: break-word;\n    color: var(--fg-secondary);\n}\n\n.log-error .logger-message {\n    color: var(--fg-primary);\n}\n\n.logger-spacer {\n    height: 1px;\n    background: var(--border);\n    margin: 4px 12px;\n    padding: 0;\n    gap: 0;\n}\n\n.logger-title-entry {\n    padding: 6px 12px 2px;\n    font-size: 9px;\n    text-transform: uppercase;\n    letter-spacing: 0.5px;\n    color: var(--fg-muted);\n}\n\n\n.log-vec2 {\n    display: inline-flex;\n    align-items: center;\n    gap: 6px;\n    background: var(--bg-hover);\n    padding: 2px 8px;\n    border-radius: 4px;\n    font-size: 10px;\n}\n\n.log-vec2-label {\n    color: var(--fg-muted);\n    font-weight: 500;\n}\n\n.log-vec2-values {\n    display: inline-flex;\n    gap: 8px;\n}\n\n.log-vec2-component {\n    display: inline-flex;\n    gap: 4px;\n}\n\n.log-vec2-key {\n    color: var(--fg-muted);\n}\n\n.log-vec2-value {\n    color: var(--accent);\n}\n\n\n.log-object,\n.log-array,\n.log-module {\n    display: inline-block;\n    vertical-align: top;\n}\n\n.log-object-header,\n.log-array-header,\n.log-module-header {\n    display: inline-flex;\n    align-items: center;\n    gap: 4px;\n}\n\n.log-object-toggle,\n.log-array-toggle,\n.log-module-toggle {\n    color: var(--fg-muted);\n    font-size: 8px;\n    width: 10px;\n    user-select: none;\n}\n\n.log-object-preview,\n.log-array-preview {\n    color: var(--fg-secondary);\n}\n\n.log-object-expanded,\n.log-array-expanded,\n.log-module-expanded {\n    margin-left: 14px;\n    padding: 4px 0;\n    border-left: 1px solid var(--border);\n    padding-left: 8px;\n}\n\n.log-object-row,\n.log-array-row,\n.log-module-row {\n    display: flex;\n    gap: 4px;\n    padding: 1px 0;\n}\n\n.log-object-key,\n.log-module-key {\n    color: var(--accent);\n}\n\n.log-array-index {\n    color: var(--fg-muted);\n    min-width: 20px;\n}\n\n.log-object-separator,\n.log-array-separator,\n.log-module-separator {\n    color: var(--fg-muted);\n}\n\n.log-object-value,\n.log-array-value,\n.log-module-value {\n    color: var(--fg-secondary);\n}\n\n.log-array-length {\n    color: var(--fg-muted);\n    font-style: italic;\n}\n\n\n.log-module-label {\n    color: var(--fg-primary);\n    background: var(--bg-hover);\n    padding: 2px 8px;\n    border-radius: 4px;\n}\n\n.log-module-category {\n    color: var(--fg-muted);\n    font-size: 0.9em;\n}\n\n.log-module-meta {\n    border-bottom: 1px solid var(--border);\n    padding-bottom: 4px;\n    margin-bottom: 4px;\n}\n\n.log-module-meta-row .log-module-key {\n    color: var(--fg-muted);\n}\n\n.log-module-meta-value {\n    color: var(--fg-secondary);\n}\n\n.log-object-methods-row,\n.log-module-methods-row {\n    flex-wrap: wrap;\n}\n\n.log-object-method-name,\n.log-module-method-name {\n    white-space: nowrap;\n}\n\n@media (max-width: 1024px) {\n    .logger-content {\n        max-height: 150px;\n    }\n\n    .logger-controls.has-entries {\n        opacity: 1;\n        pointer-events: auto;\n    }\n}\n`",
        "kind": "property",
        "value": "`\n${editorScrollbarStyles}\n${editorBaseStyles}\n\n:host {\n    display: block;\n    font-family: var(--font-mono);\n    font-size: 12px;\n    --logger-width: calc(100% - 20px);\n    --logger-margin: 0 10px 10px;\n    --logger-padding: 0;\n    --logger-border: 1px solid var(--border);\n    --logger-border-radius: 6px;\n    --logger-bg: var(--bg-primary);\n}\n\n.logger-wrapper {\n    width: var(--logger-width);\n    margin: var(--logger-margin);\n    position: relative;\n}\n\n.logger-controls {\n    display: flex;\n    gap: 2px;\n    background: var(--logger-bg);\n    padding: 4px 6px;\n    border: var(--logger-border);\n    border-bottom: none;\n    border-radius: var(--logger-border-radius) var(--logger-border-radius) 0 0;\n    width: fit-content;\n    margin-left: auto;\n    margin-right: 10px;\n    box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.2);\n    opacity: 0;\n    transition: opacity 0.2s ease;\n    pointer-events: none;\n}\n\n.logger-wrapper:hover .logger-controls {\n    opacity: 1;\n    pointer-events: auto;\n}\n\n.logger {\n    border-radius: var(--logger-border-radius);\n    overflow: hidden;\n    z-index: 100;\n    position: relative;\n    background: var(--logger-bg);\n    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);\n    border: var(--logger-border);\n    color: var(--fg-primary);\n    padding: var(--logger-padding);\n    transition: opacity 0.2s ease;\n}\n\n.logger-faded {\n    opacity: 0.4;\n}\n\n.logger-faded:hover {\n    opacity: 1;\n}\n\n.logger-btn {\n    width: 20px;\n    height: 20px;\n    padding: 3px;\n    background: transparent;\n    border: none;\n    cursor: pointer;\n    color: var(--fg-muted);\n    opacity: 0.5;\n    transition: opacity 0.15s, color 0.15s;\n}\n\n.logger-btn:hover {\n    opacity: 1;\n}\n\n.logger-btn.pinned {\n    color: var(--accent);\n    opacity: 0.8;\n}\n\n.logger-btn.pinned:hover {\n    opacity: 1;\n}\n\n.logger-btn svg {\n    width: 100%;\n    height: 100%;\n}\n\n.logger-content {\n    max-height: min(250px, 25vh);\n    overflow-y: auto;\n}\n\n.logger-entry {\n    padding: 3px 12px;\n    display: flex;\n    align-items: flex-start;\n    gap: 8px;\n    font-size: 10px;\n    line-height: 1.4;\n}\n\n.logger-indicator {\n    width: 6px;\n    height: 6px;\n    border-radius: 50%;\n    flex-shrink: 0;\n    background: var(--fg-muted);\n    opacity: 0.5;\n    position: relative;\n    top: 0.45em;\n}\n\n.log-info .logger-indicator {\n    background: var(--fg-muted);\n    opacity: 0.5;\n}\n\n.log-notice .logger-indicator {\n    background: var(--fg-muted);\n    opacity: 0.3;\n}\n\n.log-warn .logger-indicator {\n    background: var(--status-warning);\n    opacity: 1;\n}\n\n.log-error .logger-indicator {\n    background: var(--status-error);\n    opacity: 1;\n    box-shadow: 0 0 4px var(--status-error);\n}\n\n.log-success .logger-indicator {\n    background: var(--status-success);\n    opacity: 1;\n}\n\n.logger-timestamp {\n    color: var(--fg-muted);\n    font-size: 10px;\n    flex-shrink: 0;\n    opacity: 0;\n    transition: opacity 0.15s;\n    margin-top: 1px;\n}\n\n.logger-entry:hover .logger-timestamp {\n    opacity: 1;\n}\n\n.logger-copy-btn {\n    width: 14px;\n    height: 14px;\n    padding: 2px;\n    background: transparent;\n    border: none;\n    cursor: pointer;\n    color: var(--fg-muted);\n    opacity: 0;\n    transition: opacity 0.15s, color 0.15s;\n    flex-shrink: 0;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.logger-copy-btn svg {\n    width: 100%;\n    height: 100%;\n}\n\n.logger-entry:hover .logger-copy-btn {\n    opacity: 0.5;\n}\n\n.logger-copy-btn:hover {\n    opacity: 1 !important;\n    color: var(--accent);\n}\n\n.logger-message {\n    flex-grow: 1;\n    word-break: break-word;\n    color: var(--fg-secondary);\n}\n\n.log-error .logger-message {\n    color: var(--fg-primary);\n}\n\n.logger-spacer {\n    height: 1px;\n    background: var(--border);\n    margin: 4px 12px;\n    padding: 0;\n    gap: 0;\n}\n\n.logger-title-entry {\n    padding: 6px 12px 2px;\n    font-size: 9px;\n    text-transform: uppercase;\n    letter-spacing: 0.5px;\n    color: var(--fg-muted);\n}\n\n\n.log-vec2 {\n    display: inline-flex;\n    align-items: center;\n    gap: 6px;\n    background: var(--bg-hover);\n    padding: 2px 8px;\n    border-radius: 4px;\n    font-size: 10px;\n}\n\n.log-vec2-label {\n    color: var(--fg-muted);\n    font-weight: 500;\n}\n\n.log-vec2-values {\n    display: inline-flex;\n    gap: 8px;\n}\n\n.log-vec2-component {\n    display: inline-flex;\n    gap: 4px;\n}\n\n.log-vec2-key {\n    color: var(--fg-muted);\n}\n\n.log-vec2-value {\n    color: var(--accent);\n}\n\n\n.log-object,\n.log-array,\n.log-module {\n    display: inline-block;\n    vertical-align: top;\n}\n\n.log-object-header,\n.log-array-header,\n.log-module-header {\n    display: inline-flex;\n    align-items: center;\n    gap: 4px;\n}\n\n.log-object-toggle,\n.log-array-toggle,\n.log-module-toggle {\n    color: var(--fg-muted);\n    font-size: 8px;\n    width: 10px;\n    user-select: none;\n}\n\n.log-object-preview,\n.log-array-preview {\n    color: var(--fg-secondary);\n}\n\n.log-object-expanded,\n.log-array-expanded,\n.log-module-expanded {\n    margin-left: 14px;\n    padding: 4px 0;\n    border-left: 1px solid var(--border);\n    padding-left: 8px;\n}\n\n.log-object-row,\n.log-array-row,\n.log-module-row {\n    display: flex;\n    gap: 4px;\n    padding: 1px 0;\n}\n\n.log-object-key,\n.log-module-key {\n    color: var(--accent);\n}\n\n.log-array-index {\n    color: var(--fg-muted);\n    min-width: 20px;\n}\n\n.log-object-separator,\n.log-array-separator,\n.log-module-separator {\n    color: var(--fg-muted);\n}\n\n.log-object-value,\n.log-array-value,\n.log-module-value {\n    color: var(--fg-secondary);\n}\n\n.log-array-length {\n    color: var(--fg-muted);\n    font-style: italic;\n}\n\n\n.log-module-label {\n    color: var(--fg-primary);\n    background: var(--bg-hover);\n    padding: 2px 8px;\n    border-radius: 4px;\n}\n\n.log-module-category {\n    color: var(--fg-muted);\n    font-size: 0.9em;\n}\n\n.log-module-meta {\n    border-bottom: 1px solid var(--border);\n    padding-bottom: 4px;\n    margin-bottom: 4px;\n}\n\n.log-module-meta-row .log-module-key {\n    color: var(--fg-muted);\n}\n\n.log-module-meta-value {\n    color: var(--fg-secondary);\n}\n\n.log-object-methods-row,\n.log-module-methods-row {\n    flex-wrap: wrap;\n}\n\n.log-object-method-name,\n.log-module-method-name {\n    white-space: nowrap;\n}\n\n@media (max-width: 1024px) {\n    .logger-content {\n        max-height: 150px;\n    }\n\n    .logger-controls.has-entries {\n        opacity: 1;\n        pointer-events: auto;\n    }\n}\n`"
      }
    ],
    "methods": [
      {
        "name": "onConnected",
        "line": 405,
        "source": "onConnected () {\n    this.#buildDOM()\n    this.#bindLoggerEvents()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "onDisconnected",
        "line": 411,
        "source": "onDisconnected () {\n    this.#unbindLoggerEvents()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "attributeChangedCallback",
        "line": 416,
        "source": "attributeChangedCallback (name, oldValue, newValue) {\n    if (oldValue === newValue) {\n        return\n    }\n\n    this.#handleAttributeChange(name, newValue)\n}",
        "kind": "method",
        "params": [
          "name",
          "oldValue",
          "newValue"
        ]
      },
      {
        "name": "log",
        "line": 680,
        "source": "log (message, type = 'info', format = 'text', timestamp = null) {\n    const entry = createElement('div', {class: `logger-entry log-${type}`})\n\n    const indicator = createElement('span', {class: 'logger-indicator'})\n    entry.appendChild(indicator)\n\n    const messageElement = createElement('span', {class: 'logger-message'})\n\n    processMessage(messageElement, message, format)\n\n    entry.appendChild(messageElement)\n\n    const time = timestamp ? new Date(timestamp) : new Date()\n    const timestampEl = createElement('span', {\n        class: 'logger-timestamp',\n        text: time.toLocaleTimeString()\n    })\n    entry.appendChild(timestampEl)\n\n    const copyBtn = createElement('button', {\n        class: 'logger-copy-btn',\n        html: COPY_ICON,\n        title: 'Copy log entry'\n    })\n    copyBtn.addEventListener('click', (e) => {\n        e.stopPropagation()\n        const text = extractFormattedText(messageElement)\n        copyToClipboard(`[${timestampEl.textContent}] ${text}`)\n    })\n    entry.appendChild(copyBtn)\n\n    this.#entries.push(entry)\n\n    while (this.#entries.length > this.#maxEntries) {\n        const removed = this.#entries.shift()\n        if (removed.parentNode) {\n            removed.parentNode.removeChild(removed)\n        }\n    }\n\n    if (this.#contentEl) {\n        this.#contentEl.appendChild(entry)\n        this.#contentEl.scrollTop = this.#contentEl.scrollHeight\n    }\n\n    this.#updateControlsVisibility()\n\n    return entry\n}",
        "kind": "method",
        "params": [
          "message",
          "type = ...",
          "format = ...",
          "timestamp = ..."
        ]
      },
      {
        "name": "info",
        "line": 731,
        "source": "info (...messages) {\n    return this.log(formatMessage(...messages), 'info')\n}",
        "kind": "method",
        "params": [
          "...messages"
        ]
      },
      {
        "name": "notice",
        "line": 736,
        "source": "notice (...messages) {\n    return this.log(formatMessage(...messages), 'notice')\n}",
        "kind": "method",
        "params": [
          "...messages"
        ]
      },
      {
        "name": "warn",
        "line": 741,
        "source": "warn (...messages) {\n    return this.log(formatMessage(...messages), 'warn')\n}",
        "kind": "method",
        "params": [
          "...messages"
        ]
      },
      {
        "name": "error",
        "line": 746,
        "source": "error (...messages) {\n    return this.log(formatMessage(...messages), 'error')\n}",
        "kind": "method",
        "params": [
          "...messages"
        ]
      },
      {
        "name": "success",
        "line": 751,
        "source": "success (...messages) {\n    return this.log(formatMessage(...messages), 'success')\n}",
        "kind": "method",
        "params": [
          "...messages"
        ]
      },
      {
        "name": "spacer",
        "line": 756,
        "source": "spacer () {\n    const entry = createElement('div', {class: 'logger-entry logger-spacer'})\n    this.#entries.push(entry)\n\n    if (this.#contentEl) {\n        this.#contentEl.appendChild(entry)\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "title",
        "line": 766,
        "source": "title (title) {\n    const entry = createElement('div', {\n        class: 'logger-entry logger-title-entry',\n        text: title\n    })\n    this.#entries.push(entry)\n\n    if (this.#contentEl) {\n        this.#contentEl.appendChild(entry)\n    }\n}",
        "kind": "method",
        "params": [
          "title"
        ]
      },
      {
        "name": "clear",
        "line": 779,
        "source": "clear () {\n    this.#entries = []\n    if (this.#contentEl) {\n        this.#contentEl.innerHTML = ''\n    }\n    this.#updateControlsVisibility()\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "maxEntries",
        "line": 458,
        "source": "get maxEntries () {\n    return this.#maxEntries\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "position",
        "line": 469,
        "source": "get position () {\n    return this.#position\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "timestamp",
        "line": 481,
        "source": "get timestamp () {\n    return this.#timestamp\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "theme",
        "line": 496,
        "source": "get theme () {\n    return this.#theme\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "entries",
        "line": 511,
        "source": "get entries () {\n    return this.#entries\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "maxEntries",
        "line": 463,
        "source": "set maxEntries (value) {\n    this.#maxEntries = value\n    this.setAttribute('max-entries', value)\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "position",
        "line": 474,
        "source": "set position (value) {\n    this.#position = value\n    this.setAttribute('position', value)\n    this.#updateClasses()\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "timestamp",
        "line": 486,
        "source": "set timestamp (value) {\n    this.#timestamp = value\n    if (value) {\n        this.setAttribute('timestamp', '')\n    } else {\n        this.removeAttribute('timestamp')\n    }\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "theme",
        "line": 501,
        "source": "set theme (value) {\n    this.#theme = value\n    if (value) {\n        this.setAttribute('theme', value)\n    } else {\n        this.removeAttribute('theme')\n    }\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      }
    ],
    "constructor": null,
    "isDefault": true
  },
  "/editor/toggle_input.doc.js": {
    "type": "class",
    "file": "/editor/toggle_input.js",
    "name": "ToggleInput",
    "line": 97,
    "extends": "EditorComponent",
    "statics": [
      {
        "name": "styles",
        "line": 99,
        "source": "static styles = [controlsSheet, toggleInputCSS]",
        "kind": "property",
        "value": "[controlsSheet, toggleInputCSS]"
      },
      {
        "name": "observedAttributes",
        "line": 107,
        "source": "static get observedAttributes () {\n    return ['checked', 'label']\n}",
        "kind": "method",
        "params": []
      }
    ],
    "methods": [
      {
        "name": "onConnected",
        "line": 118,
        "source": "onConnected () {\n    this.#updateDisplay()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "attributeChangedCallback",
        "line": 123,
        "source": "attributeChangedCallback (name, oldValue, newValue) {\n    handleAttributeChange(this, name, oldValue, newValue)\n}",
        "kind": "method",
        "params": [
          "name",
          "oldValue",
          "newValue"
        ]
      },
      {
        "name": "setChecked",
        "line": 142,
        "source": "setChecked (val) {\n    this.#checked = val\n    this.#updateDisplay()\n}",
        "kind": "method",
        "params": [
          "val"
        ]
      },
      {
        "name": "setLabel",
        "line": 148,
        "source": "setLabel (val) {\n    this.#label = val\n    if (this.#labelEl) {\n        this.#labelEl.textContent = this.#label\n    }\n}",
        "kind": "method",
        "params": [
          "val"
        ]
      }
    ],
    "getters": [
      {
        "name": "checked",
        "line": 128,
        "source": "get checked () {\n    return this.#checked\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "checked",
        "line": 133,
        "source": "set checked (val) {\n    const newChecked = Boolean(val)\n    if (this.#checked !== newChecked) {\n        this.#checked = newChecked\n        this.#updateDisplay()\n    }\n}",
        "kind": "method",
        "params": [
          "val"
        ]
      }
    ],
    "constructor": {
      "name": "constructor",
      "line": 112,
      "source": "constructor () {\n    super()\n    this.#buildDOM()\n}",
      "kind": "constructor",
      "params": []
    },
    "isDefault": true
  },
  "/editor/vec2_input.doc.js": {
    "type": "class",
    "file": "/editor/vec2_input.js",
    "name": "Vec2Input",
    "line": 62,
    "extends": "EditorComponent",
    "statics": [
      {
        "name": "styles",
        "line": 64,
        "source": "static styles = [controlsSheet, vec2InputCSS]",
        "kind": "property",
        "value": "[controlsSheet, vec2InputCSS]"
      },
      {
        "name": "observedAttributes",
        "line": 72,
        "source": "static get observedAttributes () {\n    return ['label']\n}",
        "kind": "method",
        "params": []
      }
    ],
    "methods": [
      {
        "name": "onConnected",
        "line": 83,
        "source": "onConnected () {\n    this.#updateDisplay()\n    this.#syncContext()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "attributeChangedCallback",
        "line": 89,
        "source": "attributeChangedCallback (name, oldValue, newValue) {\n    handleAttributeChange(this, name, oldValue, newValue)\n    if (name === 'context') {\n        this.#syncContext()\n    }\n}",
        "kind": "method",
        "params": [
          "name",
          "oldValue",
          "newValue"
        ]
      },
      {
        "name": "setLabel",
        "line": 108,
        "source": "setLabel (val) {\n    this.#label = val\n    if (this.#labelEl) {\n        this.#labelEl.textContent = this.#label\n    }\n}",
        "kind": "method",
        "params": [
          "val"
        ]
      }
    ],
    "getters": [
      {
        "name": "value",
        "line": 97,
        "source": "get value () {\n    return this.#vec2\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "value",
        "line": 102,
        "source": "set value (vec2) {\n    this.#vec2 = vec2\n    this.#updateDisplay()\n}",
        "kind": "method",
        "params": [
          "vec2"
        ]
      }
    ],
    "constructor": {
      "name": "constructor",
      "line": 77,
      "source": "constructor () {\n    super()\n    this.#buildDOM()\n}",
      "kind": "constructor",
      "params": []
    },
    "isDefault": true
  },
  "/editor/inspectors/action_controller_inspector.doc.js": {
    "type": "class",
    "file": "/editor/inspectors/action_controller_inspector.js",
    "name": "ActionControllerInspector",
    "line": 8,
    "extends": "BaseInspector",
    "statics": [
      {
        "name": "matches",
        "line": 10,
        "source": "static matches (module) {\n    return module instanceof ActionController\n}",
        "kind": "method",
        "params": [
          "module"
        ]
      },
      {
        "name": "styles",
        "line": 14,
        "source": "static styles = `\n.actions-header {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    margin-bottom: 8px;\n}\n\n.actions-count {\n    font-size: 11px;\n    color: var(--fg-muted);\n}\n\n.actions-count strong {\n    color: var(--fg-primary);\n}\n\n.actions-list {\n    display: flex;\n    flex-direction: column;\n    gap: 4px;\n}\n\n.action-card {\n    background: var(--bg-hover);\n    border-radius: 4px;\n    padding: 8px 10px;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 8px;\n}\n\n.action-name {\n    font-size: 11px;\n    font-weight: 600;\n    color: var(--accent);\n    font-family: var(--font-mono);\n}\n\n.action-badge {\n    font-size: 9px;\n    padding: 2px 6px;\n    border-radius: 4px;\n    background: var(--bg-primary);\n    color: var(--fg-muted);\n}\n\n.action-badge.propagable {\n    background: var(--status-started);\n    color: var(--bg-primary);\n}\n\n.execute-btn {\n    background: var(--bg-primary);\n    border: 1px solid var(--border);\n    border-radius: 4px;\n    padding: 3px 8px;\n    font-size: 9px;\n    color: var(--fg-muted);\n    cursor: pointer;\n    transition: all 0.15s;\n}\n\n.execute-btn:hover {\n    background: var(--accent);\n    color: var(--bg-primary);\n    border-color: var(--accent);\n}\n\n.empty-message {\n    color: var(--fg-muted);\n    font-size: 11px;\n    font-style: italic;\n    text-align: center;\n    padding: 16px;\n}\n`",
        "kind": "property",
        "value": "`\n.actions-header {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    margin-bottom: 8px;\n}\n\n.actions-count {\n    font-size: 11px;\n    color: var(--fg-muted);\n}\n\n.actions-count strong {\n    color: var(--fg-primary);\n}\n\n.actions-list {\n    display: flex;\n    flex-direction: column;\n    gap: 4px;\n}\n\n.action-card {\n    background: var(--bg-hover);\n    border-radius: 4px;\n    padding: 8px 10px;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 8px;\n}\n\n.action-name {\n    font-size: 11px;\n    font-weight: 600;\n    color: var(--accent);\n    font-family: var(--font-mono);\n}\n\n.action-badge {\n    font-size: 9px;\n    padding: 2px 6px;\n    border-radius: 4px;\n    background: var(--bg-primary);\n    color: var(--fg-muted);\n}\n\n.action-badge.propagable {\n    background: var(--status-started);\n    color: var(--bg-primary);\n}\n\n.execute-btn {\n    background: var(--bg-primary);\n    border: 1px solid var(--border);\n    border-radius: 4px;\n    padding: 3px 8px;\n    font-size: 9px;\n    color: var(--fg-muted);\n    cursor: pointer;\n    transition: all 0.15s;\n}\n\n.execute-btn:hover {\n    background: var(--accent);\n    color: var(--bg-primary);\n    border-color: var(--accent);\n}\n\n.empty-message {\n    color: var(--fg-muted);\n    font-size: 11px;\n    font-style: italic;\n    text-align: center;\n    padding: 16px;\n}\n`"
      }
    ],
    "methods": [
      {
        "name": "buildDOM",
        "line": 101,
        "source": "buildDOM () {\n    super.buildDOM()\n\n    this.#containerEl = document.createElement('div')\n    this.shadowRoot.insertBefore(this.#containerEl, this.gridEl)\n    this.gridEl.style.display = 'none'\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "onModuleSet",
        "line": 110,
        "source": "onModuleSet (module) {\n    if (module) {\n        this.#update()\n    }\n}",
        "kind": "method",
        "params": [
          "module"
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 95,
      "source": "constructor () {\n    super()\n    this.buildDOM()\n}",
      "kind": "constructor",
      "params": []
    },
    "isDefault": true
  },
  "/editor/inspectors/action_dispatcher_inspector.doc.js": {
    "type": "class",
    "file": "/editor/inspectors/action_dispatcher_inspector.js",
    "name": "ActionDispatcherInspector",
    "line": 9,
    "extends": "BaseInspector",
    "statics": [
      {
        "name": "matches",
        "line": 11,
        "source": "static matches (module) {\n    return module instanceof ActionDispatcher\n}",
        "kind": "method",
        "params": [
          "module"
        ]
      },
      {
        "name": "styles",
        "line": 15,
        "source": "static styles = `\n.actions-header {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    margin-bottom: 8px;\n}\n\n.actions-count {\n    font-size: 11px;\n    color: var(--fg-muted);\n}\n\n.actions-count strong {\n    color: var(--fg-primary);\n}\n\n.controller-group {\n    margin-bottom: 12px;\n}\n\n.group-header {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    padding: 4px 0;\n    border-bottom: 1px solid var(--border);\n    margin-bottom: 6px;\n}\n\n.group-name {\n    font-size: 10px;\n    text-transform: uppercase;\n    letter-spacing: 0.5px;\n    color: var(--fg-muted);\n    flex: 1;\n}\n\n.group-inactive .group-name {\n    opacity: 0.4;\n}\n\n.group-inactive .actions-list {\n    opacity: 0.3;\n    pointer-events: none;\n}\n\n.actions-list {\n    display: flex;\n    flex-direction: column;\n    gap: 4px;\n}\n\n.action-card {\n    background: var(--bg-hover);\n    border-radius: 4px;\n    padding: 8px 10px;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 8px;\n}\n\n.action-name {\n    font-size: 11px;\n    font-weight: 600;\n    color: var(--accent);\n    font-family: var(--font-mono);\n}\n\n.execute-btn {\n    background: var(--bg-primary);\n    border: 1px solid var(--border);\n    border-radius: 4px;\n    padding: 3px 8px;\n    font-size: 9px;\n    color: var(--fg-muted);\n    cursor: pointer;\n    transition: all 0.15s;\n}\n\n.execute-btn:hover {\n    background: var(--accent);\n    color: var(--bg-primary);\n    border-color: var(--accent);\n}\n\n.empty-message {\n    color: var(--fg-muted);\n    font-size: 11px;\n    font-style: italic;\n    text-align: center;\n    padding: 16px;\n}\n`",
        "kind": "property",
        "value": "`\n.actions-header {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    margin-bottom: 8px;\n}\n\n.actions-count {\n    font-size: 11px;\n    color: var(--fg-muted);\n}\n\n.actions-count strong {\n    color: var(--fg-primary);\n}\n\n.controller-group {\n    margin-bottom: 12px;\n}\n\n.group-header {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    padding: 4px 0;\n    border-bottom: 1px solid var(--border);\n    margin-bottom: 6px;\n}\n\n.group-name {\n    font-size: 10px;\n    text-transform: uppercase;\n    letter-spacing: 0.5px;\n    color: var(--fg-muted);\n    flex: 1;\n}\n\n.group-inactive .group-name {\n    opacity: 0.4;\n}\n\n.group-inactive .actions-list {\n    opacity: 0.3;\n    pointer-events: none;\n}\n\n.actions-list {\n    display: flex;\n    flex-direction: column;\n    gap: 4px;\n}\n\n.action-card {\n    background: var(--bg-hover);\n    border-radius: 4px;\n    padding: 8px 10px;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 8px;\n}\n\n.action-name {\n    font-size: 11px;\n    font-weight: 600;\n    color: var(--accent);\n    font-family: var(--font-mono);\n}\n\n.execute-btn {\n    background: var(--bg-primary);\n    border: 1px solid var(--border);\n    border-radius: 4px;\n    padding: 3px 8px;\n    font-size: 9px;\n    color: var(--fg-muted);\n    cursor: pointer;\n    transition: all 0.15s;\n}\n\n.execute-btn:hover {\n    background: var(--accent);\n    color: var(--bg-primary);\n    border-color: var(--accent);\n}\n\n.empty-message {\n    color: var(--fg-muted);\n    font-size: 11px;\n    font-style: italic;\n    text-align: center;\n    padding: 16px;\n}\n`"
      }
    ],
    "methods": [
      {
        "name": "buildDOM",
        "line": 119,
        "source": "buildDOM () {\n    super.buildDOM()\n\n    this.#containerEl = document.createElement('div')\n    this.shadowRoot.insertBefore(this.#containerEl, this.gridEl)\n    this.gridEl.style.display = 'none'\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "onModuleSet",
        "line": 128,
        "source": "onModuleSet (module) {\n    if (module) {\n        this.#update()\n    }\n}",
        "kind": "method",
        "params": [
          "module"
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 113,
      "source": "constructor () {\n    super()\n    this.buildDOM()\n}",
      "kind": "constructor",
      "params": []
    },
    "isDefault": true
  },
  "/editor/interactive/editor_button.doc.js": {
    "type": "class",
    "file": "/editor/interactive/editor_button.js",
    "name": "EditorButton",
    "line": 6,
    "extends": "EditorComponent",
    "statics": [
      {
        "name": "styles",
        "line": 8,
        "source": "static styles = [\n    controlsSheet,\n    `\n    :host {\n        display: inline-block;\n    }\n\n    button {\n        width: 100%;\n    }\n\n    @media (pointer: coarse) {\n        button {\n            min-height: var(--touch-target);\n            min-width: var(--touch-target);\n        }\n    }\n    `\n]",
        "kind": "property",
        "value": "[\n    controlsSheet,\n    `\n    :host {\n        display: inline-block;\n    }\n\n    button {\n        width: 100%;\n    }\n\n    @media (pointer: coarse) {\n        button {\n            min-height: var(--touch-target);\n            min-width: var(--touch-target);\n        }\n    }\n    `\n]"
      },
      {
        "name": "observedAttributes",
        "line": 28,
        "source": "static observedAttributes = ['variant', 'icon', 'disabled', 'active']",
        "kind": "property",
        "value": "['variant', 'icon', 'disabled', 'active']"
      }
    ],
    "methods": [
      {
        "name": "onConnected",
        "line": 32,
        "source": "onConnected () {\n    this.#render()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "attributeChangedCallback",
        "line": 37,
        "source": "attributeChangedCallback (name, oldValue, newValue) {\n    if (oldValue === newValue || !this.#buttonEl) {\n        return\n    }\n    this.#updateButton()\n}",
        "kind": "method",
        "params": [
          "name",
          "oldValue",
          "newValue"
        ]
      },
      {
        "name": "focus",
        "line": 132,
        "source": "focus () {\n    this.#buttonEl?.focus()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "blur",
        "line": 137,
        "source": "blur () {\n    this.#buttonEl?.blur()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "click",
        "line": 142,
        "source": "click () {\n    this.#buttonEl?.click()\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "variant",
        "line": 45,
        "source": "get variant () {\n    return this.getAttribute('variant') || 'default'\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "disabled",
        "line": 55,
        "source": "get disabled () {\n    return this.hasAttribute('disabled')\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "active",
        "line": 69,
        "source": "get active () {\n    return this.hasAttribute('active')\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "variant",
        "line": 50,
        "source": "set variant (value) {\n    this.setAttribute('variant', value)\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "disabled",
        "line": 60,
        "source": "set disabled (value) {\n    if (value) {\n        this.setAttribute('disabled', '')\n    } else {\n        this.removeAttribute('disabled')\n    }\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "active",
        "line": 74,
        "source": "set active (value) {\n    if (value) {\n        this.setAttribute('active', '')\n    } else {\n        this.removeAttribute('active')\n    }\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      }
    ],
    "constructor": null,
    "isDefault": true
  },
  "/editor/interactive/tab_bar.doc.js": {
    "type": "class",
    "file": "/editor/interactive/tab_bar.js",
    "name": "TabBar",
    "line": 5,
    "extends": "EditorComponent",
    "statics": [
      {
        "name": "styles",
        "line": 7,
        "source": "static styles = `\n    :host {\n        display: inline-flex;\n        background: var(--bg-tertiary);\n        border-radius: var(--radius-md);\n        padding: 2px;\n        gap: 2px;\n        font-family: var(--font-mono);\n    }\n\n    .tab {\n        appearance: none;\n        background: transparent;\n        border: none;\n        color: var(--fg-muted);\n        font-size: var(--font-size-sm);\n        font-family: inherit;\n        padding: var(--spacing-xs) var(--spacing-sm);\n        border-radius: var(--radius-sm);\n        cursor: pointer;\n        transition: background var(--transition-fast), color var(--transition-fast);\n        white-space: nowrap;\n    }\n\n    .tab:hover {\n        color: var(--fg-secondary);\n    }\n\n    .tab.active {\n        background: var(--bg-primary);\n        color: var(--fg-primary);\n        box-shadow: var(--shadow-sm);\n    }\n\n\n    ::slotted(button) {\n        appearance: none;\n        background: transparent;\n        border: none;\n        color: var(--fg-muted);\n        font-size: var(--font-size-sm);\n        font-family: var(--font-mono);\n        padding: var(--spacing-xs) var(--spacing-sm);\n        border-radius: var(--radius-sm);\n        cursor: pointer;\n        transition: background var(--transition-fast), color var(--transition-fast);\n        white-space: nowrap;\n    }\n\n    ::slotted(button:hover) {\n        color: var(--fg-secondary);\n    }\n\n    ::slotted(button[aria-selected=\"true\"]) {\n        background: var(--bg-primary);\n        color: var(--fg-primary);\n        box-shadow: var(--shadow-sm);\n    }\n\n\n    :host([context=\"studio\"]) {\n        padding: 4px;\n        gap: 4px;\n        border-radius: var(--radius-lg);\n    }\n\n    :host([context=\"studio\"]) .tab {\n        font-size: var(--font-size-md);\n        padding: var(--spacing-sm) var(--spacing-md);\n        min-height: var(--touch-target);\n        border-radius: var(--radius-md);\n    }\n\n    :host([context=\"studio\"]) ::slotted(button) {\n        font-size: var(--font-size-md);\n        padding: var(--spacing-sm) var(--spacing-md);\n        min-height: var(--touch-target);\n        border-radius: var(--radius-md);\n    }\n`",
        "kind": "property",
        "value": "`\n    :host {\n        display: inline-flex;\n        background: var(--bg-tertiary);\n        border-radius: var(--radius-md);\n        padding: 2px;\n        gap: 2px;\n        font-family: var(--font-mono);\n    }\n\n    .tab {\n        appearance: none;\n        background: transparent;\n        border: none;\n        color: var(--fg-muted);\n        font-size: var(--font-size-sm);\n        font-family: inherit;\n        padding: var(--spacing-xs) var(--spacing-sm);\n        border-radius: var(--radius-sm);\n        cursor: pointer;\n        transition: background var(--transition-fast), color var(--transition-fast);\n        white-space: nowrap;\n    }\n\n    .tab:hover {\n        color: var(--fg-secondary);\n    }\n\n    .tab.active {\n        background: var(--bg-primary);\n        color: var(--fg-primary);\n        box-shadow: var(--shadow-sm);\n    }\n\n\n    ::slotted(button) {\n        appearance: none;\n        background: transparent;\n        border: none;\n        color: var(--fg-muted);\n        font-size: var(--font-size-sm);\n        font-family: var(--font-mono);\n        padding: var(--spacing-xs) var(--spacing-sm);\n        border-radius: var(--radius-sm);\n        cursor: pointer;\n        transition: background var(--transition-fast), color var(--transition-fast);\n        white-space: nowrap;\n    }\n\n    ::slotted(button:hover) {\n        color: var(--fg-secondary);\n    }\n\n    ::slotted(button[aria-selected=\"true\"]) {\n        background: var(--bg-primary);\n        color: var(--fg-primary);\n        box-shadow: var(--shadow-sm);\n    }\n\n\n    :host([context=\"studio\"]) {\n        padding: 4px;\n        gap: 4px;\n        border-radius: var(--radius-lg);\n    }\n\n    :host([context=\"studio\"]) .tab {\n        font-size: var(--font-size-md);\n        padding: var(--spacing-sm) var(--spacing-md);\n        min-height: var(--touch-target);\n        border-radius: var(--radius-md);\n    }\n\n    :host([context=\"studio\"]) ::slotted(button) {\n        font-size: var(--font-size-md);\n        padding: var(--spacing-sm) var(--spacing-md);\n        min-height: var(--touch-target);\n        border-radius: var(--radius-md);\n    }\n`"
      },
      {
        "name": "observedAttributes",
        "line": 103,
        "source": "static get observedAttributes () {\n    return ['value']\n}",
        "kind": "method",
        "params": []
      }
    ],
    "methods": [
      {
        "name": "onConnected",
        "line": 98,
        "source": "onConnected () {\n    this.#setupSlottedTabs()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "attributeChangedCallback",
        "line": 108,
        "source": "attributeChangedCallback (name, oldValue, newValue) {\n    if (name === 'value' && newValue !== oldValue) {\n        this.#value = newValue\n        this.#updateActiveState()\n    }\n}",
        "kind": "method",
        "params": [
          "name",
          "oldValue",
          "newValue"
        ]
      },
      {
        "name": "setTabs",
        "line": 130,
        "source": "setTabs (tabs) {\n    this.#tabs = tabs\n    this.#renderTabs()\n}",
        "kind": "method",
        "params": [
          "tabs"
        ]
      }
    ],
    "getters": [
      {
        "name": "value",
        "line": 116,
        "source": "get value () {\n    return this.#value\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "value",
        "line": 121,
        "source": "set value (val) {\n    if (this.#value !== val) {\n        this.#value = val\n        this.setAttribute('value', val)\n        this.#updateActiveState()\n    }\n}",
        "kind": "method",
        "params": [
          "val"
        ]
      }
    ],
    "constructor": {
      "name": "constructor",
      "line": 92,
      "source": "constructor () {\n    super()\n    this.#buildDOM()\n}",
      "kind": "constructor",
      "params": []
    },
    "isDefault": true
  },
  "/editor/layout/app_layout.doc.js": {
    "type": "class",
    "file": "/editor/layout/app_layout.js",
    "name": "AppLayout",
    "line": 5,
    "extends": "EditorComponent",
    "statics": [
      {
        "name": "styles",
        "line": 7,
        "source": "static styles = `\n:host {\n    display: flex;\n    flex-direction: column;\n    height: 100%;\n    width: 100%;\n    background: var(--bg-primary);\n    color: var(--fg-primary);\n    font-family: var(--font-mono);\n    overflow: hidden;\n}\n\n\n.header {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    min-height: var(--touch-target);\n    padding: 0 var(--spacing-md);\n    background: var(--bg-secondary);\n    flex-shrink: 0;\n    gap: var(--spacing-md);\n}\n\n.header-start {\n    display: flex;\n    align-items: center;\n    gap: var(--spacing-sm);\n}\n\n.header-center {\n    display: flex;\n    align-items: center;\n    gap: var(--spacing-sm);\n    flex: 1;\n    justify-content: center;\n}\n\n.header-end {\n    display: flex;\n    align-items: center;\n    gap: var(--spacing-sm);\n}\n\n.title {\n    font-size: var(--font-size-lg);\n    font-weight: 500;\n    color: var(--fg-primary);\n    white-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n}\n\n.title:empty {\n    display: none;\n}\n\n.header-btn {\n    appearance: none;\n    background: transparent;\n    border: none;\n    color: var(--fg-secondary);\n    font-size: 18px;\n    width: var(--touch-target);\n    height: var(--touch-target);\n    min-width: var(--touch-target);\n    min-height: var(--touch-target);\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    cursor: pointer;\n    border-radius: var(--radius-md);\n    transition: background var(--transition-fast), color var(--transition-fast);\n    padding: 0;\n}\n\n.header-btn:hover {\n    background: var(--bg-hover);\n    color: var(--fg-primary);\n}\n\n.header-btn:active {\n    background: var(--bg-selected);\n}\n\n.header-btn.hidden {\n    display: none;\n}\n\n\n.content {\n    flex: 1;\n    overflow: auto;\n    position: relative;\n}\n\n\n.footer {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    min-height: var(--touch-target);\n    padding: var(--spacing-sm) var(--spacing-md);\n    padding-bottom: max(var(--spacing-sm), env(safe-area-inset-bottom));\n    background: var(--bg-secondary);\n    border-top: 1px solid var(--border);\n    flex-shrink: 0;\n    gap: var(--spacing-md);\n}\n\n.footer-start {\n    display: flex;\n    align-items: center;\n    gap: var(--spacing-sm);\n}\n\n.footer-center {\n    display: flex;\n    align-items: center;\n    gap: var(--spacing-sm);\n    flex: 1;\n    justify-content: center;\n}\n\n.footer-end {\n    display: flex;\n    align-items: center;\n    gap: var(--spacing-sm);\n}\n\n:host([no-footer]) .footer {\n    display: none;\n}\n\n:host([no-header]) .header {\n    display: none;\n}\n\n\n.overlay-container {\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    pointer-events: none;\n    z-index: 100;\n}\n\n.overlay-container ::slotted(*) {\n    pointer-events: auto;\n}\n`",
        "kind": "property",
        "value": "`\n:host {\n    display: flex;\n    flex-direction: column;\n    height: 100%;\n    width: 100%;\n    background: var(--bg-primary);\n    color: var(--fg-primary);\n    font-family: var(--font-mono);\n    overflow: hidden;\n}\n\n\n.header {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    min-height: var(--touch-target);\n    padding: 0 var(--spacing-md);\n    background: var(--bg-secondary);\n    flex-shrink: 0;\n    gap: var(--spacing-md);\n}\n\n.header-start {\n    display: flex;\n    align-items: center;\n    gap: var(--spacing-sm);\n}\n\n.header-center {\n    display: flex;\n    align-items: center;\n    gap: var(--spacing-sm);\n    flex: 1;\n    justify-content: center;\n}\n\n.header-end {\n    display: flex;\n    align-items: center;\n    gap: var(--spacing-sm);\n}\n\n.title {\n    font-size: var(--font-size-lg);\n    font-weight: 500;\n    color: var(--fg-primary);\n    white-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n}\n\n.title:empty {\n    display: none;\n}\n\n.header-btn {\n    appearance: none;\n    background: transparent;\n    border: none;\n    color: var(--fg-secondary);\n    font-size: 18px;\n    width: var(--touch-target);\n    height: var(--touch-target);\n    min-width: var(--touch-target);\n    min-height: var(--touch-target);\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    cursor: pointer;\n    border-radius: var(--radius-md);\n    transition: background var(--transition-fast), color var(--transition-fast);\n    padding: 0;\n}\n\n.header-btn:hover {\n    background: var(--bg-hover);\n    color: var(--fg-primary);\n}\n\n.header-btn:active {\n    background: var(--bg-selected);\n}\n\n.header-btn.hidden {\n    display: none;\n}\n\n\n.content {\n    flex: 1;\n    overflow: auto;\n    position: relative;\n}\n\n\n.footer {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    min-height: var(--touch-target);\n    padding: var(--spacing-sm) var(--spacing-md);\n    padding-bottom: max(var(--spacing-sm), env(safe-area-inset-bottom));\n    background: var(--bg-secondary);\n    border-top: 1px solid var(--border);\n    flex-shrink: 0;\n    gap: var(--spacing-md);\n}\n\n.footer-start {\n    display: flex;\n    align-items: center;\n    gap: var(--spacing-sm);\n}\n\n.footer-center {\n    display: flex;\n    align-items: center;\n    gap: var(--spacing-sm);\n    flex: 1;\n    justify-content: center;\n}\n\n.footer-end {\n    display: flex;\n    align-items: center;\n    gap: var(--spacing-sm);\n}\n\n:host([no-footer]) .footer {\n    display: none;\n}\n\n:host([no-header]) .header {\n    display: none;\n}\n\n\n.overlay-container {\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    pointer-events: none;\n    z-index: 100;\n}\n\n.overlay-container ::slotted(*) {\n    pointer-events: auto;\n}\n`"
      },
      {
        "name": "observedAttributes",
        "line": 174,
        "source": "static get observedAttributes () {\n    return ['title', 'no-header', 'no-footer', 'no-menu', 'no-close']\n}",
        "kind": "method",
        "params": []
      }
    ],
    "methods": [
      {
        "name": "onConnected",
        "line": 168,
        "source": "onConnected () {\n    this.#buildDOM()\n    this.#updateButtonVisibility()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "attributeChangedCallback",
        "line": 179,
        "source": "attributeChangedCallback (name) {\n    if (name === 'title') {\n        this.#updateTitle()\n    } else if (name === 'no-menu' || name === 'no-close') {\n        this.#updateButtonVisibility()\n    }\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "setTitle",
        "line": 198,
        "source": "setTitle (value) {\n    this.title = value\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      }
    ],
    "getters": [
      {
        "name": "title",
        "line": 188,
        "source": "get title () {\n    return this.getAttribute('title') || ''\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "title",
        "line": 193,
        "source": "set title (value) {\n    this.setAttribute('title', value)\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      }
    ],
    "constructor": null,
    "isDefault": true
  },
  "/editor/layout/overlay.doc.js": {
    "type": "class",
    "file": "/editor/layout/overlay.js",
    "name": "Overlay",
    "line": 5,
    "extends": "EditorComponent",
    "statics": [
      {
        "name": "styles",
        "line": 7,
        "source": "static styles = `\n    :host {\n        display: none;\n        position: fixed;\n        top: 0;\n        left: 0;\n        right: 0;\n        bottom: 0;\n        z-index: 1000;\n        font-family: var(--font-mono);\n    }\n\n    :host([open]) {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n    }\n\n    .backdrop {\n        position: absolute;\n        top: 0;\n        left: 0;\n        right: 0;\n        bottom: 0;\n        background: rgba(0, 0, 0, 0.6);\n        backdrop-filter: blur(4px);\n        -webkit-backdrop-filter: blur(4px);\n    }\n\n    :host([no-backdrop]) .backdrop {\n        background: transparent;\n        backdrop-filter: none;\n        -webkit-backdrop-filter: none;\n    }\n\n    .container {\n        position: relative;\n        display: flex;\n        background: var(--bg-secondary);\n        border: 1px solid var(--border);\n        border-radius: var(--radius-lg);\n        box-shadow: var(--shadow-lg);\n        max-width: 90vw;\n        max-height: 90vh;\n        overflow: hidden;\n        animation: overlay-enter 0.15s ease-out;\n    }\n\n    @keyframes overlay-enter {\n        from {\n            opacity: 0;\n            transform: scale(0.95);\n        }\n        to {\n            opacity: 1;\n            transform: scale(1);\n        }\n    }\n\n    :host([position=\"top\"]) {\n        align-items: flex-start;\n        padding-top: 10vh;\n    }\n\n    :host([position=\"bottom\"]) {\n        align-items: flex-end;\n        padding-bottom: 10vh;\n    }\n\n\n    :host([fullscreen]) .container {\n        width: 100%;\n        height: 100%;\n        max-width: 100vw;\n        max-height: 100vh;\n        border-radius: 0;\n        border: none;\n    }\n\n\n    :host([context=\"studio\"]) .container {\n        border-radius: var(--radius-xl);\n    }\n\n    :host([context=\"studio\"][fullscreen]) .container {\n        border-radius: 0;\n    }\n`",
        "kind": "property",
        "value": "`\n    :host {\n        display: none;\n        position: fixed;\n        top: 0;\n        left: 0;\n        right: 0;\n        bottom: 0;\n        z-index: 1000;\n        font-family: var(--font-mono);\n    }\n\n    :host([open]) {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n    }\n\n    .backdrop {\n        position: absolute;\n        top: 0;\n        left: 0;\n        right: 0;\n        bottom: 0;\n        background: rgba(0, 0, 0, 0.6);\n        backdrop-filter: blur(4px);\n        -webkit-backdrop-filter: blur(4px);\n    }\n\n    :host([no-backdrop]) .backdrop {\n        background: transparent;\n        backdrop-filter: none;\n        -webkit-backdrop-filter: none;\n    }\n\n    .container {\n        position: relative;\n        display: flex;\n        background: var(--bg-secondary);\n        border: 1px solid var(--border);\n        border-radius: var(--radius-lg);\n        box-shadow: var(--shadow-lg);\n        max-width: 90vw;\n        max-height: 90vh;\n        overflow: hidden;\n        animation: overlay-enter 0.15s ease-out;\n    }\n\n    @keyframes overlay-enter {\n        from {\n            opacity: 0;\n            transform: scale(0.95);\n        }\n        to {\n            opacity: 1;\n            transform: scale(1);\n        }\n    }\n\n    :host([position=\"top\"]) {\n        align-items: flex-start;\n        padding-top: 10vh;\n    }\n\n    :host([position=\"bottom\"]) {\n        align-items: flex-end;\n        padding-bottom: 10vh;\n    }\n\n\n    :host([fullscreen]) .container {\n        width: 100%;\n        height: 100%;\n        max-width: 100vw;\n        max-height: 100vh;\n        border-radius: 0;\n        border: none;\n    }\n\n\n    :host([context=\"studio\"]) .container {\n        border-radius: var(--radius-xl);\n    }\n\n    :host([context=\"studio\"][fullscreen]) .container {\n        border-radius: 0;\n    }\n`"
      },
      {
        "name": "observedAttributes",
        "line": 105,
        "source": "static get observedAttributes () {\n    return ['open']\n}",
        "kind": "method",
        "params": []
      }
    ],
    "methods": [
      {
        "name": "open",
        "line": 115,
        "source": "open () {\n    if (!this.isOpen) {\n        this.setAttribute('open', '')\n        this.dispatchEvent(new CustomEvent('open', {bubbles: true}))\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "close",
        "line": 123,
        "source": "close () {\n    if (this.isOpen) {\n        this.removeAttribute('open')\n        this.dispatchEvent(new CustomEvent('close', {bubbles: true}))\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "toggle",
        "line": 131,
        "source": "toggle () {\n    if (this.isOpen) {\n        this.close()\n    } else {\n        this.open()\n    }\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "isOpen",
        "line": 110,
        "source": "get isOpen () {\n    return this.hasAttribute('open')\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 99,
      "source": "constructor () {\n    super()\n    this.#buildDOM()\n}",
      "kind": "constructor",
      "params": []
    },
    "isDefault": true
  },
  "/editor/layout/panel.doc.js": {
    "type": "class",
    "file": "/editor/layout/panel.js",
    "name": "Panel",
    "line": 5,
    "extends": "EditorComponent",
    "statics": [
      {
        "name": "styles",
        "line": 7,
        "source": "static styles = `\n    :host {\n        display: block;\n        background: var(--bg-secondary);\n        border: 1px solid var(--border);\n        border-radius: var(--radius-lg);\n        overflow: hidden;\n        font-family: var(--font-mono);\n        box-shadow: var(--shadow-md);\n    }\n\n    :host([floating]) {\n        position: absolute;\n        min-width: 200px;\n        min-height: 100px;\n        resize: both;\n        overflow: auto;\n    }\n\n    :host([collapsed]) {\n        height: auto !important;\n        min-height: 0;\n        resize: none;\n    }\n\n    :host([collapsed]) .panel-content {\n        display: none;\n    }\n\n\n    .panel-header {\n        display: flex;\n        align-items: center;\n        justify-content: space-between;\n        height: 32px;\n        padding: 0 var(--spacing-sm);\n        background: var(--bg-tertiary);\n        border-bottom: 1px solid var(--border);\n        cursor: default;\n        user-select: none;\n        -webkit-user-select: none;\n        gap: var(--spacing-xs);\n    }\n\n    :host([floating]) .panel-header {\n        cursor: grab;\n    }\n\n    :host([floating]) .panel-header:active {\n        cursor: grabbing;\n    }\n\n    .panel-title {\n        font-size: var(--font-size-sm);\n        font-weight: 500;\n        color: var(--fg-primary);\n        flex: 1;\n        white-space: nowrap;\n        overflow: hidden;\n        text-overflow: ellipsis;\n    }\n\n    .panel-actions {\n        display: flex;\n        align-items: center;\n        gap: 2px;\n    }\n\n    .panel-btn {\n        appearance: none;\n        background: transparent;\n        border: none;\n        color: var(--fg-muted);\n        font-size: 12px;\n        width: 24px;\n        height: 24px;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        cursor: pointer;\n        border-radius: var(--radius-sm);\n        transition: background var(--transition-fast), color var(--transition-fast);\n        padding: 0;\n    }\n\n    .panel-btn:hover {\n        background: var(--bg-hover);\n        color: var(--fg-primary);\n    }\n\n    .panel-btn:active {\n        background: var(--bg-selected);\n    }\n\n\n    .panel-content {\n        padding: var(--spacing-sm);\n        overflow: auto;\n        max-height: 400px;\n    }\n\n    :host([no-padding]) .panel-content {\n        padding: 0;\n    }\n\n\n    :host([context=\"studio\"]) .panel-header {\n        height: var(--touch-target);\n        padding: 0 var(--spacing-md);\n    }\n\n    :host([context=\"studio\"]) .panel-title {\n        font-size: var(--font-size-md);\n    }\n\n    :host([context=\"studio\"]) .panel-btn {\n        width: var(--touch-target);\n        height: var(--touch-target);\n        font-size: 16px;\n    }\n\n    :host([context=\"studio\"]) .panel-content {\n        padding: var(--spacing-md);\n    }\n\n    :host([context=\"studio\"][no-padding]) .panel-content {\n        padding: 0;\n    }\n`",
        "kind": "property",
        "value": "`\n    :host {\n        display: block;\n        background: var(--bg-secondary);\n        border: 1px solid var(--border);\n        border-radius: var(--radius-lg);\n        overflow: hidden;\n        font-family: var(--font-mono);\n        box-shadow: var(--shadow-md);\n    }\n\n    :host([floating]) {\n        position: absolute;\n        min-width: 200px;\n        min-height: 100px;\n        resize: both;\n        overflow: auto;\n    }\n\n    :host([collapsed]) {\n        height: auto !important;\n        min-height: 0;\n        resize: none;\n    }\n\n    :host([collapsed]) .panel-content {\n        display: none;\n    }\n\n\n    .panel-header {\n        display: flex;\n        align-items: center;\n        justify-content: space-between;\n        height: 32px;\n        padding: 0 var(--spacing-sm);\n        background: var(--bg-tertiary);\n        border-bottom: 1px solid var(--border);\n        cursor: default;\n        user-select: none;\n        -webkit-user-select: none;\n        gap: var(--spacing-xs);\n    }\n\n    :host([floating]) .panel-header {\n        cursor: grab;\n    }\n\n    :host([floating]) .panel-header:active {\n        cursor: grabbing;\n    }\n\n    .panel-title {\n        font-size: var(--font-size-sm);\n        font-weight: 500;\n        color: var(--fg-primary);\n        flex: 1;\n        white-space: nowrap;\n        overflow: hidden;\n        text-overflow: ellipsis;\n    }\n\n    .panel-actions {\n        display: flex;\n        align-items: center;\n        gap: 2px;\n    }\n\n    .panel-btn {\n        appearance: none;\n        background: transparent;\n        border: none;\n        color: var(--fg-muted);\n        font-size: 12px;\n        width: 24px;\n        height: 24px;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        cursor: pointer;\n        border-radius: var(--radius-sm);\n        transition: background var(--transition-fast), color var(--transition-fast);\n        padding: 0;\n    }\n\n    .panel-btn:hover {\n        background: var(--bg-hover);\n        color: var(--fg-primary);\n    }\n\n    .panel-btn:active {\n        background: var(--bg-selected);\n    }\n\n\n    .panel-content {\n        padding: var(--spacing-sm);\n        overflow: auto;\n        max-height: 400px;\n    }\n\n    :host([no-padding]) .panel-content {\n        padding: 0;\n    }\n\n\n    :host([context=\"studio\"]) .panel-header {\n        height: var(--touch-target);\n        padding: 0 var(--spacing-md);\n    }\n\n    :host([context=\"studio\"]) .panel-title {\n        font-size: var(--font-size-md);\n    }\n\n    :host([context=\"studio\"]) .panel-btn {\n        width: var(--touch-target);\n        height: var(--touch-target);\n        font-size: 16px;\n    }\n\n    :host([context=\"studio\"]) .panel-content {\n        padding: var(--spacing-md);\n    }\n\n    :host([context=\"studio\"][no-padding]) .panel-content {\n        padding: 0;\n    }\n`"
      },
      {
        "name": "observedAttributes",
        "line": 159,
        "source": "static get observedAttributes () {\n    return ['title', 'collapsed', 'floating']\n}",
        "kind": "method",
        "params": []
      }
    ],
    "methods": [
      {
        "name": "onConnected",
        "line": 154,
        "source": "onConnected () {\n    this.#updateCollapseIcon()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "attributeChangedCallback",
        "line": 164,
        "source": "attributeChangedCallback (name) {\n    if (name === 'title') {\n        this.#updateTitle()\n    } else if (name === 'collapsed') {\n        this.#updateCollapseIcon()\n    }\n}",
        "kind": "method",
        "params": [
          "name"
        ]
      },
      {
        "name": "toggle",
        "line": 211,
        "source": "toggle () {\n    this.collapsed = !this.collapsed\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "title",
        "line": 173,
        "source": "get title () {\n    return this.getAttribute('title') || ''\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "collapsed",
        "line": 183,
        "source": "get collapsed () {\n    return this.hasAttribute('collapsed')\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "floating",
        "line": 197,
        "source": "get floating () {\n    return this.hasAttribute('floating')\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "title",
        "line": 178,
        "source": "set title (value) {\n    this.setAttribute('title', value)\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "collapsed",
        "line": 188,
        "source": "set collapsed (value) {\n    if (value) {\n        this.setAttribute('collapsed', '')\n    } else {\n        this.removeAttribute('collapsed')\n    }\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "floating",
        "line": 202,
        "source": "set floating (value) {\n    if (value) {\n        this.setAttribute('floating', '')\n    } else {\n        this.removeAttribute('floating')\n    }\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      }
    ],
    "constructor": {
      "name": "constructor",
      "line": 148,
      "source": "constructor () {\n    super()\n    this.#buildDOM()\n}",
      "kind": "constructor",
      "params": []
    },
    "isDefault": true
  },
  "/editor/layout/toolbar.doc.js": {
    "type": "class",
    "file": "/editor/layout/toolbar.js",
    "name": "Toolbar",
    "line": 5,
    "extends": "EditorComponent",
    "statics": [
      {
        "name": "styles",
        "line": 7,
        "source": "static styles = `\n    :host {\n        display: flex;\n        align-items: center;\n        justify-content: space-between;\n        height: 36px;\n        padding: 0 var(--spacing-sm);\n        background: var(--bg-secondary);\n        border-bottom: 1px solid var(--border);\n        gap: var(--spacing-sm);\n        font-family: var(--font-mono);\n    }\n\n    :host([variant=\"compact\"]) {\n        height: 28px;\n        padding: 0 var(--spacing-xs);\n    }\n\n    :host([variant=\"footer\"]) {\n        border-bottom: none;\n        border-top: 1px solid var(--border);\n    }\n\n    :host([no-border]) {\n        border: none;\n    }\n\n    .toolbar-section {\n        display: flex;\n        align-items: center;\n        gap: var(--spacing-xs);\n    }\n\n    .toolbar-start {\n        justify-content: flex-start;\n    }\n\n    .toolbar-center {\n        flex: 1;\n        justify-content: center;\n    }\n\n    .toolbar-end {\n        justify-content: flex-end;\n    }\n\n\n    .toolbar-separator {\n        width: 1px;\n        height: 16px;\n        background: var(--border);\n        margin: 0 var(--spacing-xs);\n    }\n\n\n    :host([context=\"studio\"]) {\n        height: var(--touch-target);\n        padding: 0 var(--spacing-md);\n        gap: var(--spacing-md);\n    }\n\n    :host([context=\"studio\"]) .toolbar-section {\n        gap: var(--spacing-sm);\n    }\n\n    :host([context=\"studio\"]) .toolbar-separator {\n        height: 24px;\n        margin: 0 var(--spacing-sm);\n    }\n`",
        "kind": "property",
        "value": "`\n    :host {\n        display: flex;\n        align-items: center;\n        justify-content: space-between;\n        height: 36px;\n        padding: 0 var(--spacing-sm);\n        background: var(--bg-secondary);\n        border-bottom: 1px solid var(--border);\n        gap: var(--spacing-sm);\n        font-family: var(--font-mono);\n    }\n\n    :host([variant=\"compact\"]) {\n        height: 28px;\n        padding: 0 var(--spacing-xs);\n    }\n\n    :host([variant=\"footer\"]) {\n        border-bottom: none;\n        border-top: 1px solid var(--border);\n    }\n\n    :host([no-border]) {\n        border: none;\n    }\n\n    .toolbar-section {\n        display: flex;\n        align-items: center;\n        gap: var(--spacing-xs);\n    }\n\n    .toolbar-start {\n        justify-content: flex-start;\n    }\n\n    .toolbar-center {\n        flex: 1;\n        justify-content: center;\n    }\n\n    .toolbar-end {\n        justify-content: flex-end;\n    }\n\n\n    .toolbar-separator {\n        width: 1px;\n        height: 16px;\n        background: var(--border);\n        margin: 0 var(--spacing-xs);\n    }\n\n\n    :host([context=\"studio\"]) {\n        height: var(--touch-target);\n        padding: 0 var(--spacing-md);\n        gap: var(--spacing-md);\n    }\n\n    :host([context=\"studio\"]) .toolbar-section {\n        gap: var(--spacing-sm);\n    }\n\n    :host([context=\"studio\"]) .toolbar-separator {\n        height: 24px;\n        margin: 0 var(--spacing-sm);\n    }\n`"
      },
      {
        "name": "observedAttributes",
        "line": 84,
        "source": "static get observedAttributes () {\n    return ['variant']\n}",
        "kind": "method",
        "params": []
      }
    ],
    "methods": [],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 78,
      "source": "constructor () {\n    super()\n    this.#buildDOM()\n}",
      "kind": "constructor",
      "params": []
    },
    "isDefault": true
  },
  "/editor/log_renderers/vec2_log_renderer.doc.js": {
    "type": "module",
    "file": "/editor/log_renderers/vec2_log_renderer.js",
    "functions": [
      {
        "name": "formatNumber",
        "line": 5,
        "params": [
          "n"
        ],
        "source": "function formatNumber (n) {\n    if (Number.isInteger(n)) {\n        return String(n)\n    }\n    return n.toFixed(2)\n}"
      }
    ],
    "exports": []
  },
  "/doc/api_parser.doc.js": {
    "type": "module",
    "file": "/doc/api_parser.js",
    "functions": [
      {
        "name": "parseSourceFile",
        "line": 5,
        "params": [
          "source",
          "filePath = ..."
        ],
        "source": "function parseSourceFile (source, filePath = null) {\n    const ast = acorn.parse(source, {\n        ecmaVersion: 'latest',\n        sourceType: 'module',\n        locations: true\n    })\n\n    const result = {\n        file: filePath,\n        classes: [],\n        functions: [],\n        exports: []\n    }\n\n    for (const node of ast.body) {\n        processNode(node, source, result)\n    }\n\n    return result\n}"
      },
      {
        "name": "processNode",
        "line": 27,
        "params": [
          "node",
          "source",
          "result"
        ],
        "source": "function processNode (node, source, result) {\n    if (node.type === 'ExportDefaultDeclaration') {\n        processDefaultExport(node, source, result)\n    } else if (node.type === 'ExportNamedDeclaration') {\n        processNamedExport(node, source, result)\n    } else if (node.type === 'ClassDeclaration') {\n        result.classes.push(parseClass(node, source))\n    } else if (node.type === 'FunctionDeclaration') {\n        result.functions.push(parseFunction(node, source))\n    }\n}"
      },
      {
        "name": "processDefaultExport",
        "line": 40,
        "params": [
          "node",
          "source",
          "result"
        ],
        "source": "function processDefaultExport (node, source, result) {\n    if (node.declaration.type === 'ClassDeclaration') {\n        const classInfo = parseClass(node.declaration, source)\n        classInfo.isDefault = true\n        result.classes.push(classInfo)\n    } else if (node.declaration.type === 'FunctionDeclaration') {\n        const fnInfo = parseFunction(node.declaration, source)\n        fnInfo.isDefault = true\n        result.functions.push(fnInfo)\n    }\n}"
      },
      {
        "name": "processNamedExport",
        "line": 53,
        "params": [
          "node",
          "source",
          "result"
        ],
        "source": "function processNamedExport (node, source, result) {\n    const decl = node.declaration\n\n    if (!decl) {\n        return\n    }\n\n    if (decl.type === 'ClassDeclaration') {\n        result.classes.push(parseClass(decl, source))\n    } else if (decl.type === 'FunctionDeclaration') {\n        result.functions.push(parseFunction(decl, source))\n    } else if (decl.type === 'VariableDeclaration') {\n        for (const varDecl of decl.declarations) {\n            result.exports.push({\n                name: varDecl.id.name,\n                kind: 'variable',\n                line: node.loc.start.line,\n                source: extractSource(source, node)\n            })\n        }\n    }\n}"
      },
      {
        "name": "parseClass",
        "line": 77,
        "params": [
          "node",
          "source"
        ],
        "source": "function parseClass (node, source) {\n    const classInfo = {\n        name: node.id?.name || 'Anonymous',\n        line: node.loc.start.line,\n        extends: node.superClass?.name || null,\n        statics: [],\n        methods: [],\n        getters: [],\n        setters: [],\n        constructor: null\n    }\n\n    for (const member of node.body.body) {\n        if (isPrivate(member)) {\n            continue\n        }\n\n        const memberInfo = parseMember(member, source)\n\n        if (memberInfo) {\n            addMemberToClass(classInfo, member, memberInfo)\n        }\n    }\n\n    return classInfo\n}"
      },
      {
        "name": "addMemberToClass",
        "line": 105,
        "params": [
          "classInfo",
          "member",
          "memberInfo"
        ],
        "source": "function addMemberToClass (classInfo, member, memberInfo) {\n    const target = getMemberTarget(classInfo, member)\n\n    if (target) {\n        target.push(memberInfo)\n    } else if (member.kind === 'constructor') {\n        classInfo.constructor = memberInfo\n    }\n}"
      },
      {
        "name": "getMemberTarget",
        "line": 116,
        "params": [
          "classInfo",
          "member"
        ],
        "source": "function getMemberTarget (classInfo, member) {\n    if (member.static) {\n        return classInfo.statics\n    }\n\n    if (member.kind === 'get') {\n        return classInfo.getters\n    }\n\n    if (member.kind === 'set') {\n        return classInfo.setters\n    }\n\n    if (member.kind === 'method') {\n        return classInfo.methods\n    }\n\n    return null\n}"
      },
      {
        "name": "parseMember",
        "line": 137,
        "params": [
          "member",
          "source"
        ],
        "source": "function parseMember (member, source) {\n    const name = getMemberName(member)\n\n    if (!name) {\n        return null\n    }\n\n    const base = {\n        name,\n        line: member.loc.start.line,\n        source: extractSource(source, member)\n    }\n\n    if (member.type === 'PropertyDefinition') {\n        return {\n            ...base,\n            kind: 'property',\n            value: member.value ? extractSource(source, member.value) : null\n        }\n    }\n\n    if (member.type === 'MethodDefinition') {\n        return {\n            ...base,\n            kind: member.kind === 'constructor' ? 'constructor' : 'method',\n            params: extractParams(member.value)\n        }\n    }\n\n    return base\n}"
      },
      {
        "name": "parseFunction",
        "line": 170,
        "params": [
          "node",
          "source"
        ],
        "source": "function parseFunction (node, source) {\n    return {\n        name: node.id?.name || 'anonymous',\n        line: node.loc.start.line,\n        params: extractParams(node),\n        source: extractSource(source, node)\n    }\n}"
      },
      {
        "name": "isPrivate",
        "line": 180,
        "params": [
          "member"
        ],
        "source": "function isPrivate (member) {\n    if (member.key?.type === 'PrivateIdentifier') {\n        return true\n    }\n\n    const name = getMemberName(member)\n\n    return name && name.startsWith('#')\n}"
      },
      {
        "name": "getMemberName",
        "line": 191,
        "params": [
          "member"
        ],
        "source": "function getMemberName (member) {\n    if (member.key?.type === 'Identifier') {\n        return member.key.name\n    }\n\n    if (member.key?.type === 'PrivateIdentifier') {\n        return '#' + member.key.name\n    }\n\n    if (member.key?.type === 'Literal') {\n        return String(member.key.value)\n    }\n\n    return null\n}"
      },
      {
        "name": "extractParams",
        "line": 208,
        "params": [
          "fnNode"
        ],
        "source": "function extractParams (fnNode) {\n    if (!fnNode.params) {\n        return []\n    }\n\n    return fnNode.params.map(param => {\n        if (param.type === 'Identifier') {\n            return param.name\n        }\n\n        if (param.type === 'AssignmentPattern') {\n            return param.left.name + ' = ...'\n        }\n\n        if (param.type === 'RestElement') {\n            return '...' + param.argument.name\n        }\n\n        if (param.type === 'ObjectPattern') {\n            return '{...}'\n        }\n\n        if (param.type === 'ArrayPattern') {\n            return '[...]'\n        }\n\n        return '?'\n    })\n}"
      },
      {
        "name": "extractSource",
        "line": 239,
        "params": [
          "source",
          "node"
        ],
        "source": "function extractSource (source, node) {\n    const raw = source.slice(node.start, node.end)\n    return dedentSource(raw)\n}"
      },
      {
        "name": "getApiForFile",
        "line": 245,
        "params": [
          "source",
          "filePath = ..."
        ],
        "source": "function getApiForFile (source, filePath = null) {\n    const parsed = parseSourceFile(source, filePath)\n\n    if (parsed.classes.length === 1) {\n        return {\n            type: 'class',\n            file: filePath,\n            ...parsed.classes[0]\n        }\n    }\n\n    if (parsed.classes.length > 1) {\n        return {\n            type: 'module',\n            file: filePath,\n            classes: parsed.classes,\n            functions: parsed.functions,\n            exports: parsed.exports\n        }\n    }\n\n    if (parsed.functions.length > 0 || parsed.exports.length > 0) {\n        return {\n            type: 'module',\n            file: filePath,\n            functions: parsed.functions,\n            exports: parsed.exports\n        }\n    }\n\n    return null\n}"
      }
    ],
    "exports": []
  },
  "/doc/discovery.doc.js": {
    "type": "module",
    "file": "/doc/discovery.js",
    "functions": [
      {
        "name": "loadOrderConfig",
        "line": 16,
        "params": [],
        "source": "function loadOrderConfig () {\n    const orderPath = path.join(__dirname, 'order.json')\n\n    try {\n        return JSON.parse(fs.readFileSync(orderPath, 'utf-8'))\n    } catch {\n        return {guides: {categories: [], items: {}}, docs: {categories: [], items: {}}}\n    }\n}"
      },
      {
        "name": "getCategoryRootAndFull",
        "line": 27,
        "params": [
          "category"
        ],
        "source": "function getCategoryRootAndFull (category) {\n    const parts = category.split('/')\n    const root = parts[0]\n    return {root, full: category}\n}"
      },
      {
        "name": "getCategoryPosition",
        "line": 34,
        "params": [
          "category",
          "categoryOrder"
        ],
        "source": "function getCategoryPosition (category, categoryOrder) {\n    const cat = getCategoryRootAndFull(category)\n    let index = categoryOrder.indexOf(cat.full)\n    if (index === -1) {\n        index = categoryOrder.indexOf(cat.root)\n    }\n    return index === -1 ? 999 : index\n}"
      },
      {
        "name": "compareCategoriesWithSameRoot",
        "line": 44,
        "params": [
          "categoryA",
          "categoryB"
        ],
        "source": "function compareCategoriesWithSameRoot (categoryA, categoryB) {\n    const aCat = getCategoryRootAndFull(categoryA)\n    const bCat = getCategoryRootAndFull(categoryB)\n\n    if (aCat.root === aCat.full && bCat.root !== bCat.full && aCat.root === bCat.root) {\n        return -1\n    }\n    if (bCat.root === bCat.full && aCat.root !== aCat.full && aCat.root === bCat.root) {\n        return 1\n    }\n\n    return categoryA.localeCompare(categoryB)\n}"
      },
      {
        "name": "getItemPosition",
        "line": 59,
        "params": [
          "itemId",
          "category",
          "itemOrder"
        ],
        "source": "function getItemPosition (itemId, category, itemOrder) {\n    const categoryItems = itemOrder[category] || []\n    const index = categoryItems.indexOf(itemId)\n    return index === -1 ? 999 : index\n}"
      },
      {
        "name": "sortWithOrder",
        "line": 66,
        "params": [
          "items",
          "orderConfig"
        ],
        "source": "function sortWithOrder (items, orderConfig) {\n    const categoryOrder = orderConfig.categories || []\n    const itemOrder = orderConfig.items || {}\n\n    return items.sort((a, b) => {\n        const catPosA = getCategoryPosition(a.category, categoryOrder)\n        const catPosB = getCategoryPosition(b.category, categoryOrder)\n\n        if (catPosA !== catPosB) {\n            return catPosA - catPosB\n        }\n\n        if (a.category !== b.category) {\n            return compareCategoriesWithSameRoot(a.category, b.category)\n        }\n\n        if (a.featured !== b.featured) {\n            return a.featured ? -1 : 1\n        }\n\n        const itemPosA = getItemPosition(a.id, a.category, itemOrder)\n        const itemPosB = getItemPosition(b.id, b.category, itemOrder)\n\n        if (itemPosA !== itemPosB) {\n            return itemPosA - itemPosB\n        }\n\n        return a.title.localeCompare(b.title)\n    })\n}"
      },
      {
        "name": "toPascalCase",
        "line": 98,
        "params": [
          "str"
        ],
        "source": "function toPascalCase (str) {\n    return str\n        .split(/[-_]/)\n        .map(word => word.charAt(0).toUpperCase() + word.slice(1))\n        .join('')\n}"
      },
      {
        "name": "extractDocMetadata",
        "line": 106,
        "params": [
          "filePath"
        ],
        "source": "function extractDocMetadata (filePath) {\n    try {\n        const source = fs.readFileSync(filePath, 'utf-8')\n\n        const titleMatch = source.match(/export\\s+default\\s+doc\\s*\\(\\s*['\"`]([^'\"`]+)['\"`]/)\n        const title = titleMatch ? titleMatch[1] : null\n\n        const optionsMatch = source.match(/export\\s+default\\s+doc\\s*\\(\\s*['\"`][^'\"`]+['\"`]\\s*,\\s*(\\{[^}]+\\})/)\n        let featured = false\n        let advanced = false\n\n        if (optionsMatch) {\n            const optionsStr = optionsMatch[1]\n            featured = /featured\\s*:\\s*true/.test(optionsStr)\n            advanced = /advanced\\s*:\\s*true/.test(optionsStr)\n        }\n\n        return {title, featured, advanced}\n    } catch {\n        return {title: null, featured: false, advanced: false}\n    }\n}"
      },
      {
        "name": "discoverDocs",
        "line": 130,
        "params": [],
        "source": "async function discoverDocs () {\n    const files = await glob('**/*.doc.js', {\n        cwd: rootDir,\n        ignore: ['node_modules/**', 'dist/**']\n    })\n\n    const orderConfig = loadOrderConfig()\n\n    const docs = files.map(file => {\n        const relativePath = '/' + file\n        const basename = path.basename(file, '.doc.js')\n        const directory = path.dirname(file)\n        const category = directory || 'core'\n        const absolutePath = path.join(rootDir, file)\n        const metadata = extractDocMetadata(absolutePath)\n\n        return {\n            id: basename,\n            file: relativePath,\n            category,\n            title: metadata.title || toPascalCase(basename),\n            tags: [category, basename],\n            featured: metadata.featured,\n            advanced: metadata.advanced\n        }\n    })\n\n    sortWithOrder(docs, orderConfig.docs || {})\n\n    return {docs}\n}"
      },
      {
        "name": "discoverGuides",
        "line": 163,
        "params": [],
        "source": "async function discoverGuides () {\n    const files = await glob('doc/guides/**/*.guide.js', {\n        cwd: rootDir,\n        ignore: ['node_modules/**', 'dist/**']\n    })\n\n    const guides = files.map(file => {\n        const relativePath = '/' + file\n        const basename = path.basename(file, '.guide.js')\n        const directory = path.dirname(file).replace('doc/guides/', '').replace('doc/guides', '')\n        const category = directory.split('/')[0] || 'general'\n\n        return {\n            id: basename,\n            file: relativePath,\n            category,\n            title: toPascalCase(basename),\n            tags: [category, basename]\n        }\n    })\n\n    const orderConfig = loadOrderConfig()\n    sortWithOrder(guides, orderConfig.guides || {})\n\n    return guides\n}"
      },
      {
        "name": "buildApiData",
        "line": 191,
        "params": [
          "docs"
        ],
        "source": "async function buildApiData (docs) {\n    const api = {}\n\n    for (const doc of docs) {\n        const sourcePath = doc.file.replace('.doc.js', '.js')\n        const fullPath = path.join(rootDir, sourcePath)\n\n        if (!fs.existsSync(fullPath)) {\n            continue\n        }\n\n        try {\n            const source = fs.readFileSync(fullPath, 'utf-8')\n            const apiData = getApiForFile(source, sourcePath)\n\n            if (apiData) {\n                api[doc.file] = apiData\n            }\n        } catch (error) {\n            logger.warn(`  Warning: Could not parse API for ${sourcePath}: ${error.message}`)\n        }\n    }\n\n    return api\n}"
      },
      {
        "name": "buildSourcesData",
        "line": 218,
        "params": [
          "docs"
        ],
        "source": "function buildSourcesData (docs) {\n    const sourcesDir = path.join(__dirname, 'sources')\n\n    if (!fs.existsSync(sourcesDir)) {\n        fs.mkdirSync(sourcesDir, {recursive: true})\n    }\n\n    let count = 0\n\n    for (const doc of docs) {\n        const fullPath = path.join(rootDir, doc.file)\n\n        try {\n            const blocks = parseDocFile(fullPath)\n            if (blocks.length > 0) {\n                const outputName = doc.file.slice(1).replace(/\\//g, '_')\n                const outputPath = path.join(sourcesDir, outputName.replace('.js', '.json'))\n                fs.writeFileSync(outputPath, JSON.stringify(blocks, null, 2))\n                count++\n            }\n        } catch (error) {\n            logger.warn(`  Warning: Could not parse sources for ${doc.file}: ${error.message}`)\n        }\n    }\n\n    return count\n}"
      },
      {
        "name": "buildGuideSources",
        "line": 247,
        "params": [
          "guides"
        ],
        "source": "function buildGuideSources (guides) {\n    const sourcesDir = path.join(__dirname, 'sources')\n\n    if (!fs.existsSync(sourcesDir)) {\n        fs.mkdirSync(sourcesDir, {recursive: true})\n    }\n\n    let count = 0\n\n    for (const guide of guides) {\n        const fullPath = path.join(rootDir, guide.file)\n\n        try {\n            const blocks = parseDocFile(fullPath)\n            if (blocks.length > 0) {\n                const outputName = 'guide_' + guide.id + '.json'\n                const outputPath = path.join(sourcesDir, outputName)\n                fs.writeFileSync(outputPath, JSON.stringify(blocks, null, 2))\n                count++\n            }\n        } catch (error) {\n            logger.warn(`  Warning: Could not parse sources for ${guide.file}: ${error.message}`)\n        }\n    }\n\n    return count\n}"
      },
      {
        "name": "buildTestsData",
        "line": 276,
        "params": [
          "docs"
        ],
        "source": "function buildTestsData (docs) {\n    const tests = {}\n\n    for (const doc of docs) {\n        const testPath = doc.file.replace('.doc.js', '.test.js')\n        const fullPath = path.join(rootDir, testPath)\n\n        if (!fs.existsSync(fullPath)) {\n            continue\n        }\n\n        try {\n            const source = fs.readFileSync(fullPath, 'utf-8')\n            const testData = getTestsForFile(source, testPath)\n\n            if (testData) {\n                tests[doc.file] = testData\n            }\n        } catch (error) {\n            logger.warn(`  Warning: Could not parse tests for ${testPath}: ${error.message}`)\n        }\n    }\n\n    return tests\n}"
      },
      {
        "name": "generateIndexHtml",
        "line": 303,
        "params": [],
        "source": "function generateIndexHtml () {\n    return `<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Perky Docs</title>\n    <link rel=\"stylesheet\" href=\"doc_index.css\">\n</head>\n<body>\n    <div class=\"docs-layout\">\n        <aside class=\"docs-sidebar\">\n            <div class=\"sidebar-header\">\n                <h1>perky docs</h1>\n                <div class=\"sidebar-search\">\n                    <svg class=\"search-icon\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\">\n                        <circle cx=\"11\" cy=\"11\" r=\"8\"></circle>\n                        <path d=\"m21 21-4.35-4.35\"></path>\n                    </svg>\n                    <input type=\"text\" class=\"search-input\" placeholder=\"Search...\">\n                </div>\n                <div class=\"nav-switcher\" id=\"nav-switcher\"></div>\n                <label class=\"advanced-toggle\" id=\"advanced-toggle\">\n                    <input type=\"checkbox\" class=\"advanced-toggle-input\">\n                    <span class=\"advanced-toggle-track\">\n                        <span class=\"advanced-toggle-thumb\"></span>\n                    </span>\n                    <span class=\"advanced-toggle-label\">Show advanced</span>\n                </label>\n            </div>\n            <nav class=\"sidebar-nav\" id=\"docs-nav\"></nav>\n        </aside>\n\n        <main class=\"docs-main\">\n            <div class=\"docs-content\" id=\"doc-container\"></div>\n            <div class=\"docs-logger\">\n                <perky-logger id=\"main-logger\" max-entries=\"30\"></perky-logger>\n            </div>\n        </main>\n    </div>\n\n    <script type=\"module\" src=\"doc_viewer.js\"></script>\n</body>\n</html>\n`\n}"
      },
      {
        "name": "main",
        "line": 351,
        "params": [],
        "source": "async function main () {\n    const result = await discoverDocs()\n    const guides = await discoverGuides()\n\n    const outputData = {\n        docs: result.docs,\n        guides\n    }\n\n    const docsOutputPath = path.join(__dirname, 'docs.json')\n    fs.writeFileSync(docsOutputPath, JSON.stringify(outputData, null, 2))\n\n    logger.log(`Discovered ${result.docs.length} doc file(s):`)\n    for (const doc of result.docs) {\n        logger.log(`  - ${doc.category}/${doc.title} (${doc.file})`)\n    }\n\n    logger.log(`\\nDiscovered ${guides.length} guide file(s):`)\n    for (const guide of guides) {\n        logger.log(`  - ${guide.category}/${guide.title} (${guide.file})`)\n    }\n\n    const apiData = await buildApiData(result.docs)\n    const apiOutputPath = path.join(__dirname, 'api.json')\n\n    fs.writeFileSync(apiOutputPath, JSON.stringify(apiData, null, 2))\n\n    const apiCount = Object.keys(apiData).length\n    logger.log(`\\nGenerated API data for ${apiCount} file(s)`)\n\n    const testsData = buildTestsData(result.docs)\n    const testsOutputPath = path.join(__dirname, 'tests.json')\n\n    fs.writeFileSync(testsOutputPath, JSON.stringify(testsData, null, 2))\n\n    const testsCount = Object.keys(testsData).length\n    logger.log(`\\nGenerated tests data for ${testsCount} file(s)`)\n\n    const sourcesCount = buildSourcesData(result.docs)\n    logger.log(`\\nExtracted sources for ${sourcesCount} doc file(s)`)\n\n    const guideSourcesCount = buildGuideSources(guides)\n    logger.log(`Extracted sources for ${guideSourcesCount} guide file(s)`)\n\n    const indexHtml = generateIndexHtml()\n    const indexPath = path.join(__dirname, 'index.html')\n    fs.writeFileSync(indexPath, indexHtml)\n    logger.log('\\nGenerated index.html')\n}"
      }
    ],
    "exports": []
  },
  "/doc/doc_page.doc.js": {
    "type": "class",
    "file": "/doc/doc_page.js",
    "name": "DocPage",
    "line": 12,
    "extends": "HTMLElement",
    "statics": [],
    "methods": [
      {
        "name": "connectedCallback",
        "line": 32,
        "source": "connectedCallback () {\n    this.#buildDOM()\n    this.#setupAnchorNavigation()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "disconnectedCallback",
        "line": 57,
        "source": "disconnectedCallback () {\n    this.#disposeAll()\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "doc",
        "line": 81,
        "source": "get doc () {\n    return this.#doc\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "api",
        "line": 94,
        "source": "get api () {\n    return this.#api\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "sources",
        "line": 104,
        "source": "get sources () {\n    return this.#sources\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "tests",
        "line": 114,
        "source": "get tests () {\n    return this.#tests\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "activeTab",
        "line": 126,
        "source": "get activeTab () {\n    return this.#activeTab\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "availableTabs",
        "line": 131,
        "source": "get availableTabs () {\n    const tabs = ['doc']\n    if (this.#api) {\n        tabs.push('api')\n    }\n    if (this.#tests) {\n        tabs.push('test')\n    }\n    return tabs\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [
      {
        "name": "doc",
        "line": 73,
        "source": "set doc (value) {\n    this.#doc = value\n    if (this.isConnected) {\n        this.#render()\n    }\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "api",
        "line": 86,
        "source": "set api (value) {\n    this.#api = value\n    if (this.isConnected) {\n        this.#render()\n    }\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "sources",
        "line": 99,
        "source": "set sources (value) {\n    this.#sources = value\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "tests",
        "line": 109,
        "source": "set tests (value) {\n    this.#tests = value\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      },
      {
        "name": "initialTab",
        "line": 119,
        "source": "set initialTab (value) {\n    if (value === 'api' || value === 'doc' || value === 'test') {\n        this.#activeTab = value\n    }\n}",
        "kind": "method",
        "params": [
          "value"
        ]
      }
    ],
    "constructor": {
      "name": "constructor",
      "line": 26,
      "source": "constructor () {\n    super()\n    this.attachShadow({mode: 'open'})\n}",
      "kind": "constructor",
      "params": []
    },
    "isDefault": true
  },
  "/doc/doc_parser.doc.js": {
    "type": "module",
    "file": "/doc/doc_parser.js",
    "functions": [
      {
        "name": "parseDocFile",
        "line": 6,
        "params": [
          "filePath"
        ],
        "source": "function parseDocFile (filePath) {\n    const source = fs.readFileSync(filePath, 'utf-8')\n    return extractBlocks(source)\n}"
      },
      {
        "name": "extractBlocks",
        "line": 12,
        "params": [
          "source"
        ],
        "source": "function extractBlocks (source) {\n    const blocks = []\n    const blockTypes = ['code', 'action', 'container']\n    let setupIndex = 0\n\n    let ast\n    try {\n        ast = parse(source, {\n            ecmaVersion: 'latest',\n            sourceType: 'module',\n            locations: true\n        })\n    } catch {\n        return blocks\n    }\n\n    walkNode(ast, (node) => {\n        const block = extractBlock(node, source, blockTypes)\n        if (block) {\n            blocks.push(block)\n        }\n\n        const setupBlock = extractSetupBlock(node, source, setupIndex)\n        if (setupBlock) {\n            blocks.push(setupBlock)\n            setupIndex++\n        }\n    })\n\n    return blocks\n}"
      },
      {
        "name": "extractBlock",
        "line": 45,
        "params": [
          "node",
          "source",
          "blockTypes"
        ],
        "source": "function extractBlock (node, source, blockTypes) {\n    if (node.type !== 'CallExpression') {\n        return null\n    }\n\n    const callee = node.callee\n    if (callee.type !== 'Identifier' || !blockTypes.includes(callee.name)) {\n        return null\n    }\n\n    const args = node.arguments\n    if (args.length < 2) {\n        return null\n    }\n\n    const title = extractTitle(args[0])\n    if (!title) {\n        return null\n    }\n\n    const callbackArg = args[1]\n    if (callbackArg.type !== 'ArrowFunctionExpression' && callbackArg.type !== 'FunctionExpression') {\n        return null\n    }\n\n    const body = callbackArg.body\n    if (body.type !== 'BlockStatement') {\n        return null\n    }\n\n    return {\n        type: callee.name,\n        title,\n        source: extractBlockBody(source, body.start, body.end)\n    }\n}"
      },
      {
        "name": "extractTitle",
        "line": 83,
        "params": [
          "titleArg"
        ],
        "source": "function extractTitle (titleArg) {\n    if (titleArg.type === 'Literal' && typeof titleArg.value === 'string') {\n        return titleArg.value\n    }\n\n    if (titleArg.type === 'ObjectExpression') {\n        const titleProp = titleArg.properties.find(\n            p => p.key?.name === 'title' || p.key?.value === 'title'\n        )\n        if (titleProp?.value?.type === 'Literal') {\n            return titleProp.value.value\n        }\n    }\n\n    return null\n}"
      },
      {
        "name": "walkNode",
        "line": 101,
        "params": [
          "node",
          "callback"
        ],
        "source": "function walkNode (node, callback) {\n    if (!node || typeof node !== 'object') {\n        return\n    }\n\n    callback(node)\n\n    for (const key of Object.keys(node)) {\n        const child = node[key]\n\n        if (Array.isArray(child)) {\n            for (const item of child) {\n                walkNode(item, callback)\n            }\n        } else if (child && typeof child === 'object' && child.type) {\n            walkNode(child, callback)\n        }\n    }\n}"
      },
      {
        "name": "extractSetupBlock",
        "line": 122,
        "params": [
          "node",
          "source",
          "index"
        ],
        "source": "function extractSetupBlock (node, source, index) {\n    if (node.type !== 'CallExpression') {\n        return null\n    }\n\n    const callee = node.callee\n    if (callee.type !== 'Identifier' || callee.name !== 'setup') {\n        return null\n    }\n\n    const args = node.arguments\n    if (args.length < 1) {\n        return null\n    }\n\n    const callbackArg = args[0]\n    if (callbackArg.type !== 'ArrowFunctionExpression' && callbackArg.type !== 'FunctionExpression') {\n        return null\n    }\n\n    const body = callbackArg.body\n    if (body.type !== 'BlockStatement') {\n        return null\n    }\n\n    return {\n        type: 'setup',\n        index,\n        source: extractBlockBody(source, body.start, body.end)\n    }\n}"
      },
      {
        "name": "extractBlockBody",
        "line": 155,
        "params": [
          "source",
          "start",
          "end"
        ],
        "source": "function extractBlockBody (source, start, end) {\n    const inner = source.slice(start + 1, end - 1)\n    const filtered = inner.split('\\n')\n        .filter(line => !line.trim().startsWith('ctx.setApp('))\n        .join('\\n')\n    return dedent(filtered)\n}"
      }
    ],
    "exports": []
  },
  "/doc/doc_registry.doc.js": {
    "type": "module",
    "file": "/doc/doc_registry.js",
    "functions": [
      {
        "name": "initRegistry",
        "line": 5,
        "params": [
          "docs",
          "guides = ..."
        ],
        "source": "function initRegistry (docs, guides = []) {\n    docsRegistry = new Map()\n    guidesRegistry = new Map()\n\n    for (const doc of docs) {\n        const titleLower = doc.title.toLowerCase()\n        docsRegistry.set(titleLower, doc)\n    }\n\n    for (const guide of guides) {\n        const titleLower = guide.title.toLowerCase()\n        guidesRegistry.set(titleLower, guide)\n        guidesRegistry.set(guide.id, guide)\n    }\n}"
      },
      {
        "name": "lookupDoc",
        "line": 22,
        "params": [
          "name"
        ],
        "source": "function lookupDoc (name) {\n    if (!docsRegistry) {\n        return null\n    }\n    return docsRegistry.get(name.toLowerCase()) || null\n}"
      },
      {
        "name": "lookupGuide",
        "line": 30,
        "params": [
          "name"
        ],
        "source": "function lookupGuide (name) {\n    if (!guidesRegistry) {\n        return null\n    }\n    return guidesRegistry.get(name.toLowerCase()) || null\n}"
      },
      {
        "name": "isRegistryInitialized",
        "line": 38,
        "params": [],
        "source": "function isRegistryInitialized () {\n    return docsRegistry !== null\n}"
      }
    ],
    "exports": []
  },
  "/doc/runtime.doc.js": {
    "type": "module",
    "file": "/doc/runtime.js",
    "functions": [
      {
        "name": "doc",
        "line": 9,
        "params": [
          "title",
          "options",
          "fn"
        ],
        "source": "function doc (title, options, fn) {\n    const opts = typeof options === 'function' ? {} : options\n    const callback = typeof options === 'function' ? options : fn\n\n    const docData = {\n        title,\n        options: opts,\n        blocks: []\n    }\n\n    currentBlocks = docData.blocks\n    currentSetup = null\n    callback()\n    currentBlocks = null\n    currentSetup = null\n\n    return docData\n}"
      },
      {
        "name": "section",
        "line": 29,
        "params": [
          "title",
          "fn"
        ],
        "source": "function section (title, fn) {\n    if (!currentBlocks) {\n        throw new Error('section() must be called inside doc()')\n    }\n\n    const sectionData = {\n        type: 'section',\n        title,\n        blocks: [],\n        setup: null\n    }\n\n    const parentBlocks = currentBlocks\n    const parentSetup = currentSetup\n\n    currentBlocks = sectionData.blocks\n    currentSetup = null\n    fn()\n    sectionData.setup = currentSetup\n\n    currentBlocks = parentBlocks\n    currentSetup = parentSetup\n\n    currentBlocks.push(sectionData)\n}"
      },
      {
        "name": "setup",
        "line": 56,
        "params": [
          "fn"
        ],
        "source": "function setup (fn) {\n    if (!currentBlocks) {\n        throw new Error('setup() must be called inside doc() or section()')\n    }\n\n    currentSetup = {\n        source: extractFunctionBody(fn),\n        fn\n    }\n}"
      },
      {
        "name": "text",
        "line": 68,
        "params": [
          "content"
        ],
        "source": "function text (content) {\n    if (!currentBlocks) {\n        throw new Error('text() must be called inside doc()')\n    }\n\n    currentBlocks.push({\n        type: 'text',\n        content: dedent(content)\n    })\n}"
      },
      {
        "name": "code",
        "line": 80,
        "params": [
          "title",
          "fn"
        ],
        "source": "function code (title, fn) {\n    if (!currentBlocks) {\n        throw new Error('code() must be called inside doc()')\n    }\n\n    currentBlocks.push({\n        type: 'code',\n        title,\n        source: extractFunctionBody(fn)\n    })\n}"
      },
      {
        "name": "action",
        "line": 93,
        "params": [
          "title",
          "fn"
        ],
        "source": "function action (title, fn) {\n    if (!currentBlocks) {\n        throw new Error('action() must be called inside doc()')\n    }\n\n    currentBlocks.push({\n        type: 'action',\n        title,\n        source: extractFunctionBody(fn),\n        fn\n    })\n}"
      },
      {
        "name": "see",
        "line": 107,
        "params": [
          "name",
          "options = ..."
        ],
        "source": "function see (name, options = {}) {\n    if (!currentBlocks) {\n        throw new Error('see() must be called inside doc()')\n    }\n\n    currentBlocks.push({\n        type: 'see',\n        name,\n        pageType: options.type || 'doc',\n        section: options.section || null,\n        category: options.category || null\n    })\n}"
      },
      {
        "name": "disclaimer",
        "line": 122,
        "params": [
          "content"
        ],
        "source": "function disclaimer (content) {\n    if (!currentBlocks) {\n        throw new Error('disclaimer() must be called inside doc()')\n    }\n\n    currentBlocks.push({\n        type: 'disclaimer',\n        content: dedent(content)\n    })\n}"
      },
      {
        "name": "container",
        "line": 181,
        "params": [
          "options",
          "fn"
        ],
        "source": "function container (options, fn) {\n    if (!currentBlocks) {\n        throw new Error('container() must be called inside doc()')\n    }\n\n    const opts = typeof options === 'function' ? {} : options\n    const callback = typeof options === 'function' ? options : fn\n\n    currentBlocks.push({\n        type: 'container',\n        width: opts.width || null,\n        height: opts.height || 300,\n        title: opts.title || null,\n        preset: opts.preset || null,\n        scrollable: opts.scrollable || false,\n        source: extractFunctionBody(callback),\n        fn: callback\n    })\n}"
      },
      {
        "name": "applyContainerPreset",
        "line": 202,
        "params": [
          "element",
          "presetName"
        ],
        "source": "function applyContainerPreset (element, presetName) {\n    const preset = CONTAINER_PRESETS[presetName]\n    if (!preset) {\n        return\n    }\n\n    if (preset.tabIndex !== undefined) {\n        element.tabIndex = preset.tabIndex\n    }\n\n    if (preset.style) {\n        Object.assign(element.style, preset.style)\n    }\n}"
      },
      {
        "name": "extractFunctionBody",
        "line": 218,
        "params": [
          "fn"
        ],
        "source": "function extractFunctionBody (fn) {\n    const source = fn.toString()\n\n    let body = null\n\n    const arrowMatch = source.match(/^\\s*\\(?[^)]*\\)?\\s*=>\\s*\\{([\\s\\S]*)\\}\\s*$/)\n    if (arrowMatch) {\n        body = arrowMatch[1]\n    }\n\n    if (!body) {\n        const functionMatch = source.match(/^function\\s*\\w*\\s*\\([^)]*\\)\\s*\\{([\\s\\S]*)\\}\\s*$/)\n        if (functionMatch) {\n            body = functionMatch[1]\n        }\n    }\n\n    if (!body) {\n        const arrowExpressionMatch = source.match(/^\\s*\\(?[^)]*\\)?\\s*=>\\s*(.+)$/)\n        if (arrowExpressionMatch) {\n            return arrowExpressionMatch[1].trim()\n        }\n    }\n\n    if (!body) {\n        return source\n    }\n\n    body = body.split('\\n')\n        .filter(line => !line.trim().startsWith('ctx.setApp('))\n        .join('\\n')\n\n    return dedent(body)\n}"
      },
      {
        "name": "addSpacerIfNeeded",
        "line": 254,
        "params": [],
        "source": "function addSpacerIfNeeded () {\n    const hasVisibleLogs = logger.history.some(e => e.event === 'log')\n    const lastEntry = logger.history[logger.history.length - 1]\n    const lastIsSpacer = lastEntry?.event === 'spacer'\n\n    if (hasVisibleLogs && !lastIsSpacer) {\n        logger.spacer()\n    }\n}"
      },
      {
        "name": "executeAction",
        "line": 265,
        "params": [
          "block",
          "sectionSetup = ..."
        ],
        "source": "async function executeAction (block, sectionSetup = null) {\n    try {\n        addSpacerIfNeeded()\n        const ctx = {}\n\n        if (sectionSetup?.fn) {\n            await sectionSetup.fn(ctx)\n        }\n        await block.fn(ctx)\n    } catch (error) {\n        logger.error('Action error:', error.message)\n    }\n}"
      },
      {
        "name": "executeContainer",
        "line": 280,
        "params": [
          "block",
          "containerEl",
          "sectionSetup = ..."
        ],
        "source": "async function executeContainer (block, containerEl, sectionSetup = null) {\n    addSpacerIfNeeded()\n\n    const prevApp = containerEl._currentApp\n    if (prevApp?.dispose) {\n        prevApp.dispose()\n    }\n    containerEl.innerHTML = ''\n\n    if (block.preset) {\n        applyContainerPreset(containerEl, block.preset)\n    }\n\n    if (block.scrollable) {\n        containerEl.style.overflow = 'auto'\n    }\n\n    try {\n        let actionsBar = null\n        let slidersBar = null\n        let infoBar = null\n\n        const ctx = {\n            container: containerEl,\n            setApp: (app, ...args) => {\n                containerEl._currentApp = app\n                const [scene] = args\n                if (scene && app.autoFitEnabled && app.render) {\n                    app.on('resize', () => app.render(scene))\n                }\n            },\n            action: (label, callback) => {\n                if (!actionsBar) {\n                    actionsBar = document.createElement('div')\n                    actionsBar.className = 'doc-actions-bar'\n                    containerEl.appendChild(actionsBar)\n                }\n\n                const isFirst = actionsBar.children.length === 0\n                const btn = document.createElement('button')\n                btn.className = 'doc-actions-btn'\n                if (isFirst) {\n                    btn.classList.add('doc-actions-btn--active')\n                }\n                btn.textContent = label\n                btn.addEventListener('click', () => {\n                    actionsBar.querySelectorAll('.doc-actions-btn').forEach(b => b.classList.remove('doc-actions-btn--active'))\n                    btn.classList.add('doc-actions-btn--active')\n                    callback()\n                })\n                actionsBar.appendChild(btn)\n\n                if (isFirst) {\n                    callback()\n                }\n            },\n            slider: (label, opts, onChange) => {\n                if (!slidersBar) {\n                    slidersBar = document.createElement('div')\n                    slidersBar.className = 'doc-sliders-bar'\n                    containerEl.appendChild(slidersBar)\n                }\n\n                const wrapper = document.createElement('div')\n                wrapper.className = 'doc-slider-wrapper'\n\n                const labelEl = document.createElement('span')\n                labelEl.className = 'doc-slider-label'\n                labelEl.textContent = label\n\n                const valueEl = document.createElement('span')\n                valueEl.className = 'doc-slider-value'\n                valueEl.textContent = opts.default ?? opts.min\n\n                const input = document.createElement('input')\n                input.type = 'range'\n                input.className = 'doc-slider'\n                input.min = opts.min\n                input.max = opts.max\n                input.step = opts.step ?? (opts.max - opts.min) / 100\n                input.value = opts.default ?? opts.min\n\n                input.addEventListener('input', () => {\n                    const value = parseFloat(input.value)\n                    valueEl.textContent = Number.isInteger(value) ? value : value.toFixed(2)\n                    onChange(value)\n                })\n\n                wrapper.appendChild(labelEl)\n                wrapper.appendChild(input)\n                wrapper.appendChild(valueEl)\n                slidersBar.appendChild(wrapper)\n\n                onChange(parseFloat(input.value))\n\n                return {\n                    set: (value) => {\n                        input.value = value\n                        valueEl.textContent = Number.isInteger(value) ? value : value.toFixed(2)\n                    },\n                    get: () => parseFloat(input.value)\n                }\n            },\n            info: (formatter) => {\n                if (!infoBar) {\n                    infoBar = document.createElement('div')\n                    infoBar.className = 'doc-info-bar'\n                    containerEl.appendChild(infoBar)\n                }\n\n                const el = document.createElement('div')\n                el.className = 'doc-info'\n                infoBar.appendChild(el)\n                const update = (...args) => {\n                    el.textContent = formatter(...args)\n                }\n                update()\n                return update\n            },\n            hint: (message) => {\n                const el = document.createElement('div')\n                el.className = 'doc-hint'\n                el.textContent = message\n                containerEl.appendChild(el)\n            },\n            display: (formatter) => {\n                const el = document.createElement('div')\n                el.className = 'doc-display'\n                containerEl.appendChild(el)\n                const update = (...args) => {\n                    const result = formatter(...args)\n                    if (result instanceof HTMLElement) {\n                        el.innerHTML = ''\n                        el.appendChild(result)\n                    } else if (Array.isArray(result)) {\n                        el.innerHTML = result.map(item => `<span class=\"doc-display-tag\">${item}</span>`).join('')\n                    } else {\n                        el.innerHTML = result\n                    }\n                }\n                update()\n                return update\n            },\n            box: (opts = {}) => {\n                const size = opts.size || 40\n                const color = opts.color || '#4a9eff'\n                const el = document.createElement('div')\n                el.style.cssText = `width:${size}px;height:${size}px;background:${color};position:absolute;border-radius:4px;left:50%;top:50%;transform:translate(-50%,-50%)`\n                containerEl.appendChild(el)\n                return el\n            },\n            marker: (x = 0, y = 0, opts = {}) => {\n                const size = opts.size || 20\n                const color = opts.color || '#4a9eff'\n                const el = document.createElement('div')\n                el.style.cssText = `width:${size}px;height:${size}px;background:${color};position:absolute;border-radius:50%;transform:translate(-50%,-50%);left:${x}px;top:${y}px`\n                containerEl.appendChild(el)\n                return el\n            },\n            column: (opts = {}) => {\n                const gap = opts.gap || 4\n                const el = document.createElement('div')\n                el.style.cssText = `display:flex;flex-direction:column;align-items:center;gap:${gap}px;`\n                if (opts.parent) {\n                    opts.parent.appendChild(el)\n                } else {\n                    containerEl.appendChild(el)\n                }\n                return el\n            },\n            row: (opts = {}) => {\n                const gap = opts.gap || 8\n                const el = document.createElement('div')\n                el.style.cssText = `display:flex;flex-direction:row;align-items:center;gap:${gap}px;flex-wrap:wrap;justify-content:center;`\n                if (opts.parent) {\n                    opts.parent.appendChild(el)\n                } else {\n                    containerEl.appendChild(el)\n                }\n                return el\n            },\n            label: (content, opts = {}) => {\n                const el = document.createElement('div')\n                el.style.cssText = 'color:#888;font-family:monospace;font-size:11px;'\n                el.textContent = content\n                if (opts.overlay) {\n                    el.style.cssText += 'position:absolute;top:64px;left:50%;transform:translateX(-50%);z-index:10;'\n                }\n                if (opts.parent) {\n                    opts.parent.appendChild(el)\n                } else {\n                    containerEl.appendChild(el)\n                }\n                return el\n            },\n            checkerBoard: (opts = {}) => {\n                const size = opts.size || 8\n                const color1 = opts.color1 || '#222'\n                const color2 = opts.color2 || '#1a1a1a'\n                const el = document.createElement('div')\n                el.style.cssText = `background:repeating-conic-gradient(${color1} 0% 25%, ${color2} 0% 50%) 50% / ${size * 2}px ${size * 2}px;border:1px solid #333;overflow:hidden;`\n                if (opts.width) {\n                    el.style.width = opts.width + 'px'\n                }\n                if (opts.height) {\n                    el.style.height = opts.height + 'px'\n                }\n                if (opts.parent) {\n                    opts.parent.appendChild(el)\n                } else {\n                    containerEl.appendChild(el)\n                }\n                return el\n            },\n            canvas: (source, opts = {}) => {\n                const wrapper = document.createElement('div')\n                const size = opts.checkerSize || 8\n                wrapper.style.cssText = `background:repeating-conic-gradient(#222 0% 25%, #1a1a1a 0% 50%) 50% / ${size * 2}px ${size * 2}px;border:1px solid #333;display:inline-block;`\n                if (opts.parent) {\n                    opts.parent.appendChild(wrapper)\n                } else {\n                    containerEl.appendChild(wrapper)\n                }\n\n                const displayCanvas = document.createElement('canvas')\n                displayCanvas.style.cssText = 'display:block;'\n                if (opts.maxWidth) {\n                    displayCanvas.style.maxWidth = opts.maxWidth + 'px'\n                    displayCanvas.style.height = 'auto'\n                }\n                wrapper.appendChild(displayCanvas)\n\n                const update = (src) => {\n                    const canvas = src || source\n                    displayCanvas.width = canvas.width\n                    displayCanvas.height = canvas.height\n                    const dctx = displayCanvas.getContext('2d')\n                    dctx.clearRect(0, 0, canvas.width, canvas.height)\n                    dctx.drawImage(canvas, 0, 0)\n                }\n\n                if (source) {\n                    update(source)\n                }\n\n                return {element: wrapper, canvas: displayCanvas, update}\n            }\n        }\n\n        if (sectionSetup?.fn) {\n            await sectionSetup.fn(ctx)\n        }\n        await block.fn(ctx)\n\n        if (containerEl.tabIndex >= 0) {\n            containerEl.focus()\n        }\n    } catch (error) {\n        logger.error('Container error:', error.message)\n    }\n}"
      },
      {
        "name": "renderAction",
        "line": 543,
        "params": [
          "block",
          "sectionSetup = ...",
          "extractedSource = ..."
        ],
        "source": "function renderAction (block, sectionSetup = null, extractedSource = null) {\n    const wrapper = document.createElement('div')\n    wrapper.className = 'doc-action-block'\n\n    const codeEl = document.createElement('perky-code')\n    codeEl.setAttribute('title', block.title)\n    codeEl.code = extractedSource || block.source\n    wrapper.appendChild(codeEl)\n\n    const button = document.createElement('button')\n    button.className = 'doc-action-btn'\n    button.innerHTML = `\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n            <path d=\"M8 5v14l11-7z\"/>\n        </svg>\n        Run\n    `\n    button.addEventListener('click', () => executeAction(block, sectionSetup))\n    wrapper.appendChild(button)\n\n    return wrapper\n}"
      }
    ],
    "exports": []
  },
  "/doc/doc_viewer.doc.js": {
    "type": "class",
    "file": "/doc/doc_viewer.js",
    "name": "DocViewer",
    "line": 16,
    "extends": null,
    "statics": [],
    "methods": [
      {
        "name": "init",
        "line": 34,
        "source": "async init () {\n    await this.loadMetadata()\n    this.setupNavigation()\n    this.setupSearch()\n    this.route()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "loadMetadata",
        "line": 42,
        "source": "async loadMetadata () {\n    try {\n        const [docsRes, apiRes, testsRes] = await Promise.all([\n            fetch('./docs.json'),\n            fetch('./api.json'),\n            fetch('./tests.json')\n        ])\n        const docsData = await docsRes.json()\n        this.docs = docsData.docs\n        this.guides = docsData.guides || []\n        this.apiData = await apiRes.json()\n        this.testsData = await testsRes.json()\n\n        initRegistry(this.docs, this.guides)\n    } catch (error) {\n        logger.error('Failed to load metadata:', error)\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "setupNavigation",
        "line": 62,
        "source": "setupNavigation () {\n    this.renderNav()\n    renderSwitcher()\n    this.setupSwitcher()\n    this.setupNavClicks()\n    this.setupAdvancedToggle()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "renderNav",
        "line": 71,
        "source": "renderNav () {\n    this.nav.innerHTML = ''\n\n    const docsSection = createElement('div', {class: 'nav-section'})\n    docsSection.dataset.section = 'docs'\n    renderNavItems(docsSection, this.docs, 'doc')\n    this.nav.appendChild(docsSection)\n\n    const guidesSection = createElement('div', {class: 'nav-section'})\n    guidesSection.dataset.section = 'guides'\n    guidesSection.style.display = 'none'\n    renderNavItems(guidesSection, this.guides, 'guide')\n    this.nav.appendChild(guidesSection)\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "setupSwitcher",
        "line": 87,
        "source": "setupSwitcher () {\n    const switcherContainer = document.getElementById('nav-switcher')\n    if (!switcherContainer) {\n        return\n    }\n\n    for (const btn of switcherContainer.querySelectorAll('.nav-switch')) {\n        btn.addEventListener('click', () => {\n            this.switchSection(btn.dataset.section)\n        })\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "setupNavClicks",
        "line": 101,
        "source": "setupNavClicks () {\n    this.nav.addEventListener('click', (e) => {\n        const item = e.target.closest('.nav-item')\n        if (!item) {\n            return\n        }\n\n        closeMobileMenu()\n    })\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "setupAdvancedToggle",
        "line": 113,
        "source": "setupAdvancedToggle () {\n    if (!this.advancedCheckbox) {\n        return\n    }\n\n    const stored = localStorage.getItem('perky-docs-show-advanced')\n    if (stored === 'true') {\n        this.showAdvanced = true\n        this.advancedCheckbox.checked = true\n    }\n\n    this.advancedCheckbox.addEventListener('change', () => {\n        this.showAdvanced = this.advancedCheckbox.checked\n        localStorage.setItem('perky-docs-show-advanced', this.showAdvanced)\n        this.#applyAdvancedFilter()\n    })\n\n    this.#applyAdvancedFilter()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "switchSection",
        "line": 150,
        "source": "switchSection (section) {\n    this.currentSection = section\n\n    const switcherContainer = document.getElementById('nav-switcher')\n    if (switcherContainer) {\n        for (const btn of switcherContainer.querySelectorAll('.nav-switch')) {\n            btn.classList.toggle('active', btn.dataset.section === section)\n        }\n    }\n\n    for (const sec of this.nav.querySelectorAll('.nav-section')) {\n        sec.style.display = sec.dataset.section === section ? '' : 'none'\n    }\n\n    this.#reapplySearch()\n}",
        "kind": "method",
        "params": [
          "section"
        ]
      },
      {
        "name": "setupSearch",
        "line": 186,
        "source": "setupSearch () {\n    this.searchInput.addEventListener('input', () => {\n        this.#reapplySearch()\n    })\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "route",
        "line": 193,
        "source": "route () {\n    const {docPath, guidePath, tab} = this.getPathFromFilename()\n\n    if (guidePath) {\n        this.switchSection('guides')\n        this.showGuide(guidePath)\n        this.updateActiveNav(guidePath)\n    } else if (docPath) {\n        this.switchSection('docs')\n        this.showDoc(docPath, tab)\n        this.updateActiveNav(docPath)\n    } else {\n        this.showWelcome()\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "getPathFromFilename",
        "line": 210,
        "source": "getPathFromFilename () {\n    const pathname = window.location.pathname\n    const filename = pathname.split('/').pop()\n\n    if (!filename || filename === 'index.html' || !filename.endsWith('.html')) {\n        return {docPath: null, guidePath: null, tab: 'doc'}\n    }\n\n    if (filename.startsWith('guide_')) {\n        const guideId = filename.replace('guide_', '').replace('.html', '')\n        const guide = this.guides.find(g => g.id === guideId)\n        return {docPath: null, guidePath: guide ? guide.file : null, tab: 'doc'}\n    }\n\n    const isApiPage = filename.endsWith('_api.html')\n    const isTestPage = filename.endsWith('_test.html')\n    const baseName = extractBaseName(filename)\n\n    const doc = this.docs.find(d => {\n        const docBaseName = d.file.slice(1).replace(/\\//g, '_').replace('.doc.js', '')\n        return docBaseName === baseName\n    })\n\n    let tab = 'doc'\n    if (isApiPage) {\n        tab = 'api'\n    }\n    if (isTestPage) {\n        tab = 'test'\n    }\n\n    return {docPath: doc ? doc.file : null, guidePath: null, tab}\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "updateActiveNav",
        "line": 245,
        "source": "updateActiveNav (docPath) {\n    let activeItem = null\n\n    for (const item of this.nav.querySelectorAll('.nav-item')) {\n        const isActive = item.dataset.file === docPath\n        item.classList.toggle('active', isActive)\n        if (isActive) {\n            activeItem = item\n        }\n    }\n\n    if (activeItem) {\n        activeItem.scrollIntoView({block: 'center', behavior: 'instant'})\n    }\n}",
        "kind": "method",
        "params": [
          "docPath"
        ]
      },
      {
        "name": "showWelcome",
        "line": 262,
        "source": "showWelcome () {\n    this.container.innerHTML = `\n        <div class=\"welcome-message\">\n            <h2>Welcome to Perky Docs</h2>\n            <p>Select a module from the sidebar to view its documentation.</p>\n        </div>\n    `\n    this.currentDoc = null\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "showDoc",
        "line": 273,
        "source": "async showDoc (docPath, tab = 'doc') {\n    logger.clear()\n\n    try {\n        let modulePath = '..' + docPath\n        let loader = docModules[modulePath]\n\n        if (!loader && docPath.startsWith('/doc/')) {\n            modulePath = '.' + docPath.slice(4)\n            loader = docModules[modulePath]\n        }\n\n        if (!loader) {\n            throw new Error(`Doc module not found: ${docPath}`)\n        }\n\n        const module = await loader()\n        const docData = module.default\n\n        this.container.innerHTML = ''\n        const docPage = document.createElement('doc-page')\n        docPage.doc = docData\n        docPage.initialTab = tab\n\n        const api = this.apiData[docPath]\n        if (api) {\n            docPage.api = api\n        }\n\n        const sources = await loadSourcesFor(docPath)\n        if (sources) {\n            docPage.sources = sources\n        }\n\n        const tests = this.testsData[docPath]\n        if (tests) {\n            docPage.tests = tests\n        }\n\n        this.container.appendChild(docPage)\n        this.currentDoc = docPath\n\n        requestAnimationFrame(() => {\n            updateMobileTabs(docPage)\n        })\n    } catch (error) {\n        logger.error('Failed to load doc:', error)\n        this.container.innerHTML = `\n            <div class=\"error-message\">\n                <h2>Failed to load documentation</h2>\n                <p>${error.message}</p>\n            </div>\n        `\n        hideMobileTabs()\n    }\n}",
        "kind": "method",
        "params": [
          "docPath",
          "tab = ..."
        ]
      },
      {
        "name": "showGuide",
        "line": 331,
        "source": "async showGuide (guidePath) {\n    logger.clear()\n\n    try {\n        const modulePath = '.' + guidePath.replace('/doc', '')\n        const loader = guideModules[modulePath]\n\n        if (!loader) {\n            throw new Error(`Guide module not found: ${guidePath}`)\n        }\n\n        const module = await loader()\n        const guideData = module.default\n\n        this.container.innerHTML = ''\n        const docPage = document.createElement('doc-page')\n        docPage.doc = guideData\n        docPage.initialTab = 'doc'\n\n        const guide = this.guides.find(g => g.file === guidePath)\n        if (guide) {\n            const sources = await loadGuideSourcesFor(guide.id)\n            if (sources) {\n                docPage.sources = sources\n            }\n        }\n\n        this.container.appendChild(docPage)\n        this.currentDoc = guidePath\n        hideMobileTabs()\n    } catch (error) {\n        logger.error('Failed to load guide:', error)\n        this.container.innerHTML = `\n            <div class=\"error-message\">\n                <h2>Failed to load guide</h2>\n                <p>${error.message}</p>\n            </div>\n        `\n        hideMobileTabs()\n    }\n}",
        "kind": "method",
        "params": [
          "guidePath"
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 18,
      "source": "constructor () {\n    this.container = document.getElementById('doc-container')\n    this.nav = document.getElementById('docs-nav')\n    this.searchInput = document.querySelector('.sidebar-search .search-input')\n    this.advancedToggle = document.getElementById('advanced-toggle')\n    this.advancedCheckbox = this.advancedToggle?.querySelector('.advanced-toggle-input')\n    this.docs = []\n    this.guides = []\n    this.apiData = {}\n    this.testsData = {}\n    this.currentDoc = null\n    this.currentSection = 'docs'\n    this.showAdvanced = false\n}",
      "kind": "constructor",
      "params": []
    }
  },
  "/doc/generate_pages.doc.js": {
    "type": "module",
    "file": "/doc/generate_pages.js",
    "functions": [
      {
        "name": "findCssFile",
        "line": 14,
        "params": [],
        "source": "function findCssFile () {\n    const assetsDir = path.join(distDir, 'assets')\n\n    try {\n        const files = fs.readdirSync(assetsDir)\n        const cssFile = files.find(f => f.startsWith('main-') && f.endsWith('.css'))\n        return cssFile ? `assets/${cssFile}` : 'doc_index.css'\n    } catch {\n        return 'doc_index.css'\n    }\n}"
      },
      {
        "name": "escapeHtml",
        "line": 27,
        "params": [
          "text"
        ],
        "source": "function escapeHtml (text) {\n    return text\n        .replace(/&/g, '&amp;')\n        .replace(/</g, '&lt;')\n        .replace(/>/g, '&gt;')\n        .replace(/\"/g, '&quot;')\n}"
      },
      {
        "name": "parseMarkdown",
        "line": 36,
        "params": [
          "text"
        ],
        "source": "function parseMarkdown (text) {\n    return text\n        .replace(/`([^`]+)`/g, '<code>$1</code>')\n        .replace(/\\*\\*([^*]+)\\*\\*/g, '<strong>$1</strong>')\n        .replace(/\\*([^*]+)\\*/g, '<em>$1</em>')\n        .split('\\n\\n')\n        .filter(p => p.trim())\n        .map(p => `<p>${p.trim()}</p>`)\n        .join('')\n}"
      },
      {
        "name": "renderBlocksToHtml",
        "line": 48,
        "params": [
          "blocks",
          "sources"
        ],
        "source": "function renderBlocksToHtml (blocks, sources) {\n    let html = ''\n\n    for (const block of blocks) {\n        html += renderBlock(block, sources)\n    }\n\n    return html\n}"
      },
      {
        "name": "renderBlock",
        "line": 59,
        "params": [
          "block",
          "sources"
        ],
        "source": "function renderBlock (block, sources) {\n    switch (block.type) {\n    case 'text':\n        return `<div class=\"doc-text\">${parseMarkdown(block.content)}</div>`\n\n    case 'code':\n    case 'action':\n    case 'container': {\n        const source = getSourceFor(block, sources)\n        const code = source || '[Code example]'\n        return `\n            <div class=\"doc-block\">\n                <h3>${escapeHtml(block.title)}</h3>\n                <pre><code>${escapeHtml(code)}</code></pre>\n            </div>\n        `\n    }\n\n    case 'section':\n        return `\n            <section class=\"doc-section\">\n                <h2>${escapeHtml(block.title)}</h2>\n                ${renderBlocksToHtml(block.blocks || [], sources)}\n            </section>\n        `\n\n    default:\n        return ''\n    }\n}"
      },
      {
        "name": "getSourceFor",
        "line": 91,
        "params": [
          "block",
          "sources"
        ],
        "source": "function getSourceFor (block, sources) {\n    if (!sources) {\n        return null\n    }\n\n    const match = sources.find(\n        s => s.type === block.type && s.title === block.title\n    )\n\n    return match?.source || null\n}"
      },
      {
        "name": "renderApiToHtml",
        "line": 104,
        "params": [
          "api"
        ],
        "source": "function renderApiToHtml (api) {\n    if (!api) {\n        return '<p>No API documentation available.</p>'\n    }\n\n    let html = ''\n\n    if (api.extends) {\n        html += `<p class=\"api-extends\">extends <code>${escapeHtml(api.extends)}</code></p>`\n    }\n\n    const categories = [\n        {key: 'statics', title: 'Static'},\n        {key: 'constructor', title: 'Constructor', single: true},\n        {key: 'methods', title: 'Methods'},\n        {key: 'getters', title: 'Getters'},\n        {key: 'setters', title: 'Setters'}\n    ]\n\n    for (const cat of categories) {\n        html += renderApiCategory(api, cat)\n    }\n\n    return html\n}"
      },
      {
        "name": "getApiCategoryItems",
        "line": 131,
        "params": [
          "api",
          "cat"
        ],
        "source": "function getApiCategoryItems (api, cat) {\n    if (cat.single) {\n        return api[cat.key] ? [api[cat.key]] : []\n    }\n    return api[cat.key] || []\n}"
      },
      {
        "name": "renderApiCategory",
        "line": 139,
        "params": [
          "api",
          "cat"
        ],
        "source": "function renderApiCategory (api, cat) {\n    const items = getApiCategoryItems(api, cat)\n\n    if (items.length === 0) {\n        return ''\n    }\n\n    let html = `<section class=\"api-section\"><h2>${cat.title}</h2>`\n\n    for (const item of items) {\n        html += renderApiMember(item)\n    }\n\n    html += '</section>'\n    return html\n}"
      },
      {
        "name": "renderApiMember",
        "line": 157,
        "params": [
          "item"
        ],
        "source": "function renderApiMember (item) {\n    const signature = item.params\n        ? `${item.name}(${item.params.join(', ')})`\n        : item.name\n\n    return `\n        <div class=\"api-member\">\n            <h3><code>${escapeHtml(signature)}</code></h3>\n            <pre><code>${escapeHtml(item.source || '')}</code></pre>\n        </div>\n    `\n}"
      },
      {
        "name": "renderTestsToHtml",
        "line": 171,
        "params": [
          "tests"
        ],
        "source": "function renderTestsToHtml (tests) {\n    if (!tests || !tests.describes || tests.describes.length === 0) {\n        return '<p>No test documentation available.</p>'\n    }\n\n    let html = ''\n\n    for (const describe of tests.describes) {\n        html += renderDescribeToHtml(describe, 0)\n    }\n\n    return html\n}"
      },
      {
        "name": "renderDescribeToHtml",
        "line": 186,
        "params": [
          "describe",
          "depth"
        ],
        "source": "function renderDescribeToHtml (describe, depth) {\n    const sectionClass = depth === 0 ? 'test-section' : 'test-section-nested'\n    const headingTag = depth === 0 ? 'h2' : 'h3'\n\n    let html = `<section class=\"${sectionClass}\">`\n    html += `<${headingTag}>${escapeHtml(describe.title)}</${headingTag}>`\n\n    html += renderTestHooks(describe)\n    html += renderTestCases(describe.tests)\n    html += renderNestedDescribes(describe.describes, depth)\n\n    html += '</section>'\n    return html\n}"
      },
      {
        "name": "renderTestHooks",
        "line": 202,
        "params": [
          "describe"
        ],
        "source": "function renderTestHooks (describe) {\n    let html = ''\n\n    if (describe.beforeEach) {\n        html += renderTestHookHtml('beforeEach', describe.beforeEach)\n    }\n\n    if (describe.afterEach) {\n        html += renderTestHookHtml('afterEach', describe.afterEach)\n    }\n\n    return html\n}"
      },
      {
        "name": "renderTestHookHtml",
        "line": 217,
        "params": [
          "name",
          "hook"
        ],
        "source": "function renderTestHookHtml (name, hook) {\n    return `\n        <div class=\"test-hook\">\n            <h4>${name}</h4>\n            <pre><code>${escapeHtml(hook.source || '')}</code></pre>\n        </div>\n    `\n}"
      },
      {
        "name": "renderTestCases",
        "line": 227,
        "params": [
          "tests"
        ],
        "source": "function renderTestCases (tests) {\n    let html = ''\n\n    for (const test of tests || []) {\n        html += `\n            <div class=\"test-case\">\n                <h4>${escapeHtml(test.title)}</h4>\n                <pre><code>${escapeHtml(test.source || '')}</code></pre>\n            </div>\n        `\n    }\n\n    return html\n}"
      },
      {
        "name": "renderNestedDescribes",
        "line": 243,
        "params": [
          "describes",
          "depth"
        ],
        "source": "function renderNestedDescribes (describes, depth) {\n    let html = ''\n\n    for (const nested of describes || []) {\n        html += renderDescribeToHtml(nested, depth + 1)\n    }\n\n    return html\n}"
      },
      {
        "name": "findMainJs",
        "line": 254,
        "params": [],
        "source": "function findMainJs () {\n    const assetsDir = path.join(distDir, 'assets')\n\n    try {\n        const files = fs.readdirSync(assetsDir)\n        const jsFile = files.find(f => f.startsWith('main-') && f.endsWith('.js'))\n        return jsFile ? `assets/${jsFile}` : null\n    } catch {\n        return null\n    }\n}"
      },
      {
        "name": "getTabContent",
        "line": 267,
        "params": [
          "tab",
          "api",
          "tests",
          "sources"
        ],
        "source": "function getTabContent (tab, api, tests, sources) {\n    if (tab === 'api') {\n        return renderApiToHtml(api)\n    }\n    if (tab === 'test') {\n        return renderTestsToHtml(tests)\n    }\n    return renderBlocksToHtml(sources || [], sources)\n}"
      },
      {
        "name": "generatePageHtml",
        "line": 278,
        "params": [
          "pageData"
        ],
        "source": "function generatePageHtml (pageData) {\n    const {doc, sources, api, tests, docs, guides = [], tab = 'doc', cssFile, section = 'docs'} = pageData\n    const title = `${doc.title} - Perky Docs`\n    const description = section === 'guides'\n        ? `${doc.title} guide for the Perky game framework`\n        : `Documentation for ${doc.title} in the Perky game framework`\n\n    const content = getTabContent(tab, api, tests, sources)\n    const navHtml = generateNavHtml(docs, guides, doc.file, section)\n    const switcherHtml = generateSwitcherHtml(section)\n    const mainJs = findMainJs()\n\n    return `<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>${escapeHtml(title)}</title>\n    <meta name=\"description\" content=\"${escapeHtml(description)}\">\n    <meta property=\"og:title\" content=\"${escapeHtml(title)}\">\n    <meta property=\"og:description\" content=\"${escapeHtml(description)}\">\n    <link rel=\"stylesheet\" href=\"${cssFile}\">\n</head>\n<body>\n    <noscript>\n        <style>\n            .seo-content { max-width: 800px; padding: 2rem; margin: 0 auto; }\n            .seo-content h1 { margin-bottom: 1rem; }\n            .seo-content h2 { margin-top: 2rem; margin-bottom: 1rem; border-bottom: 1px solid #333; padding-bottom: 0.5rem; }\n            .seo-content h3 { margin-top: 1.5rem; margin-bottom: 0.5rem; }\n            .seo-content pre { background: #1a1a2e; padding: 1rem; border-radius: 6px; overflow-x: auto; }\n            .seo-content code { font-family: monospace; }\n            .seo-content .doc-text { margin-bottom: 1rem; line-height: 1.6; }\n            .seo-content .doc-block { margin-bottom: 1.5rem; }\n            .seo-content .api-extends { margin-bottom: 1rem; }\n            .seo-content .api-member { margin-bottom: 1rem; }\n        </style>\n        <div class=\"seo-content\">\n            <h1>${escapeHtml(doc.title)}</h1>\n            ${content}\n        </div>\n    </noscript>\n    <button class=\"mobile-toggle\" id=\"mobile-toggle\" aria-label=\"Toggle menu\">\n        <svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\">\n            <path d=\"M3 12h18M3 6h18M3 18h18\"></path>\n        </svg>\n    </button>\n    <div class=\"mobile-overlay\" id=\"mobile-overlay\"></div>\n    <div class=\"docs-layout\">\n        <aside class=\"docs-sidebar\" id=\"docs-sidebar\">\n            <div class=\"sidebar-header\">\n                <h1>perky docs</h1>\n                <div class=\"sidebar-search\">\n                    <svg class=\"search-icon\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\">\n                        <circle cx=\"11\" cy=\"11\" r=\"8\"></circle>\n                        <path d=\"m21 21-4.35-4.35\"></path>\n                    </svg>\n                    <input type=\"text\" class=\"search-input\" placeholder=\"Search...\">\n                </div>\n                <div class=\"nav-switcher\" id=\"nav-switcher\">${switcherHtml}</div>\n                <label class=\"advanced-toggle\" id=\"advanced-toggle\">\n                    <input type=\"checkbox\" class=\"advanced-toggle-input\">\n                    <span class=\"advanced-toggle-track\">\n                        <span class=\"advanced-toggle-thumb\"></span>\n                    </span>\n                    <span class=\"advanced-toggle-label\">Show advanced</span>\n                </label>\n            </div>\n            <nav class=\"sidebar-nav\" id=\"docs-nav\">${navHtml}</nav>\n        </aside>\n\n        <main class=\"docs-main\">\n            <div class=\"docs-content\" id=\"doc-container\"></div>\n            <div class=\"docs-logger\">\n                <perky-logger id=\"main-logger\" max-entries=\"30\"></perky-logger>\n            </div>\n        </main>\n    </div>\n\n    ${mainJs ? `<script type=\"module\" src=\"${mainJs}\"></script>` : ''}\n</body>\n</html>`\n}"
      },
      {
        "name": "generateNavHtml",
        "line": 363,
        "params": [
          "docs",
          "guides",
          "activeFile",
          "activeSection = ..."
        ],
        "source": "function generateNavHtml (docs, guides, activeFile, activeSection = 'docs') {\n    let html = ''\n\n    const docsHidden = activeSection === 'docs' ? '' : ' style=\"display:none\"'\n    const guidesHidden = activeSection === 'guides' ? '' : ' style=\"display:none\"'\n\n    html += `<div class=\"nav-section\" data-section=\"docs\"${docsHidden}>`\n    html += generateItemsHtml(docs, activeFile, 'doc')\n    html += '</div>'\n\n    html += `<div class=\"nav-section\" data-section=\"guides\"${guidesHidden}>`\n    html += generateItemsHtml(guides, activeFile, 'guide')\n    html += '</div>'\n\n    return html\n}"
      },
      {
        "name": "generateSwitcherHtml",
        "line": 381,
        "params": [
          "activeSection = ..."
        ],
        "source": "function generateSwitcherHtml (activeSection = 'docs') {\n    let html = ''\n    html += `<button class=\"nav-switch${activeSection === 'docs' ? ' active' : ''}\" data-section=\"docs\">Docs</button>`\n    html += `<button class=\"nav-switch${activeSection === 'guides' ? ' active' : ''}\" data-section=\"guides\">Guides</button>`\n    return html\n}"
      },
      {
        "name": "generateItemHtml",
        "line": 389,
        "params": [
          "item",
          "activeFile",
          "type"
        ],
        "source": "function generateItemHtml (item, activeFile, type) {\n    const classes = ['nav-item']\n    if (item.file === activeFile) {\n        classes.push('active')\n    }\n    if (item.featured) {\n        classes.push('featured')\n    }\n    if (item.advanced) {\n        classes.push('advanced', 'hidden-advanced')\n    }\n    const href = type === 'guide'\n        ? guideIdToHtml(item.id)\n        : docFileToHtml(item.file)\n    const displayTitle = type === 'guide' ? toHumanCase(item.title) : item.title\n    return `<a class=\"${classes.join(' ')}\" href=\"${href}\" data-file=\"${escapeHtml(item.file)}\" data-title=\"${escapeHtml(item.title.toLowerCase())}\" data-category=\"${escapeHtml(item.category)}\">${escapeHtml(displayTitle)}</a>`\n}"
      },
      {
        "name": "generateItemsHtml",
        "line": 408,
        "params": [
          "items",
          "activeFile",
          "type"
        ],
        "source": "function generateItemsHtml (items, activeFile, type) {\n    const byCategory = {}\n\n    for (const item of items) {\n        if (!byCategory[item.category]) {\n            byCategory[item.category] = []\n        }\n        byCategory[item.category].push(item)\n    }\n\n    let html = ''\n\n    for (const [category, categoryItems] of Object.entries(byCategory)) {\n        const allAdvanced = categoryItems.every(item => item.advanced)\n        const categoryClasses = ['nav-category']\n        if (allAdvanced) {\n            categoryClasses.push('hidden')\n        }\n        html += `<div class=\"${categoryClasses.join(' ')}\">${escapeHtml(category)}</div>`\n\n        for (const item of categoryItems) {\n            html += generateItemHtml(item, activeFile, type)\n        }\n    }\n\n    return html\n}"
      },
      {
        "name": "loadSources",
        "line": 437,
        "params": [
          "docFile"
        ],
        "source": "function loadSources (docFile) {\n    const fileName = docFile.slice(1).replace(/\\//g, '_').replace('.js', '.json')\n    const sourcePath = path.join(distDir, 'sources', fileName)\n\n    try {\n        return JSON.parse(fs.readFileSync(sourcePath, 'utf-8'))\n    } catch {\n        return null\n    }\n}"
      },
      {
        "name": "generateSitemap",
        "line": 449,
        "params": [
          "docs",
          "apiData",
          "testsData",
          "baseUrl"
        ],
        "source": "function generateSitemap (docs, apiData, testsData, baseUrl) {\n    const today = new Date().toISOString().split('T')[0]\n\n    let xml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n'\n    xml += '<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\\n'\n\n    xml += `  <url>\\n    <loc>${baseUrl}/</loc>\\n    <lastmod>${today}</lastmod>\\n    <priority>1.0</priority>\\n  </url>\\n`\n\n    for (const doc of docs) {\n        xml += `  <url>\\n    <loc>${baseUrl}/${docFileToHtml(doc.file)}</loc>\\n    <lastmod>${today}</lastmod>\\n    <priority>0.8</priority>\\n  </url>\\n`\n\n        if (apiData[doc.file]) {\n            xml += `  <url>\\n    <loc>${baseUrl}/${docFileToHtml(doc.file, 'api')}</loc>\\n    <lastmod>${today}</lastmod>\\n    <priority>0.6</priority>\\n  </url>\\n`\n        }\n\n        if (testsData[doc.file]) {\n            xml += `  <url>\\n    <loc>${baseUrl}/${docFileToHtml(doc.file, 'test')}</loc>\\n    <lastmod>${today}</lastmod>\\n    <priority>0.5</priority>\\n  </url>\\n`\n        }\n    }\n\n    xml += '</urlset>'\n    return xml\n}"
      },
      {
        "name": "loadGuideSources",
        "line": 474,
        "params": [
          "guideId"
        ],
        "source": "function loadGuideSources (guideId) {\n    const sourcePath = path.join(distDir, 'sources', `guide_${guideId}.json`)\n\n    try {\n        return JSON.parse(fs.readFileSync(sourcePath, 'utf-8'))\n    } catch {\n        return null\n    }\n}"
      },
      {
        "name": "main",
        "line": 485,
        "params": [],
        "source": "async function main () {\n    const docsPath = path.join(distDir, 'docs.json')\n    const apiPath = path.join(distDir, 'api.json')\n    const testsPath = path.join(distDir, 'tests.json')\n\n    const docsData = JSON.parse(fs.readFileSync(docsPath, 'utf-8'))\n    const apiData = JSON.parse(fs.readFileSync(apiPath, 'utf-8'))\n    const testsData = JSON.parse(fs.readFileSync(testsPath, 'utf-8'))\n\n    const docs = docsData.docs\n    const guides = docsData.guides || []\n    const cssFile = findCssFile()\n\n    logger.log(`Generating static pages for ${docs.length} doc(s)...`)\n    logger.log(`Using CSS: ${cssFile}`)\n\n    for (const doc of docs) {\n        const sources = loadSources(doc.file)\n        const api = apiData[doc.file]\n        const tests = testsData[doc.file]\n        const pageData = {doc, sources, api, tests, docs, guides, cssFile, section: 'docs'}\n\n        const docHtml = generatePageHtml({...pageData, tab: 'doc'})\n        fs.writeFileSync(path.join(distDir, docFileToHtml(doc.file)), docHtml)\n\n        if (api) {\n            const apiHtml = generatePageHtml({...pageData, tab: 'api'})\n            fs.writeFileSync(path.join(distDir, docFileToHtml(doc.file, 'api')), apiHtml)\n        }\n\n        if (tests) {\n            const testHtml = generatePageHtml({...pageData, tab: 'test'})\n            fs.writeFileSync(path.join(distDir, docFileToHtml(doc.file, 'test')), testHtml)\n        }\n\n        logger.log(`  - ${doc.title}`)\n    }\n\n    logger.log(`\\nGenerating static pages for ${guides.length} guide(s)...`)\n\n    for (const guide of guides) {\n        const sources = loadGuideSources(guide.id)\n        const pageData = {\n            doc: guide,\n            sources,\n            api: null,\n            tests: null,\n            docs,\n            guides,\n            cssFile,\n            section: 'guides'\n        }\n\n        const guideHtml = generatePageHtml({...pageData, tab: 'doc'})\n        fs.writeFileSync(path.join(distDir, guideIdToHtml(guide.id)), guideHtml)\n\n        logger.log(`  - ${guide.title}`)\n    }\n\n    const baseUrl = 'https://perkycrow.com/doc'\n    const sitemap = generateSitemap(docs, apiData, testsData, baseUrl)\n    fs.writeFileSync(path.join(distDir, 'sitemap.xml'), sitemap)\n    logger.log('\\nGenerated sitemap.xml')\n\n    logger.log('\\nDone!')\n}"
      }
    ],
    "exports": []
  },
  "/doc/parse_markdown.doc.js": {
    "type": "module",
    "file": "/doc/parse_markdown.js",
    "functions": [
      {
        "name": "parseMarkdown",
        "line": 4,
        "params": [
          "text",
          "options = ..."
        ],
        "source": "function parseMarkdown (text, options = {}) {\n    const {buildSeeUrl = buildDocUrl} = options\n\n    return text\n        .replace(/`([^`]+)`/g, '<code>$1</code>')\n        .replace(/\\*\\*([^*]+)\\*\\*/g, '<strong>$1</strong>')\n        .replace(/\\*([^*]+)\\*/g, '<em>$1</em>')\n        .replace(/\\[\\[([^\\]]+)\\]\\]/g, (_, ref) => parseSeeLink(ref, buildSeeUrl))\n        .split('\\n\\n')\n        .filter(p => p.trim())\n        .map(p => renderBlock(p.trim()))\n        .join('')\n}"
      },
      {
        "name": "renderBlock",
        "line": 19,
        "params": [
          "block"
        ],
        "source": "function renderBlock (block) {\n    const lines = block.split('\\n')\n    const firstLine = lines[0].trim()\n\n    if (firstLine === '---') {\n        return '<hr>'\n    }\n\n    if (firstLine.startsWith('- ')) {\n        return renderList(lines)\n    }\n\n    const listStartIndex = lines.findIndex(line => line.trim().startsWith('- '))\n\n    if (listStartIndex > 0) {\n        const textLines = lines.slice(0, listStartIndex)\n        const listLines = lines.slice(listStartIndex)\n        const textContent = textLines.map(l => l.trim()).join(' ')\n        return `<p>${textContent}</p>${renderList(listLines)}`\n    }\n\n    return `<p>${block}</p>`\n}"
      },
      {
        "name": "renderList",
        "line": 44,
        "params": [
          "lines"
        ],
        "source": "function renderList (lines) {\n    const items = lines\n        .map(line => line.trim())\n        .filter(line => line.startsWith('- '))\n        .map(line => `<li>${line.slice(2)}</li>`)\n        .join('')\n\n    return `<ul>${items}</ul>`\n}"
      },
      {
        "name": "parseSeeLink",
        "line": 55,
        "params": [
          "ref",
          "buildSeeUrl"
        ],
        "source": "function parseSeeLink (ref, buildSeeUrl) {\n    let name = ref\n    let pageType = 'doc'\n    let section = null\n    let category = null\n\n    const hashIndex = ref.indexOf('#')\n    if (hashIndex !== -1) {\n        section = ref.slice(hashIndex + 1)\n        ref = ref.slice(0, hashIndex)\n    }\n\n    const atIndex = ref.indexOf('@')\n    if (atIndex !== -1) {\n        category = ref.slice(atIndex + 1)\n        ref = ref.slice(0, atIndex)\n    }\n\n    const colonIndex = ref.indexOf(':')\n    if (colonIndex === -1) {\n        name = ref\n    } else {\n        name = ref.slice(0, colonIndex)\n        pageType = ref.slice(colonIndex + 1)\n    }\n\n    const url = buildSeeUrl({name, pageType, section, category})\n    const label = section ? `${name} > ${section}` : name\n\n    return `<a href=\"${url}\" class=\"doc-see-inline\">${label}</a>`\n}"
      }
    ],
    "exports": []
  },
  "/doc/test_parser.doc.js": {
    "type": "module",
    "file": "/doc/test_parser.js",
    "functions": [
      {
        "name": "parseTestFile",
        "line": 5,
        "params": [
          "source",
          "filePath = ..."
        ],
        "source": "function parseTestFile (source, filePath = null) {\n    const ast = acorn.parse(source, {\n        ecmaVersion: 'latest',\n        sourceType: 'module',\n        locations: true\n    })\n\n    const result = {\n        file: filePath,\n        describes: []\n    }\n\n    for (const node of ast.body) {\n        if (isDescribeCall(node)) {\n            result.describes.push(parseDescribe(node, source))\n        }\n    }\n\n    return result\n}"
      },
      {
        "name": "isDescribeCall",
        "line": 27,
        "params": [
          "node"
        ],
        "source": "function isDescribeCall (node) {\n    if (node.type !== 'ExpressionStatement') {\n        return false\n    }\n\n    const expr = node.expression\n\n    if (expr.type !== 'CallExpression') {\n        return false\n    }\n\n    return expr.callee.type === 'Identifier' && expr.callee.name === 'describe'\n}"
      },
      {
        "name": "isTestCall",
        "line": 42,
        "params": [
          "node"
        ],
        "source": "function isTestCall (node) {\n    if (node.type !== 'ExpressionStatement') {\n        return false\n    }\n\n    const expr = node.expression\n\n    if (expr.type !== 'CallExpression') {\n        return false\n    }\n\n    const name = expr.callee.name\n\n    return expr.callee.type === 'Identifier' && (name === 'test' || name === 'it')\n}"
      },
      {
        "name": "isBeforeEachCall",
        "line": 59,
        "params": [
          "node"
        ],
        "source": "function isBeforeEachCall (node) {\n    if (node.type !== 'ExpressionStatement') {\n        return false\n    }\n\n    const expr = node.expression\n\n    if (expr.type !== 'CallExpression') {\n        return false\n    }\n\n    return expr.callee.type === 'Identifier' && expr.callee.name === 'beforeEach'\n}"
      },
      {
        "name": "isAfterEachCall",
        "line": 74,
        "params": [
          "node"
        ],
        "source": "function isAfterEachCall (node) {\n    if (node.type !== 'ExpressionStatement') {\n        return false\n    }\n\n    const expr = node.expression\n\n    if (expr.type !== 'CallExpression') {\n        return false\n    }\n\n    return expr.callee.type === 'Identifier' && expr.callee.name === 'afterEach'\n}"
      },
      {
        "name": "parseDescribe",
        "line": 89,
        "params": [
          "node",
          "source"
        ],
        "source": "function parseDescribe (node, source) {\n    const expr = node.expression\n    const args = expr.arguments\n    const title = getCallTitle(args[0], source)\n    const callback = args[1]\n\n    const describe = {\n        title,\n        line: node.loc.start.line,\n        beforeEach: null,\n        afterEach: null,\n        tests: [],\n        describes: []\n    }\n\n    if (callback && callback.type === 'ArrowFunctionExpression') {\n        parseDescribeBody(callback.body, source, describe)\n    }\n\n    return describe\n}"
      },
      {
        "name": "getCallTitle",
        "line": 112,
        "params": [
          "arg",
          "source"
        ],
        "source": "function getCallTitle (arg, source) {\n    if (!arg) {\n        return 'Unknown'\n    }\n\n    if (arg.type === 'Literal') {\n        return String(arg.value)\n    }\n\n    if (arg.type === 'Identifier') {\n        return arg.name\n    }\n\n    return source.slice(arg.start, arg.end)\n}"
      },
      {
        "name": "parseDescribeBody",
        "line": 129,
        "params": [
          "body",
          "source",
          "describe"
        ],
        "source": "function parseDescribeBody (body, source, describe) {\n    if (body.type !== 'BlockStatement') {\n        return\n    }\n\n    for (const statement of body.body) {\n        if (isDescribeCall(statement)) {\n            describe.describes.push(parseDescribe(statement, source))\n            continue\n        }\n\n        if (isTestCall(statement)) {\n            describe.tests.push(parseTest(statement, source))\n            continue\n        }\n\n        if (isBeforeEachCall(statement)) {\n            describe.beforeEach = parseHook(statement, source)\n            continue\n        }\n\n        if (isAfterEachCall(statement)) {\n            describe.afterEach = parseHook(statement, source)\n        }\n    }\n}"
      },
      {
        "name": "parseTest",
        "line": 157,
        "params": [
          "node",
          "source"
        ],
        "source": "function parseTest (node, source) {\n    const expr = node.expression\n    const args = expr.arguments\n    const title = getCallTitle(args[0], source)\n    const callback = args[1]\n\n    return {\n        title,\n        line: node.loc.start.line,\n        source: callback ? extractFunctionBody(callback, source) : null\n    }\n}"
      },
      {
        "name": "parseHook",
        "line": 171,
        "params": [
          "node",
          "source"
        ],
        "source": "function parseHook (node, source) {\n    const expr = node.expression\n    const callback = expr.arguments[0]\n\n    return {\n        line: node.loc.start.line,\n        source: callback ? extractFunctionBody(callback, source) : null\n    }\n}"
      },
      {
        "name": "extractFunctionBody",
        "line": 182,
        "params": [
          "fn",
          "source"
        ],
        "source": "function extractFunctionBody (fn, source) {\n    if (fn.type === 'ArrowFunctionExpression' || fn.type === 'FunctionExpression') {\n        const body = fn.body\n\n        if (body.type === 'BlockStatement') {\n            const inner = source.slice(body.start + 1, body.end - 1)\n            return dedentSource(inner.trim())\n        }\n\n        return source.slice(body.start, body.end)\n    }\n\n    return null\n}"
      },
      {
        "name": "getTestsForFile",
        "line": 198,
        "params": [
          "source",
          "filePath = ..."
        ],
        "source": "function getTestsForFile (source, filePath = null) {\n    const parsed = parseTestFile(source, filePath)\n\n    if (parsed.describes.length === 0) {\n        return null\n    }\n\n    return {\n        file: filePath,\n        describes: parsed.describes\n    }\n}"
      }
    ],
    "exports": []
  },
  "/doc/renderers/api_renderers.doc.js": {
    "type": "module",
    "file": "/doc/renderers/api_renderers.js",
    "functions": [
      {
        "name": "getApiItems",
        "line": 1,
        "params": [
          "api",
          "cat"
        ],
        "source": "function getApiItems (api, cat) {\n    if (cat.single) {\n        return api[cat.key] ? [api[cat.key]] : []\n    }\n\n    return api[cat.key] || []\n}"
      },
      {
        "name": "renderApiMember",
        "line": 10,
        "params": [
          "member",
          "file"
        ],
        "source": "function renderApiMember (member, file) {\n    const wrapper = document.createElement('div')\n    wrapper.className = 'api-member'\n\n    const header = document.createElement('div')\n    header.className = 'api-member-header'\n\n    const signature = document.createElement('span')\n    signature.className = 'api-member-name'\n\n    if (member.params) {\n        signature.textContent = `${member.name}(${member.params.join(', ')})`\n    } else if (member.value) {\n        signature.innerHTML = `${member.name} = <code>${member.value}</code>`\n    } else {\n        signature.textContent = member.name\n    }\n\n    header.appendChild(signature)\n\n    if (member.line && file) {\n        const lineLink = document.createElement('span')\n        lineLink.className = 'api-member-line'\n        lineLink.textContent = `:${member.line}`\n        header.appendChild(lineLink)\n    }\n\n    const toggle = document.createElement('button')\n    toggle.className = 'api-toggle'\n    toggle.innerHTML = `\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n            <path d=\"M7 10l5 5 5-5z\"/>\n        </svg>\n    `\n    header.appendChild(toggle)\n\n    wrapper.appendChild(header)\n\n    const codeWrapper = document.createElement('div')\n    codeWrapper.className = 'api-code-wrapper'\n\n    const codeEl = document.createElement('perky-code')\n    codeEl.code = member.source\n    codeEl.setAttribute('no-header', '')\n    codeWrapper.appendChild(codeEl)\n\n    wrapper.appendChild(codeWrapper)\n\n    toggle.addEventListener('click', () => {\n        wrapper.classList.toggle('expanded')\n    })\n\n    header.addEventListener('click', e => {\n        if (e.target !== toggle && !toggle.contains(e.target)) {\n            wrapper.classList.toggle('expanded')\n        }\n    })\n\n    return wrapper\n}"
      }
    ],
    "exports": []
  },
  "/doc/renderers/block_renderers.doc.js": {
    "type": "module",
    "file": "/doc/renderers/block_renderers.js",
    "functions": [
      {
        "name": "renderText",
        "line": 5,
        "params": [
          "block"
        ],
        "source": "function renderText (block) {\n    const el = document.createElement('div')\n    el.className = 'doc-text'\n    el.innerHTML = parseMarkdown(block.content, {buildSeeUrl})\n    return el\n}"
      },
      {
        "name": "renderDisclaimer",
        "line": 13,
        "params": [
          "block"
        ],
        "source": "function renderDisclaimer (block) {\n    const el = document.createElement('div')\n    el.className = 'doc-disclaimer'\n    el.innerHTML = parseMarkdown(block.content, {buildSeeUrl})\n    return el\n}"
      },
      {
        "name": "renderCode",
        "line": 21,
        "params": [
          "block",
          "extractedSource = ..."
        ],
        "source": "function renderCode (block, extractedSource = null) {\n    const wrapper = document.createElement('div')\n    wrapper.className = 'doc-code-block'\n\n    const codeEl = document.createElement('perky-code')\n    codeEl.setAttribute('title', block.title)\n    codeEl.code = extractedSource || block.source\n    wrapper.appendChild(codeEl)\n\n    return wrapper\n}"
      },
      {
        "name": "renderSee",
        "line": 34,
        "params": [
          "block"
        ],
        "source": "function renderSee (block) {\n    const wrapper = document.createElement('div')\n    wrapper.className = 'doc-see'\n\n    const link = document.createElement('a')\n    link.className = 'doc-see-link'\n    link.href = buildSeeUrl({\n        name: block.name,\n        pageType: block.pageType,\n        section: block.section,\n        category: block.category\n    })\n\n    const label = buildSeeLabel(block.name, block.pageType, block.section)\n    link.innerHTML = `\n        <svg width=\"14\" height=\"14\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\">\n            <path d=\"M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6\"/>\n            <polyline points=\"15 3 21 3 21 9\"/>\n            <line x1=\"10\" y1=\"14\" x2=\"21\" y2=\"3\"/>\n        </svg>\n        ${label}\n    `\n\n    wrapper.appendChild(link)\n    return wrapper\n}"
      },
      {
        "name": "buildSeeLabel",
        "line": 62,
        "params": [
          "name",
          "pageType",
          "section"
        ],
        "source": "function buildSeeLabel (name, pageType, section) {\n    let label = `See ${name}`\n\n    if (pageType !== 'doc') {\n        label += ` (${pageType})`\n    }\n\n    if (section) {\n        label += ` > ${section}`\n    }\n\n    return label\n}"
      }
    ],
    "exports": []
  },
  "/doc/renderers/test_renderers.doc.js": {
    "type": "module",
    "file": "/doc/renderers/test_renderers.js",
    "functions": [
      {
        "name": "createDescribeWrapper",
        "line": 1,
        "params": [
          "describe",
          "sectionId",
          "depth"
        ],
        "source": "function createDescribeWrapper (describe, sectionId, depth) {\n    const wrapper = document.createElement('div')\n    wrapper.className = depth === 0 ? 'test-describe' : 'test-describe-nested'\n    wrapper.id = depth <= 1 ? sectionId : ''\n\n    const header = document.createElement('h2')\n    header.className = depth === 0 ? 'test-describe-title' : 'test-describe-subtitle'\n    header.textContent = describe.title\n    wrapper.appendChild(header)\n\n    return wrapper\n}"
      },
      {
        "name": "addDescribeTocLink",
        "line": 15,
        "params": [
          "tocList",
          "title",
          "sectionId",
          "depth"
        ],
        "source": "function addDescribeTocLink (tocList, title, sectionId, depth) {\n    if (!tocList || depth > 1) {\n        return\n    }\n\n    const tocLink = document.createElement('a')\n    tocLink.className = depth === 0 ? 'doc-toc-link doc-toc-root' : 'doc-toc-link'\n    tocLink.textContent = title\n    tocLink.href = `#${sectionId}`\n    tocList.appendChild(tocLink)\n}"
      },
      {
        "name": "renderTestHook",
        "line": 28,
        "params": [
          "name",
          "hook"
        ],
        "source": "function renderTestHook (name, hook) {\n    const wrapper = document.createElement('div')\n    wrapper.className = 'test-hook'\n\n    const label = document.createElement('div')\n    label.className = 'test-hook-label'\n    label.textContent = name\n    wrapper.appendChild(label)\n\n    if (hook.source) {\n        const codeEl = document.createElement('perky-code')\n        codeEl.setAttribute('title', name)\n        codeEl.code = hook.source\n        wrapper.appendChild(codeEl)\n    }\n\n    return wrapper\n}"
      },
      {
        "name": "renderTest",
        "line": 48,
        "params": [
          "test"
        ],
        "source": "function renderTest (test) {\n    const wrapper = document.createElement('div')\n    wrapper.className = 'test-case'\n\n    const codeEl = document.createElement('perky-code')\n    codeEl.setAttribute('title', test.title)\n    codeEl.code = test.source || ''\n    wrapper.appendChild(codeEl)\n\n    return wrapper\n}"
      }
    ],
    "exports": []
  },
  "/doc/utils/dedent.doc.js": {
    "type": "module",
    "file": "/doc/utils/dedent.js",
    "functions": [
      {
        "name": "dedent",
        "line": 1,
        "params": [
          "str",
          "options = ..."
        ],
        "source": "function dedent (str, options = {}) {\n    const {trimEmptyLines = true, preserveFirstLine = false} = options\n    let lines = str.split('\\n')\n\n    if (trimEmptyLines) {\n        lines = trimLines(lines)\n    }\n\n    if (lines.length === 0) {\n        return ''\n    }\n\n    const minIndent = getMinIndent(lines, preserveFirstLine)\n\n    if (minIndent === 0) {\n        return lines.join('\\n')\n    }\n\n    return removeIndent(lines, minIndent, preserveFirstLine)\n}"
      },
      {
        "name": "trimLines",
        "line": 23,
        "params": [
          "lines"
        ],
        "source": "function trimLines (lines) {\n    while (lines.length > 0 && lines[0].trim() === '') {\n        lines.shift()\n    }\n    while (lines.length > 0 && lines[lines.length - 1].trim() === '') {\n        lines.pop()\n    }\n    return lines\n}"
      },
      {
        "name": "getMinIndent",
        "line": 34,
        "params": [
          "lines",
          "preserveFirstLine"
        ],
        "source": "function getMinIndent (lines, preserveFirstLine) {\n    const linesToCheck = preserveFirstLine ? lines.slice(1) : lines\n    const nonEmptyLines = linesToCheck.filter(line => line.trim())\n\n    if (nonEmptyLines.length === 0) {\n        return 0\n    }\n\n    return Math.min(\n        ...nonEmptyLines.map(line => {\n            const match = line.match(/^(\\s*)/)\n            return match ? match[1].length : 0\n        })\n    )\n}"
      },
      {
        "name": "removeIndent",
        "line": 51,
        "params": [
          "lines",
          "indent",
          "preserveFirstLine"
        ],
        "source": "function removeIndent (lines, indent, preserveFirstLine) {\n    return lines.map((line, index) => {\n        if (preserveFirstLine && index === 0) {\n            return line\n        }\n        return line.slice(indent)\n    }).join('\\n')\n}"
      },
      {
        "name": "dedentSource",
        "line": 61,
        "params": [
          "code"
        ],
        "source": "function dedentSource (code) {\n    return dedent(code, {trimEmptyLines: false, preserveFirstLine: true})\n}"
      }
    ],
    "exports": []
  },
  "/doc/utils/paths.doc.js": {
    "type": "module",
    "file": "/doc/utils/paths.js",
    "functions": [
      {
        "name": "getTabUrl",
        "line": 5,
        "params": [
          "tab"
        ],
        "source": "function getTabUrl (tab) {\n    const pathname = window.location.pathname\n    const filename = pathname.split('/').pop()\n    const baseName = extractBaseName(filename)\n\n    if (tab === 'api') {\n        return `${baseName}_api.html`\n    }\n    if (tab === 'test') {\n        return `${baseName}_test.html`\n    }\n    return `${baseName}.html`\n}"
      },
      {
        "name": "extractBaseName",
        "line": 20,
        "params": [
          "filename"
        ],
        "source": "function extractBaseName (filename) {\n    return filename\n        .replace('_api.html', '')\n        .replace('_test.html', '')\n        .replace('.html', '')\n}"
      },
      {
        "name": "buildDocUrl",
        "line": 28,
        "params": [
          "undefined = ..."
        ],
        "source": "function buildDocUrl ({name, pageType = 'doc', section = null, category = null} = {}) {\n    const url = pageType === 'guide'\n        ? buildGuideUrl(name)\n        : buildDocPageUrl(name, pageType, category)\n\n    return section ? `${url}#${toKebabCase(section)}` : url\n}"
      },
      {
        "name": "buildGuideUrl",
        "line": 37,
        "params": [
          "name"
        ],
        "source": "function buildGuideUrl (name) {\n    const guide = lookupGuide(name)\n    if (guide) {\n        return guideIdToHtml(guide.id)\n    }\n    return guideIdToHtml(toKebabCase(name).replace(/-/g, '_'))\n}"
      },
      {
        "name": "buildDocPageUrl",
        "line": 46,
        "params": [
          "name",
          "pageType",
          "category"
        ],
        "source": "function buildDocPageUrl (name, pageType, category) {\n    const doc = lookupDoc(name)\n    if (doc) {\n        return docFileToHtml(doc.file, pageType)\n    }\n    return buildFallbackUrl(name, pageType, category)\n}"
      },
      {
        "name": "buildFallbackUrl",
        "line": 55,
        "params": [
          "name",
          "pageType",
          "category"
        ],
        "source": "function buildFallbackUrl (name, pageType, category) {\n    const baseName = toKebabCase(name).replace(/-/g, '_')\n    const cat = category || 'core'\n    const suffix = {api: '_api', test: '_test'}[pageType] || ''\n    return `${cat}_${baseName}${suffix}.html`\n}"
      },
      {
        "name": "docFileToHtml",
        "line": 63,
        "params": [
          "docFile",
          "tab = ..."
        ],
        "source": "function docFileToHtml (docFile, tab = 'doc') {\n    const base = docFile.slice(1).replace(/\\//g, '_').replace('.doc.js', '')\n\n    if (tab === 'api') {\n        return `${base}_api.html`\n    }\n    if (tab === 'test') {\n        return `${base}_test.html`\n    }\n    return `${base}.html`\n}"
      },
      {
        "name": "guideIdToHtml",
        "line": 76,
        "params": [
          "guideId"
        ],
        "source": "function guideIdToHtml (guideId) {\n    return `guide_${guideId}.html`\n}"
      }
    ],
    "exports": []
  },
  "/collision/collision_detector.doc.js": {
    "type": "module",
    "file": "/collision/collision_detector.js",
    "functions": [
      {
        "name": "detectCollision",
        "line": 1,
        "params": [
          "shapeA",
          "shapeB"
        ],
        "source": "function detectCollision (shapeA, shapeB) {\n    if (isBoxVsBox(shapeA, shapeB)) {\n        return detectBoxCollision(shapeA, shapeB)\n    }\n\n    if (isCircleVsCircle(shapeA, shapeB)) {\n        return detectCircleCollision(shapeA, shapeB)\n    }\n\n    if (isBoxVsCircle(shapeA, shapeB)) {\n        return detectBoxCircleCollision(shapeA, shapeB)\n    }\n\n    if (isCircleVsBox(shapeA, shapeB)) {\n        const collision = detectBoxCircleCollision(shapeB, shapeA)\n        if (collision) {\n            collision.normal.x = -collision.normal.x\n            collision.normal.y = -collision.normal.y\n        }\n        return collision\n    }\n\n    return null\n}"
      },
      {
        "name": "isBoxVsBox",
        "line": 27,
        "params": [
          "shapeA",
          "shapeB"
        ],
        "source": "function isBoxVsBox (shapeA, shapeB) {\n    return shapeA.type === 'box' && shapeB.type === 'box'\n}"
      },
      {
        "name": "isCircleVsCircle",
        "line": 32,
        "params": [
          "shapeA",
          "shapeB"
        ],
        "source": "function isCircleVsCircle (shapeA, shapeB) {\n    return shapeA.type === 'circle' && shapeB.type === 'circle'\n}"
      },
      {
        "name": "isBoxVsCircle",
        "line": 37,
        "params": [
          "shapeA",
          "shapeB"
        ],
        "source": "function isBoxVsCircle (shapeA, shapeB) {\n    return shapeA.type === 'box' && shapeB.type === 'circle'\n}"
      },
      {
        "name": "isCircleVsBox",
        "line": 42,
        "params": [
          "shapeA",
          "shapeB"
        ],
        "source": "function isCircleVsBox (shapeA, shapeB) {\n    return shapeA.type === 'circle' && shapeB.type === 'box'\n}"
      },
      {
        "name": "detectBoxCollision",
        "line": 47,
        "params": [
          "boxA",
          "boxB"
        ],
        "source": "function detectBoxCollision (boxA, boxB) {\n    const boundsA = boxA.getBounds()\n    const boundsB = boxB.getBounds()\n\n    if (boundsA.right < boundsB.left || boundsA.left > boundsB.right ||\n        boundsA.bottom < boundsB.top || boundsA.top > boundsB.bottom) {\n        return null\n    }\n\n    const overlapX = Math.min(boundsA.right - boundsB.left, boundsB.right - boundsA.left)\n    const overlapY = Math.min(boundsA.bottom - boundsB.top, boundsB.bottom - boundsA.top)\n\n    if (overlapX < overlapY) {\n        return createHorizontalCollision(boundsA, boundsB, overlapX)\n    }\n\n    return createVerticalCollision(boundsA, boundsB, overlapY)\n}"
      },
      {
        "name": "createHorizontalCollision",
        "line": 67,
        "params": [
          "boundsA",
          "boundsB",
          "overlapX"
        ],
        "source": "function createHorizontalCollision (boundsA, boundsB, overlapX) {\n    const normalX = boundsA.centerX < boundsB.centerX ? -1 : 1\n    return {\n        depth: overlapX,\n        normal: {x: normalX, y: 0},\n        contactPoint: {\n            x: normalX > 0 ? boundsA.right : boundsA.left,\n            y: (Math.max(boundsA.top, boundsB.top) + Math.min(boundsA.bottom, boundsB.bottom)) / 2\n        }\n    }\n}"
      },
      {
        "name": "createVerticalCollision",
        "line": 80,
        "params": [
          "boundsA",
          "boundsB",
          "overlapY"
        ],
        "source": "function createVerticalCollision (boundsA, boundsB, overlapY) {\n    const normalY = boundsA.centerY < boundsB.centerY ? -1 : 1\n    return {\n        depth: overlapY,\n        normal: {x: 0, y: normalY},\n        contactPoint: {\n            x: (Math.max(boundsA.left, boundsB.left) + Math.min(boundsA.right, boundsB.right)) / 2,\n            y: normalY > 0 ? boundsA.bottom : boundsA.top\n        }\n    }\n}"
      },
      {
        "name": "detectCircleCollision",
        "line": 93,
        "params": [
          "circleA",
          "circleB"
        ],
        "source": "function detectCircleCollision (circleA, circleB) {\n    const posA = circleA.getWorldPosition()\n    const posB = circleB.getWorldPosition()\n\n    const dx = posB.x - posA.x\n    const dy = posB.y - posA.y\n    const distance = Math.sqrt(dx * dx + dy * dy)\n    const minDistance = circleA.radius + circleB.radius\n\n    if (distance >= minDistance || distance === 0) {\n        return null\n    }\n\n    const normalX = dx / distance\n    const normalY = dy / distance\n\n    return {\n        depth: minDistance - distance,\n        normal: {x: normalX, y: normalY},\n        contactPoint: {\n            x: posA.x + normalX * circleA.radius,\n            y: posA.y + normalY * circleA.radius\n        }\n    }\n}"
      },
      {
        "name": "detectBoxCircleCollision",
        "line": 120,
        "params": [
          "box",
          "circle"
        ],
        "source": "function detectBoxCircleCollision (box, circle) {\n    const boxBounds = box.getBounds()\n    const circlePos = circle.getWorldPosition()\n\n    const closestX = Math.max(boxBounds.left, Math.min(circlePos.x, boxBounds.right))\n    const closestY = Math.max(boxBounds.top, Math.min(circlePos.y, boxBounds.bottom))\n\n    const dx = circlePos.x - closestX\n    const dy = circlePos.y - closestY\n    const distance = Math.sqrt(dx * dx + dy * dy)\n\n    if (distance >= circle.radius) {\n        return null\n    }\n\n    if (distance === 0) {\n        return handleCircleInsideBox(boxBounds, circlePos, circle.radius)\n    }\n\n    const normalX = dx / distance\n    const normalY = dy / distance\n\n    return {\n        depth: circle.radius - distance,\n        normal: {x: normalX, y: normalY},\n        contactPoint: {x: closestX, y: closestY}\n    }\n}"
      },
      {
        "name": "handleCircleInsideBox",
        "line": 150,
        "params": [
          "boxBounds",
          "circlePos",
          "radius"
        ],
        "source": "function handleCircleInsideBox (boxBounds, circlePos, radius) {\n    const penetrations = [\n        {depth: circlePos.x - boxBounds.left, normal: {x: -1, y: 0}},\n        {depth: boxBounds.right - circlePos.x, normal: {x: 1, y: 0}},\n        {depth: circlePos.y - boxBounds.top, normal: {x: 0, y: -1}},\n        {depth: boxBounds.bottom - circlePos.y, normal: {x: 0, y: 1}}\n    ]\n\n    const minPen = penetrations.reduce((min, pen) => (pen.depth < min.depth ? pen : min))\n\n    return {\n        depth: radius - minPen.depth,\n        normal: minPen.normal,\n        contactPoint: {\n            x: circlePos.x - minPen.normal.x * minPen.depth,\n            y: circlePos.y - minPen.normal.y * minPen.depth\n        }\n    }\n}"
      }
    ],
    "exports": []
  },
  "/collision/collision_resolver.doc.js": {
    "type": "class",
    "file": "/collision/collision_resolver.js",
    "name": "CollisionResolver",
    "line": 1,
    "extends": null,
    "statics": [],
    "methods": [
      {
        "name": "resolve",
        "line": 13,
        "source": "resolve (bodyA, bodyB, collision) {\n    this.separateBodies(bodyA, bodyB, collision)\n\n    if (hasPhysicsProperties(bodyA, bodyB)) {\n        this.resolveVelocity(bodyA, bodyB, collision)\n    }\n}",
        "kind": "method",
        "params": [
          "bodyA",
          "bodyB",
          "collision"
        ]
      },
      {
        "name": "separateBodies",
        "line": 22,
        "source": "separateBodies (bodyA, bodyB, collision) {\n    const {normal, depth} = collision\n    const separationDistance = depth * this.options.separationFactor\n\n    const massA = bodyA.userData?.mass || 1\n    const massB = bodyB.userData?.mass || 1\n    const totalMass = massA + massB\n\n    const ratioA = massB / totalMass\n    const ratioB = massA / totalMass\n\n    const separationA = {\n        x: -normal.x * separationDistance * ratioA,\n        y: -normal.y * separationDistance * ratioA\n    }\n\n    const separationB = {\n        x: normal.x * separationDistance * ratioB,\n        y: normal.y * separationDistance * ratioB\n    }\n\n    if (!isStatic(bodyA)) {\n        bodyA.position.x += separationA.x\n        bodyA.position.y += separationA.y\n    }\n\n    if (!isStatic(bodyB)) {\n        bodyB.position.x += separationB.x\n        bodyB.position.y += separationB.y\n    }\n}",
        "kind": "method",
        "params": [
          "bodyA",
          "bodyB",
          "collision"
        ]
      },
      {
        "name": "resolveVelocity",
        "line": 55,
        "source": "resolveVelocity (bodyA, bodyB, collision) {\n    const {normal} = collision\n\n    const velA = getVelocity(bodyA)\n    const velB = getVelocity(bodyB)\n\n    const relativeVel = {\n        x: velB.x - velA.x,\n        y: velB.y - velA.y\n    }\n\n    const velAlongNormal = relativeVel.x * normal.x + relativeVel.y * normal.y\n\n    if (velAlongNormal > 0) {\n        return\n    }\n\n    const restitution = getRestitution(bodyA, bodyB, this.options.restitution)\n\n    const impulseScalar = -(1 + restitution) * velAlongNormal\n    const massA = bodyA.userData?.mass || 1\n    const massB = bodyB.userData?.mass || 1\n    const totalMass = massA + massB\n\n    const impulse = {\n        x: impulseScalar * normal.x / totalMass,\n        y: impulseScalar * normal.y / totalMass\n    }\n\n    if (!isStatic(bodyA)) {\n        velA.x -= impulse.x * massB\n        velA.y -= impulse.y * massB\n        setVelocity(bodyA, velA)\n    }\n\n    if (!isStatic(bodyB)) {\n        velB.x += impulse.x * massA\n        velB.y += impulse.y * massA\n        setVelocity(bodyB, velB)\n    }\n\n    this.applyFriction(bodyA, bodyB, collision, impulse)\n}",
        "kind": "method",
        "params": [
          "bodyA",
          "bodyB",
          "collision"
        ]
      },
      {
        "name": "applyFriction",
        "line": 100,
        "source": "applyFriction (bodyA, bodyB, collision, impulse) {\n    const {normal} = collision\n\n    const velA = getVelocity(bodyA)\n    const velB = getVelocity(bodyB)\n\n    const relativeVel = {\n        x: velB.x - velA.x,\n        y: velB.y - velA.y\n    }\n\n    const velAlongNormal = relativeVel.x * normal.x + relativeVel.y * normal.y\n    const tangent = {\n        x: relativeVel.x - velAlongNormal * normal.x,\n        y: relativeVel.y - velAlongNormal * normal.y\n    }\n\n    const tangentLength = Math.sqrt(tangent.x * tangent.x + tangent.y * tangent.y)\n    if (tangentLength > 0) {\n        tangent.x /= tangentLength\n        tangent.y /= tangentLength\n    }\n\n    const friction = getFriction(bodyA, bodyB, this.options.friction)\n\n    const frictionImpulse = Math.abs(impulse.x * normal.x + impulse.y * normal.y) * friction\n\n    const frictionForce = {\n        x: -tangent.x * frictionImpulse,\n        y: -tangent.y * frictionImpulse\n    }\n\n    const massA = bodyA.userData?.mass || 1\n    const massB = bodyB.userData?.mass || 1\n    const totalMass = massA + massB\n\n    if (!isStatic(bodyA)) {\n        velA.x -= frictionForce.x * massB / totalMass\n        velA.y -= frictionForce.y * massB / totalMass\n        setVelocity(bodyA, velA)\n    }\n\n    if (!isStatic(bodyB)) {\n        velB.x += frictionForce.x * massA / totalMass\n        velB.y += frictionForce.y * massA / totalMass\n        setVelocity(bodyB, velB)\n    }\n}",
        "kind": "method",
        "params": [
          "bodyA",
          "bodyB",
          "collision",
          "impulse"
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 3,
      "source": "constructor (options = {}) {\n    this.options = {\n        separationFactor: 0.5,\n        restitution: 0.2,\n        friction: 0.8,\n        ...options\n    }\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/collision/collision_system.doc.js": {
    "type": "class",
    "file": "/collision/collision_system.js",
    "name": "CollisionSystem",
    "line": 26,
    "extends": null,
    "statics": [],
    "methods": [
      {
        "name": "setupSpatialGrid",
        "line": 44,
        "source": "setupSpatialGrid () {\n    if (!this.bounds) {\n        logger.warn('CollisionSystem: spatialGrid requires bounds to be set')\n        return\n    }\n\n    const cols = Math.ceil(this.bounds.width / this.gridSize)\n    const rows = Math.ceil(this.bounds.height / this.gridSize)\n\n    this.grid = Array(rows).fill(null).map(() => Array(cols).fill(null).map(() => []))\n    this.gridCols = cols\n    this.gridRows = rows\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "addBody",
        "line": 59,
        "source": "addBody (object, options = {}) {\n    const renderType = object.constructor.name.toLowerCase()\n    const createShape = SHAPE_CREATORS[renderType] || SHAPE_CREATORS.default\n\n    object.collisionShape = createShape(object)\n    object.collisionShape.body = object\n\n    const bodyOptions = getBodyOptions(options)\n    Object.assign(object, bodyOptions)\n\n    if (object.isStatic) {\n        this.staticBodies.push(object)\n    } else {\n        this.collisionBodies.push(object)\n    }\n\n    return object\n}",
        "kind": "method",
        "params": [
          "object",
          "options = ..."
        ]
      },
      {
        "name": "removeBody",
        "line": 79,
        "source": "removeBody (object) {\n    const dynamicIndex = this.collisionBodies.indexOf(object)\n    if (dynamicIndex !== -1) {\n        this.collisionBodies.splice(dynamicIndex, 1)\n    }\n\n    const staticIndex = this.staticBodies.indexOf(object)\n    if (staticIndex !== -1) {\n        this.staticBodies.splice(staticIndex, 1)\n    }\n}",
        "kind": "method",
        "params": [
          "object"
        ]
      },
      {
        "name": "update",
        "line": 92,
        "source": "update (deltaTime) {\n    this.applyGravity(deltaTime)\n    this.updateShapes()\n    this.detectCollisions()\n    this.updatePositions(deltaTime)\n}",
        "kind": "method",
        "params": [
          "deltaTime"
        ]
      },
      {
        "name": "applyGravity",
        "line": 100,
        "source": "applyGravity (deltaTime) {\n    this.collisionBodies.forEach(body => {\n        if (!body.isStatic) {\n            body.velocity.x += this.gravity.x * deltaTime\n            body.velocity.y += this.gravity.y * deltaTime\n        }\n    })\n}",
        "kind": "method",
        "params": [
          "deltaTime"
        ]
      },
      {
        "name": "updateShapes",
        "line": 110,
        "source": "updateShapes () {\n    [...this.collisionBodies, ...this.staticBodies].forEach(body => {\n        body.collisionShape.updateFromBody(body)\n    })\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "detectCollisions",
        "line": 117,
        "source": "detectCollisions () {\n    const allBodies = [...this.collisionBodies, ...this.staticBodies]\n\n    if (this.spatialGrid) {\n        this.detectCollisionsWithGrid(allBodies)\n    } else {\n        this.detectCollisionsBruteForce(allBodies)\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "detectCollisionsBruteForce",
        "line": 128,
        "source": "detectCollisionsBruteForce (allBodies) {\n    for (let i = 0; i < allBodies.length; i++) {\n        for (let j = i + 1; j < allBodies.length; j++) {\n            this.checkCollisionPair(allBodies[i], allBodies[j])\n        }\n    }\n}",
        "kind": "method",
        "params": [
          "allBodies"
        ]
      },
      {
        "name": "detectCollisionsWithGrid",
        "line": 137,
        "source": "detectCollisionsWithGrid (allBodies) {\n    this.clearGrid()\n    this.populateGrid(allBodies)\n    this.checkGridCollisions()\n}",
        "kind": "method",
        "params": [
          "allBodies"
        ]
      },
      {
        "name": "checkGridCollisions",
        "line": 144,
        "source": "checkGridCollisions () {\n    for (let row = 0; row < this.gridRows; row++) {\n        for (let col = 0; col < this.gridCols; col++) {\n            this.checkCellCollisions(this.grid[row][col])\n        }\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "checkCellCollisions",
        "line": 153,
        "source": "checkCellCollisions (cellBodies) {\n    for (let i = 0; i < cellBodies.length; i++) {\n        for (let j = i + 1; j < cellBodies.length; j++) {\n            this.checkCollisionPair(cellBodies[i], cellBodies[j])\n        }\n    }\n}",
        "kind": "method",
        "params": [
          "cellBodies"
        ]
      },
      {
        "name": "checkCollisionPair",
        "line": 162,
        "source": "checkCollisionPair (bodyA, bodyB) {\n    if (bodyA.isStatic && bodyB.isStatic) {\n        return\n    }\n\n    const collision = detectCollision(bodyA.collisionShape, bodyB.collisionShape)\n    if (collision) {\n        this.resolver.resolve(bodyA, bodyB, collision)\n\n        if (this.onCollision) {\n            this.onCollision(bodyA, bodyB, collision)\n        }\n    }\n}",
        "kind": "method",
        "params": [
          "bodyA",
          "bodyB"
        ]
      },
      {
        "name": "clearGrid",
        "line": 178,
        "source": "clearGrid () {\n    for (let row = 0; row < this.gridRows; row++) {\n        for (let col = 0; col < this.gridCols; col++) {\n            this.grid[row][col].length = 0\n        }\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "populateGrid",
        "line": 187,
        "source": "populateGrid (bodies) {\n    bodies.forEach(body => {\n        this.addBodyToGrid(body)\n    })\n}",
        "kind": "method",
        "params": [
          "bodies"
        ]
      },
      {
        "name": "addBodyToGrid",
        "line": 194,
        "source": "addBodyToGrid (body) {\n    const bounds = body.collisionShape.getBounds()\n    const startCol = Math.max(0, Math.floor((bounds.left - this.bounds.x) / this.gridSize))\n    const endCol = Math.min(this.gridCols - 1, Math.floor((bounds.right - this.bounds.x) / this.gridSize))\n    const startRow = Math.max(0, Math.floor((bounds.top - this.bounds.y) / this.gridSize))\n    const endRow = Math.min(this.gridRows - 1, Math.floor((bounds.bottom - this.bounds.y) / this.gridSize))\n\n    for (let row = startRow; row <= endRow; row++) {\n        for (let col = startCol; col <= endCol; col++) {\n            this.grid[row][col].push(body)\n        }\n    }\n}",
        "kind": "method",
        "params": [
          "body"
        ]
      },
      {
        "name": "updatePositions",
        "line": 209,
        "source": "updatePositions (deltaTime) {\n    this.collisionBodies.forEach(body => {\n        if (!body.isStatic) {\n            body.position.x += body.velocity.x * deltaTime\n            body.position.y += body.velocity.y * deltaTime\n        }\n    })\n}",
        "kind": "method",
        "params": [
          "deltaTime"
        ]
      },
      {
        "name": "debug",
        "line": 219,
        "source": "debug (ctx) {\n    if (!this.debugEnabled) {\n        return\n    }\n\n    ctx.save()\n    ctx.strokeStyle = '#00ff00'\n    ctx.fillStyle = 'rgba(0, 255, 0, 0.1)'\n    ctx.lineWidth = 1\n\n    const allBodies = [...this.collisionBodies, ...this.staticBodies]\n\n    allBodies.forEach(body => {\n        drawBodyDebug(ctx, body)\n    })\n\n    ctx.restore()\n}",
        "kind": "method",
        "params": [
          "ctx"
        ]
      },
      {
        "name": "enableDebug",
        "line": 239,
        "source": "enableDebug () {\n    this.debugEnabled = true\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "disableDebug",
        "line": 244,
        "source": "disableDebug () {\n    this.debugEnabled = false\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "queryAABB",
        "line": 249,
        "source": "queryAABB (bounds) {\n\n    this.updateShapes()\n\n    const overlappingBodies = []\n    const allBodies = [...this.collisionBodies, ...this.staticBodies]\n\n\n    const queryBounds = {\n        left: bounds.x,\n        right: bounds.x + bounds.width,\n        top: bounds.y,\n        bottom: bounds.y + bounds.height\n    }\n\n    for (const body of allBodies) {\n        const bodyBounds = body.collisionShape.getBounds()\n\n        if (boundsOverlap(queryBounds, bodyBounds)) {\n            overlappingBodies.push(body)\n        }\n    }\n\n    return overlappingBodies\n}",
        "kind": "method",
        "params": [
          "bounds"
        ]
      },
      {
        "name": "queryPoint",
        "line": 276,
        "source": "queryPoint (x, y) {\n\n    this.updateShapes()\n\n    const allBodies = [...this.collisionBodies, ...this.staticBodies]\n    return allBodies.filter(body => body.collisionShape.containsPoint(x, y))\n}",
        "kind": "method",
        "params": [
          "x",
          "y"
        ]
      },
      {
        "name": "queryRadius",
        "line": 285,
        "source": "queryRadius (x, y, radius) {\n\n    this.updateShapes()\n\n    const allBodies = [...this.collisionBodies, ...this.staticBodies]\n    return allBodies.filter(body => {\n        const bounds = body.collisionShape.getBounds()\n        const dx = x - bounds.centerX\n        const dy = y - bounds.centerY\n        const distance = Math.sqrt(dx * dx + dy * dy)\n        return distance <= radius\n    })\n}",
        "kind": "method",
        "params": [
          "x",
          "y",
          "radius"
        ]
      },
      {
        "name": "enableDebugDraw",
        "line": 300,
        "source": "enableDebugDraw (scene) {\n    this.debugScene = scene\n    this.debugEnabled = true\n    return this\n}",
        "kind": "method",
        "params": [
          "scene"
        ]
      },
      {
        "name": "pauseBody",
        "line": 307,
        "source": "pauseBody (body) {\n    if (body.velocity) {\n        body.pausedVelocity = {...body.velocity}\n        body.velocity.x = 0\n        body.velocity.y = 0\n    }\n    body.paused = true\n    return this\n}",
        "kind": "method",
        "params": [
          "body"
        ]
      },
      {
        "name": "resumeBody",
        "line": 318,
        "source": "resumeBody (body) {\n    if (body.pausedVelocity) {\n        body.velocity = body.pausedVelocity\n        delete body.pausedVelocity\n    }\n    body.paused = false\n    return this\n}",
        "kind": "method",
        "params": [
          "body"
        ]
      },
      {
        "name": "setCollisionCallback",
        "line": 328,
        "source": "setCollisionCallback (callback) {\n    this.onCollision = callback\n    return this\n}",
        "kind": "method",
        "params": [
          "callback"
        ]
      },
      {
        "name": "setGravity",
        "line": 334,
        "source": "setGravity (x, y) {\n    this.gravity.x = x\n    this.gravity.y = y\n}",
        "kind": "method",
        "params": [
          "x",
          "y"
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 28,
      "source": "constructor (options = {}) {\n    this.gravity = options.gravity || {x: 0, y: -800}\n    this.bounds = options.bounds || null\n    this.spatialGrid = options.spatialGrid || null\n    this.gridSize = options.gridSize || 64\n    this.resolver = new CollisionResolver()\n    this.collisionBodies = []\n    this.staticBodies = []\n    this.debugEnabled = false\n\n    if (this.spatialGrid) {\n        this.setupSpatialGrid()\n    }\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/collision/simple_collision_detector.doc.js": {
    "type": "class",
    "file": "/collision/simple_collision_detector.js",
    "name": "SimpleCollisionDetector",
    "line": 2,
    "extends": null,
    "statics": [],
    "methods": [
      {
        "name": "addBody",
        "line": 11,
        "source": "addBody (object, options = {}) {\n    const body = {\n        object,\n        type: options.type || 'default',\n        radius: options.radius || getDefaultRadius(object),\n        enabled: options.enabled !== false\n    }\n\n    this.bodies.push(body)\n    return body\n}",
        "kind": "method",
        "params": [
          "object",
          "options = ..."
        ]
      },
      {
        "name": "removeBody",
        "line": 24,
        "source": "removeBody (object) {\n    const index = this.bodies.findIndex(body => body.object === object)\n    if (index > -1) {\n        this.bodies.splice(index, 1)\n    }\n}",
        "kind": "method",
        "params": [
          "object"
        ]
      },
      {
        "name": "onCollision",
        "line": 32,
        "source": "onCollision (typeA, typeB, callback) {\n    const key = getCollisionKey(typeA, typeB)\n    this.callbacks.set(key, callback)\n}",
        "kind": "method",
        "params": [
          "typeA",
          "typeB",
          "callback"
        ]
      },
      {
        "name": "detectCollisions",
        "line": 38,
        "source": "detectCollisions () {\n    if (!this.enabled) {\n        return\n    }\n\n    for (let i = 0; i < this.bodies.length; i++) {\n        this.checkBodyCollisions(i)\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "checkBodyCollisions",
        "line": 49,
        "source": "checkBodyCollisions (bodyIndex) {\n    const bodyA = this.bodies[bodyIndex]\n\n    for (let j = bodyIndex + 1; j < this.bodies.length; j++) {\n        const bodyB = this.bodies[j]\n\n        if (!bodyA.enabled || !bodyB.enabled) {\n            continue\n        }\n\n        if (checkCollision(bodyA, bodyB)) {\n            this.handleCollision(bodyA, bodyB)\n        }\n    }\n}",
        "kind": "method",
        "params": [
          "bodyIndex"
        ]
      },
      {
        "name": "handleCollision",
        "line": 66,
        "source": "handleCollision (bodyA, bodyB) {\n    const key1 = getCollisionKey(bodyA.type, bodyB.type)\n    const key2 = getCollisionKey(bodyB.type, bodyA.type)\n\n    const callback = this.callbacks.get(key1) || this.callbacks.get(key2)\n\n    if (callback) {\n        callback(bodyA.object, bodyB.object, {\n            distance: getDistance(bodyA.object, bodyB.object),\n            bodyA,\n            bodyB\n        })\n    }\n}",
        "kind": "method",
        "params": [
          "bodyA",
          "bodyB"
        ]
      },
      {
        "name": "enable",
        "line": 82,
        "source": "enable () {\n    this.enabled = true\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "disable",
        "line": 87,
        "source": "disable () {\n    this.enabled = false\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "clear",
        "line": 92,
        "source": "clear () {\n    this.bodies = []\n    this.callbacks.clear()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "getBodiesOfType",
        "line": 98,
        "source": "getBodiesOfType (type) {\n    return this.bodies.filter(body => body.type === type)\n}",
        "kind": "method",
        "params": [
          "type"
        ]
      },
      {
        "name": "getBodiesNear",
        "line": 103,
        "source": "getBodiesNear (x, y, radius) {\n    return this.bodies.filter(body => {\n        const dx = body.object.position.x - x\n        const dy = body.object.position.y - y\n        const distance = Math.sqrt(dx * dx + dy * dy)\n        return distance <= radius\n    })\n}",
        "kind": "method",
        "params": [
          "x",
          "y",
          "radius"
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 4,
      "source": "constructor () {\n    this.bodies = []\n    this.callbacks = new Map()\n    this.enabled = true\n}",
      "kind": "constructor",
      "params": []
    },
    "isDefault": true
  },
  "/collision/shapes/box_shape.doc.js": {
    "type": "class",
    "file": "/collision/shapes/box_shape.js",
    "name": "BoxShape",
    "line": 1,
    "extends": null,
    "statics": [],
    "methods": [
      {
        "name": "updateFromBody",
        "line": 14,
        "source": "updateFromBody (body) {\n    this.x = body.position.x + this.offset.x\n    this.y = body.position.y + this.offset.y\n\n    if (body.scale) {\n        this.scaledWidth = this.width * body.scale.x\n        this.scaledHeight = this.height * body.scale.y\n    } else {\n        this.scaledWidth = this.width\n        this.scaledHeight = this.height\n    }\n}",
        "kind": "method",
        "params": [
          "body"
        ]
      },
      {
        "name": "getBounds",
        "line": 28,
        "source": "getBounds () {\n    const halfWidth = (this.scaledWidth || this.width) / 2\n    const halfHeight = (this.scaledHeight || this.height) / 2\n\n    return {\n        left: this.x - halfWidth,\n        right: this.x + halfWidth,\n        top: this.y - halfHeight,\n        bottom: this.y + halfHeight,\n        centerX: this.x,\n        centerY: this.y,\n        width: this.scaledWidth || this.width,\n        height: this.scaledHeight || this.height\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "containsPoint",
        "line": 45,
        "source": "containsPoint (x, y) {\n    const bounds = this.getBounds()\n    return x >= bounds.left && x <= bounds.right &&\n           y >= bounds.top && y <= bounds.bottom\n}",
        "kind": "method",
        "params": [
          "x",
          "y"
        ]
      },
      {
        "name": "setSize",
        "line": 52,
        "source": "setSize (width, height) {\n    this.width = width\n    this.height = height || width\n    return this\n}",
        "kind": "method",
        "params": [
          "width",
          "height"
        ]
      },
      {
        "name": "setOffset",
        "line": 59,
        "source": "setOffset (x, y) {\n    this.offset = {x, y}\n    return this\n}",
        "kind": "method",
        "params": [
          "x",
          "y"
        ]
      },
      {
        "name": "debug",
        "line": 65,
        "source": "debug (ctx) {\n    const width = this.scaledWidth || this.width\n    const height = this.scaledHeight || this.height\n    ctx.strokeRect(-width / 2, -height / 2, width, height)\n}",
        "kind": "method",
        "params": [
          "ctx"
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 3,
      "source": "constructor (options = {}) {\n    this.type = 'box'\n    this.width = options.width || 32\n    this.height = options.height || 32\n    this.offset = options.offset || {x: 0, y: 0}\n    this.x = options.x || 0\n    this.y = options.y || 0\n    this.body = null\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/collision/shapes/circle_shape.doc.js": {
    "type": "class",
    "file": "/collision/shapes/circle_shape.js",
    "name": "CircleShape",
    "line": 2,
    "extends": null,
    "statics": [],
    "methods": [
      {
        "name": "updateFromBody",
        "line": 14,
        "source": "updateFromBody (body) {\n    this.x = body.position.x + this.offset.x\n    this.y = body.position.y + this.offset.y\n\n    if (body.scale) {\n        this.scaledRadius = this.radius * Math.max(body.scale.x, body.scale.y)\n    } else {\n        this.scaledRadius = this.radius\n    }\n}",
        "kind": "method",
        "params": [
          "body"
        ]
      },
      {
        "name": "getWorldPosition",
        "line": 26,
        "source": "getWorldPosition () {\n    return {x: this.x, y: this.y}\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "getBounds",
        "line": 31,
        "source": "getBounds () {\n    const radius = this.scaledRadius || this.radius\n\n    return {\n        left: this.x - radius,\n        right: this.x + radius,\n        top: this.y - radius,\n        bottom: this.y + radius,\n        centerX: this.x,\n        centerY: this.y,\n        width: radius * 2,\n        height: radius * 2\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "containsPoint",
        "line": 47,
        "source": "containsPoint (x, y) {\n    const dx = x - this.x\n    const dy = y - this.y\n    const radius = this.scaledRadius || this.radius\n    return (dx * dx + dy * dy) <= (radius * radius)\n}",
        "kind": "method",
        "params": [
          "x",
          "y"
        ]
      },
      {
        "name": "setRadius",
        "line": 55,
        "source": "setRadius (radius) {\n    this.radius = radius\n    return this\n}",
        "kind": "method",
        "params": [
          "radius"
        ]
      },
      {
        "name": "setOffset",
        "line": 61,
        "source": "setOffset (x, y) {\n    this.offset = {x, y}\n    return this\n}",
        "kind": "method",
        "params": [
          "x",
          "y"
        ]
      },
      {
        "name": "debug",
        "line": 67,
        "source": "debug (ctx) {\n    const radius = this.scaledRadius || this.radius\n    ctx.beginPath()\n    ctx.arc(0, 0, radius, 0, Math.PI * 2)\n    ctx.stroke()\n}",
        "kind": "method",
        "params": [
          "ctx"
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 4,
      "source": "constructor (options = {}) {\n    this.type = 'circle'\n    this.radius = options.radius || 16\n    this.offset = options.offset || {x: 0, y: 0}\n    this.x = options.x || 0\n    this.y = options.y || 0\n    this.body = null\n}",
      "kind": "constructor",
      "params": [
        "options = ..."
      ]
    },
    "isDefault": true
  },
  "/io/binary_reader.doc.js": {
    "type": "class",
    "file": "/io/binary_reader.js",
    "name": "BinaryReader",
    "line": 1,
    "extends": null,
    "statics": [],
    "methods": [
      {
        "name": "seek",
        "line": 28,
        "source": "seek (offset) {\n    this.offset = offset\n}",
        "kind": "method",
        "params": [
          "offset"
        ]
      },
      {
        "name": "skip",
        "line": 33,
        "source": "skip (bytes) {\n    this.offset += bytes\n}",
        "kind": "method",
        "params": [
          "bytes"
        ]
      },
      {
        "name": "readUint8",
        "line": 38,
        "source": "readUint8 () {\n    const value = this.view.getUint8(this.offset)\n    this.offset += 1\n    return value\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "readInt8",
        "line": 45,
        "source": "readInt8 () {\n    const value = this.view.getInt8(this.offset)\n    this.offset += 1\n    return value\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "readUint16",
        "line": 52,
        "source": "readUint16 (littleEndian = false) {\n    const value = this.view.getUint16(this.offset, littleEndian)\n    this.offset += 2\n    return value\n}",
        "kind": "method",
        "params": [
          "littleEndian = ..."
        ]
      },
      {
        "name": "readInt16",
        "line": 59,
        "source": "readInt16 (littleEndian = false) {\n    const value = this.view.getInt16(this.offset, littleEndian)\n    this.offset += 2\n    return value\n}",
        "kind": "method",
        "params": [
          "littleEndian = ..."
        ]
      },
      {
        "name": "readUint32",
        "line": 66,
        "source": "readUint32 (littleEndian = false) {\n    const value = this.view.getUint32(this.offset, littleEndian)\n    this.offset += 4\n    return value\n}",
        "kind": "method",
        "params": [
          "littleEndian = ..."
        ]
      },
      {
        "name": "readInt32",
        "line": 73,
        "source": "readInt32 (littleEndian = false) {\n    const value = this.view.getInt32(this.offset, littleEndian)\n    this.offset += 4\n    return value\n}",
        "kind": "method",
        "params": [
          "littleEndian = ..."
        ]
      },
      {
        "name": "readFloat32",
        "line": 80,
        "source": "readFloat32 (littleEndian = false) {\n    const value = this.view.getFloat32(this.offset, littleEndian)\n    this.offset += 4\n    return value\n}",
        "kind": "method",
        "params": [
          "littleEndian = ..."
        ]
      },
      {
        "name": "readFloat64",
        "line": 87,
        "source": "readFloat64 (littleEndian = false) {\n    const value = this.view.getFloat64(this.offset, littleEndian)\n    this.offset += 8\n    return value\n}",
        "kind": "method",
        "params": [
          "littleEndian = ..."
        ]
      },
      {
        "name": "readBytes",
        "line": 94,
        "source": "readBytes (length) {\n    const bytes = this.buffer.slice(this.offset, this.offset + length)\n    this.offset += length\n    return bytes\n}",
        "kind": "method",
        "params": [
          "length"
        ]
      },
      {
        "name": "readString",
        "line": 101,
        "source": "readString (length) {\n    const bytes = this.readBytes(length)\n    return String.fromCharCode(...bytes)\n}",
        "kind": "method",
        "params": [
          "length"
        ]
      },
      {
        "name": "readPascalString",
        "line": 107,
        "source": "readPascalString (padding = 1) {\n    const length = this.readUint8()\n    const str = length > 0 ? this.readString(length) : ''\n    const totalLength = 1 + length\n    const remainder = totalLength % padding\n    if (remainder !== 0) {\n        this.skip(padding - remainder)\n    }\n    return str\n}",
        "kind": "method",
        "params": [
          "padding = ..."
        ]
      }
    ],
    "getters": [
      {
        "name": "length",
        "line": 18,
        "source": "get length () {\n    return this.buffer.length\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "remaining",
        "line": 23,
        "source": "get remaining () {\n    return this.buffer.length - this.offset\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 3,
      "source": "constructor (buffer) {\n    if (buffer instanceof ArrayBuffer) {\n        this.buffer = new Uint8Array(buffer)\n        this.view = new DataView(buffer)\n    } else if (buffer instanceof Uint8Array) {\n        this.buffer = buffer\n        this.view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n    } else {\n        this.buffer = new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n        this.view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n    }\n    this.offset = 0\n}",
      "kind": "constructor",
      "params": [
        "buffer"
      ]
    },
    "isDefault": true
  },
  "/io/canvas.doc.js": {
    "type": "module",
    "file": "/io/canvas.js",
    "functions": [
      {
        "name": "getNodeCanvas",
        "line": 4,
        "params": [],
        "source": "async function getNodeCanvas () {\n    if (!nodeCanvas) {\n        nodeCanvas = await import(/* @vite-ignore */ 'canvas')\n    }\n    return nodeCanvas\n}"
      },
      {
        "name": "isNode",
        "line": 12,
        "params": [],
        "source": "function isNode () {\n    return typeof document === 'undefined'\n}"
      },
      {
        "name": "createCanvas",
        "line": 17,
        "params": [
          "width",
          "height"
        ],
        "source": "async function createCanvas (width, height) {\n    if (isNode()) {\n        const {createCanvas: nodeCreateCanvas} = await getNodeCanvas()\n        return nodeCreateCanvas(width, height)\n    }\n    const canvas = document.createElement('canvas')\n    canvas.width = width\n    canvas.height = height\n    return canvas\n}"
      },
      {
        "name": "canvasToBuffer",
        "line": 29,
        "params": [
          "canvas"
        ],
        "source": "async function canvasToBuffer (canvas) {\n    if (isNode()) {\n        return canvas.toBuffer('image/png')\n    }\n    return new Promise((resolve, reject) => {\n        canvas.toBlob(blob => {\n            if (!blob) {\n                reject(new Error('Failed to create blob'))\n                return\n            }\n            blob.arrayBuffer().then(buffer => {\n                resolve(Buffer.from(buffer))\n            })\n        }, 'image/png')\n    })\n}"
      },
      {
        "name": "canvasToBlob",
        "line": 47,
        "params": [
          "canvas"
        ],
        "source": "async function canvasToBlob (canvas) {\n    if (isNode()) {\n        const buffer = canvas.toBuffer('image/png')\n        return new Blob([buffer], {type: 'image/png'})\n    }\n    return new Promise((resolve, reject) => {\n        canvas.toBlob(blob => {\n            if (!blob) {\n                reject(new Error('Failed to create blob'))\n                return\n            }\n            resolve(blob)\n        }, 'image/png')\n    })\n}"
      },
      {
        "name": "putPixels",
        "line": 64,
        "params": [
          "ctx",
          "{...}"
        ],
        "source": "function putPixels (ctx, {pixels, width, height, x = 0, y = 0}) {\n    const imageData = ctx.createImageData(width, height)\n    imageData.data.set(new Uint8ClampedArray(pixels.buffer, pixels.byteOffset, pixels.byteLength))\n    ctx.putImageData(imageData, x, y)\n}"
      },
      {
        "name": "calculateResizeDimensions",
        "line": 71,
        "params": [
          "srcWidth",
          "srcHeight",
          "targetWidth",
          "targetHeight"
        ],
        "source": "function calculateResizeDimensions (srcWidth, srcHeight, targetWidth, targetHeight) {\n    if (targetWidth && targetHeight) {\n        return {width: targetWidth, height: targetHeight}\n    }\n\n    if (targetWidth) {\n        const scale = targetWidth / srcWidth\n        return {width: targetWidth, height: Math.round(srcHeight * scale)}\n    }\n\n    if (targetHeight) {\n        const scale = targetHeight / srcHeight\n        return {width: Math.round(srcWidth * scale), height: targetHeight}\n    }\n\n    return {width: srcWidth, height: srcHeight}\n}"
      },
      {
        "name": "resizeCanvas",
        "line": 90,
        "params": [
          "sourceCanvas",
          "targetWidth",
          "targetHeight",
          "nearest = ..."
        ],
        "source": "async function resizeCanvas (sourceCanvas, targetWidth, targetHeight, nearest = false) {\n    const destCanvas = await createCanvas(targetWidth, targetHeight)\n    const ctx = destCanvas.getContext('2d')\n\n    if (nearest) {\n        ctx.imageSmoothingEnabled = false\n    } else {\n        ctx.imageSmoothingEnabled = true\n        ctx.imageSmoothingQuality = 'high'\n    }\n\n    ctx.drawImage(sourceCanvas, 0, 0, targetWidth, targetHeight)\n    return destCanvas\n}"
      }
    ],
    "exports": []
  },
  "/io/manifest_patcher.doc.js": {
    "type": "module",
    "file": "/io/manifest_patcher.js",
    "functions": [
      {
        "name": "applyOverrides",
        "line": 4,
        "params": [
          "manifestData",
          "overrides"
        ],
        "source": "function applyOverrides (manifestData, overrides) {\n    const assets = {...manifestData.assets}\n\n    for (const {id, source} of overrides) {\n        if (assets[id]) {\n            assets[id] = {...assets[id], source}\n        }\n    }\n\n    return {...manifestData, assets}\n}"
      },
      {
        "name": "loadStudioOverrides",
        "line": 17,
        "params": [],
        "source": "async function loadStudioOverrides () {\n    const store = new PerkyStore()\n    const resources = await store.list('animator')\n    const overrides = []\n\n    for (const meta of resources) {\n        const resource = await store.get(meta.id)\n        if (!resource) {\n            continue\n        }\n\n        const animatorFile = resource.files.find(f => f.name.endsWith('Animator.json'))\n        if (!animatorFile) {\n            continue\n        }\n\n        const animatorConfig = JSON.parse(await animatorFile.blob.text())\n        overrides.push({id: meta.id, source: animatorConfig})\n\n        const spritesheetName = animatorConfig.spritesheet\n        if (!spritesheetName) {\n            continue\n        }\n\n        const spritesheetFile = resource.files.find(f =>\n            f.name.endsWith('.json') && !f.name.endsWith('Animator.json'))\n        if (!spritesheetFile) {\n            continue\n        }\n\n        const spritesheetData = JSON.parse(await spritesheetFile.blob.text())\n        const pngFiles = resource.files\n            .filter(f => f.name.endsWith('.png'))\n            .sort((a, b) => a.name.localeCompare(b.name))\n        const images = await Promise.all(pngFiles.map(f => loadImageFromBlob(f.blob)))\n\n        overrides.push({id: spritesheetName, source: {data: spritesheetData, images}})\n    }\n\n    return overrides\n}"
      },
      {
        "name": "loadImageFromBlob",
        "line": 60,
        "params": [
          "blob"
        ],
        "source": "function loadImageFromBlob (blob) {\n    return createImageBitmap(blob)\n}"
      }
    ],
    "exports": []
  },
  "/io/pack.doc.js": {
    "type": "module",
    "file": "/io/pack.js",
    "functions": [
      {
        "name": "blobToArrayBuffer",
        "line": 1,
        "params": [
          "blob"
        ],
        "source": "function blobToArrayBuffer (blob) {\n    if (typeof blob.arrayBuffer === 'function') {\n        return blob.arrayBuffer()\n    }\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader()\n        reader.onload = () => resolve(reader.result)\n        reader.onerror = reject\n        reader.readAsArrayBuffer(blob)\n    })\n}"
      },
      {
        "name": "compress",
        "line": 14,
        "params": [
          "blob"
        ],
        "source": "async function compress (blob) {\n    if (typeof CompressionStream === 'undefined') {\n        return blob\n    }\n    if (typeof blob.stream !== 'function') {\n        const buffer = await blobToArrayBuffer(blob)\n        const stream = new Response(buffer).body.pipeThrough(new CompressionStream('gzip'))\n        return new Response(stream).blob()\n    }\n    const stream = blob.stream().pipeThrough(new CompressionStream('gzip'))\n    return new Response(stream).blob()\n}"
      },
      {
        "name": "decompress",
        "line": 28,
        "params": [
          "blob"
        ],
        "source": "async function decompress (blob) {\n    if (typeof DecompressionStream === 'undefined') {\n        return blob\n    }\n    if (typeof blob.stream !== 'function') {\n        const buffer = await blobToArrayBuffer(blob)\n        const stream = new Response(buffer).body.pipeThrough(new DecompressionStream('gzip'))\n        return new Response(stream).blob()\n    }\n    const stream = blob.stream().pipeThrough(new DecompressionStream('gzip'))\n    return new Response(stream).blob()\n}"
      },
      {
        "name": "pack",
        "line": 42,
        "params": [
          "files",
          "undefined = ..."
        ],
        "source": "async function pack (files, {compress: shouldCompress = true} = {}) {\n    const header = {\n        files: files.map(f => ({\n            name: f.name,\n            size: f.blob.size,\n            type: f.blob.type\n        }))\n    }\n\n    const headerBytes = new TextEncoder().encode(JSON.stringify(header))\n    const headerSize = new Uint32Array([headerBytes.length])\n\n    const blob = new Blob([headerSize, headerBytes, ...files.map(f => f.blob)])\n\n    return shouldCompress ? compress(blob) : blob\n}"
      },
      {
        "name": "unpack",
        "line": 60,
        "params": [
          "blob",
          "undefined = ..."
        ],
        "source": "async function unpack (blob, {compressed = true} = {}) {\n    const data = compressed ? await decompress(blob) : blob\n    const buffer = await blobToArrayBuffer(data)\n    const headerSize = new Uint32Array(buffer, 0, 1)[0]\n    const headerBytes = new Uint8Array(buffer, 4, headerSize)\n    const header = JSON.parse(new TextDecoder().decode(headerBytes))\n\n    let offset = 4 + headerSize\n    return header.files.map(file => {\n        const fileBlob = new Blob([buffer.slice(offset, offset + file.size)], {type: file.type})\n        offset += file.size\n        return {name: file.name, blob: fileBlob}\n    })\n}"
      }
    ],
    "exports": []
  },
  "/io/perky_store.doc.js": {
    "type": "class",
    "file": "/io/perky_store.js",
    "name": "PerkyStore",
    "line": 10,
    "extends": null,
    "statics": [],
    "methods": [
      {
        "name": "open",
        "line": 20,
        "source": "async open () {\n    if (this.#db) {\n        return this.#db\n    }\n\n    return new Promise((resolve, reject) => {\n        const request = indexedDB.open(this.#dbName, DB_VERSION)\n\n        request.onupgradeneeded = (event) => {\n            const db = event.target.result\n            if (!db.objectStoreNames.contains(STORE_NAME)) {\n                const store = db.createObjectStore(STORE_NAME, {keyPath: 'id'})\n                store.createIndex('type', 'type', {unique: false})\n            }\n        }\n\n        request.onsuccess = (event) => {\n            this.#db = event.target.result\n            resolve(this.#db)\n        }\n\n        request.onerror = () => {\n            reject(new Error('Failed to open database'))\n        }\n    })\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "list",
        "line": 48,
        "source": "async list (type = null) {\n    const db = await this.open()\n\n    return new Promise((resolve, reject) => {\n        const transaction = db.transaction(STORE_NAME, 'readonly')\n        const store = transaction.objectStore(STORE_NAME)\n\n        const request = type\n            ? store.index('type').getAll(type)\n            : store.getAll()\n\n        request.onsuccess = () => {\n            const items = request.result.map(item => ({\n                id: item.id,\n                type: item.type,\n                name: item.name,\n                createdAt: item.createdAt,\n                updatedAt: item.updatedAt\n            }))\n            resolve(items)\n        }\n\n        request.onerror = () => {\n            reject(new Error('Failed to list resources'))\n        }\n    })\n}",
        "kind": "method",
        "params": [
          "type = ..."
        ]
      },
      {
        "name": "get",
        "line": 77,
        "source": "async get (id) {\n    const db = await this.open()\n\n    return new Promise((resolve, reject) => {\n        const transaction = db.transaction(STORE_NAME, 'readonly')\n        const store = transaction.objectStore(STORE_NAME)\n        const request = store.get(id)\n\n        request.onsuccess = async () => {\n            const item = request.result\n            if (!item) {\n                resolve(null)\n                return\n            }\n\n            const allFiles = await unpack(item.blob)\n            const files = allFiles.filter(f => f.name !== META_FILENAME)\n\n            resolve({\n                id: item.id,\n                type: item.type,\n                name: item.name,\n                files,\n                createdAt: item.createdAt,\n                updatedAt: item.updatedAt\n            })\n        }\n\n        request.onerror = () => {\n            reject(new Error('Failed to get resource'))\n        }\n    })\n}",
        "kind": "method",
        "params": [
          "id"
        ]
      },
      {
        "name": "save",
        "line": 112,
        "source": "async save (id, data) {\n    const db = await this.open()\n    const {type, name, files} = data\n\n    if (!type) {\n        throw new Error('Resource type is required')\n    }\n\n    const now = Date.now()\n\n    const meta = {\n        type,\n        name: name || id,\n        version: 1,\n        updatedAt: now\n    }\n\n    const allFiles = [\n        {name: META_FILENAME, blob: new Blob([JSON.stringify(meta)], {type: 'application/json'})},\n        ...files\n    ]\n\n    const blob = await pack(allFiles)\n\n    return new Promise((resolve, reject) => {\n        const transaction = db.transaction(STORE_NAME, 'readwrite')\n        const store = transaction.objectStore(STORE_NAME)\n\n        const getRequest = store.get(id)\n        getRequest.onsuccess = () => {\n            const existing = getRequest.result\n            const record = {\n                id,\n                type,\n                name: name || id,\n                blob,\n                createdAt: existing?.createdAt || now,\n                updatedAt: now\n            }\n\n            const putRequest = store.put(record)\n            putRequest.onsuccess = () => {\n                resolve({id, type, name: record.name})\n            }\n            putRequest.onerror = () => {\n                reject(new Error('Failed to save resource'))\n            }\n        }\n\n        getRequest.onerror = () => {\n            reject(new Error('Failed to save resource'))\n        }\n    })\n}",
        "kind": "method",
        "params": [
          "id",
          "data"
        ]
      },
      {
        "name": "delete",
        "line": 168,
        "source": "async delete (id) {\n    const db = await this.open()\n\n    return new Promise((resolve, reject) => {\n        const transaction = db.transaction(STORE_NAME, 'readwrite')\n        const store = transaction.objectStore(STORE_NAME)\n        const request = store.delete(id)\n\n        request.onsuccess = () => {\n            resolve()\n        }\n\n        request.onerror = () => {\n            reject(new Error('Failed to delete resource'))\n        }\n    })\n}",
        "kind": "method",
        "params": [
          "id"
        ]
      },
      {
        "name": "export",
        "line": 187,
        "source": "async export (id) {\n    const db = await this.open()\n\n    return new Promise((resolve, reject) => {\n        const transaction = db.transaction(STORE_NAME, 'readonly')\n        const store = transaction.objectStore(STORE_NAME)\n        const request = store.get(id)\n\n        request.onsuccess = async () => {\n            const item = request.result\n            if (!item) {\n                reject(new Error('Resource not found'))\n                return\n            }\n\n            const filename = `${item.name}.perky`\n            const file = new File([item.blob], filename)\n\n            if (navigator.canShare?.({files: [file]})) {\n                await navigator.share({files: [file]})\n            } else {\n                const url = URL.createObjectURL(item.blob)\n                const a = document.createElement('a')\n                a.href = url\n                a.download = filename\n                a.click()\n                URL.revokeObjectURL(url)\n            }\n\n            resolve()\n        }\n\n        request.onerror = () => {\n            reject(new Error('Failed to export resource'))\n        }\n    })\n}",
        "kind": "method",
        "params": [
          "id"
        ]
      },
      {
        "name": "import",
        "line": 226,
        "source": "async import (file) {\n    const blob = file instanceof Blob ? file : new Blob([await file.arrayBuffer()])\n    const allFiles = await unpack(blob)\n\n    const metaFile = allFiles.find(f => f.name === META_FILENAME)\n    if (!metaFile) {\n        throw new Error('Invalid .perky file: missing meta.json')\n    }\n\n    const metaText = await blobToText(metaFile.blob)\n    const meta = JSON.parse(metaText)\n\n    if (!meta.type || !meta.name) {\n        throw new Error('Invalid .perky file: meta.json must have type and name')\n    }\n\n    const files = allFiles.filter(f => f.name !== META_FILENAME)\n    const id = `${meta.name}${capitalize(meta.type)}`\n\n    await this.save(id, {\n        type: meta.type,\n        name: meta.name,\n        files\n    })\n\n    return {id, type: meta.type, name: meta.name}\n}",
        "kind": "method",
        "params": [
          "file"
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 15,
      "source": "constructor (dbName = 'studio') {\n    this.#dbName = `${DB_PREFIX}${dbName}`\n}",
      "kind": "constructor",
      "params": [
        "dbName = ..."
      ]
    },
    "isDefault": true
  },
  "/io/psd.doc.js": {
    "type": "module",
    "file": "/io/psd.js",
    "functions": [
      {
        "name": "readUtf16String",
        "line": 16,
        "params": [
          "reader",
          "byteLength"
        ],
        "source": "function readUtf16String (reader, byteLength) {\n    const chars = []\n    const charCount = byteLength / 2\n    for (let i = 0; i < charCount; i++) {\n        const charCode = reader.readUint16()\n        if (charCode > 0) {\n            chars.push(String.fromCharCode(charCode))\n        }\n    }\n    return chars.join('')\n}"
      },
      {
        "name": "readProfileName",
        "line": 29,
        "params": [
          "reader",
          "startOffset",
          "descOffset"
        ],
        "source": "function readProfileName (reader, startOffset, descOffset) {\n    if (descOffset <= 0) {\n        return 'Unknown'\n    }\n\n    reader.seek(startOffset + descOffset)\n    const descType = reader.readString(4)\n\n    if (descType === 'desc') {\n        reader.skip(4)\n        const strLength = reader.readUint32()\n        return reader.readString(strLength - 1)\n    }\n\n    if (descType !== 'mluc') {\n        return 'Unknown'\n    }\n\n    reader.skip(4)\n    const recordCount = reader.readUint32()\n    reader.skip(4)\n\n    if (recordCount <= 0) {\n        return 'Unknown'\n    }\n\n    reader.skip(4)\n    const strLength = reader.readUint32()\n    const strOffset = reader.readUint32()\n    reader.seek(startOffset + descOffset + strOffset)\n\n    return readUtf16String(reader, strLength)\n}"
      },
      {
        "name": "processRlePacket",
        "line": 64,
        "params": [
          "reader",
          "ctx"
        ],
        "source": "function processRlePacket (reader, ctx) {\n    const header = reader.readInt8()\n\n    if (header >= 0) {\n        const count = header + 1\n        for (let i = 0; i < count && ctx.offset < ctx.rowEnd; i++) {\n            ctx.output[ctx.offset++] = reader.readUint8()\n        }\n        return\n    }\n\n    if (header > -128) {\n        const count = -header + 1\n        const value = reader.readUint8()\n        for (let i = 0; i < count && ctx.offset < ctx.rowEnd; i++) {\n            ctx.output[ctx.offset++] = value\n        }\n    }\n}"
      },
      {
        "name": "copyPixelToRgba",
        "line": 85,
        "params": [
          "rgba",
          "dstIdx",
          "channels",
          "srcIdx"
        ],
        "source": "function copyPixelToRgba (rgba, dstIdx, channels, srcIdx) {\n    rgba[dstIdx * 4] = channels.red ? channels.red[srcIdx] : 0\n    rgba[dstIdx * 4 + 1] = channels.green ? channels.green[srcIdx] : 0\n    rgba[dstIdx * 4 + 2] = channels.blue ? channels.blue[srcIdx] : 0\n    rgba[dstIdx * 4 + 3] = channels.alpha ? channels.alpha[srcIdx] : 255\n}"
      },
      {
        "name": "parsePsd",
        "line": 93,
        "params": [
          "buffer"
        ],
        "source": "function parsePsd (buffer) {\n    const reader = new BinaryReader(buffer)\n\n    const header = parseHeader(reader)\n    skipColorModeData(reader)\n    const colorProfile = parseImageResources(reader)\n    const layers = parseLayerSection(reader)\n    const tree = buildLayerTree(layers)\n    const animations = findAnimations(tree)\n\n    return {\n        width: header.width,\n        height: header.height,\n        depth: header.depth,\n        colorMode: header.colorMode,\n        colorProfile,\n        layers,\n        tree,\n        animations\n    }\n}"
      },
      {
        "name": "parseHeader",
        "line": 116,
        "params": [
          "reader"
        ],
        "source": "function parseHeader (reader) {\n    const signature = reader.readString(4)\n    if (signature !== '8BPS') {\n        throw new Error(`Invalid PSD signature: ${signature}`)\n    }\n\n    const version = reader.readUint16()\n    if (version !== 1 && version !== 2) {\n        throw new Error(`Unsupported PSD version: ${version}`)\n    }\n\n    reader.skip(6)\n\n    const channels = reader.readUint16()\n    const height = reader.readUint32()\n    const width = reader.readUint32()\n    const depth = reader.readUint16()\n    const colorMode = reader.readUint16()\n\n    return {\n        version: version === 1 ? 'PSD' : 'PSB',\n        channels,\n        width,\n        height,\n        depth,\n        colorMode: COLOR_MODES[colorMode] || colorMode\n    }\n}"
      },
      {
        "name": "skipColorModeData",
        "line": 146,
        "params": [
          "reader"
        ],
        "source": "function skipColorModeData (reader) {\n    const length = reader.readUint32()\n    reader.skip(length)\n}"
      },
      {
        "name": "parseImageResources",
        "line": 152,
        "params": [
          "reader"
        ],
        "source": "function parseImageResources (reader) {\n    const length = reader.readUint32()\n    const endOffset = reader.offset + length\n\n    let colorProfile = null\n\n    while (reader.offset < endOffset) {\n        const signature = reader.readString(4)\n        if (signature !== '8BIM') {\n            break\n        }\n\n        const resourceId = reader.readUint16()\n        const nameLength = reader.readUint8()\n        const namePadding = (nameLength + 1) % 2 === 0 ? 0 : 1\n        reader.skip(nameLength + namePadding)\n\n        const dataLength = reader.readUint32()\n        const dataPadding = dataLength % 2 === 0 ? 0 : 1\n\n        if (resourceId === 1039) {\n            colorProfile = parseICCProfile(reader, dataLength)\n            reader.skip(dataPadding)\n        } else {\n            reader.skip(dataLength + dataPadding)\n        }\n    }\n\n    reader.seek(endOffset)\n    return colorProfile || {name: 'sRGB', isP3: false}\n}"
      },
      {
        "name": "parseICCProfile",
        "line": 185,
        "params": [
          "reader",
          "length"
        ],
        "source": "function parseICCProfile (reader, length) {\n    const startOffset = reader.offset\n\n    reader.skip(4)\n    reader.skip(4)\n    reader.skip(4)\n    reader.skip(4)\n    const colorSpace = reader.readString(4).trim()\n\n    reader.seek(startOffset + 128)\n\n    const tagCount = reader.readUint32()\n    let descOffset = 0\n\n    for (let i = 0; i < tagCount; i++) {\n        const tagSig = reader.readString(4)\n        const tagOffset = reader.readUint32()\n        reader.skip(4)\n\n        if (tagSig === 'desc') {\n            descOffset = tagOffset\n            break\n        }\n    }\n\n    const profileName = readProfileName(reader, startOffset, descOffset)\n\n    reader.seek(startOffset + length)\n\n    const nameLower = profileName.toLowerCase()\n    const isP3 = nameLower.includes('p3') || nameLower.includes('display p3')\n    const isSRGB = nameLower.includes('srgb')\n\n    return {\n        name: profileName,\n        colorSpace,\n        isP3,\n        isSRGB\n    }\n}"
      },
      {
        "name": "parseLayerSection",
        "line": 227,
        "params": [
          "reader"
        ],
        "source": "function parseLayerSection (reader) {\n    const sectionLength = reader.readUint32()\n    if (sectionLength === 0) {\n        return []\n    }\n\n    const sectionEnd = reader.offset + sectionLength\n    const layerInfoLength = reader.readUint32()\n\n    if (layerInfoLength === 0) {\n        reader.seek(sectionEnd)\n        return []\n    }\n\n    let layerCount = reader.readInt16()\n    layerCount = Math.abs(layerCount)\n\n    const layers = []\n\n    for (let i = 0; i < layerCount; i++) {\n        layers.push(parseLayerRecord(reader))\n    }\n\n    for (const layer of layers) {\n        layer.channelData = parseChannelData(reader, layer)\n    }\n\n    reader.seek(sectionEnd)\n    return layers\n}"
      },
      {
        "name": "parseLayerRecord",
        "line": 259,
        "params": [
          "reader"
        ],
        "source": "function parseLayerRecord (reader) {\n    const top = reader.readInt32()\n    const left = reader.readInt32()\n    const bottom = reader.readInt32()\n    const right = reader.readInt32()\n\n    const channelCount = reader.readUint16()\n    const channels = []\n\n    for (let i = 0; i < channelCount; i++) {\n        const id = reader.readInt16()\n        const dataLength = reader.readUint32()\n        channels.push({id, dataLength})\n    }\n\n    reader.skip(4) // blend signature\n    const blendMode = reader.readString(4)\n    const opacity = reader.readUint8()\n    reader.skip(1) // clipping\n    const flags = reader.readUint8()\n    reader.skip(1) // filler\n\n    const extraDataLength = reader.readUint32()\n    const extraDataEnd = reader.offset + extraDataLength\n\n    const maskDataLength = reader.readUint32()\n    reader.skip(maskDataLength)\n\n    const blendingRangesLength = reader.readUint32()\n    reader.skip(blendingRangesLength)\n\n    const name = readLayerName(reader)\n\n    let isGroup = false\n    let isGroupEnd = false\n    let sectionType = 0\n\n    while (reader.offset < extraDataEnd) {\n        const sig = reader.readString(4)\n        if (sig !== '8BIM' && sig !== '8B64') {\n            reader.offset -= 4\n            break\n        }\n\n        const key = reader.readString(4)\n        const dataLength = reader.readUint32()\n        const dataEnd = reader.offset + dataLength\n\n        if (key === 'lsct' || key === 'lsdk') {\n            sectionType = reader.readUint32()\n            isGroup = sectionType === 1 || sectionType === 2\n            isGroupEnd = sectionType === 3\n        }\n\n        reader.seek(dataEnd)\n        if (dataLength % 2 !== 0) {\n            reader.skip(1)\n        }\n    }\n\n    reader.seek(extraDataEnd)\n\n    return {\n        name,\n        top,\n        left,\n        bottom,\n        right,\n        width: right - left,\n        height: bottom - top,\n        channels,\n        opacity,\n        blendMode,\n        isGroup,\n        isGroupEnd,\n        visible: (flags & 2) === 0 // eslint-disable-line no-bitwise -- clean\n    }\n}"
      },
      {
        "name": "readLayerName",
        "line": 339,
        "params": [
          "reader"
        ],
        "source": "function readLayerName (reader) {\n    const length = reader.readUint8()\n    const name = length > 0 ? reader.readString(length) : ''\n    const padding = (4 - ((length + 1) % 4)) % 4\n    reader.skip(padding)\n    return name\n}"
      },
      {
        "name": "parseChannelData",
        "line": 348,
        "params": [
          "reader",
          "layer"
        ],
        "source": "function parseChannelData (reader, layer) {\n    const channelData = {}\n\n    for (const channel of layer.channels) {\n        const compression = reader.readUint16()\n        const dataLength = channel.dataLength - 2\n\n        if (layer.width === 0 || layer.height === 0) {\n            reader.skip(dataLength)\n            continue\n        }\n\n        let pixels\n        if (compression === 0) {\n            pixels = reader.readBytes(dataLength)\n        } else if (compression === 1) {\n            pixels = decodeRLE(reader, layer.width, layer.height)\n        } else {\n            reader.skip(dataLength)\n            continue\n        }\n\n        channelData[channel.id] = pixels\n    }\n\n    return channelData\n}"
      },
      {
        "name": "decodeRLE",
        "line": 377,
        "params": [
          "reader",
          "width",
          "height"
        ],
        "source": "function decodeRLE (reader, width, height) {\n    for (let y = 0; y < height; y++) {\n        reader.readUint16()\n    }\n\n    const output = new Uint8Array(width * height)\n    const ctx = {output, offset: 0, rowEnd: 0}\n\n    for (let y = 0; y < height; y++) {\n        ctx.rowEnd = ctx.offset + width\n        while (ctx.offset < ctx.rowEnd) {\n            processRlePacket(reader, ctx)\n        }\n    }\n\n    return output\n}"
      },
      {
        "name": "buildLayerTree",
        "line": 396,
        "params": [
          "layers"
        ],
        "source": "function buildLayerTree (layers) {\n    const root = {children: []}\n    const stack = [root]\n\n    for (let i = layers.length - 1; i >= 0; i--) {\n        const layer = layers[i]\n        const current = stack[stack.length - 1]\n\n        if (!current) {\n            continue\n        }\n\n        if (layer.isGroup) {\n            const group = {\n                type: 'group',\n                name: layer.name,\n                children: []\n            }\n            current.children.push(group)\n            stack.push(group)\n        } else if (layer.isGroupEnd) {\n            if (stack.length > 1) {\n                stack.pop()\n            }\n        } else {\n            current.children.push({\n                type: 'layer',\n                name: layer.name,\n                layer\n            })\n        }\n    }\n\n    return root.children\n}"
      },
      {
        "name": "findAnimations",
        "line": 433,
        "params": [
          "tree"
        ],
        "source": "function findAnimations (tree) {\n    const animations = {}\n\n    function traverse (nodes) {\n        for (const node of nodes) {\n            if (node.type === 'group') {\n                if (node.name.startsWith('anim - ')) {\n                    const animName = node.name.replace('anim - ', '')\n                    const frames = node.children\n                        .filter(child => child.type === 'layer')\n                        .map(child => child.layer)\n                        .sort((a, b) => {\n                            const numA = parseInt(a.name.match(/^(\\d+)/)?.[1] || '0', 10)\n                            const numB = parseInt(b.name.match(/^(\\d+)/)?.[1] || '0', 10)\n                            return numA - numB\n                        })\n                    animations[animName] = frames\n                } else {\n                    traverse(node.children)\n                }\n            }\n        }\n    }\n\n    traverse(tree)\n    return animations\n}"
      },
      {
        "name": "layerToRGBA",
        "line": 462,
        "params": [
          "layer",
          "psdWidth",
          "psdHeight",
          "options = ..."
        ],
        "source": "function layerToRGBA (layer, psdWidth, psdHeight, options = {}) {\n    const {channelData, width, height, left, top} = layer\n    const trim = options.trim ?? false\n\n    if (width === 0 || height === 0) {\n        return null\n    }\n\n    const channels = {\n        red: channelData[0],\n        green: channelData[1],\n        blue: channelData[2],\n        alpha: channelData[-1]\n    }\n\n    if (trim) {\n        return createTrimmedRgba(channels, {width, height, left, top})\n    }\n\n    return createFullRgba(channels, layer, psdWidth, psdHeight)\n}"
      },
      {
        "name": "createTrimmedRgba",
        "line": 485,
        "params": [
          "channels",
          "bounds"
        ],
        "source": "function createTrimmedRgba (channels, bounds) {\n    const {width, height, left, top} = bounds\n    const rgba = new Uint8Array(width * height * 4)\n    for (let i = 0; i < width * height; i++) {\n        copyPixelToRgba(rgba, i, channels, i)\n    }\n    return {pixels: rgba, width, height, left, top}\n}"
      },
      {
        "name": "createFullRgba",
        "line": 495,
        "params": [
          "channels",
          "layer",
          "psdWidth",
          "psdHeight"
        ],
        "source": "function createFullRgba (channels, layer, psdWidth, psdHeight) {\n    const rgba = new Uint8Array(psdWidth * psdHeight * 4)\n    const ctx = {rgba, channels, layer, psdWidth, psdHeight}\n\n    for (let ly = 0; ly < layer.height; ly++) {\n        copyRowToRgba(ctx, ly)\n    }\n\n    return {pixels: rgba, width: psdWidth, height: psdHeight, left: 0, top: 0}\n}"
      },
      {
        "name": "copyRowToRgba",
        "line": 507,
        "params": [
          "ctx",
          "ly"
        ],
        "source": "function copyRowToRgba (ctx, ly) {\n    const {rgba, channels, layer, psdWidth, psdHeight} = ctx\n    const {width, left, top} = layer\n    const dstY = top + ly\n\n    if (dstY < 0 || dstY >= psdHeight) {\n        return\n    }\n\n    for (let lx = 0; lx < width; lx++) {\n        const dstX = left + lx\n        if (dstX < 0 || dstX >= psdWidth) {\n            continue\n        }\n\n        const srcIdx = ly * width + lx\n        const dstIdx = dstY * psdWidth + dstX\n        copyPixelToRgba(rgba, dstIdx, channels, srcIdx)\n    }\n}"
      }
    ],
    "exports": []
  },
  "/io/psd_converter.doc.js": {
    "type": "class",
    "file": "/io/psd_converter.js",
    "name": "PsdConverter",
    "line": 18,
    "extends": "Notifier",
    "statics": [],
    "methods": [
      {
        "name": "parse",
        "line": 20,
        "source": "parse (buffer) { // eslint-disable-line local/class-methods-use-this -- clean\n    return parse(buffer)\n}",
        "kind": "method",
        "params": [
          "buffer"
        ]
      },
      {
        "name": "getAnimationGroups",
        "line": 25,
        "source": "getAnimationGroups (psd) { // eslint-disable-line local/class-methods-use-this -- clean\n    return getAnimationGroups(psd)\n}",
        "kind": "method",
        "params": [
          "psd"
        ]
      },
      {
        "name": "getAnimationInfo",
        "line": 30,
        "source": "getAnimationInfo (psd) { // eslint-disable-line local/class-methods-use-this -- clean\n    const groups = getAnimationGroups(psd)\n    return groups.map(group => ({\n        name: parseAnimationName(group.name),\n        frameCount: countFrames(group)\n    }))\n}",
        "kind": "method",
        "params": [
          "psd"
        ]
      },
      {
        "name": "convert",
        "line": 39,
        "source": "async convert (psd, options = {}) {\n    const {\n        targetWidth = null,\n        targetHeight = null,\n        nearest = false,\n        name = psd.filename || 'sprite'\n    } = options\n\n    this.emit('progress', {stage: 'extracting', percent: 0})\n\n    const resize = calculateResizeDimensions(\n        psd.width,\n        psd.height,\n        targetWidth,\n        targetHeight\n    )\n\n    const animGroups = getAnimationGroups(psd)\n    let frames = []\n    const animations = {}\n\n    for (const group of animGroups) {\n        const animName = parseAnimationName(group.name)\n        const groupFrames = extractFramesFromGroup(group, psd.width, psd.height)\n        frames = frames.concat(groupFrames)\n        animations[animName] = groupFrames.map(f => f.filename)\n    }\n\n    this.emit('progress', {stage: 'resizing', percent: 20})\n\n    frames = await resizeFrames(frames, {\n        psdWidth: psd.width,\n        psdHeight: psd.height,\n        targetWidth: resize.width,\n        targetHeight: resize.height,\n        nearest\n    })\n\n    this.emit('progress', {stage: 'packing', percent: 40})\n\n    const atlases = packFramesIntoAtlases(frames, MAX_ATLAS_SIZE)\n\n    this.emit('progress', {stage: 'compositing', percent: 60})\n\n    for (const atlas of atlases) {\n        const usedHeight = atlas.packer.currentY\n        atlas.finalHeight = nextPowerOfTwo(usedHeight)\n        atlas.canvas = await compositeAtlas(\n            atlas.frames,\n            MAX_ATLAS_SIZE,\n            atlas.finalHeight\n        )\n    }\n\n    this.emit('progress', {stage: 'finalizing', percent: 80})\n\n    const spritesheetName = `${name}Spritesheet`\n    const spritesheetJson = buildJsonData(atlases, animations, name)\n    const animatorConfig = buildAnimatorConfig(spritesheetName, animations)\n\n    this.emit('progress', {stage: 'complete', percent: 100})\n\n    return {\n        atlases,\n        spritesheetJson,\n        animatorConfig,\n        name,\n        spritesheetName\n    }\n}",
        "kind": "method",
        "params": [
          "psd",
          "options = ..."
        ]
      },
      {
        "name": "buildAnimatorConfig",
        "line": 111,
        "source": "buildAnimatorConfig (spritesheetName, animations) { // eslint-disable-line local/class-methods-use-this -- clean\n    return buildAnimatorConfig(spritesheetName, animations)\n}",
        "kind": "method",
        "params": [
          "spritesheetName",
          "animations"
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": null,
    "isDefault": true
  },
  "/io/spritesheet.doc.js": {
    "type": "module",
    "file": "/io/spritesheet.js",
    "functions": [
      {
        "name": "isAnimationGroup",
        "line": 14,
        "params": [
          "name"
        ],
        "source": "function isAnimationGroup (name) {\n    return ANIM_GROUP_PATTERN.test(name)\n}"
      },
      {
        "name": "findAnimationGroups",
        "line": 19,
        "params": [
          "tree"
        ],
        "source": "function findAnimationGroups (tree) {\n    const groups = []\n\n    function traverse (nodes) {\n        for (const node of nodes) {\n            if (node.type === 'group') {\n                if (isAnimationGroup(node.name)) {\n                    groups.push(node)\n                } else {\n                    traverse(node.children)\n                }\n            }\n        }\n    }\n\n    traverse(tree)\n    return groups\n}"
      },
      {
        "name": "parseAnimationName",
        "line": 39,
        "params": [
          "groupName"
        ],
        "source": "function parseAnimationName (groupName) {\n    const match = groupName.match(ANIM_GROUP_PATTERN)\n    if (!match) {\n        return groupName\n    }\n\n    const rawName = match[1].trim().toLowerCase()\n    return toCamelCase(rawName)\n}"
      },
      {
        "name": "parseFrameNumber",
        "line": 50,
        "params": [
          "layerName"
        ],
        "source": "function parseFrameNumber (layerName) {\n    const match = layerName.match(/^(\\d+)/)\n    return match ? match[1] : null\n}"
      },
      {
        "name": "countFrames",
        "line": 56,
        "params": [
          "group"
        ],
        "source": "function countFrames (group) {\n    return group.children.filter(c => c.type === 'layer' && parseFrameNumber(c.name)).length\n}"
      },
      {
        "name": "extractFramesFromGroup",
        "line": 61,
        "params": [
          "group",
          "psdWidth",
          "psdHeight"
        ],
        "source": "function extractFramesFromGroup (group, psdWidth, psdHeight) {\n    const animName = parseAnimationName(group.name)\n    const frames = []\n\n    const layersWithFrameNumbers = []\n\n    for (const child of group.children) {\n        if (child.type !== 'layer') {\n            continue\n        }\n\n        const frameNumber = parseFrameNumber(child.name)\n        if (!frameNumber) {\n            continue\n        }\n\n        layersWithFrameNumbers.push({\n            layer: child.layer,\n            name: child.name,\n            frameNumber: parseInt(frameNumber, 10)\n        })\n    }\n\n    layersWithFrameNumbers.sort((a, b) => a.frameNumber - b.frameNumber)\n\n    for (const {layer, frameNumber} of layersWithFrameNumbers) {\n        const rgba = layerToRGBA(layer, psdWidth, psdHeight)\n        if (!rgba) {\n            continue\n        }\n\n        frames.push({\n            filename: `${animName}/${frameNumber}`,\n            pixels: rgba.pixels,\n            width: rgba.width,\n            height: rgba.height,\n            animName,\n            frameNumber\n        })\n    }\n\n    return frames\n}"
      },
      {
        "name": "resizeFrame",
        "line": 106,
        "params": [
          "frameData",
          "targetWidth",
          "targetHeight",
          "nearest"
        ],
        "source": "async function resizeFrame (frameData, targetWidth, targetHeight, nearest) {\n    const srcCanvas = await createCanvas(frameData.width, frameData.height)\n    const srcCtx = srcCanvas.getContext('2d')\n    putPixels(srcCtx, {pixels: frameData.pixels, width: frameData.width, height: frameData.height})\n\n    const resizedCanvas = await resizeCanvas(srcCanvas, targetWidth, targetHeight, nearest)\n    const resizedCtx = resizedCanvas.getContext('2d')\n    const imageData = resizedCtx.getImageData(0, 0, targetWidth, targetHeight)\n\n    return {\n        pixels: new Uint8Array(imageData.data.buffer),\n        width: targetWidth,\n        height: targetHeight\n    }\n}"
      },
      {
        "name": "resizeFrames",
        "line": 123,
        "params": [
          "frames",
          "{...}"
        ],
        "source": "async function resizeFrames (frames, {psdWidth, psdHeight, targetWidth, targetHeight, nearest}) {\n    const resize = calculateResizeDimensions(psdWidth, psdHeight, targetWidth, targetHeight)\n    const needsResize = resize.width !== psdWidth || resize.height !== psdHeight\n\n    if (!needsResize) {\n        return frames\n    }\n\n    const resized = []\n    for (const frame of frames) {\n        const resizedFrame = await resizeFrame(frame, resize.width, resize.height, nearest)\n        resized.push({\n            ...frame,\n            pixels: resizedFrame.pixels,\n            width: resizedFrame.width,\n            height: resizedFrame.height\n        })\n    }\n    return resized\n}"
      },
      {
        "name": "packFramesIntoAtlases",
        "line": 145,
        "params": [
          "frames",
          "atlasSize = ...",
          "padding = ..."
        ],
        "source": "function packFramesIntoAtlases (frames, atlasSize = MAX_ATLAS_SIZE, padding = PADDING) {\n    const atlases = []\n    let currentAtlas = {\n        packer: new ShelfPacker(atlasSize, atlasSize, padding),\n        frames: []\n    }\n    atlases.push(currentAtlas)\n\n    for (const frame of frames) {\n        let slot = currentAtlas.packer.pack(frame.width, frame.height)\n\n        if (!slot) {\n            currentAtlas = {\n                packer: new ShelfPacker(atlasSize, atlasSize, padding),\n                frames: []\n            }\n            atlases.push(currentAtlas)\n            slot = currentAtlas.packer.pack(frame.width, frame.height)\n\n            if (!slot) {\n                logger.warn(`Frame too large: ${frame.filename}`)\n                continue\n            }\n        }\n\n        currentAtlas.frames.push({\n            ...frame,\n            x: slot.x,\n            y: slot.y,\n            atlasIndex: atlases.length - 1\n        })\n    }\n\n    return atlases\n}"
      },
      {
        "name": "compositeAtlas",
        "line": 182,
        "params": [
          "packedFrames",
          "atlasWidth",
          "atlasHeight"
        ],
        "source": "async function compositeAtlas (packedFrames, atlasWidth, atlasHeight) {\n    const canvas = await createCanvas(atlasWidth, atlasHeight)\n    const ctx = canvas.getContext('2d')\n\n    for (const frame of packedFrames) {\n        putPixels(ctx, {pixels: frame.pixels, width: frame.width, height: frame.height, x: frame.x, y: frame.y})\n    }\n\n    return canvas\n}"
      },
      {
        "name": "nextPowerOfTwo",
        "line": 194,
        "params": [
          "n"
        ],
        "source": "function nextPowerOfTwo (n) {\n    const powers = [16, 32, 64, 128, 256, 512, 1024, 2048, 4096]\n    for (const p of powers) {\n        if (p >= n) {\n            return p\n        }\n    }\n    return 4096\n}"
      },
      {
        "name": "buildJsonData",
        "line": 205,
        "params": [
          "atlases",
          "animations",
          "baseName",
          "appName = ..."
        ],
        "source": "function buildJsonData (atlases, animations, baseName, appName = 'perky-spritesheet') {\n    const allFrames = []\n    const images = []\n\n    for (let i = 0; i < atlases.length; i++) {\n        const atlas = atlases[i]\n        const imageName = atlases.length === 1\n            ? `${baseName}.png`\n            : `${baseName}_${i}.png`\n\n        images.push({\n            filename: imageName,\n            size: {\n                w: MAX_ATLAS_SIZE,\n                h: atlas.finalHeight\n            }\n        })\n\n        for (const frame of atlas.frames) {\n            allFrames.push({\n                filename: frame.filename,\n                frame: {\n                    x: frame.x,\n                    y: frame.y,\n                    w: frame.width,\n                    h: frame.height\n                },\n                sourceSize: {\n                    w: frame.width,\n                    h: frame.height\n                },\n                atlas: i\n            })\n        }\n    }\n\n    return {\n        frames: allFrames,\n        animations,\n        meta: {\n            app: appName,\n            version: '1.0',\n            images\n        }\n    }\n}"
      }
    ],
    "exports": [
      {
        "name": "MAX_ATLAS_SIZE",
        "kind": "variable",
        "line": 8,
        "source": "export const MAX_ATLAS_SIZE = 4096"
      },
      {
        "name": "PADDING",
        "kind": "variable",
        "line": 9,
        "source": "export const PADDING = 1"
      }
    ]
  },
  "/service/service_client.doc.js": {
    "type": "class",
    "file": "/service/service_client.js",
    "name": "ServiceClient",
    "line": 6,
    "extends": "PerkyModule",
    "statics": [
      {
        "name": "$category",
        "line": 8,
        "source": "static $category = 'serviceClient'",
        "kind": "property",
        "value": "'serviceClient'"
      },
      {
        "name": "$eagerStart",
        "line": 10,
        "source": "static $eagerStart = false",
        "kind": "property",
        "value": "false"
      },
      {
        "name": "fromWorker",
        "line": 107,
        "source": "static fromWorker (servicePath, config = {}) {\n    const workerUrl = new URL('./service_worker.js', import.meta.url)\n    const worker = new Worker(workerUrl, {type: 'module'})\n    const client = new ServiceClient({target: worker})\n\n    worker.postMessage({\n        type: 'init-service',\n        servicePath,\n        config\n    })\n\n    return client\n}",
        "kind": "method",
        "params": [
          "servicePath",
          "config = ..."
        ]
      },
      {
        "name": "fromService",
        "line": 122,
        "source": "static async fromService (ServiceClass, config = {}) {\n    const [transportA, transportB] = ServiceTransport.pair()\n\n    const serviceHost = new ServiceClass({...config, transport: transportA})\n    const client = new ServiceClient({transport: transportB})\n\n    client.serviceHost = serviceHost\n    return client\n}",
        "kind": "method",
        "params": [
          "ServiceClass",
          "config = ..."
        ]
      },
      {
        "name": "fromPath",
        "line": 133,
        "source": "static async fromPath (servicePath, config = {}) {\n    const module = await import(/* @vite-ignore */ servicePath)\n\n    const ServiceClass = module.default || Object.values(module).find(value => {\n        return typeof value === 'function' && value.prototype\n    })\n\n    return ServiceClient.fromService(ServiceClass, config)\n}",
        "kind": "method",
        "params": [
          "servicePath",
          "config = ..."
        ]
      },
      {
        "name": "from",
        "line": 144,
        "source": "static from (options) {\n    const {worker, service, path, config = {}} = options\n\n    const optionCount = [worker, service, path].filter(Boolean).length\n\n    if (optionCount === 0) {\n        throw new Error('ServiceClient.from() requires one of: worker, service, or path')\n    }\n\n    if (optionCount > 1) {\n        throw new Error('ServiceClient.from() requires exactly one option: worker, service, or path')\n    }\n\n    if (worker) {\n        return ServiceClient.fromWorker(worker, config)\n    }\n\n    if (service) {\n        return ServiceClient.fromService(service, config)\n    }\n\n    return ServiceClient.fromPath(path, config)\n}",
        "kind": "method",
        "params": [
          "options"
        ]
      }
    ],
    "methods": [
      {
        "name": "request",
        "line": 28,
        "source": "async request (action, params = {}, timeout = 5000) {\n    const request = new ServiceRequest(action, params)\n\n    return new Promise((resolve, reject) => {\n        this.pendingRequests.set(request.id, {resolve, reject})\n\n        const timeoutId = setTimeout(() => {\n            this.pendingRequests.delete(request.id)\n            reject(new Error(`Request timeout for action '${action}'`))\n        }, timeout)\n\n        const originalResolve = this.pendingRequests.get(request.id).resolve\n        const originalReject = this.pendingRequests.get(request.id).reject\n\n        this.pendingRequests.set(request.id, {\n            resolve: (value) => {\n                clearTimeout(timeoutId)\n                this.pendingRequests.delete(request.id)\n                originalResolve(value)\n            },\n            reject: (error) => {\n                clearTimeout(timeoutId)\n                this.pendingRequests.delete(request.id)\n                originalReject(error)\n            }\n        })\n\n        this.transport.send({\n            type: 'service-request',\n            request: request.export()\n        })\n    })\n}",
        "kind": "method",
        "params": [
          "action",
          "params = ...",
          "timeout = ..."
        ]
      },
      {
        "name": "handleMessage",
        "line": 63,
        "source": "handleMessage (message) {\n    if (message.type === 'service-event') {\n        this.handleEvent(message)\n        return\n    }\n\n    if (message.type !== 'service-response') {\n        return\n    }\n\n    const response = message.response\n    const pending = this.pendingRequests.get(response.requestId)\n\n    if (!pending) {\n        return\n    }\n\n    if (response.success) {\n        pending.resolve(response.data)\n    } else {\n        pending.reject(new Error(response.error))\n    }\n}",
        "kind": "method",
        "params": [
          "message"
        ]
      },
      {
        "name": "handleEvent",
        "line": 88,
        "source": "handleEvent (message) {\n    const {eventName, args, direction} = message\n\n    if (direction === 'host-to-client') {\n        this.emit(`host:${eventName}`, ...args)\n    }\n}",
        "kind": "method",
        "params": [
          "message"
        ]
      },
      {
        "name": "emitToHost",
        "line": 97,
        "source": "emitToHost (eventName, ...args) {\n    this.transport.send({\n        type: 'service-event',\n        eventName,\n        args,\n        direction: 'client-to-host'\n    })\n}",
        "kind": "method",
        "params": [
          "eventName",
          "...args"
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 12,
      "source": "constructor ({transport, target, ...options} = {}) {\n    super(options)\n\n    if (transport) {\n        this.transport = transport\n    } else if (target) {\n        this.transport = ServiceTransport.auto(target)\n    } else {\n        this.transport = ServiceTransport.auto()\n    }\n\n    this.pendingRequests = new Map()\n    this.transport.onMessage(this.handleMessage.bind(this))\n}",
      "kind": "constructor",
      "params": [
        "undefined = ..."
      ]
    },
    "isDefault": true
  },
  "/service/service_host.doc.js": {
    "type": "class",
    "file": "/service/service_host.js",
    "name": "ServiceHost",
    "line": 7,
    "extends": "PerkyModule",
    "statics": [
      {
        "name": "$category",
        "line": 9,
        "source": "static $category = 'serviceHost'",
        "kind": "property",
        "value": "'serviceHost'"
      },
      {
        "name": "$eagerStart",
        "line": 11,
        "source": "static $eagerStart = false",
        "kind": "property",
        "value": "false"
      }
    ],
    "methods": [
      {
        "name": "register",
        "line": 35,
        "source": "register (action, handler) {\n    this.actions.set(action, handler)\n    return this\n}",
        "kind": "method",
        "params": [
          "action",
          "handler"
        ]
      },
      {
        "name": "registerMethod",
        "line": 41,
        "source": "registerMethod (methodName) {\n    if (typeof this[methodName] !== 'function') {\n        throw new Error(`Method '${methodName}' not found on service`)\n    }\n\n    this.actions.set(methodName, this[methodName].bind(this))\n    return this\n}",
        "kind": "method",
        "params": [
          "methodName"
        ]
      },
      {
        "name": "unregister",
        "line": 51,
        "source": "unregister (action) {\n    this.actions.delete(action)\n    return this\n}",
        "kind": "method",
        "params": [
          "action"
        ]
      },
      {
        "name": "handleMessage",
        "line": 57,
        "source": "handleMessage (message) {\n    if (message.type === 'service-event') {\n        this.handleEvent(message)\n        return\n    }\n\n    if (message.type !== 'service-request') {\n        return\n    }\n\n    const request = ServiceRequest.import(message.request)\n    const response = new ServiceResponse(request.id)\n\n    if (!this.actions.has(request.action)) {\n        response.fail(`Action '${request.action}' not found`)\n        this.sendResponse(response)\n        return\n    }\n\n    try {\n        const req = {\n            id: request.id,\n            action: request.action,\n            params: request.params,\n            timestamp: request.timestamp\n        }\n\n        const res = {\n            send: (data) => {\n                response.send(data)\n                this.sendResponse(response)\n            },\n            error: (error) => {\n                response.fail(error)\n                this.sendResponse(response)\n            }\n        }\n\n        this.actions.get(request.action)(req, res)\n    } catch (error) {\n        response.fail(error.message)\n        this.sendResponse(response)\n    }\n}",
        "kind": "method",
        "params": [
          "message"
        ]
      },
      {
        "name": "handleEvent",
        "line": 103,
        "source": "handleEvent (message) {\n    const {eventName, args, direction} = message\n\n    if (direction === 'client-to-host') {\n        this.emit(`client:${eventName}`, ...args)\n    }\n}",
        "kind": "method",
        "params": [
          "message"
        ]
      },
      {
        "name": "sendResponse",
        "line": 112,
        "source": "sendResponse (response) {\n    this.transport.send({\n        type: 'service-response',\n        response: response.export()\n    })\n}",
        "kind": "method",
        "params": [
          "response"
        ]
      },
      {
        "name": "emitToClient",
        "line": 120,
        "source": "emitToClient (eventName, ...args) {\n    this.transport.send({\n        type: 'service-event',\n        eventName,\n        args,\n        direction: 'host-to-client'\n    })\n}",
        "kind": "method",
        "params": [
          "eventName",
          "...args"
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 13,
      "source": "constructor ({transport, target, ...options} = {}) {\n    super(options)\n\n    if (transport) {\n        this.transport = transport\n    } else if (target) {\n        this.transport = ServiceTransport.auto(target)\n    } else {\n        this.transport = ServiceTransport.auto()\n    }\n\n    this.actions = new Map()\n    this.transport.onMessage(this.handleMessage.bind(this))\n\n    if (this.constructor.serviceMethods && Array.isArray(this.constructor.serviceMethods)) {\n        this.constructor.serviceMethods.forEach(methodName => {\n            this.registerMethod(methodName)\n        })\n    }\n}",
      "kind": "constructor",
      "params": [
        "undefined = ..."
      ]
    },
    "isDefault": true
  },
  "/service/service_request.doc.js": {
    "type": "class",
    "file": "/service/service_request.js",
    "name": "ServiceRequest",
    "line": 1,
    "extends": null,
    "statics": [
      {
        "name": "import",
        "line": 21,
        "source": "static import (data) {\n    const req = new ServiceRequest(data.action, data.params)\n    req.id = data.id\n    req.timestamp = data.timestamp\n    return req\n}",
        "kind": "method",
        "params": [
          "data"
        ]
      }
    ],
    "methods": [
      {
        "name": "export",
        "line": 11,
        "source": "export () {\n    return {\n        id: this.id,\n        action: this.action,\n        params: this.params,\n        timestamp: this.timestamp\n    }\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 3,
      "source": "constructor (action, params = {}) {\n    this.id = crypto.randomUUID()\n    this.action = action\n    this.params = params\n    this.timestamp = Date.now()\n}",
      "kind": "constructor",
      "params": [
        "action",
        "params = ..."
      ]
    },
    "isDefault": true
  },
  "/service/service_response.doc.js": {
    "type": "class",
    "file": "/service/service_response.js",
    "name": "ServiceResponse",
    "line": 1,
    "extends": null,
    "statics": [],
    "methods": [
      {
        "name": "send",
        "line": 11,
        "source": "send (data) {\n    this.success = true\n    this.data = data\n    return this\n}",
        "kind": "method",
        "params": [
          "data"
        ]
      },
      {
        "name": "fail",
        "line": 18,
        "source": "fail (error) {\n    this.success = false\n    this.error = error\n    return this\n}",
        "kind": "method",
        "params": [
          "error"
        ]
      },
      {
        "name": "export",
        "line": 25,
        "source": "export () {\n    return {\n        requestId: this.requestId,\n        success: this.success,\n        data: this.data,\n        error: this.error\n    }\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 3,
      "source": "constructor (requestId) {\n    this.requestId = requestId\n    this.success = true\n    this.data = null\n    this.error = null\n}",
      "kind": "constructor",
      "params": [
        "requestId"
      ]
    },
    "isDefault": true
  },
  "/service/service_transport.doc.js": {
    "type": "class",
    "file": "/service/service_transport.js",
    "name": "ServiceTransport",
    "line": 1,
    "extends": null,
    "statics": [
      {
        "name": "create",
        "line": 33,
        "source": "static create (config) {\n    return new ServiceTransport(config)\n}",
        "kind": "method",
        "params": [
          "config"
        ]
      },
      {
        "name": "auto",
        "line": 38,
        "source": "static auto (target) {\n    if (target && typeof target.postMessage === 'function' && typeof target.onmessage !== 'undefined') {\n        return new ServiceTransport({\n            send: (message) => target.postMessage(message),\n            receive: (handler) => {\n                target.onmessage = (e) => handler(e.data)\n            }\n        })\n    }\n\n    if (typeof self !== 'undefined' && typeof self.postMessage === 'function') {\n        return new ServiceTransport({\n            send: (message) => self.postMessage(message),\n            receive: (handler) => {\n                self.onmessage = (e) => handler(e.data)\n            }\n        })\n    }\n\n    return ServiceTransport.local()\n}",
        "kind": "method",
        "params": [
          "target"
        ]
      },
      {
        "name": "worker",
        "line": 61,
        "source": "static worker (worker) {\n    return new ServiceTransport({\n        send: (message) => worker.postMessage(message),\n        receive: (handler) => {\n            worker.onmessage = (e) => handler(e.data)\n        }\n    })\n}",
        "kind": "method",
        "params": [
          "worker"
        ]
      },
      {
        "name": "main",
        "line": 71,
        "source": "static main () {\n    return new ServiceTransport({\n        send: (message) => self.postMessage(message),\n        receive: (handler) => {\n            self.onmessage = (e) => handler(e.data)\n        }\n    })\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "local",
        "line": 81,
        "source": "static local () {\n    const handlers = []\n    return new ServiceTransport({\n        send: (message) => handlers.forEach(h => h(message)),\n        receive: (handler) => handlers.push(handler)\n    })\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "channel",
        "line": 90,
        "source": "static channel (port) {\n    return new ServiceTransport({\n        send: (message) => port.postMessage(message),\n        receive: (handler) => {\n            port.onmessage = (e) => handler(e.data)\n        }\n    })\n}",
        "kind": "method",
        "params": [
          "port"
        ]
      },
      {
        "name": "pair",
        "line": 100,
        "source": "static pair () {\n    const handlersA = []\n    const handlersB = []\n\n    const transportA = new ServiceTransport({\n        send: (message) => handlersB.forEach(h => h(message)),\n        receive: (handler) => handlersA.push(handler)\n    })\n\n    const transportB = new ServiceTransport({\n        send: (message) => handlersA.forEach(h => h(message)),\n        receive: (handler) => handlersB.push(handler)\n    })\n\n    return [transportA, transportB]\n}",
        "kind": "method",
        "params": []
      }
    ],
    "methods": [
      {
        "name": "send",
        "line": 13,
        "source": "send (message) {\n    this.sendFn(message)\n}",
        "kind": "method",
        "params": [
          "message"
        ]
      },
      {
        "name": "onMessage",
        "line": 18,
        "source": "onMessage (handler) {\n    this.messageHandlers.add(handler)\n}",
        "kind": "method",
        "params": [
          "handler"
        ]
      },
      {
        "name": "offMessage",
        "line": 23,
        "source": "offMessage (handler) {\n    this.messageHandlers.delete(handler)\n}",
        "kind": "method",
        "params": [
          "handler"
        ]
      },
      {
        "name": "handleMessage",
        "line": 28,
        "source": "handleMessage (message) {\n    this.messageHandlers.forEach(handler => handler(message))\n}",
        "kind": "method",
        "params": [
          "message"
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 3,
      "source": "constructor (config) {\n    this.sendFn = config.send\n    this.messageHandlers = new Set()\n\n    if (config.receive) {\n        config.receive(this.handleMessage.bind(this))\n    }\n}",
      "kind": "constructor",
      "params": [
        "config"
      ]
    },
    "isDefault": true
  },
  "/studio/hub_view.doc.js": {
    "type": "class",
    "file": "/studio/hub_view.js",
    "name": "HubView",
    "line": 238,
    "extends": "EditorComponent",
    "statics": [],
    "methods": [
      {
        "name": "onConnected",
        "line": 258,
        "source": "onConnected () {\n    adoptStyleSheets(this.shadowRoot, hubViewStyles)\n    this.#buildDOM()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "setContext",
        "line": 264,
        "source": "setContext ({manifest, animators, textureSystem}) {\n    this.#manifest = manifest\n    this.#animators = animators || {}\n    this.#textureSystem = textureSystem\n\n    if (this.isConnected) {\n        this.#render()\n    }\n}",
        "kind": "method",
        "params": [
          "{...}"
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": null,
    "isDefault": true
  },
  "/studio/launcher.doc.js": {
    "type": "module",
    "file": "/studio/launcher.js",
    "functions": [
      {
        "name": "rewriteUrls",
        "line": 8,
        "params": [
          "data",
          "basePath"
        ],
        "source": "function rewriteUrls (data, basePath) {\n    if (!basePath) {\n        return data\n    }\n    const rewritten = {...data, assets: {}}\n    for (const [id, asset] of Object.entries(data.assets)) {\n        rewritten.assets[id] = {\n            ...asset,\n            url: asset.url.replace('./', basePath)\n        }\n    }\n    return rewritten\n}"
      },
      {
        "name": "loadManifest",
        "line": 23,
        "params": [
          "manifestData",
          "basePath"
        ],
        "source": "async function loadManifest (manifestData, basePath) {\n    const data = rewriteUrls(manifestData, basePath)\n    const manifest = new Manifest({data})\n\n    const sourceManager = new SourceManager({\n        loaders: new Registry(loaders),\n        manifest\n    })\n\n    await sourceManager.loadAll()\n    return manifest\n}"
      },
      {
        "name": "buildTextureSystem",
        "line": 37,
        "params": [
          "manifest"
        ],
        "source": "function buildTextureSystem (manifest) {\n    const textureSystem = new TextureSystem()\n\n    const imageAssets = manifest.getAssetsByType('image')\n    textureSystem.buildFromAssets(imageAssets)\n\n    const spritesheetAssets = manifest.getAssetsByType('spritesheet')\n    for (const asset of spritesheetAssets) {\n        if (asset.source) {\n            textureSystem.registerSpritesheet(asset.id, asset.source)\n        }\n    }\n\n    return textureSystem\n}"
      },
      {
        "name": "collectAnimators",
        "line": 54,
        "params": [
          "manifest"
        ],
        "source": "function collectAnimators (manifest) {\n    const animatorAssets = manifest.getAssetsByType('animator')\n    const animators = {}\n    for (const asset of animatorAssets) {\n        if (asset.source) {\n            animators[asset.id] = asset.source\n        }\n    }\n    return animators\n}"
      },
      {
        "name": "getStudioConfig",
        "line": 66,
        "params": [
          "manifest",
          "tool"
        ],
        "source": "function getStudioConfig (manifest, tool) {\n    return manifest.getConfig(`studio.${tool}`) || {}\n}"
      },
      {
        "name": "getBackgroundImage",
        "line": 71,
        "params": [
          "manifest",
          "studioConfig"
        ],
        "source": "function getBackgroundImage (manifest, studioConfig) {\n    const backgroundId = studioConfig.background\n    const backgroundAsset = backgroundId ? manifest.getAsset(backgroundId) : null\n    return backgroundAsset?.source || null\n}"
      }
    ],
    "exports": []
  },
  "/studio/animator/animator_helpers.doc.js": {
    "type": "module",
    "file": "/studio/animator/animator_helpers.js",
    "functions": [
      {
        "name": "inferSpritesheetName",
        "line": 1,
        "params": [
          "animatorConfig"
        ],
        "source": "function inferSpritesheetName (animatorConfig) {\n    const animations = animatorConfig?.animations\n    if (!animations) {\n        return null\n    }\n\n    const firstAnim = Object.values(animations)[0]\n    if (firstAnim?.source) {\n        return firstAnim.source.split(':')[0]\n    }\n    if (firstAnim?.frames?.[0]?.source) {\n        return firstAnim.frames[0].source.split(':')[0]\n    }\n    return null\n}"
      },
      {
        "name": "collectEventSuggestions",
        "line": 18,
        "params": [
          "animator",
          "excludeEvents"
        ],
        "source": "function collectEventSuggestions (animator, excludeEvents) {\n    const allEvents = new Set()\n\n    for (const anim of animator.children) {\n        for (const frame of anim.frames) {\n            const events = frame.events || []\n            events.forEach(event => allEvents.add(event))\n        }\n    }\n\n    excludeEvents.forEach(event => allEvents.delete(event))\n\n    return Array.from(allEvents).slice(0, 6)\n}"
      },
      {
        "name": "buildAnimationConfig",
        "line": 34,
        "params": [
          "anim",
          "spritesheetName"
        ],
        "source": "function buildAnimationConfig (anim, spritesheetName) {\n    const config = {\n        fps: anim.fps,\n        loop: anim.loop\n    }\n\n    if (anim.playbackMode !== 'forward') {\n        config.playbackMode = anim.playbackMode\n    }\n\n    if (anim.motion?.enabled) {\n        config.motion = {\n            mode: anim.motion.mode || 'sidescroller',\n            direction: anim.motion.direction || 'e'\n        }\n    }\n\n    config.frames = anim.frames.map(frame => {\n        const fc = {}\n        if (frame.source) {\n            fc.source = frame.source\n        } else if (frame.name) {\n            fc.source = `${spritesheetName || 'spritesheet'}:${frame.name}`\n        }\n        if (frame.duration && frame.duration !== 1) {\n            fc.duration = frame.duration\n        }\n        if (frame.events?.length) {\n            fc.events = [...frame.events]\n        }\n        return fc\n    })\n\n    return config\n}"
      },
      {
        "name": "buildFramePreview",
        "line": 71,
        "params": [
          "frame"
        ],
        "source": "function buildFramePreview (frame) {\n    const section = document.createElement('div')\n    section.className = 'frame-editor-preview'\n\n    const canvas = document.createElement('canvas')\n    canvas.width = 120\n    canvas.height = 120\n    canvas.className = 'frame-editor-canvas'\n\n    const region = frame.region\n    if (region?.image) {\n        const ctx = canvas.getContext('2d')\n        const scale = Math.min(120 / region.width, 120 / region.height)\n        const w = region.width * scale\n        const h = region.height * scale\n        const x = (120 - w) / 2\n        const y = (120 - h) / 2\n        ctx.drawImage(region.image, region.x, region.y, region.width, region.height, x, y, w, h)\n    }\n\n    const name = document.createElement('div')\n    name.className = 'frame-editor-name'\n    name.textContent = frame.name || 'Unnamed frame'\n    name.title = frame.name || ''\n\n    section.appendChild(canvas)\n    section.appendChild(name)\n    return section\n}"
      }
    ],
    "exports": []
  },
  "/studio/animator/launcher.doc.js": {
    "type": "module",
    "file": "/studio/animator/launcher.js",
    "functions": [
      {
        "name": "launchAnimatorStudio",
        "line": 15,
        "params": [
          "manifestData",
          "container",
          "options = ..."
        ],
        "source": "async function launchAnimatorStudio (manifestData, container, options = {}) {\n    try {\n        const manifest = await loadManifest(manifestData, options.basePath)\n        const studioConfig = getStudioConfig(manifest, 'animator')\n        const backgroundImage = getBackgroundImage(manifest, studioConfig)\n\n        const animatorData = await resolveAnimatorData(manifest, options)\n\n        if (!animatorData.animatorConfig) {\n            container.innerHTML = '<div class=\"loading\" style=\"color: #f66;\">No animator found</div>'\n            return\n        }\n\n        container.innerHTML = ''\n        const animatorView = document.createElement('animator-view')\n        animatorView.setContext({\n            ...animatorData,\n            backgroundImage,\n            studioConfig\n        })\n        container.appendChild(animatorView)\n\n    } catch (error) {\n        container.innerHTML = `<div class=\"loading\" style=\"color: #f66;\">Error: ${error.message}</div>`\n        logger.error(error)\n    }\n}"
      },
      {
        "name": "resolveAnimatorData",
        "line": 44,
        "params": [
          "manifest",
          "options"
        ],
        "source": "async function resolveAnimatorData (manifest, options) {\n    if (options.isCustom && options.animatorId) {\n        const customData = await loadCustomAnimator(options.animatorId)\n        if (customData) {\n            return {\n                textureSystem: customData.textureSystem,\n                animatorConfig: customData.animatorConfig,\n                animatorName: options.animatorId,\n                isCustom: true\n            }\n        }\n    }\n\n    return loadGameAnimator(manifest, options.animatorId)\n}"
      },
      {
        "name": "loadGameAnimator",
        "line": 61,
        "params": [
          "manifest",
          "animatorId"
        ],
        "source": "function loadGameAnimator (manifest, animatorId) {\n    const textureSystem = buildTextureSystem(manifest)\n    const animators = collectAnimators(manifest)\n\n    const result = {textureSystem, animatorConfig: null, animatorName: null, isCustom: false, manifest}\n\n    if (animatorId && animators[animatorId]) {\n        result.animatorConfig = animators[animatorId]\n        result.animatorName = animatorId\n        return result\n    }\n\n    const firstKey = Object.keys(animators)[0]\n    if (firstKey) {\n        result.animatorConfig = animators[firstKey]\n        result.animatorName = firstKey\n    }\n\n    return result\n}"
      },
      {
        "name": "loadCustomAnimator",
        "line": 83,
        "params": [
          "animatorId"
        ],
        "source": "async function loadCustomAnimator (animatorId) {\n    const store = new PerkyStore()\n    const resource = await store.get(animatorId)\n\n    if (!resource) {\n        return null\n    }\n\n    const configFile = resource.files.find(f => f.name.endsWith('Animator.json'))\n    const spritesheetJsonFile = resource.files.find(f => f.name.endsWith('Spritesheet.json'))\n    const pngFiles = resource.files.filter(f => f.name.endsWith('.png')).sort((a, b) => a.name.localeCompare(b.name))\n\n    if (!configFile || !spritesheetJsonFile || pngFiles.length === 0) {\n        return null\n    }\n\n    const configText = await blobToText(configFile.blob)\n    const animatorConfig = JSON.parse(configText)\n\n    const spritesheetText = await blobToText(spritesheetJsonFile.blob)\n    const spritesheetData = JSON.parse(spritesheetText)\n    const images = await Promise.all(pngFiles.map(f => blobToImage(f.blob)))\n\n    const textureSystem = new TextureSystem()\n    const spritesheetName = spritesheetJsonFile.name.replace('.json', '')\n\n    textureSystem.registerSpritesheet(spritesheetName, {\n        images,\n        data: spritesheetData\n    })\n\n    return {textureSystem, animatorConfig}\n}"
      },
      {
        "name": "blobToText",
        "line": 118,
        "params": [
          "blob"
        ],
        "source": "function blobToText (blob) {\n    if (typeof blob.text === 'function') {\n        return blob.text()\n    }\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader()\n        reader.onload = () => resolve(reader.result)\n        reader.onerror = reject\n        reader.readAsText(blob)\n    })\n}"
      },
      {
        "name": "blobToImage",
        "line": 131,
        "params": [
          "blob"
        ],
        "source": "function blobToImage (blob) {\n    return new Promise((resolve, reject) => {\n        const url = URL.createObjectURL(blob)\n        const img = new Image()\n        img.onload = () => {\n            URL.revokeObjectURL(url)\n            resolve(img)\n        }\n        img.onerror = () => {\n            URL.revokeObjectURL(url)\n            reject(new Error('Failed to load image'))\n        }\n        img.src = url\n    })\n}"
      }
    ],
    "exports": []
  },
  "/studio/animator/animator_preview.doc.js": {
    "type": "class",
    "file": "/studio/animator/animator_preview.js",
    "name": "AnimatorPreview",
    "line": 7,
    "extends": null,
    "statics": [],
    "methods": [
      {
        "name": "setUnitsInView",
        "line": 62,
        "source": "setUnitsInView (unitsInView) {\n    this.#unitsInView = unitsInView\n    this.#camera.setUnitsInView(unitsInView)\n    this.#updateBackground()\n}",
        "kind": "method",
        "params": [
          "unitsInView"
        ]
      },
      {
        "name": "setSize",
        "line": 69,
        "source": "setSize (size) {\n    this.#size = size || {width: 1, height: 1}\n    this.#updateAnimatorSprite()\n}",
        "kind": "method",
        "params": [
          "size"
        ]
      },
      {
        "name": "setMotion",
        "line": 75,
        "source": "setMotion (motion) {\n    this.#motion = motion\n}",
        "kind": "method",
        "params": [
          "motion"
        ]
      },
      {
        "name": "setBackgroundRegion",
        "line": 80,
        "source": "setBackgroundRegion (region) {\n    if (!region) {\n        this.#backgroundSprite.visible = false\n        return\n    }\n\n    this.#backgroundSprite.region = region\n    this.#updateBackground()\n    this.#backgroundSprite.visible = true\n}",
        "kind": "method",
        "params": [
          "region"
        ]
      },
      {
        "name": "setAnimation",
        "line": 106,
        "source": "setAnimation (animation) {\n    this.#animation = animation\n    this.#spriteX = 0\n    this.#updateAnimatorSprite()\n}",
        "kind": "method",
        "params": [
          "animation"
        ]
      },
      {
        "name": "setAnchor",
        "line": 113,
        "source": "setAnchor (anchor) {\n    this.#anchor = anchor || {x: 0.5, y: 0}\n    this.#updateAnimatorSprite()\n}",
        "kind": "method",
        "params": [
          "anchor"
        ]
      },
      {
        "name": "resize",
        "line": 147,
        "source": "resize (width, height) {\n    this.#canvas.width = width\n    this.#canvas.height = height\n\n    this.#renderer.displayWidth = width\n    this.#renderer.displayHeight = height\n    this.#renderer.applyPixelRatio()\n\n    this.#camera.viewportWidth = width\n    this.#camera.viewportHeight = height\n\n    this.#updateAnimatorSprite()\n}",
        "kind": "method",
        "params": [
          "width",
          "height"
        ]
      },
      {
        "name": "play",
        "line": 162,
        "source": "play () {\n    if (this.#isPlaying || !this.#animation) {\n        return\n    }\n\n    this.#isPlaying = true\n    this.#animation.play()\n    this.#lastTime = performance.now()\n    this.#animationFrameId = requestAnimationFrame((t) => this.#loop(t))\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "pause",
        "line": 174,
        "source": "pause () {\n    this.#isPlaying = false\n    this.#animation?.pause()\n\n    if (this.#animationFrameId) {\n        cancelAnimationFrame(this.#animationFrameId)\n        this.#animationFrameId = null\n    }\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "stop",
        "line": 185,
        "source": "stop () {\n    this.pause()\n    this.#animation?.stop()\n    this.#spriteX = 0\n    this.#updateAnimatorSprite()\n    this.render()\n    this.#onComplete?.()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "render",
        "line": 256,
        "source": "render () {\n    this.#renderer.render(this.#scene)\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "seekToFrame",
        "line": 261,
        "source": "seekToFrame (index) {\n    if (!this.#animation) {\n        return\n    }\n    this.#animation.seekToFrame(index)\n    this.#updateAnimatorSprite()\n    this.render()\n}",
        "kind": "method",
        "params": [
          "index"
        ]
      },
      {
        "name": "dispose",
        "line": 291,
        "source": "dispose () {\n    this.stop()\n    this.#renderer = null\n    this.#scene = null\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [
      {
        "name": "isPlaying",
        "line": 271,
        "source": "get isPlaying () {\n    return this.#isPlaying\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "animation",
        "line": 276,
        "source": "get animation () {\n    return this.#animation\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "sprite",
        "line": 281,
        "source": "get sprite () {\n    return this.#animatorSprite\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "currentIndex",
        "line": 286,
        "source": "get currentIndex () {\n    return this.#animation?.currentIndex ?? 0\n}",
        "kind": "method",
        "params": []
      }
    ],
    "setters": [],
    "constructor": {
      "name": "constructor",
      "line": 27,
      "source": "constructor ({canvas, unitsInView, onFrame, onComplete} = {}) {\n    this.#canvas = canvas\n    if (unitsInView) {\n        this.#unitsInView = unitsInView\n    }\n    this.#onFrame = onFrame\n    this.#onComplete = onComplete\n\n    this.#setup()\n}",
      "kind": "constructor",
      "params": [
        "undefined = ..."
      ]
    },
    "isDefault": true
  },
  "/studio/animator/animator_view.doc.js": {
    "type": "class",
    "file": "/studio/animator/animator_view.js",
    "name": "AnimatorView",
    "line": 28,
    "extends": "EditorComponent",
    "statics": [],
    "methods": [
      {
        "name": "onConnected",
        "line": 59,
        "source": "onConnected () {\n    this.#buildDOM()\n\n    if (this.#context && this.#animatorConfig) {\n        this.#initAnimator()\n    }\n\n    this.#boundBeforeUnload = () => this.#flushSave()\n    window.addEventListener('beforeunload', this.#boundBeforeUnload)\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "onDisconnected",
        "line": 71,
        "source": "onDisconnected () {\n    clearTimeout(this.#autoSaveTimer)\n    this.#flushSave()\n    window.removeEventListener('beforeunload', this.#boundBeforeUnload)\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "setContext",
        "line": 78,
        "source": "setContext ({textureSystem, animatorConfig, animatorName, backgroundImage, studioConfig, isCustom, manifest}) {\n    this.#context = {textureSystem, studioConfig, manifest}\n    this.#animatorConfig = animatorConfig\n    this.#animatorName = animatorName || 'animator'\n    this.#backgroundImage = backgroundImage || null\n    this.#isCustom = isCustom || false\n\n    if (this.isConnected && this.#animatorConfig) {\n        this.#initAnimator()\n    }\n}",
        "kind": "method",
        "params": [
          "{...}"
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": null,
    "isDefault": true
  },
  "/studio/animator/components/anchor_editor.doc.js": {
    "type": "module",
    "file": "/studio/animator/components/anchor_editor.js",
    "functions": [
      {
        "name": "buildAnchorEditor",
        "line": 4,
        "params": [
          "spritesheet",
          "anchor",
          "onChange"
        ],
        "source": "function buildAnchorEditor (spritesheet, anchor, onChange) {\n    const container = document.createElement('div')\n    container.className = 'spritesheet-settings'\n\n    const anchorSection = document.createElement('div')\n    anchorSection.className = 'settings-section'\n\n    const anchorLabel = document.createElement('div')\n    anchorLabel.className = 'settings-label'\n    anchorLabel.textContent = 'Anchor'\n    anchorSection.appendChild(anchorLabel)\n\n    const {wrapper, canvas, handle} = buildAnchorPreview(spritesheet, anchor, onChange)\n    anchorSection.appendChild(wrapper)\n\n    const {row, xInput, yInput} = buildAnchorInputs(anchor, (axis, value) => {\n        anchor[axis] = value\n        renderAnchorPreview(canvas, handle, anchor, getFirstFrameData(spritesheet))\n        onChange?.(anchor)\n    })\n    anchorSection.appendChild(row)\n\n    container.appendChild(anchorSection)\n\n    return {\n        container,\n        syncInputs: () => {\n            xInput.setValue(anchor.x)\n            yInput.setValue(anchor.y)\n        },\n        updatePreview: () => {\n            renderAnchorPreview(canvas, handle, anchor, getFirstFrameData(spritesheet))\n        }\n    }\n}"
      },
      {
        "name": "buildAnchorPreview",
        "line": 41,
        "params": [
          "spritesheet",
          "anchor",
          "onChange"
        ],
        "source": "function buildAnchorPreview (spritesheet, anchor, onChange) {\n    const wrapper = document.createElement('div')\n    wrapper.className = 'anchor-preview-wrapper'\n\n    const canvas = document.createElement('canvas')\n    canvas.className = 'anchor-preview-canvas'\n    wrapper.appendChild(canvas)\n\n    const handle = document.createElement('div')\n    handle.className = 'anchor-handle'\n    wrapper.appendChild(handle)\n\n    requestAnimationFrame(() => {\n        const rect = wrapper.getBoundingClientRect()\n        const size = Math.floor(rect.width)\n        canvas.width = size\n        canvas.height = size\n        renderAnchorPreview(canvas, handle, anchor, getFirstFrameData(spritesheet))\n    })\n\n    setupAnchorDrag({canvas, handle, anchor, onChange})\n\n    return {wrapper, canvas, handle}\n}"
      },
      {
        "name": "renderAnchorPreview",
        "line": 67,
        "params": [
          "canvas",
          "handle",
          "anchor",
          "frameData"
        ],
        "source": "function renderAnchorPreview (canvas, handle, anchor, frameData) {\n    const ctx = canvas.getContext('2d')\n\n    ctx.clearRect(0, 0, canvas.width, canvas.height)\n\n    if (!frameData) {\n        return\n    }\n\n    const {image, region} = frameData\n    const scale = Math.min(\n        (canvas.width - 20) / region.width,\n        (canvas.height - 20) / region.height\n    )\n    const drawWidth = region.width * scale\n    const drawHeight = region.height * scale\n    const offsetX = (canvas.width - drawWidth) / 2\n    const offsetY = (canvas.height - drawHeight) / 2\n\n    ctx.imageSmoothingEnabled = false\n    ctx.drawImage(\n        image,\n        region.x, region.y, region.width, region.height,\n        offsetX, offsetY, drawWidth, drawHeight\n    )\n\n    const anchorX = offsetX + anchor.x * drawWidth\n    const anchorY = offsetY + (1 - anchor.y) * drawHeight\n\n    handle.style.left = `${anchorX}px`\n    handle.style.top = `${anchorY}px`\n\n    handle.dataset.offsetX = offsetX\n    handle.dataset.offsetY = offsetY\n    handle.dataset.drawWidth = drawWidth\n    handle.dataset.drawHeight = drawHeight\n}"
      },
      {
        "name": "getFirstFrameData",
        "line": 106,
        "params": [
          "spritesheet"
        ],
        "source": "function getFirstFrameData (spritesheet) {\n    if (!spritesheet) {\n        return null\n    }\n\n    const frames = spritesheet.getFrames()\n    if (!frames.length) {\n        return null\n    }\n\n    const firstFrame = frames[0]\n    return {\n        image: firstFrame.image,\n        region: firstFrame.region\n    }\n}"
      },
      {
        "name": "setupAnchorDrag",
        "line": 124,
        "params": [
          "{...}"
        ],
        "source": "function setupAnchorDrag ({canvas, handle, anchor, onChange}) {\n    let isDragging = false\n\n    const updateAnchor = (e) => {\n        const rect = canvas.getBoundingClientRect()\n        const offsetX = parseFloat(handle.dataset.offsetX) || 0\n        const offsetY = parseFloat(handle.dataset.offsetY) || 0\n        const drawWidth = parseFloat(handle.dataset.drawWidth) || 1\n        const drawHeight = parseFloat(handle.dataset.drawHeight) || 1\n\n        const x = e.clientX - rect.left\n        const y = e.clientY - rect.top\n\n        const anchorX = Math.max(0, Math.min(1, (x - offsetX) / drawWidth))\n        const anchorY = Math.max(0, Math.min(1, 1 - (y - offsetY) / drawHeight))\n\n        anchor.x = Math.round(anchorX * 100) / 100\n        anchor.y = Math.round(anchorY * 100) / 100\n\n        onChange?.(anchor)\n    }\n\n    handle.addEventListener('pointerdown', (e) => {\n        isDragging = true\n        handle.setPointerCapture(e.pointerId)\n    })\n\n    handle.addEventListener('pointermove', (e) => {\n        if (isDragging) {\n            updateAnchor(e)\n        }\n    })\n\n    handle.addEventListener('pointerup', () => {\n        isDragging = false\n    })\n\n    canvas.addEventListener('click', updateAnchor)\n}"
      },
      {
        "name": "buildAnchorInputs",
        "line": 165,
        "params": [
          "anchor",
          "onChange"
        ],
        "source": "function buildAnchorInputs (anchor, onChange) {\n    const row = document.createElement('div')\n    row.className = 'settings-row anchor-inputs'\n\n    const xInput = document.createElement('number-input')\n    xInput.setAttribute('context', 'studio')\n    xInput.setLabel('X')\n    xInput.setValue(anchor.x)\n    xInput.setStep(0.01)\n    xInput.setPrecision(2)\n    xInput.setMin(0)\n    xInput.setMax(1)\n    xInput.addEventListener('change', (e) => {\n        onChange?.('x', e.detail.value)\n    })\n\n    const yInput = document.createElement('number-input')\n    yInput.setAttribute('context', 'studio')\n    yInput.setLabel('Y')\n    yInput.setValue(anchor.y)\n    yInput.setStep(0.01)\n    yInput.setPrecision(2)\n    yInput.setMin(0)\n    yInput.setMax(1)\n    yInput.addEventListener('change', (e) => {\n        onChange?.('y', e.detail.value)\n    })\n\n    row.appendChild(xInput)\n    row.appendChild(yInput)\n\n    return {row, xInput, yInput}\n}"
      }
    ],
    "exports": []
  },
  "/studio/animator/components/animation_settings.doc.js": {
    "type": "module",
    "file": "/studio/animator/components/animation_settings.js",
    "functions": [
      {
        "name": "buildAnimationSettings",
        "line": 7,
        "params": [
          "animator",
          "selectedAnimation",
          "callbacks"
        ],
        "source": "function buildAnimationSettings (animator, selectedAnimation, callbacks) {\n    const container = document.createElement('div')\n    container.className = 'animation-settings'\n\n    const nameSection = document.createElement('div')\n    nameSection.className = 'settings-section'\n\n    const nameLabel = document.createElement('div')\n    nameLabel.className = 'settings-label'\n    nameLabel.textContent = 'Name'\n    nameSection.appendChild(nameLabel)\n\n    const nameInput = document.createElement('input')\n    nameInput.className = 'event-input'\n    nameInput.type = 'text'\n    nameInput.spellcheck = false\n    nameInput.value = selectedAnimation?.$id || ''\n\n    const commitRename = () => {\n        const result = resolveAnimationName(nameInput.value, animator, selectedAnimation)\n        nameInput.value = result.displayName\n        if (result.renamed) {\n            callbacks.onRename?.(result.displayName)\n        }\n    }\n\n    nameInput.addEventListener('blur', commitRename)\n    nameInput.addEventListener('keydown', (e) => {\n        if (e.key === 'Enter') {\n            e.preventDefault()\n            nameInput.blur()\n        }\n    })\n\n    nameSection.appendChild(nameInput)\n    container.appendChild(nameSection)\n\n    buildAnimationSettingsContent(container, selectedAnimation, callbacks)\n    buildDeleteSection(container, callbacks)\n\n    return {\n        container,\n        nameInput,\n        rebuild: (animation) => {\n            nameInput.value = animation?.$id || ''\n            const sections = container.querySelectorAll('[data-setting]')\n            sections.forEach(s => s.remove())\n            buildAnimationSettingsContent(container, animation, callbacks)\n            buildDeleteSection(container, callbacks)\n        }\n    }\n}"
      },
      {
        "name": "buildAnimationSettingsContent",
        "line": 61,
        "params": [
          "container",
          "animation",
          "callbacks"
        ],
        "source": "function buildAnimationSettingsContent (container, animation, callbacks) {\n    if (!animation) {\n        return\n    }\n\n    const motion = animation.motion || {}\n    const hasMotion = motion.enabled || motion.mode\n    const currentMode = hasMotion ? (motion.mode || 'sidescroller') : 'none'\n\n    const motionSection = document.createElement('div')\n    motionSection.className = 'settings-section'\n    motionSection.dataset.setting = 'motion'\n\n    const motionLabel = document.createElement('div')\n    motionLabel.className = 'settings-label'\n    motionLabel.textContent = 'Motion'\n    motionSection.appendChild(motionLabel)\n\n    const motionOptions = document.createElement('div')\n    motionOptions.className = 'motion-options'\n    motionOptions.style.display = currentMode === 'none' ? 'none' : 'flex'\n    motionOptions.style.flexDirection = 'column'\n    motionOptions.style.gap = 'var(--spacing-md)'\n    motionOptions.style.marginTop = 'var(--spacing-md)'\n\n    const modeSelect = document.createElement('select-input')\n    modeSelect.setAttribute('context', 'studio')\n    modeSelect.setOptions([\n        {value: 'none', label: 'None'},\n        {value: 'sidescroller', label: 'Sidescroller'},\n        {value: 'topdown', label: 'Top-down'}\n    ])\n    modeSelect.setValue(currentMode)\n    modeSelect.addEventListener('change', (e) => {\n        if (!animation.motion) {\n            animation.motion = {}\n        }\n        const isEnabled = e.detail.value !== 'none'\n        animation.motion.enabled = isEnabled\n        animation.motion.mode = isEnabled ? e.detail.value : animation.motion.mode\n        motionOptions.style.display = isEnabled ? 'flex' : 'none'\n        rebuildDirectionPad(directionPad, animation, callbacks)\n        callbacks.onMotionChange?.(animation.motion)\n    })\n    motionSection.appendChild(modeSelect)\n\n    const dirSubSection = document.createElement('div')\n    dirSubSection.className = 'settings-section'\n\n    const dirLabel = document.createElement('div')\n    dirLabel.className = 'settings-label'\n    dirLabel.textContent = 'Direction'\n    dirSubSection.appendChild(dirLabel)\n\n    const directionPad = document.createElement('div')\n    directionPad.className = 'direction-pad'\n    rebuildDirectionPad(directionPad, animation, callbacks)\n    dirSubSection.appendChild(directionPad)\n    motionOptions.appendChild(dirSubSection)\n\n    const speedSubSection = document.createElement('div')\n    speedSubSection.className = 'settings-section'\n\n    const speedLabel = document.createElement('div')\n    speedLabel.className = 'settings-label'\n    speedLabel.textContent = 'Speed'\n    speedSubSection.appendChild(speedLabel)\n\n    const speedInput = document.createElement('slider-input')\n    speedInput.setAttribute('context', 'studio')\n    speedInput.setAttribute('min', '0.01')\n    speedInput.setAttribute('max', '3')\n    speedInput.setAttribute('step', '0.01')\n    speedInput.setValue(motion.speed ?? 1)\n    speedInput.addEventListener('change', (e) => {\n        if (!animation.motion) {\n            animation.motion = {}\n        }\n        animation.motion.speed = e.detail.value\n        callbacks.onMotionUpdate?.(animation.motion)\n    })\n    speedSubSection.appendChild(speedInput)\n    motionOptions.appendChild(speedSubSection)\n\n    motionSection.appendChild(motionOptions)\n    container.appendChild(motionSection)\n}"
      },
      {
        "name": "rebuildDirectionPad",
        "line": 150,
        "params": [
          "pad",
          "animation",
          "callbacks"
        ],
        "source": "function rebuildDirectionPad (pad, animation, callbacks) {\n    pad.innerHTML = ''\n    const motion = animation.motion || {}\n    const mode = motion.mode || 'sidescroller'\n    const direction = motion.direction || 'e'\n\n    const arrows = {\n        nw: '\\u2196',\n        n: '\\u2191',\n        ne: '\\u2197',\n        w: '\\u2190',\n        center: '',\n        e: '\\u2192',\n        sw: '\\u2199',\n        s: '\\u2193',\n        se: '\\u2198'\n    }\n\n    const sideDirections = ['n', 'e', 's', 'w']\n    const topDownDirections = ['nw', 'n', 'ne', 'w', 'e', 'sw', 's', 'se']\n    const activeDirections = mode === 'topdown' ? topDownDirections : sideDirections\n\n    const layout = ['nw', 'n', 'ne', 'w', 'center', 'e', 'sw', 's', 'se']\n\n    for (const pos of layout) {\n        const btn = document.createElement('button')\n        btn.className = 'direction-btn'\n        if (pos === 'center') {\n            btn.classList.add('center')\n        } else if (activeDirections.includes(pos)) {\n            btn.textContent = arrows[pos]\n            if (direction === pos) {\n                btn.classList.add('active')\n            }\n            btn.addEventListener('click', () => {\n                if (!animation.motion) {\n                    animation.motion = {}\n                }\n                animation.motion.direction = pos\n                rebuildDirectionPad(pad, animation, callbacks)\n                callbacks.onMotionChange?.(animation.motion)\n            })\n        } else {\n            btn.style.visibility = 'hidden'\n        }\n        pad.appendChild(btn)\n    }\n}"
      },
      {
        "name": "resolveAnimationName",
        "line": 200,
        "params": [
          "rawValue",
          "animator",
          "selectedAnimation"
        ],
        "source": "function resolveAnimationName (rawValue, animator, selectedAnimation) {\n    const currentId = selectedAnimation?.$id || ''\n    const trimmed = rawValue.trim()\n\n    if (!trimmed) {\n        return {displayName: currentId, renamed: false}\n    }\n\n    let newName = toCamelCase(trimmed)\n    if (!newName) {\n        return {displayName: currentId, renamed: false}\n    }\n\n    if (newName === currentId) {\n        return {displayName: newName, renamed: false}\n    }\n\n    if (animator.hasChild(newName)) {\n        let counter = 2\n        while (animator.hasChild(`${newName}${counter}`)) {\n            counter++\n        }\n        newName = `${newName}${counter}`\n    }\n\n    return {displayName: newName, renamed: true}\n}"
      },
      {
        "name": "buildDeleteSection",
        "line": 229,
        "params": [
          "container",
          "callbacks"
        ],
        "source": "function buildDeleteSection (container, callbacks) {\n    const section = createElement('div', {\n        class: 'settings-section',\n        style: {marginTop: 'auto'}\n    })\n    section.dataset.setting = 'delete'\n\n    const btn = createElement('button', {\n        class: 'settings-delete-btn',\n        text: 'Delete Animation'\n    })\n\n    let confirmTimer = null\n\n    btn.addEventListener('click', () => {\n        if (btn.classList.contains('confirming')) {\n            clearTimeout(confirmTimer)\n            callbacks.onDelete?.()\n            return\n        }\n\n        btn.textContent = 'Confirm?'\n        btn.classList.add('confirming')\n        confirmTimer = setTimeout(() => {\n            btn.textContent = 'Delete Animation'\n            btn.classList.remove('confirming')\n        }, 3000)\n    })\n\n    section.appendChild(btn)\n    container.appendChild(section)\n}"
      }
    ],
    "exports": []
  },
  "/studio/animator/components/frame_editor.doc.js": {
    "type": "module",
    "file": "/studio/animator/components/frame_editor.js",
    "functions": [
      {
        "name": "buildFrameEditor",
        "line": 6,
        "params": [
          "frame",
          "{...}"
        ],
        "source": "function buildFrameEditor (frame, {onFramesUpdate, getSuggestions}) {\n    const container = document.createElement('div')\n    container.className = 'frame-editor'\n\n    container.appendChild(buildFramePreview(frame))\n    container.appendChild(buildDurationSection(frame, onFramesUpdate))\n    container.appendChild(buildEventsSection(frame, {onFramesUpdate, getSuggestions}))\n\n    return container\n}"
      },
      {
        "name": "buildDurationSection",
        "line": 18,
        "params": [
          "frame",
          "onUpdate"
        ],
        "source": "function buildDurationSection (frame, onUpdate) {\n    const section = document.createElement('div')\n    section.className = 'frame-editor-section'\n\n    const label = document.createElement('div')\n    label.className = 'frame-editor-label'\n    label.textContent = 'Duration multiplier'\n    section.appendChild(label)\n\n    const controls = document.createElement('div')\n    controls.className = 'frame-editor-duration'\n\n    const slider = document.createElement('slider-input')\n    slider.setAttribute('context', 'studio')\n    slider.setAttribute('no-value', '')\n    slider.setAttribute('no-label', '')\n    slider.setValue(frame.duration || 1)\n    slider.setMin(0.5)\n    slider.setMax(3)\n    slider.setStep(0.1)\n\n    const numberInput = document.createElement('number-input')\n    numberInput.setAttribute('context', 'studio')\n    numberInput.setValue(frame.duration || 1)\n    numberInput.setStep(0.1)\n    numberInput.setPrecision(2)\n    numberInput.setMin(0.1)\n    numberInput.setMax(10)\n\n    const updateDuration = (value) => {\n        frame.duration = value\n        onUpdate?.()\n    }\n\n    slider.addEventListener('change', (e) => {\n        numberInput.setValue(e.detail.value)\n        updateDuration(e.detail.value)\n    })\n\n    numberInput.addEventListener('change', (e) => {\n        slider.setValue(Math.min(3, Math.max(0.5, e.detail.value)))\n        updateDuration(e.detail.value)\n    })\n\n    controls.appendChild(slider)\n    controls.appendChild(numberInput)\n    section.appendChild(controls)\n    return section\n}"
      },
      {
        "name": "buildEventsSection",
        "line": 69,
        "params": [
          "frame",
          "{...}"
        ],
        "source": "function buildEventsSection (frame, {onFramesUpdate, getSuggestions}) {\n    const section = document.createElement('div')\n    section.className = 'frame-editor-section'\n\n    const label = document.createElement('div')\n    label.className = 'frame-editor-label'\n    label.textContent = 'Events'\n    section.appendChild(label)\n\n    const eventsContainer = document.createElement('div')\n    eventsContainer.className = 'frame-editor-events'\n\n    const renderEvents = () => {\n        eventsContainer.innerHTML = ''\n\n        const currentEvents = frame.events || []\n        for (const event of currentEvents) {\n            const chip = document.createElement('div')\n            chip.className = 'event-chip'\n\n            const chipText = document.createElement('span')\n            chipText.textContent = event\n\n            const removeBtn = document.createElement('button')\n            removeBtn.className = 'event-chip-remove'\n            removeBtn.innerHTML = '&times;'\n            removeBtn.addEventListener('click', () => {\n                frame.events = currentEvents.filter(e => e !== event)\n                onFramesUpdate?.()\n                renderEvents()\n            })\n\n            chip.appendChild(chipText)\n            chip.appendChild(removeBtn)\n            eventsContainer.appendChild(chip)\n        }\n\n        const suggestions = getSuggestions?.(currentEvents) || []\n        if (suggestions.length > 0) {\n            const suggestionsEl = document.createElement('div')\n            suggestionsEl.className = 'event-suggestions'\n\n            for (const suggestion of suggestions) {\n                const btn = document.createElement('button')\n                btn.className = 'event-suggestion'\n                btn.textContent = suggestion\n                btn.addEventListener('click', () => {\n                    if (!frame.events) {\n                        frame.events = []\n                    }\n                    frame.events.push(suggestion)\n                    onFramesUpdate?.()\n                    renderEvents()\n                })\n                suggestionsEl.appendChild(btn)\n            }\n            eventsContainer.appendChild(suggestionsEl)\n        }\n\n        const input = document.createElement('input')\n        input.type = 'text'\n        input.className = 'event-input'\n        input.placeholder = 'New event...'\n\n        input.addEventListener('keydown', (e) => {\n            if (e.key === 'Enter') {\n                const value = input.value.trim()\n                if (value) {\n                    if (!frame.events) {\n                        frame.events = []\n                    }\n                    if (!frame.events.includes(value)) {\n                        frame.events.push(value)\n                        onFramesUpdate?.()\n                        renderEvents()\n                    }\n                    input.value = ''\n                }\n            }\n        })\n\n        eventsContainer.appendChild(input)\n    }\n\n    renderEvents()\n    section.appendChild(eventsContainer)\n    return section\n}"
      }
    ],
    "exports": []
  },
  "/studio/components/conflict_resolver.doc.js": {
    "type": "class",
    "file": "/studio/components/conflict_resolver.js",
    "name": "ConflictResolver",
    "line": 129,
    "extends": "EditorComponent",
    "statics": [],
    "methods": [
      {
        "name": "onConnected",
        "line": 136,
        "source": "onConnected () {\n    adoptStyleSheets(this.shadowRoot, styles)\n    this.#buildDOM()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "resolve",
        "line": 142,
        "source": "resolve (conflicts) {\n    this.#conflicts = conflicts\n    this.#choices.clear()\n\n    for (const conflict of conflicts) {\n        this.#choices.set(conflict.id, 'custom')\n    }\n\n    this.#renderConflicts()\n    this.#overlay.open()\n\n    return new Promise(resolve => {\n        this.#resolvePromise = resolve\n    })\n}",
        "kind": "method",
        "params": [
          "conflicts"
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": null,
    "isDefault": true
  },
  "/studio/components/psd_importer.doc.js": {
    "type": "class",
    "file": "/studio/components/psd_importer.js",
    "name": "PsdImporter",
    "line": 377,
    "extends": "EditorComponent",
    "statics": [],
    "methods": [
      {
        "name": "onConnected",
        "line": 391,
        "source": "onConnected () {\n    adoptStyleSheets(this.shadowRoot, styles)\n    this.#converter.on('progress', ({stage, percent}) => this.#onProgress(stage, percent))\n    this.#buildDOM()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "open",
        "line": 398,
        "source": "open () {\n    this.#reset()\n    this.#overlay.open()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "close",
        "line": 404,
        "source": "close () {\n    this.#overlay.close()\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "setExistingNames",
        "line": 409,
        "source": "setExistingNames (names) {\n    this.#existingNames = new Set(names.map(n => n.toLowerCase()))\n}",
        "kind": "method",
        "params": [
          "names"
        ]
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": null,
    "isDefault": true
  },
  "/studio/components/storage_info.doc.js": {
    "type": "class",
    "file": "/studio/components/storage_info.js",
    "name": "StorageInfo",
    "line": 94,
    "extends": "EditorComponent",
    "statics": [],
    "methods": [
      {
        "name": "onConnected",
        "line": 100,
        "source": "onConnected () {\n    adoptStyleSheets(this.shadowRoot, styles)\n    this.#buildDOM()\n    this.#boundClose = (e) => this.#onOutsideClick(e)\n}",
        "kind": "method",
        "params": []
      },
      {
        "name": "onDisconnected",
        "line": 107,
        "source": "onDisconnected () {\n    document.removeEventListener('pointerdown', this.#boundClose)\n}",
        "kind": "method",
        "params": []
      }
    ],
    "getters": [],
    "setters": [],
    "constructor": null,
    "isDefault": true
  }
}